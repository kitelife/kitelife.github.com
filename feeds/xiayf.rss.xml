<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>黑·白 - xiayf</title><link>http://youngsterxyf.github.io/</link><description></description><lastBuildDate>Thu, 10 Oct 2019 00:00:00 +0800</lastBuildDate><item><title>读文笔记：日志 - 每个软件工程师都应该了解的实时数据统一抽象</title><link>http://youngsterxyf.github.io/2019/10/10/reading-the-log/</link><description>&lt;p&gt;原文：&lt;a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话概括，这篇文章细说了 Kafka 的本质原理、解决的问题、适用性等。&lt;/p&gt;
&lt;p&gt;Kafka 本质上是提供日志数据流。&lt;/p&gt;
&lt;p&gt;日志是客观世界的事件记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A log is perhaps the simplest possible storage abstraction. It is an append-only, totally-ordered sequence of records ordered by time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志数据的特点是：只增不改，自带时间戳，数据存储的先后顺序即（大致）是实际发生的时间先后顺序。&lt;/p&gt;
&lt;p&gt;数据库可以基于日志来还原历史操作行为 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Thu, 10 Oct 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-10-10:/2019/10/10/reading-the-log/</guid><category>论文</category><category>笔记</category></item><item><title>Lucene 查询解析器语法</title><link>http://youngsterxyf.github.io/2019/09/04/lucene-query-parser-syntax/</link><description>&lt;p&gt;原文：&lt;a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description"&gt;Query Parser Syntax&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（一个词法分析器，使用 JavaCC 将一个字符串翻译成一个 Lucene 查询）提供一种功能丰富的查询语言。&lt;/p&gt;
&lt;p&gt;一般来说，查询解析器支持的语法在不同发布版本之间可能会有变化。当前这个文档页面描述的是当前这个发布版本的语法。如果你正在使用一个不同版本的 Lucene，请参考该版本自带的 docs/queryparsersyntax.html 文档。&lt;/p&gt;
&lt;p&gt;在选择使用这个查询解析器之前，请考虑以下 3 点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你准备以编程的方式生成一个查询字符串，然后使用查询解析器来解析它。那么，你应该认真考虑一下是否应该直接使用查询 API 来构建查询。换句话说，查询解析器专门用于人类输入的文本，而不是程序生成的文本。&lt;/li&gt;
&lt;li&gt;不可分词（untokenized）的域（译者注：抱歉，此处没太理解）最好直接添加到查询中，而不是通过查询解析器来解析。如果一个域的值是通过应用自动生成的，那么应该为这个域自动生成查询子句 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 04 Sep 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-09-04:/2019/09/04/lucene-query-parser-syntax/</guid><category>翻译</category><category>Lucene</category><category>ElasticSearch</category><category>Kibana</category></item><item><title>一个 Python 小项目的小结</title><link>http://youngsterxyf.github.io/2019/08/14/a-python-project-summary/</link><description>&lt;p&gt;前段时间临时接手一个 Python 小项目，这个项目实现的类似一个管控平台，其中核心功能是为算法同学提供机器学习模型训练任务的全流程管理，平台后端基于 Flask 框架实现，前端基于 Ant Design Pro 实现。&lt;/p&gt;
&lt;p&gt;代码稍微有些乱，所以做了部分代码的重构，在此做点经验小结。&lt;/p&gt;
&lt;h3&gt;1、并行化或异步化&lt;/h3&gt;
&lt;p&gt;部分请求处理逻辑，由于比较耗时，故使用线程池来加速，或者使用独立线程异步处理，或者先存储一个中间状态，由后台定时任务来完成实际的处理工作。对于异步处理结果，前端通过轮询来获取。&lt;/p&gt;
&lt;p&gt;线程池的使用，主要使用 map 方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool

input_list = [...]
pool: Pool = Pool(len(input_list))
pool.map(func, input_list)
pool.close()
pool.join()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;独立线程异步处理 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 14 Aug 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-08-14:/2019/08/14/a-python-project-summary/</guid><category>总结</category><category>Python</category></item><item><title>Reactor 官方文档翻译简化版</title><link>http://youngsterxyf.github.io/2019/06/26/simplified-reactor-doc-zh/</link><description>&lt;p&gt;原文：&lt;a href="https://projectreactor.io/docs/core/release/reference/"&gt;Reactor 3 Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. 起步&lt;/h3&gt;
&lt;h4&gt;1.1 Reactor 简介&lt;/h4&gt;
&lt;p&gt;Reactor 是为 JVM 准备的一个完全非阻塞的反应式编程基础组件，支持高效的需求管理（以管理“反压”的形式），直接与 Java 8 的函数式 API 集成，尤其是 &lt;code&gt;CompletableFuture&lt;/code&gt;、&lt;code&gt;Stream&lt;/code&gt; 以及 &lt;code&gt;Duration&lt;/code&gt;，提供可组合的异步序列 API - &lt;code&gt;Flux&lt;/code&gt;（适用于 N 个元素的序列）和 &lt;code&gt;Mono&lt;/code&gt;（适用于 0 或 1个元素的序列）--- 并且全面地（extensively）实现了 &lt;a href="https://www.reactive-streams.org/"&gt;反应式流（Reative Streams）&lt;/a&gt; 规范。&lt;/p&gt;
&lt;p&gt;借助 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-06-26:/2019/06/26/simplified-reactor-doc-zh/</guid><category>翻译</category><category>Reactor</category><category>Reactive</category></item><item><title>Java System.getProperty VS. System.getenv（译）</title><link>http://youngsterxyf.github.io/2019/06/25/java-prop-env/</link><description>&lt;p&gt;原文：&lt;a href="https://www.baeldung.com/java-system-get-property-vs-system-getenv"&gt;Java System.getProperty vs System.getenv&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1、简介&lt;/h2&gt;
&lt;p&gt;Java 应用代码中会自动引入 &lt;code&gt;java.lang&lt;/code&gt; 包。这个包包含很多常用的类，包括 &lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;java.lang.System&lt;/code&gt; 类是一个 final 类，这意味着开发者无法继承它，其所有方法都是静态的（static）。&lt;/p&gt;
&lt;p&gt;System 类中有两个方法，分别来&lt;strong&gt;读取系统属性（system properties）和环境变量（environment variables）&lt;/strong&gt;，下面我们来看看这两者的区别。&lt;/p&gt;
&lt;h2&gt;2、使用 System.getProperty()&lt;/h2&gt;
&lt;p&gt;Java 平台使用一个 &lt;code&gt;Properties&lt;/code&gt; 对象来提供&lt;strong&gt;本地系统相关的信息和配置 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Tue, 25 Jun 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-06-25:/2019/06/25/java-prop-env/</guid><category>翻译</category><category>Java</category></item><item><title>Java 单测伴侣 - mockito</title><link>http://youngsterxyf.github.io/2019/06/17/mockito/</link><description>&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码还挺难的，挺花时间，其中最麻烦的是待测代码可能会访问外部资源（比如数据库、HTTP API），如果不能方便地进模拟访问这些外部资源，那么测试起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;但，对于复杂逻辑，如果不经过严格测试，发布到生产环境，又有些不放心，没底气，或者在代码重构时，如果没有覆盖全面的测试，很难评估代码变动带来的影响。&lt;/p&gt;
&lt;p&gt;直到遇到 &lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt;，我才觉得是时候认真写写测试代码了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt; 提供两种对象模拟方式：&lt;strong&gt;mock&lt;/strong&gt; 和 &lt;strong&gt;spy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，mock 模拟的对象是一个完全假的对象，只是具备指定类型的接口，以 &lt;code&gt;java.util.List&lt;/code&gt; 为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.mock;

List mockedList = mock(List.class);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Mon, 17 Jun 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-06-17:/2019/06/17/mockito/</guid><category>Java</category><category>mockito</category><category>单测</category></item><item><title>编写漂亮的 shell 代码</title><link>http://youngsterxyf.github.io/2018/05/16/beautiful-shell-code/</link><description>&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is true, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

map() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 16 May 2018 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2018-05-16:/2018/05/16/beautiful-shell-code/</guid><category>Bash</category></item><item><title>配置 Maven 自动化构建 protobuf 代码依赖</title><link>http://youngsterxyf.github.io/2018/05/14/maven-protobuf/</link><description>&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin.version&amp;gt;
    &amp;lt;maven-dependency-plugin.version&amp;gt;3.0.2&amp;lt;/maven-dependency-plugin.version …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Mon, 14 May 2018 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2018-05-14:/2018/05/14/maven-protobuf/</guid><category>java</category><category>maven</category><category>protobuf</category></item><item><title>《Python 编程之美》译者序</title><link>http://youngsterxyf.github.io/2018/04/01/the-python-guide/</link><description>&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语言包括：Python、PHP、Go、Java、JavaScript 等。&lt;/p&gt;
&lt;p&gt;虽说编程语言各异，但我使用它们来写各种项目的代码却一直坚持两点：代码可读性和自解释性/自文档性（self-documentation）。这很大程度上应该是受到 Python 语言设计哲学的影响 - 追求简单易读易懂的代码。&lt;/p&gt;
&lt;p&gt;很多人可能会认为这两点其实是一点 - 代码可读性，但我想做点区分：代码可读性突出对代码阅读者视觉上的影响，是否存在不必要的理解干扰，比如：必要的空行、变量定义与使用之间的距离、函数体/逻辑分支是否过长、逻辑表达是否直观等等。可读性高的代码通常都非常漂亮、赏心悦目。自解释性代码则更突出语义层面，比如：变量名称/函数名称/类名是否恰当、函数/方法/API 是否单一职责、工程目录结构/包/模块拆分是否符合“高内聚低耦合”原则等等 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2018-04-01:/2018/04/01/the-python-guide/</guid><category>翻译</category><category>书籍</category></item></channel></rss>