<!DOCTYPE html>
<html lang="zh">
<head>

        <title>笔试题目</title>
        <meta charset="utf-8" />
        <link href="http://youngsterxyf.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="黑·白 Full Atom Feed" />
        <link href="http://youngsterxyf.github.io/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="黑·白 Full RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../../../../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/pygment.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/SentyZHAO/SentyZHAO.css" />

        <script src="../../../../theme/js/libs/jquery-1.9.1.min.js"></script>
        <script src="../../../../theme/js/libs/modernizr-2.6.2.min.js"></script>
            <script>
              var _hmt = _hmt || [];
              (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?5c5d8c3fe75afeff117777b9236b96ec";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
              })();
            </script>
            
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type= "text/javascript">
       MathJax.Hub.Config({
           config: ["MMLorHTML.js"],
           jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML"],
           TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"], equationNumbers: { autoNumber: "AMS" } },
           extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js"],
           tex2jax: { 
               inlineMath: [ ['$','$'] ],
               displayMath: [ ['$$','$$'] ],
               processEscapes: true },
           "HTML-CSS": {
               styles: { ".MathJax .mo, .MathJax .mi": {color: "black ! important"}}
           }
       });
    </script>

</head>

<body id="index" class="home">
    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1 style='font-family: "SentyZHAO";'><a href="../../../..">黑·白 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>

              <ul class="columns" style='font-family: "SentyZHAO";'>
                <li><a href="../../../..">主 页</a></li>

                <li><a href="/archives.html">归 档</a></li>
                <li><a href="/pages/tech-share.html">技术分享</a></li>
                <li><a href="/pages/translation.html">技术翻译</a></li>
                <li><a href="/pages/tools.html">工具集</a></li>
                <li><a href="/pages/links.html">链 接</a></li>
                <li><a href="/pages/aboutme.html">关于我</a></li>
                <li><a href="/feeds/rss.xml">RSS</a></li>

              </ul>
            </div>

<section id="content" class="body">
   <div class="row">
        <div class="columns">
            <header>
              <h2 class="entry-title">
                <a href="../../../../2012/11/20/work-exam/" rel="bookmark" title="Permalink to 笔试题目">笔试题目</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2012-11-20T00:00:00+08:00">
                2012-11-20 二
              </abbr>
              <address class="vcard author">
                By <a class="url fn" href="../../../../author/youngsterxyf.html">youngsterxyf</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <h3>2013-网易-校园招聘-C++开发工程师</h3>
<h4>Fibonacci number</h4>
<p>F(n)的值是多少？</p>
<p><img alt="Fabonacci" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/NumberedEquation6.gif"></p>
<p><strong>常规算法</strong>：根据Fabonacci的定义，递归求值。时间复杂度$ O(2^n) $</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">def</span> fibobacci(n):
    <span style="color: #0000ff">return</span> n&gt;=2 <span style="color: #0000ff">and</span> fibonacci(n-2) + fibonacci(n-1) <span style="color: #0000ff">or</span> n
</pre></div>


<p><strong>迭代</strong>：利用循环取代递归。时间复杂度O(n)</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">def</span> fibonacci(n):
    a, b = 0, 1
    <span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> range(n):
        a, b = b, a+b
    <span style="color: #0000ff">return</span> a
</pre></div>


<p><em>迭代算法的变种</em> ：利用python的generator，原理一样，只是应用场合不一样。</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">def</span> fibonacci():
    a, b = 0, 1
    <span style="color: #0000ff">while</span> 1:
        <span style="color: #0000ff">yield</span> a
        a, b = b, a+b

f = fibonacci()
n = 100
<span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> range(n+1):
    <span style="color: #0000ff">print</span>(next(f)
</pre></div>


<p><strong>利用矩阵运算来加速的算法</strong>：（还没懂）算法复杂度$ O(\log n) $</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">import</span> numpy

fibonacci_matrix = numpy.matrix([1,1],[1,0], dtype=numpy.ndarray)
<span style="color: #0000ff">def</span> fibonacci(n):
    <span style="color: #0000ff">return</span> fibonacci_matrix**(n-1)[0, 0]
</pre></div>


<p><strong>数学方法:使用Fibonacci序列的通用公式</strong>：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">from</span> math <span style="color: #0000ff">import</span> sqrt

<span style="color: #0000ff">def</span> fibonacci(n):
    <span style="color: #0000ff">return</span> int(((1+sqrt(5))/2)**n/sqrt(5))
</pre></div>


<p>虽然数学方法在4种方法中速度最快，但当n越大，其计算精度偏差越大。</p>
<h4>图的遍历</h4>
<p><img alt="graph" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/graph-sample.jpg"></p>
<p><a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/graph.cpp">源代码</a></p>
<h4>大文件处理</h4>
<p>设计算法从文件中随机取K行(内存够存储K行)，每行被取的概率相等，算法复杂度要低。(具体的记不太清楚了)</p>
<h4>CAS(Compare And Swap)</h4>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #2b91af">bool</span> compare_and_swap(<span style="color: #2b91af">int</span> *accum, <span style="color: #2b91af">int</span> *dest, <span style="color: #2b91af">int</span> newval)
{
    <span style="color: #0000ff">if</span>(*accum == *dest)
    {
        *dest = newval;
        <span style="color: #0000ff">return</span> true;
    }
    <span style="color: #0000ff">return</span> false;
}
</pre></div>


<p>CAS方式实现的进队列操作：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>EnQueue(x)  <span style="color: #008000">//进队列</span>
{
    q = new record();
    q-&gt;value = x;
    q-&gt;next = NULL;

    <span style="color: #0000ff">do</span> {
        p = tail;   <span style="color: #008000">//取链表尾指针的快照</span>
    }<span style="color: #0000ff">while</span>(CAS(p-&gt;next, NULL, q) != TRUE)   <span style="color: #008000">//如果没有把结点链上，再试</span>

    CAS(tail, p, q);    <span style="color: #008000">//置尾结点</span>
}
</pre></div>


<ol>
<li>
<p><a href="http://blog.csdn.net/lifesider/article/details/6582338">无锁的数据结构（Lock-Free）及CAS（Compare-and-Swap）机制</a></p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Compare-and-swap">Wikipedia---Compare-and-swap</a></p>
</li>
<li>
<p><a href="http://coolshell.cn/articles/8239.html">无锁队列的实现</a></p>
</li>
</ol>
<h4>排序算法</h4>
<p>不稳定排序算法可能会在相等的键值中改变记录的相对次序，但是稳定排序算法从来不会如此。</p>
<p><strong>稳定的</strong></p>
<ul>
<li>
<p>冒泡排序(Bubble sort) --- $ O(n^2) $</p>
</li>
<li>
<p>插入排序(Insertion sort) --- $ O(n^2) $</p>
</li>
<li>
<p>桶排序(Bucket sort) --- $ O(n) $，需要$O(k)$额外空间</p>
</li>
<li>
<p>计数排序(Counting sort) --- $ O(n+k) $，需要$O(n+k)$额外空间</p>
</li>
<li>
<p>归并排序(Merge sort) --- $ O(n \log n) $，需要$O(n)$额外空间</p>
</li>
<li>
<p>基数排序(Radix sort) --- $ O(n \times k) $，需要$O(n)$额外空间</p>
</li>
</ul>
<p><strong>不稳定的</strong></p>
<ul>
<li>
<p>选择排序(Selection sort) --- $ O(n^2) $</p>
</li>
<li>
<p>希尔排序(Shell sort) --- $ O(n \log n) $</p>
</li>
<li>
<p>堆排序(Heap sort) --- $ O(n \log n) $</p>
</li>
<li>
<p>快速排序(Quick sort) --- $ O(n \log n) $</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p><em>冒泡排序---Python</em>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">def</span> bubbleSort(L):
    <span style="color: #0000ff">print</span> <span style="color: #a31515">&#39;start bubble sort:&#39;</span>
    <span style="color: #0000ff">print</span> L
    count = 0
    <span style="color: #0000ff">while</span> True:
        step = 0
        <span style="color: #0000ff">for</span> i <span style="color: #0000ff">in</span> range(len(L)-1):
            <span style="color: #0000ff">if</span> L[i] &gt; L[i+1]:
                L[i], L[i+1] = L[i+1], L[i]
                <span style="color: #0000ff">print</span> L
                step += 1
                count += 1
        <span style="color: #0000ff">if</span> step == 0:
            <span style="color: #0000ff">return</span> L, <span style="color: #a31515">&#39;totalstep:&#39;</span>, count
</pre></div>


<p><em>计数排序---C</em>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">#include</span> <span style="color: #008000">&lt;stdlib.h&gt;</span><span style="color: #0000ff"></span>

<span style="color: #2b91af">void</span> counting_sort(<span style="color: #2b91af">int</span> *array, <span style="color: #2b91af">int</span> size)
{
    <span style="color: #2b91af">int</span> i, min, max;
    min = max = array[0];
    <span style="color: #0000ff">for</span>(i=1; i&lt;size; i++)
    {
        <span style="color: #0000ff">if</span>(array[i] &lt; min)
            min = array[i];
        <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span>(array[i] &gt; max)
            max = array[i];
    }

    <span style="color: #2b91af">int</span> range = max-min+1;
    <span style="color: #2b91af">int</span> *count = (<span style="color: #2b91af">int</span> *)malloc(range * <span style="color: #0000ff">sizeof</span>(<span style="color: #2b91af">int</span>));

    <span style="color: #0000ff">for</span>(i = 0; i &lt; range; i++)
        count[i] = 0;
    <span style="color: #0000ff">for</span>(i = 0; i &lt; size; i++)
        count[array[i]-min]++;

    <span style="color: #2b91af">int</span> j, z = 0;
    <span style="color: #0000ff">for</span>(i=min; i&lt;=max; i++)
        <span style="color: #0000ff">for</span>(j=0; j&lt;count[i-min]; j++)
            array[z++] = i;
    free(count);
}
</pre></div>


<p><em>快速排序---Python</em>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">def</span> qsort(L):
    <span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span> L: <span style="color: #0000ff">return</span> []
    <span style="color: #0000ff">return</span> qsort([x <span style="color: #0000ff">for</span> x <span style="color: #0000ff">in</span> L[1:] <span style="color: #0000ff">if</span> x &lt; L[0]]) + L[0:1] + \
        qsort([x <span style="color: #0000ff">for</span> x <span style="color: #0000ff">in</span> L[1:] <span style="color: #0000ff">if</span> x&gt;=L[0]])
</pre></div>


<h3>2013-小米科技-校园招聘-笔试-软件开发工程师</h3>
<h4>完全二叉树</h4>
<p>深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为<strong>完全二叉树</strong> 。</p>
<p>这种树的特点是:1.叶子结点只可能在层次最大的两层上出现; 2.对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。</p>
<p>具有n个结点的完全二叉树的深度为$ [\log n]+1 $</p>
<h4>指针的基本理解</h4>
<p>已知int* p = &amp;n，请问*p是什么？</p>
<p><em>*p是n的值</em></p>
<p><strong>理解指针</strong> ：</p>
<ol>
<li>
<p>每个指针都对应一个类型。这个类型表明指针指向哪一类对象。特殊的void* 类型代表通用指针。比如说，malloc函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。</p>
</li>
<li>
<p>每个指针都有一个值。特殊的NULL(0)值表示该指针没有指向任何地方。</p>
</li>
<li>
<p>指针用&amp;运算符创建。（注：因为leal指令是设计用来计算存储器引用的地址的，&amp;运算符的机器代码实现常常用这条指令来计算表达式的值）</p>
</li>
<li>
<p>数组与指针紧密联系。一个数组的名字可以像一个指针变量一样使用(但是不能修改)</p>
</li>
<li>
<p>将指针从一个类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。例如，如果p是一个char*类型的指针，它的值是P，那么表达式(int*)p+7计算为P+28，而(int*)(p+7)计算为P+7。(回想一下，强制类型转换的优先级高于加法)</p>
</li>
<li>
<p>指针也可以指向函数。例如，如果我们有一个函数，用下面的这个原型定义: <code>int fun(int x, int *p)</code></p>
</li>
</ol>
<p>然后，我们可以声明一个指针fp，将它赋值为这个函数，代码如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>(<span style="color: #2b91af">int</span>) (*fp)(<span style="color: #2b91af">int</span>, <span style="color: #2b91af">int</span> *);
fp = fun;
</pre></div>


<p>然后用以下指针来调用这个函数：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #2b91af">int</span> y = 1;
<span style="color: #2b91af">int</span> result = fp(3, &amp;y);
</pre></div>


<p>函数指针的值是该函数机器代码表示中第一条指令的地址。</p>
<h4>93&amp;-8等于多少</h4>
<p>11011101 &amp; 11111000 = 11011000 = 88</p>
<h4>已知(he)^2 = she，请求出s, h, e各自的值为多少？</h4>
<p>s = 6; h = 2; e = 5;</p>
<h4>给定二维数组a[1...100][1...65]，以行序进行存储，假设数组的基地址为10000，每个元素需要2个存储单元，请求出元素a[56][21]的存储地址。</h4>
<p>$$ (55 \times 65 + 22) \times 2 + 10000 = 17194 $$</p>
<h4>给定一个数组a，求数组result，其中result[i]的值为除a[i]之外的其他a的元素值的乘积(假设不会溢出)。算法的时间，空间复杂度要尽可能低。</h4>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #2b91af">int</span>* getProduct(<span style="color: #2b91af">int</span>* a, <span style="color: #2b91af">int</span> n)
{
    <span style="color: #2b91af">int</span> allproduct = 1;
    <span style="color: #2b91af">int</span> index;
    <span style="color: #0000ff">for</span>(index=0; index&lt;n; index++)
        allproduct *= a[index];
    <span style="color: #2b91af">int</span>* productResult = new <span style="color: #2b91af">int</span>[n];
    <span style="color: #0000ff">for</span>(index=0; index&lt;n; index++)
        productResult[index] = allproduct / a[index];
    <span style="color: #0000ff">return</span> productResult;
}
</pre></div>


<p>时间复杂度为O(n)</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #2b91af">int</span>* getProduct(<span style="color: #2b91af">int</span>* a, <span style="color: #2b91af">int</span> n)
{
    <span style="color: #2b91af">int</span>* productResult = new <span style="color: #2b91af">int</span>[n];
    <span style="color: #2b91af">int</span> i, j, temp;
    <span style="color: #0000ff">for</span>(i=0; i&lt;n; i++)
    {

        temp = 1;
        <span style="color: #0000ff">for</span>(j=0; j&lt;n; j++)
        {
            <span style="color: #0000ff">if</span>(j != i)
                temp *= a[j];
        }
        productResult[i] = temp;
    }
    <span style="color: #0000ff">return</span> productResult;
}
</pre></div>


<p>时间复杂度为O(n^2)</p>
<h4>给定一个数组a，其中有3个元素出现了两次，其余元素仅出现一次。请找出其中仅出现一次的任意一个元素。算法的时间，空间复杂度要低</h4>
<p>方法一：先排序，然后对元素依次两两比较遍历一遍排好序的数组，如果两个元素不同，则输出第一个元素，并退出循环。如果相同，则跳过下一个元素，再次开始两两比较。</p>
<p>方法二：先找出数组a中的最大元素x，创建一个大小为x的数组temp，并所有元素初始化为-1。遍历数组a，temp[a[i]]++。再遍历temp，如果temp[i]==0，则返回i，并退出循环。</p>
<h4>给定n个人，以及m对人之间的关联(以二维数组的方式存储)，人与人之间直接关联或间接关联形成一个朋友圈。请找出给定信息的朋友圈的个数。算法时间空间复杂度要低。并分析其时间空间复杂度。</h4>
<p>使用 <strong>合并-查找算法</strong> (<a href="http://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>)</p>
<p><strong>连通问题的快速查找算法</strong>：算法的基础是一个整型数组，当且仅当第p个元素和第q个元素相等时，p和q是连通的。初始时，数组中的第i个元素的值为i，$0 \le i &lt; N$。为实现p与q的合并操作，我们遍历数组，把所有名为p的元素值改为q。我们也可以选择另一种方式，把所有名为q的元素改为p。</p>
<hr>
<h3>2013-腾讯-校园招聘-笔试-后台开发工程师</h3>
<h4>黑盒，白盒测试的目的</h4>
<h4>TCP三次握手包含的指令(SYN, ACK)</h4>
<h4>完全二叉树的结点数为769,求其叶子结点数目</h4>
<p>(769-x)*2 = 769-1 =&gt; x=385</p>
<h4>C++的四种类型转换符</h4>
<p><a href="http://www.bccn.net/Article/kfyy/cjj/jszl/200809/7955.html">C++中四种类型转换运算符的使用方法</a></p>
<h4>快速排序</h4>
<h4>有一个指针void *mPem指向一段分配好的内存空间，现在创建类A的对象a，如何使得a在其上申请内存空间？</h4>
<p>难道真是A* a = (A*)mPem么?</p>
<h4>虚继承与多态</h4>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">#include</span> <span style="color: #008000">&lt;stdio.h&gt;</span><span style="color: #0000ff"></span>
<span style="color: #0000ff">#include</span><span style="color: #008000">&lt;stdlib.h&gt;</span><span style="color: #0000ff"></span>

<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span> std;

<span style="color: #0000ff">class</span> <span style="color: #2b91af">A</span>{
    <span style="color: #0000ff">public</span>:
        A():a(0){}
        <span style="color: #2b91af">void</span> S(){
            printf(<span style="color: #a31515">&quot;aaa%d&quot;</span>,0);
        }
        <span style="color: #2b91af">int</span> a;
};

<span style="color: #0000ff">class</span> <span style="color: #2b91af">B</span>:<span style="color: #0000ff">public</span> A
{
    <span style="color: #0000ff">public</span>:
        B():a(2){}
        <span style="color: #2b91af">void</span> S(){
            printf(<span style="color: #a31515">&quot;bbb%d&quot;</span>,1);
        }
        <span style="color: #2b91af">int</span> a;
};

<span style="color: #2b91af">int</span> main()
{
    A *a = <span style="color: #0000ff">new</span> B();
    a-&gt;S();
    printf(<span style="color: #a31515">&quot;%d&quot;</span>,a-&gt;a);
}
</pre></div>


<h4>BITMAP的简单实现：使用char类型数组</h4>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #2b91af">char</span>* a;
...
<span style="color: #2b91af">void</span> set(<span style="color: #2b91af">int</span> n) <span style="color: #008000">//设置第n位为1</span>
{
    <span style="color: #2b91af">int</span> index = (n-1)/8;
    a[index] |= 1&lt;&lt;(n-1-(n-1)%8)
}
</pre></div>


<h4>矩阵向右旋转90度的实现</h4>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #2b91af">int</span> maxtrix[M][N];
...
<span style="color: #2b91af">int</span> reverseMatrix[N][M];
<span style="color: #2b91af">int</span> i, j;
<span style="color: #0000ff">for</span>(i=0; i&lt;M; i++)
{
    <span style="color: #0000ff">for</span>(j=0; j&lt;N; j++)
    {
        reverseMatrix[j][M-1-i] = matrix[i][j];
    }
}
</pre></div>


<h4>数据结构：线性结构与非线性结构</h4>
<h4>综合考虑等待时间和执行时间的进程调度算法？</h4>
<p><em>高响应比优先调度算法</em></p>
<h4>无法提高可靠性的RAID是？</h4>
<p><em>RAID0</em></p>
<p><a href="http://zh.wikipedia.org/zh/RAID">wikipedia-RAID</a></p>
<h4>类型的空间占用</h4>
<p>下列哪个占用的空间最大？</p>
<p>A.1   B.'1'   C."1"   D.1.0</p>
<p>答：D</p>
<h4>union和struct结构的存储与空间占用问题(对齐)</h4>
<p>1.</p>
<p>联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">union</span> U3 {
    <span style="color: #2b91af">char</span> c;
    <span style="color: #2b91af">int</span> i[2];
    <span style="color: #2b91af">double</span> v;
}
</pre></div>


<p>对于类型union U3*的指针p, p-&gt;c、p-&gt;i[0]和p-&gt;v引用的都是数据结构的起始位置。一个联合的总的大小等于它最大字段的大小。</p>
<p>2.</p>
<p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2, 4和8)的倍数。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计。例如，假设一个处理器总是从存储器中取出8个字节，则地址必须是为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个存储器操作来读或者写值了。否则，我们可能需要执行两次存储器访问，因为对象可能被分放在两个8字节存储器块中。</p>
<p>无论数据是否对齐，IA32已经都能正确工作。不过，Intel还是建议要对齐数据以提高存储器系统的性能。Linux沿用的对齐策略是，2字节数据类型(例如short)的地址必须是2的倍数，而较大的数据类型(例如int、int*、float和double)的地址必须是4的倍数。</p>
<h4>二叉树中序遍历</h4>
<h4>最小堆(堆排序)</h4>
<p>堆排序(Heap Sort)只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。</p>
<p>堆的定义如下：n个元素的序列{K1, K2,...,Kn}当且仅当满足关系时，称之为堆:
Ki &lt;= K2i 并且 Ki &lt;= K2i+1  或  Ki &gt;= K2i 并且 Ki &gt;= K2i+1</p>
<p>若将和此序列对应的一维数组看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于(或不小于)其左、右孩子结点的值。由此，若序列{Ki,K2,...,Kn}是堆，则堆顶元素(或完全二叉树的根)必为序列中n个元素的最小值(或最大值)。</p>
<p>若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素中次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。</p>
<p>由此，实现堆排序需要解决两个问题：(1)如何由一个无序序列建成一个堆？(2)如何在输出栈顶元素之后，调整剩余元素成为一个新的堆？</p>
<p><a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/heapSort.c">源代码</a></p>
<h4>一个线段上，任取两点，截成三段，能组成三角形的概率</h4>
<p>1/4 (怎么算？)</p>
<p>思考1：线段等分成两个区间。两点属于同一区间的概率是1/2，属于不同区间且两点距离大于等于线段长度一半的概率是1/2 * 1/2，则1-1/2-1/4 = 1/4;</p>
<p>思考2：线性规划。<a href="http://zhidao.baidu.com/question/6678655">百度知道</a></p>
<h4>哈希表</h4>
<p><strong>哈希函数的构造方法</strong></p>
<ul>
<li>
<p>直接定址法：取关键字或关键字的某个线性函数值为哈希地址</p>
</li>
<li>
<p>数字分析法：假设关键字是以r为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</p>
</li>
<li>
<p>平方取中法：取关键字平方后的中间几位为哈希地址</p>
</li>
<li>
<p>折叠法：将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和(舍去进位)作为哈希地址，这方法称为折叠法。</p>
</li>
<li>
<p>除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。</p>
</li>
<li>
<p>随机数法：选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key)，其中random为随机函数</p>
</li>
</ul>
<p>实际工作中需视不同的情况采用不同的哈希函数。通常，考虑的因素有：</p>
<ul>
<li>
<p>计算哈希函数所需时间(包括硬件指令的因素)</p>
</li>
<li>
<p>关键字的长度</p>
</li>
<li>
<p>哈希表的大小</p>
</li>
<li>
<p>关键字的分布情况</p>
</li>
<li>
<p>记录的查找频率</p>
</li>
</ul>
<p>处理冲突的方法：</p>
<ul>
<li>
<p>开放定址法</p>
</li>
<li>
<p>再哈希法</p>
</li>
<li>
<p>链地址法</p>
</li>
<li>
<p>建立一个公共溢出区</p>
</li>
</ul>
<h3>程序员面试宝典</h3>
<h4>用一个表达式，判断一个数X是否是2的N次方(2,4,8,16,...)，不可用循环语句。</h4>
<h4>下面程序的结果是多少？</h4>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">#include</span> <span style="color: #008000">&lt;iostream&gt;</span><span style="color: #0000ff"></span>
<span style="color: #0000ff">#include</span> <span style="color: #008000">&lt;string&gt;</span><span style="color: #0000ff"></span>

<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span> std;
<span style="color: #2b91af">int</span> main()
{
    <span style="color: #2b91af">int</span> count = 0;
    <span style="color: #2b91af">int</span> m = 9999;
    <span style="color: #0000ff">while</span>(m){
        count++;
        m=m&amp;(m-1);
    }
    cout &lt;&lt; count &lt;&lt; endl;

    <span style="color: #0000ff">return</span> 0;
}
</pre></div>


<h4>There are two int variables: a and b, don't use "if", "?:", "switch" or other judgement statements, find out the biggest one of the two numbers.</h4>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #2b91af">int</span> max = ((a+b)+abs(a-b)) / 2;
</pre></div>


<h4>如何将a, b的值进行交换，并且不使用任何中间变量?</h4>
<p>简而言之，用异或语句比较容易，不用担心超界的问题。</p>
<p>如果采用：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>a=a+b;
b=a-b;
a=a-b;
</pre></div>


<p>这样做的缺点就是如果a, b都是比较大的两个数，a=a+b时就会超界。</p>
<p>而采用：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>a=a^b;
b=a^b;
a=a^b;
</pre></div>


<p>无需担心超界的问题，这样就比较好</p>
            </div><!-- /.entry-content -->
            <div class="comments">
              <h3>欢迎评论</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "2012/11/20/work-exam/";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://xiayfblackwhite.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>
        </div><!-- /.twelve.columns -->
 </div><!-- /.row -->
</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">


        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="http://github.com/youngsterxyf" target="_blank">Github</a></div></li>

                <li><div class="btn twitter"><a href="https://twitter.com/youngsterxyf" target="_blank">Twitter</a></div></li>

                <li><div class="btn warning"><a href="http://weibo.com/u/1855563263" target="_blank">Weibo</a></div></li>

                <li><div class="btn douban"><a href="http://www.douban.com/people/youngster21/" target="_blank">Douban</a></div></li>



              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'xiayfblackwhite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../../../../theme/js/libs/gumby.min.js"></script>
  <script src="../../../../theme/js/plugins.js"></script>
  <script src="../../../../theme/js/main.js"></script>
  <link rel="stylesheet" type="text/css" href="../../../../theme/emoji/css/basic/emojify.min.css" />
  <script src="../../../../theme/emoji/js/emojify.min.js"></script>
  <script>
    emojify.setConfig({
        img_dir : '../../../../theme/emoji/images/basic'
    });
    emojify.run();
</script>
</body>
</html>