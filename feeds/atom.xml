<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>数据与智能</title><link href="http://youngsterxyf.github.io/" rel="alternate"></link><link href="http://youngsterxyf.github.io/feeds/atom.xml" rel="self"></link><id>http://youngsterxyf.github.io/</id><updated>2022-11-16T00:00:00+08:00</updated><entry><title>与一个前 leader 的交流笔记</title><link href="http://youngsterxyf.github.io/2022/11/16/talk-about-how-to-do/" rel="alternate"></link><published>2022-11-16T00:00:00+08:00</published><updated>2022-11-16T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2022-11-16:/2022/11/16/talk-about-how-to-do/</id><summary type="html">&lt;p&gt;如下这份笔记，是 19 年和一个前 leader 交流后记录下来的。说是交流，其实是针对我当时工作中存在的问题，他给我提出的一些 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;如下这份笔记，是 19 年和一个前 leader 交流后记录下来的。说是交流，其实是针对我当时工作中存在的问题，他给我提出的一些改进建议。如今再看看，仍然能引起自己的思考。&lt;/p&gt;
&lt;h2&gt;2019-10-27&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如何讨论需求/技术方案&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统性理解需求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全面梳理技术方案，论证方案的不合理之处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何证明方案不合理？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源成本（机器、人力），重复工作也是对资源的一种浪费&lt;/li&gt;
&lt;li&gt;对效果（收入等）的影响&lt;/li&gt;
&lt;li&gt;要站在“公正”的角度来论证，从大家共有的认知(机器、带宽、内存)出发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后才是什么系统复杂度（说到这个点，很容易扯淡，谁都会说自己复杂）&lt;/p&gt;
&lt;p&gt;讨论问题的时候，自己不做，但不要从“硬推给别人的角度”去讨论，而是要从“为啥自己不应该做”的角度出发。比如做了，导致系统耦合，复杂，做了导致多余的调用量更多等 。&lt;/p&gt;
&lt;h2&gt;2019-12-17&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;跨团队工作讨论时，围绕应该怎么做（怎么做最合理）来讨论，而不是围绕如果自己来做会有什么困难来讨论&lt;/li&gt;
&lt;li&gt;项目/系统要有 目标/长远架构图（最终做成什么样子，核心 KPI）&lt;/li&gt;
&lt;li&gt;做好向上汇报&lt;/li&gt;
&lt;li&gt;不要拿“做的过程中的困难”来搪塞不做，而是要从客观事实的角度来问应不应该做&lt;/li&gt;
&lt;li&gt;不要聚焦于解决现实世界的一个个问题，而是要靠具体的一个个问题，抽象出一张大图&lt;/li&gt;
&lt;li&gt;把自己的系统做成链路上最极致的那个，而不是等别人做好后来反推自己变革&lt;/li&gt;
&lt;li&gt;要区分重要和不重要的事情，核心的事情要仔细揣摩，没有人是傻子，那些资深的人说出的话更要揣摩，理解&lt;/li&gt;
&lt;li&gt;要有规划和愿景，leader 没有这些，团队走不远&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="讨论"></category><category term="思考"></category><category term="精进"></category></entry><entry><title>读文笔记：关于 MMAP 与 SSD</title><link href="http://youngsterxyf.github.io/2022/09/14/reading-about-mmap-ssd/" rel="alternate"></link><published>2022-09-14T00:00:00+08:00</published><updated>2022-09-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2022-09-14:/2022/09/14/reading-about-mmap-ssd/</id><summary type="html">&lt;p&gt;设计一种存储，第一要明确应用场景和存储系统的工作负载，第二要了解底层硬件的特点。&lt;/p&gt;
&lt;h2&gt;1、&lt;a href="https://db.cs.cmu.edu/mmap-cidr2022/"&gt;Are You Sure You Want to Use MMAP in Your Database Management …&lt;/a&gt;&lt;/h2&gt;</summary><content type="html">&lt;p&gt;设计一种存储，第一要明确应用场景和存储系统的工作负载，第二要了解底层硬件的特点。&lt;/p&gt;
&lt;h2&gt;1、&lt;a href="https://db.cs.cmu.edu/mmap-cidr2022/"&gt;Are You Sure You Want to Use MMAP in Your Database Management System? &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MMAP（Memory-mapped file I/O）是操作系统提供的一种功能特性 - 将二级存储（磁盘、SSD）上一个文件的内容映射到程序/进程的地址空间，然后程序就可以以指针访问内存页的方式来访问文件内容。当程序访问到某个内存页时，操作系统就会自动将对应文件内容加载到该内存页中，当内存用满了，也会自动剔除某些内存页。&lt;/p&gt;
&lt;p&gt;MMAP 其实就一个现成的缓冲池（buffer pool），核心特点就是简单易用，不需要重复开发，缺点是在需要时无法精确控制其行为。&lt;/p&gt;
&lt;p&gt;使用 MMAP 的优势是由操作系统封装了如下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从磁盘读数据&lt;/li&gt;
&lt;li&gt;不同线程读相同数据的并发处理&lt;/li&gt;
&lt;li&gt;缓存和缓冲管理（Caching and buffer management）&lt;/li&gt;
&lt;li&gt;从内存中剔除/驱逐内存页&lt;/li&gt;
&lt;li&gt;同一个机器上不同进程之间可以友好交互 🤔&lt;/li&gt;
&lt;li&gt;跟踪脏页以及将脏页写入磁盘 🤔&lt;/li&gt;
&lt;li&gt;相比 read/write 系统调用，mmap 不需要将内存页从内核空间拷贝到用户空间，而是直接从操作系统的内存页缓存中直接访问内存页，有一定的性能优势&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MMAP 相关 POSIX API：mmap、madvise、mlock、msync。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/U7xMgzj36dZDGaO.jpg"&gt;&lt;/p&gt;
&lt;p&gt;① A program calls mmap and receives a pointer to the memory-mapped file contents.&lt;/p&gt;
&lt;p&gt;② The OS reserves part of the program’s virtual address space but does not load any part of the file.&lt;/p&gt;
&lt;p&gt;③ The program accesses the file’s contents using the pointer.&lt;/p&gt;
&lt;p&gt;④ The OS attempts to retrieve the page.&lt;/p&gt;
&lt;p&gt;⑤ Since no valid mapping exists for the specified virtual address, the OS triggers a page fault to load the referenced part of the file from secondary storage into a physical memory page.&lt;/p&gt;
&lt;p&gt;⑥ The OS adds an entry to the page table that maps the virtual address to the new physical address.&lt;/p&gt;
&lt;p&gt;⑦ The initiating CPU core also caches this entry in its local translation lookaside buffer (TLB) to accelerate future accesses.&lt;/p&gt;
&lt;p&gt;不过论文作者认为 mmap 存在一些数据安全性和系统性性能问题，为解决这些问题而引入的工程成本会抵消掉简单性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、事务安全性（Transactional Safety）&lt;/strong&gt;：由于透明的页式调度机制，操作系统可能会任意时刻将一个脏页刷到二级存储中，不管写事务是否已提交。DBMS 无法组织这种内存数据刷出，并且发生时也不会接收到任何信号。所以基于 mmap 的数据库系统只能采用复杂的协议来确保（写/更新）事务安全，手段上大概分3种：操作系统写时复制、用户空间写时复制、影子页管理（shadow paging）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、I/O 停顿（I/O Stalls）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mmap 不支持异步读；自己搞缓冲池的话，可以使用异步 I/O（比如 libaio、io_uring）来避免查询时阻塞线程&lt;/li&gt;
&lt;li&gt;对于 mmap，因为操作系统会自动/透明地剔除一些内存页，这样可能导致 - 如果某些只读查询命中了已被剔除的内存页，就会无法预知地触发阻塞性的页错误/缺页处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方案：1、使用 mlock，不过操作系统对一个进程能锁住的内存页数量有限制；2、使用 madvise 的 MADV_SEQUENTIAL 标记，仅能问题的一部分；3、使用额外的线程来进行内存页预取，避免主线程被阻塞，不过会引入较大的复杂性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、错误处理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;DBMS 的核心职责之一是确保数据完整性 - 比如：校验磁盘数据是否有损坏&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 mmap，DBMS 需要在每次内存页访问时检查校验和（checksum），因为内存页一次访问之后操作系统可能会将该页驱逐到磁盘&lt;/li&gt;
&lt;li&gt;如果 DBMS 是使用非内存安全的编程语言编写的，就有可能在指针操作时损坏内存页内容，所以需要在内存页刷到二级存储之前进行错误检测，mmap 会默默地将损坏的内存页持久化到二级存储&lt;/li&gt;
&lt;li&gt;使用 mmap 也更难优雅地进行 I/O 错误处理，和 mmap 内存交互的任何代码都可能抛出 SIGBUS 信号，DBMS 必须使用信号处理器（signal handlers）来处理 ❓&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4、性能问题（最重大）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大家普遍认为 mmap 性能优于传统文件 I/O（read/write），因为它避免两个开销：(1) 显式调用 read/write 系统调用的开销 (2) mmap 会返回指向操作系统页缓存的页指针，因此避免了到用户内存空间的一次内存拷贝，也因此降低了内存占用；由此，大家也认为在 SSD 上 mmap 的性能优势会进一步扩大。&lt;/li&gt;
&lt;li&gt;不过实验测试发现：对于高带宽的二级存储设备（比如 SSD），DBMS 管理的数据量大于内存空间时，操作系统的页驱逐机制（page eviction mechanisms）多线程扩展性比较差（备注：因为 SSD I/O 带宽大、访问速度快，页驱逐机制就可能成了瓶颈）（we have found that the OS’s page eviction mechanisms cannot scale beyond a few threads for larger-thanmemory DBMS workloads on high-bandwidth secondary storage devices. We believe that one of the main reasons these performance issues have gone largely unnoticed is due to historically limited file I/O bandwidth）。瓶颈源于3个因素：&lt;ul&gt;
&lt;li&gt;页表争用（page table contention）/ 锁（备注：当前 linux 内核实现优化了这个问题，&lt;a href="https://github.com/torvalds/linux/blob/master/Documentation/mm/split_page_table_lock.rst"&gt;linux/split_page_table_lock.rst at master · torvalds/linux (github.com)&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;单线程页驱逐（single-threaded page eviction），&lt;a href="https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim/"&gt;Page Cache eviction and page reclaim | Viacheslav Biriukov&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;旁路转换缓冲击落（TLB shootdowns）：TLB shootdowns occur during page eviction when a core needs to invalidate mappings in a remote TLB. Whereas flushing the local TLB is inexpensive, issuing interprocessor interrupts to synchronize remote TLBs can take thousands of cycles&lt;ul&gt;
&lt;li&gt;&lt;a href="https://juejin.cn/post/6844904084957315086"&gt;深入理解 Linux 内核--jemalloc 引起的 TLB shootdown 及优化 - 掘金 (juejin.cn)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kernel.org/doc/html/v4.18/core-api/cachetlb.html"&gt;Cache and TLB Flushing Under Linux — The Linux Kernel documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实验分析：&lt;/p&gt;
&lt;p&gt;As a baseline, we used the fio storage benchmarking tool (v3.25) with direct I/O (O_DIRECT) to bypass the OS page cache. Our analysis focused exclusively on read-only workloads, which represent the best-case scenario for mmap-based DBMSs.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/FlAJqH8E4K1UWvp.jpg"&gt;
&lt;img alt="" src="https://s2.loli.net/2022/11/16/qhz3OQHlgaZ2YMn.jpg"&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/oczkfgLw9EMR1ue.jpg"&gt;&lt;/p&gt;
&lt;p&gt;那么，到底要不要使用 mmap 呢？直接使用 ssd？还是自己搞一个 buffer pool？&lt;/p&gt;
&lt;p&gt;论文作者给出这样的结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以下情况不要使用 mmap：&lt;ul&gt;
&lt;li&gt;需要以事务安全的方式进行更新操作&lt;/li&gt;
&lt;li&gt;希望处理缺页错误时不会阻塞在慢 I/O 上，或者希望明确控制哪些数据应该在内存中&lt;/li&gt;
&lt;li&gt;关心错误处理，也希望始终返回正确的数据结果&lt;/li&gt;
&lt;li&gt;要求在快速持久化存储设备（比如 SSD）上获得高吞吐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以下情况可能应该使用 mmap：&lt;ul&gt;
&lt;li&gt;内存可以容纳整个数据工作集（或者说整个数据库），并且是只读的工作负载&lt;/li&gt;
&lt;li&gt;希望将一个产品快速推向市场，也不关注数据一致性或者长期的工程技术债&lt;/li&gt;
&lt;li&gt;Otherwise, never 🤣🙃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;彩蛋：论文的奇数页页眉  😂
&lt;img alt="" src="https://s2.loli.net/2022/11/16/AIqHKTC213FYaxX.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;2、&lt;a href="https://ayende.com/blog/196161-C/re-are-you-sure-you-want-to-use-mmap-in-your-database-management-system"&gt;re: Are You Sure You Want to Use MMAP in Your Database Management System? &lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文作者认为自己实现一个内存分页管理器/缓冲池比较复杂，使用 mmap 来实现存储系统会很快。&lt;/p&gt;
&lt;p&gt;不过吐槽了原论文没有给出可供选择的替代方案，基准测试和结论之间也没太多相关性（compares apples to camels），也低估了自己实现一个替代 mmap 的缓冲池的复杂性。&lt;/p&gt;
&lt;p&gt;不用 mmap 的话，论文提及的那些问题，也是要解决的（If you aren’t using mmap, on the other hand, you still need to handle all those issues. That is a key point that I believe isn’t addressed in the paper. Solving those issues properly (and efficiently) is a seriously challenging task. Given that you are building a specialized solution, you can probably do better than the generic mmap, but it will absolutely have a cost. That cost is both in terms of runtime overhead as well as increased development time.）。&lt;/p&gt;
&lt;p&gt;原论文的实验说明了 mmap 的性能问题，但是换个 buffer pool 的实现能不能获得更好的性能呢？该文作者持悲观态度。&lt;/p&gt;
&lt;p&gt;存储系统实际面对的工作负载不会是完全的随机读（写）或顺序扫描，通常都具有一定的热点数据，这时 buffer pool 的优势就会体现出来？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于“问题 1 - 事务安全性” - 不用 mmap，解决这个问题的方案没什么不同（I don’t actually care if the data is written to memory behind my back. What I care about is MVCC (a totally separate concern than buffer management). The fact that I’m copying the modified data to the side means that I Can support concurrent transactions with far greater ease.）&lt;/li&gt;
&lt;li&gt;关于“问题 2 - I/O 停顿” - 该文作者认为确实个问题（not having control over the I/O means that you may incur a page fault at any time），并且是基于 mmap 的系统要面对的最大问题。不过实际情况是 linux 系统中 io_uring 之外的异步 I/O 方案在某些时候异步操作也会是阻塞的。是否使用 mmap，这个问题的解决方案也没有本质区别。&lt;/li&gt;
&lt;li&gt;关于“问题 3 - 错误处理” - 该文作者以自己开发的 Voron 为例说明即使使用 mmap，也可以较好地实现校验和检查（使用一个 bitmap 来记录哪些内存页被访问过，在第一次访问某个内存页的时候检查校验和），并认为程序一次运行过程中对于指定的一个内存页检查一次就可以，其他情况下的检查都是没有意义的。When you use read() to get data from the disk, you have no guarantees that the data wasn’t fetched from a cache along the way. So you may validate the data you read is “correct”, while the on disk representation is broken. For that reason, we only do the check once, instead of each time. 🤔 好像不是这个理？&lt;ul&gt;
&lt;li&gt;至于发现 I/O 错误，如何处理？该文作者认为答案只有一个 - 让它崩溃然后重新恢复并运行（Crash and then run recovery from scratch），因为如果 I/O 系统返回了一个错误，应用逻辑也不会有任何方式知道 I/O 系统的当前状态是什么，应该怎么解决，唯一的方式就是停下来，重新加载一切（应用 WAL 进行恢复），回到一个稳定状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于“问题 4 - 性能问题” - &lt;ul&gt;
&lt;li&gt;页表争用（page table contention）：linux 内核已优化解决&lt;/li&gt;
&lt;li&gt;单线程页驱逐（single-threaded page eviction）：如果写/更新频率不高，脏页不多的话，也不会成为性能瓶颈&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/3748384/what-is-tlb-shootdown"&gt;旁路转换缓冲击落（TLB shootdowns）&lt;/a&gt;：在一定条件下才会成为性能瓶颈，当你真的遇到时应该也会多花钱买内存来解决 🤣🙃（In order to actually observe the cost of TLS Shootdown in a significant manner, you need to have: (1) really fast I/O (2)working set that significantly exceeds memory (3) no other work that needs to be done for processing a request; In practice, if you have really fast I/O, you spent money on that, you’ll more likely get more RAM as well. And you typically need to do something with the data you read, which means that you won’t notice the TLB shootdown as much）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3、&lt;a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf"&gt;WiscKey: Separating Keys from Values in SSD-Conscious Storage&lt;/a&gt; /   &lt;a href="https://dgraph.io/blog/post/badger/"&gt;Introducing Badger: A fast key-value store written purely in Go&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;WiscKey 是一个基于 LSM (Log Structured Merge)树的 KV 存储引擎，针对 SSD 的随机读和顺序读性能特点，将 Key 和 Value 分开存储，以尽可能缩小 I/O 放大问题，提升性能。&lt;/p&gt;
&lt;p&gt;Value 存放在 Log 文件中，LSM 树仅存储 Key 和 Value 在 Log 文件的位置以及长度/大小。&lt;/p&gt;
&lt;p&gt;对于 Value 比较大的应用场景，性能优势明显。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/y84VKqJZWMSjBu7.jpg"&gt;&lt;/p&gt;
&lt;p&gt;因为 LSM 树不存储 Value 本身，通常比较小，可以全部放在内存中，所以不考虑获取 Value 的值，点查和范围查找速度非常快。&lt;/p&gt;
&lt;p&gt;LSM 树比较小，所以 Compaction 次数少，速度快（特别是如果整个 LSM 都放在内存中的话）。Compaction 过程中不需要读写 Value 的值，所以 I/O 放大倍数要小很多。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/2tvp5LROXG4UYrw.jpg"&gt;&lt;/p&gt;
&lt;p&gt;点查过程，从 LSM 树中获取 Value 的位置和大小后，需要从 Value Log 中获取 Value 值。因为 LSM 树小，所以读放大倍数小，综合起来看，WiscKey 点查的性能优势依旧明显。&lt;/p&gt;
&lt;p&gt;范围查找/遍历过程，先从 LSM 树中获得目标范围内的所有 Value 的位置和大小，放入队列，使用多线程进行并发预取，利用 SSD 随机读的吞吐能力随并发树近线性增长的特点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/APbQlhq3nWsf47j.jpg"&gt;
&lt;img alt="" src="https://s2.loli.net/2022/11/16/j357k6XMfYO2udm.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Value Log 也需要 GC，清理掉无用的 Value 值。LSM 树的 Compaction 主要是为了提升查找/检索的性能/效率，控制读放大，减少内存/磁盘空间占用是次要的。Value Log 的 GC 则主要是为了减少内存/磁盘空间占用。&lt;/p&gt;
&lt;p&gt;为了实现在线的轻量级 GC，Value Log 中也存储了 Key，&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/JMKxWiaCovyhgr8.jpg"&gt;&lt;/p&gt;
&lt;p&gt;tail 指向 Value Log 有效值范围内时序上最先写入的那个 value 的位置。&lt;/p&gt;
&lt;p&gt;head 指向 Value Log 中下一个新 value 写入的位置。&lt;/p&gt;
&lt;p&gt;tail 和 head 及其对应的位置信息均作为 kv 存入 LSM 树中（head 的指向什么时候会更新？：每次有新值写入的时候都更新？还是在 GC 的过程中才会更新？）&lt;/p&gt;
&lt;p&gt;GC 的流程为：&lt;/p&gt;
&lt;p&gt;① 从 tail 指向的位置开始顺序扫描一块数据，根据其中的 key 检索 LSM 树，确认当前 value 是否有效（没有被删除也没有被覆盖）&lt;/p&gt;
&lt;p&gt;② 如果有效则插入到 head 指向的位置，head 指向移动到下一个位置；如果无效，则直接丢弃&lt;/p&gt;
&lt;p&gt;③ 一块数据处理完成后，移动 tail 指向到下一个位置，释放/回收原来数据块的存储空间；然后继续循环处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;疑问&lt;/strong&gt;：1. GC 过程中每次向 head 插入有效值时，是否先要从 LSM 树中查询最新指向的位置？2. 在根据 key 从 LSM 树查询后将有效值写入 head 位置前，有新数据写入的话，怎么处理？GC 期间是否要停止正常的写操作？还是说对某个临界区加锁？ &lt;/p&gt;
&lt;p&gt;LSM 树原理：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/k6cHFOUluo1Ibfp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/17WubUhqSpCjMr5.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/Tomk3VOEs7jduQl.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://zhuanlan.zhihu.com/p/181498475"&gt;LSM树详解 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4、&lt;a href="http://www.vldb.org/pvldb/vol14/p364-didona.pdf"&gt;Toward a Better Understanding and Evaluation of Tree Structures on Flash SSDs（VLDB）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;PTS - Persistent tree data structure&lt;/p&gt;
&lt;p&gt;使用 LSM 树（RocksDB）和 B+ 树（WiredTiger）来分析 SSD 基准测试（Benchmarking）中可能踩到的 7 个坑（pitfall）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）Running short tests / 测试过于短平快&lt;/strong&gt; ⚡️&lt;/p&gt;
&lt;p&gt;随着使用时间的增加，SSD 的性能会一定的动态变化。&lt;/p&gt;
&lt;p&gt;Because both the PTS and SSD performance vary over time, short-lived tests are unable to capture how the systems will behave under a continuous（non-bursty）workload.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/HSuzIeC8itjndGw.jpg"&gt;&lt;/p&gt;
&lt;p&gt;WA-A（应用/存储系统的写放大） increases over time while the levels of the LSM-Tree fills up, and its curve flattens once the layout of the LSM tree has stabilized.&lt;/p&gt;
&lt;p&gt;WA-D（SSD 设备的写放大） increases over time because of the effect of garbage collection.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）Ignoring the device write amplification (WA-D) / 忽视了 SSD 设备本身的写放大&lt;/strong&gt; ⚡️&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WA-D directly affects the throughput of the device, which strongly correlates with the application-level throughput.&lt;/li&gt;
&lt;li&gt;WA-D is an essential measure of the I/O efficiency of a PTS. 端到端的写放大倍数应该是 WA-A 乘以 WA-D&lt;/li&gt;
&lt;li&gt;WA-D measures the flash-friendliness of a PTS. &lt;ul&gt;
&lt;li&gt;A low WA-D indicates that a PTS generates a write access that does not incur much garbage collection overhead in the SSD. &lt;/li&gt;
&lt;li&gt;以前大家可能认为 LSM 树（顺序写）相比 B+ 树（随机写）对 SSD 更友好，但实测 WA-D 颠覆了这个认知 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（3）Ignoring the internal state of the SSD / 忽视了 SSD 的初始内部状态&lt;/strong&gt; ⚡️&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/pFyqSCVZnrHB1g9.jpg"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Trim(Discard)的出现主要是为了提高GC的效率以及减少写入放大的发生，最大作用是清空待删除的无效数据&lt;/strong&gt;。在SSD执行读、擦、写步骤的时候，预先把擦除的步骤先做了，这样才能发挥出SSD的性能，通常SSD掉速很大一部分原因就是待删除的无效数据太多，每次写入的时候主控都要先做清空处理，所以性能受到了限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The steady-state performance of a PTS can greatly differ depending on the initial state of the drive, this is surprising.&lt;/p&gt;
&lt;p&gt;This phenomenon is caused by how the LBA (logic block address)  access patterns of RocksDB and WiredTiger intertwine with the SSD garbage collection mechanism as a function of the initial state the drive.&lt;/p&gt;
&lt;p&gt;WiredTiger only writes to a limited portion of the logical block address space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）Ignore the dataset size / 忽视了数据集大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/SlVWJfP5rO7xpNQ.jpg"&gt;&lt;/p&gt;
&lt;p&gt;The amount of data stored by the SSD changes its behavior and affects overall performance.&lt;/p&gt;
&lt;p&gt;The performance degradation brought by the larger dataset is primarily due to the idiosyncrasies（特质/特点） of the SSD: larger datasets lead to more valid pages in each flash block, which increases the amount of data being relocated upon performing garbage collection, i.e., the WA-D&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）Ignoring the extra storage capacity a PTS needs to manage data and store additional meta-data / 未考虑空间放大（Space amplification）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;涉及存储成本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）Ignoring SSD over-provisioning&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成本与性能之间的权衡折中 - 可以预留一部分 SSD 空间给 SSD 做 GC 使用，这部分空间对文件系统不可见。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://s2.loli.net/2022/11/16/YEFp5g69mnqBe3w.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（7）Ignoring the effect of the underlying storage technology on performance&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;5、SSD 原理相关资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/102089411"&gt;浅谈分布式存储之SSD基本原理 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/_uiCsFXWjepeHSdgiUABhg"&gt;聊聊 SSD 的基本原理 (qq.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://xiongduo.cn/posts/coding-for-ssds-part-1-introduction-and-table-of-contents.html"&gt;为SSD编程（1）：简介和目录 (xiongduo.cn)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ssdfans.com/?p=8077"&gt;SSD背后的秘密：SSD基本工作原理 (ssdfans.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="论文"></category><category term="SSD"></category><category term="学习"></category><category term="性能"></category></entry><entry><title>Disruptor 等待策略引发的 CPU 负载异常问题</title><link href="http://youngsterxyf.github.io/2020/07/14/disruptor-waitstrategy-cpu-busy/" rel="alternate"></link><published>2020-07-14T00:00:00+08:00</published><updated>2020-07-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2020-07-14:/2020/07/14/disruptor-waitstrategy-cpu-busy/</id><summary type="html">&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;工作中，我负责的系统是一个数据流处理服务 - 以流水线（pipeline）的形式分多级异步处理：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/ONwUsrlhLmIq8BW.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其中的 队列 实际使用的是 &lt;a href="https://github.com/LMAX-Exchange/disruptor"&gt;Disruptor&lt;/a&gt;，多生 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;工作中，我负责的系统是一个数据流处理服务 - 以流水线（pipeline）的形式分多级异步处理：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/ONwUsrlhLmIq8BW.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其中的 队列 实际使用的是 &lt;a href="https://github.com/LMAX-Exchange/disruptor"&gt;Disruptor&lt;/a&gt;，多生产者单消费者模式：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ThreadFactory factory = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ThreadFactoryBuilder().setNameFormat(name).setDaemon(&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;).build();
Disruptor&amp;lt;Event&amp;lt;T&amp;gt;&amp;gt;  disruptor = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Disruptor&amp;lt;&amp;gt;(Event&amp;lt;T&amp;gt;::&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;, bufferSize, factory, ProducerType.MULTI, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SleepingWaitStrategy());
disruptor.handleEventsWith((Event&amp;lt;T&amp;gt; event, &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; sequence, &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; endOfBatch) -&amp;gt; {
    consumer.accept(event.value, endOfBatch);
    event.value = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务运行在 k8s 集群上，每个容器节点上可能会运行多个 pipeline，也即意味着单个节点上会存在多个 disruptor 实例。&lt;/p&gt;
&lt;h2&gt;现象&lt;/h2&gt;
&lt;p&gt;近期突然收到测试环境很多节点（生产环境也有少量节点）的 CPU 使用率告警 - CPU 使用率持续 5 分钟以上超过 90%，如下其中一个任务节点的 CPU 使用率监控图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/XJVsiMI3b9m5dlB.jpg"&gt;
&lt;img alt="" src="https://i.loli.net/2020/07/14/2YwPQAqaICr879x.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpu.busy = cpu.system + cpu.user + 软/硬中断&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意其中 &lt;code&gt;cpu.system&lt;/code&gt; 比 &lt;code&gt;cpu.user&lt;/code&gt; 高不少，&lt;code&gt;cpu.busy&lt;/code&gt; 又比 &lt;code&gt;cpu.system&lt;/code&gt; 高不少。也即 CPU 时间片资源主要消耗在 内核态 和中断逻辑上（对于这些任务而言 &lt;code&gt;cpu.user&lt;/code&gt; 指标也是异常的）。&lt;/p&gt;
&lt;p&gt;这些节点运行的任务，几乎没有数据需要处理，也就是说几乎是空跑的。从线程数量监控以及 jstack 输出的堆栈跟踪信息，也未发现明显异常。&lt;/p&gt;
&lt;h2&gt;原因排查&lt;/h2&gt;
&lt;p&gt;将测试环境的任务在本地环境运行起来，并基于 &lt;a href="https://www.lightbend.com/blog/profiling-jvm-applications"&gt;How to profile JVM applications&lt;/a&gt; 一文中提到的火焰图工具，产出对应 JVM 应用的火焰图：
&lt;img alt="" src="https://i.loli.net/2020/07/14/zQMWsBeKbuZLamN.jpg"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以大致看出其中 &lt;code&gt;com/lmax/disruptor/SleepingWaitStrategy:::waitFor&lt;/code&gt; / &lt;code&gt;jdk/internal/misc/Unsafe:::park&lt;/code&gt; 比较可疑，在调用栈中耗时最长。&lt;/p&gt;
&lt;p&gt;从项目源码和 jstack 输出的堆栈跟踪信息可以看到，测试任务中大致涉及 18个 disruptor 实例，均使用 &lt;code&gt;SleepingWaitStrategy&lt;/code&gt; 等待策略，该策略的 &lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/SleepingWaitStrategy.java#L56"&gt;waitFor&lt;/a&gt; 方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; waitFor(&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; sequence, Sequence cursor, &lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Sequence dependentSequence, &lt;span style="color: #0000ff"&gt;final&lt;/span&gt; SequenceBarrier barrier) &lt;span style="color: #0000ff"&gt;throws&lt;/span&gt; AlertException {
    &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; availableSequence;
    &lt;span style="color: #008000"&gt;// 默认 200&lt;/span&gt;
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; counter = retries;

    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; ((availableSequence = dependentSequence.get()) &amp;lt; sequence) {
      counter = applyWaitMethod(barrier, counter);
    }

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; availableSequence;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;waitFor 方法中核心调用了 &lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/SleepingWaitStrategy.java#L76"&gt;applyWaitMethod&lt;/a&gt; ：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; applyWaitMethod(&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; SequenceBarrier barrier, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; counter) &lt;span style="color: #0000ff"&gt;throws&lt;/span&gt; AlertException {
    barrier.checkAlert();

    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (counter &amp;gt; 100)
    {
        --counter;
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (counter &amp;gt; 0)
    {
        --counter;
        Thread.yield();
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
    {
        &lt;span style="color: #008000"&gt;// sleepTimeNs 默认 100&lt;/span&gt;
        &lt;span style="color: #008000"&gt;// 间接调用  jdk/internal/misc/Unsafe:::park 方法&lt;/span&gt;
        LockSupport.parkNanos(sleepTimeNs);
    }

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; counter;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html#parkNanos-long-"&gt;LockSupport.parkNanos&lt;/a&gt; 方法的作用简单而言即让当前线程睡眠 sleepTimeNs 纳秒。&lt;/p&gt;
&lt;p&gt;Disruptor 作为一个任务队列，自带一个线程池，线程池的线程工厂即构造方法传入的 factory，线程数量等于 &lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/dsl/Disruptor.java#L165"&gt;disruptor.handleEventsWith&lt;/a&gt; 调用时传入的回调方法数量，handleEventsWith 的参数数量不定（&lt;code&gt;public final EventHandlerGroup&amp;lt;T&amp;gt; handleEventsWith(final EventHandler&amp;lt;? super T&amp;gt;... handlers)&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;18个 Disruptor 实例，每个实例有一个消费者线程，消费者线程不断检查队列中是否有新的 &lt;code&gt;Event&amp;lt;T&amp;gt;&lt;/code&gt; 任务需要处理，如果有，则调用 EventHandler 回调方法进行处理，否则睡眠 sleepTimeNs 纳秒。&lt;/p&gt;
&lt;p&gt;到此，结合监控指标，可以大致猜测：由于 sleepTimeNs 较小，导致多个线程的状态不断在 &lt;code&gt;运行&lt;/code&gt;、&lt;code&gt;睡眠&lt;/code&gt;、&lt;code&gt;等待调度&lt;/code&gt; 之间切换，线程上下文切换非常频繁。&lt;/p&gt;
&lt;p&gt;围绕 LockSupport.parkNanos 编写一个测试程序，来复现这个问题：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.Executors;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.locks.LockSupport;

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Test&lt;/span&gt; {

  &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; main(String[] args) &lt;span style="color: #0000ff"&gt;throws&lt;/span&gt; InterruptedException {
    ExecutorService tp = Executors.newFixedThreadPool(18);
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; idx = 0; idx &amp;lt; 18; idx++) {
      tp.submit(() -&amp;gt; {
        &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;) {
          LockSupport.parkNanos(100);
        }
      });
    }
    CountDownLatch wg = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CountDownLatch(1);
    wg.await();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 3.2 GHz 6-Core Intel Core i7 配置 macOS 系统中，这个测试程序可以稳定地将 CPU 使用率控制在 700%+，如下 &lt;code&gt;top -pid [测试程序的进程 id]&lt;/code&gt; 命令的输出：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/Z6jixvuWY1yTnL4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其中 CSW 为线程上下文切换的次数。&lt;/p&gt;
&lt;p&gt;既然问题原因在于多个线程频繁睡眠导致，那么解决方案也比较简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用更大的值来替换 sleepTimeNs 默认值：&lt;code&gt;new Disruptor&amp;lt;&amp;gt;(Event&amp;lt;T&amp;gt;::new, bufferSize, factory, ProducerType.MULTI, new SleepingWaitStrategy(200, 1000 * 1000 / 10)); // 0.1 ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用其他等待策略（WaitStrategy），比如：&lt;code&gt;com.lmax.disruptor.BlockingWaitStrategy&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过解决方案也有微小的负作用 - 部分新任务/&lt;code&gt;Event&amp;lt;T&amp;gt;&lt;/code&gt;实例的处理时延会增大，但在我们的数据流处理场景下，这点时延增大对业务完全没有影响。&lt;/p&gt;
&lt;p&gt;不过，这个问题应该是一直存在，为什么近期才收到告警，为什么以前从监控上未发现？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么近期才收到告警？因为这个监控告警是近期公司监控平台才统一配置的&lt;/li&gt;
&lt;li&gt;为什么以前从监控上未发现？因为公司切换了新的监控平台，老的监控平台没有 cpu.busy 这个指标，而这些没什么数据要处理的任务长时间不需要开发维护，也就未得到及时关注。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;扩展资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;上下文切换耗时多少？&lt;a href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html"&gt;How long does it take to make a context switch?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LockSupport.parkNanos(100)&lt;/code&gt; 真的就是睡眠 100 纳秒吗？&lt;a href="https://hazelcast.com/blog/locksupport-parknanos-under-the-hood-and-the-curious-case-of-parking/"&gt;LockSupport.parkNanos() Under the Hood and the Curious Case of Parking&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="问题排查"></category><category term="Java"></category><category term="Disruptor"></category></entry><entry><title>如何剖析 JVM 应用（译）</title><link href="http://youngsterxyf.github.io/2020/07/13/how-to-profile-jvm-applications/" rel="alternate"></link><published>2020-07-13T00:00:00+08:00</published><updated>2020-07-13T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2020-07-13:/2020/07/13/how-to-profile-jvm-applications/</id><summary type="html">&lt;p&gt;原文链接：&lt;a href="https://www.lightbend.com/blog/profiling-jvm-applications"&gt;How to profile JVM applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hi 大家好。工具团队（tooling team）近期的一个关注点是改进 sbt 贡献流程（ improvement of the contribution process to sbt）。我们一直在思考的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文链接：&lt;a href="https://www.lightbend.com/blog/profiling-jvm-applications"&gt;How to profile JVM applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hi 大家好。工具团队（tooling team）近期的一个关注点是改进 sbt 贡献流程（ improvement of the contribution process to sbt）。我们一直在思考的另一个事情是 sbt 的性能。为一举解决这两件事情，我调研了 Jason Zaugg、Johannes Rudolph 这些人如何剖析 JVM 应用，这篇文章即是调研结果。&lt;/p&gt;
&lt;p&gt;这里论述的技术应该可以应用于Java 和 Scala，也基本与你使用的工具无关。&lt;/p&gt;
&lt;h2&gt;火焰图（使用 async-profiler 生成）&lt;/h2&gt;
&lt;p&gt;剖析 JVM 应用的方式有多种，但新晋热门是Netflix 高级性能架构师（Senior Performance Architect）Brendan Gregg 发明的&lt;strong&gt;火焰图&lt;/strong&gt;。开发者先收集堆栈踪迹抽样数据（stack trace samples），然后将其处理成一张交互式的 svg 图。若要快速了解火焰图，可阅读如下链接资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=ugRrFdda_JQ"&gt;Using FlameGraphs To Illuminate The JVM by Nitsan Wakart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=D53T1Ejig1Q"&gt;USENIX ATC ’17: Visualizing Performance with Flame Graphs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我推荐的第一个火焰图工具是  Andrei Pangin 发起的 async-profiler，在 macOS 和 Linux 操作系统环境下均可使用，上手使用也更简单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载安装器 &lt;a href="https://github.com/jvm-profiling-tools/async-profiler/releases/tag/v1.2"&gt;async-profiler 1.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;假设你的系统中存在一个命令查找路径 &lt;code&gt;$HOME/bin&lt;/code&gt;，在 &lt;code&gt;$HOME/bin&lt;/code&gt; 目录下创建符号链接指向 &lt;code&gt;build/&lt;/code&gt; 和 &lt;code&gt;profiler.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ln -s ~/App/async-profiler/profiler.sh $HOME/bin/profiler.sh
ln -s ~/App/async-profiler/build $HOME/bin/build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，关闭所有 Java 应用，以及任何可能影响剖析过程的东西，比如 Slack，然后在终端程序（terminal）中运行你的应用。对于我而言，则是尝试剖析 &lt;code&gt;sbt&lt;/code&gt; 的初始化加载过程：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sbt exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在另一个终端中，运行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ jps
92746 sbt-launch.jar
92780 Jps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由此我们知道应用的进程 ID。对于我而言，目标进程 ID 是 &lt;code&gt;92746&lt;/code&gt;。在应用运行的同时，运行如下命令：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;$&lt;/span&gt; profiler.sh -d 60 &amp;lt;process id&amp;gt;
Started [cpu] profiling
--- Execution profile ---
Total samples:         31602
Non-Java:              3239 (10.25%)
GC active:             46 (0.15%)
&lt;span style="color: #0000ff"&gt;Unknown&lt;/span&gt; (native)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;      14667 (46.41%)
&lt;span style="color: #0000ff"&gt;Not&lt;/span&gt; walkable (native)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt; 3 (0.01%)
&lt;span style="color: #0000ff"&gt;Unknown&lt;/span&gt; (Java)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;        433 (1.37%)
&lt;span style="color: #0000ff"&gt;Not&lt;/span&gt; walkable (Java)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;   8 (0.03%)
Thread &lt;span style="color: #0000ff"&gt;exit&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;           1 (0.00%)
Deopt:                 9 (0.03%)

Frame buffer &lt;span style="color: #0000ff"&gt;usage&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;    55.658%

Total: 1932000000 (6.11%)  samples: 1932
  [ 0] java.lang.ClassLoader&lt;span style="border: 1px solid #FF0000"&gt;$&lt;/span&gt;NativeLibrary.&lt;span style="color: #0000ff"&gt;load&lt;/span&gt;
  [ 1] java.lang.ClassLoader.loadLibrary0
  [ 2] java.lang.ClassLoader.loadLibrary
  [ 3] java.lang.Runtime.loadLibrary0
  [ 4] java.lang.&lt;span style="color: #0000ff"&gt;System&lt;/span&gt;.loadLibrary
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;命令会输出一大堆有用的堆栈跟踪信息（stacktraces），为将这些信息可视化为一张火焰图，运行如下命令：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;profiler.sh -d 60 -f /tmp/flamegraph.svg &amp;lt;process id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;命令最后应该会产出文件 &lt;code&gt;/tmp/flamegraph.svg&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flamegraph" src="https://i.loli.net/2020/07/13/dZVkB9xq2Gy6NfA.png"&gt;&lt;/p&gt;
&lt;p&gt;你自己来体验一下 &lt;a href="https://downloads.lightbend.com/website/blog/2019/flamegraph.svg?_ga=2.187105832.1642569835.1594378538-197429397.1594378538"&gt;flamegraph.svg&lt;/a&gt; 输出的信息。&lt;/p&gt;
&lt;h2&gt;火焰图（使用 perf-map-agent 生成）&lt;/h2&gt;
&lt;p&gt;虽然 async-profiler 上手使用很简单，但火焰图真正有趣之处在于可以混合展现 JVM 堆栈追踪和原生代码（native code）堆栈跟踪信息，让开发者可以看到 CPU 实际消耗在程序的何处。Lightbend 公司的 Johannes Rudolph 为此写了一个工具 - &lt;a href="https://github.com/jvm-profiling-tools/perf-map-agent"&gt;perf-map-agent&lt;/a&gt;。该工具在 macOS 环境下会使用 &lt;code&gt;dtrace&lt;/code&gt;，在 Linux 环境下会使用 &lt;code&gt;perf&lt;/code&gt;。如果你想确认瓶颈是否出现在原生代码中，这个工具会特别有用。&lt;/p&gt;
&lt;p&gt;我们先要编译 &lt;a href="https://github.com/jvm-profiling-tools/perf-map-agent"&gt;perf-map-agent&lt;/a&gt;。对于 macOS 环境，在运行 &lt;code&gt;cmake .&lt;/code&gt; 之前需要先设置 &lt;code&gt;JAVA_HOME&lt;/code&gt; 环境变量：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cd work
$ git clone https://github.com/brendangregg/FlameGraph.git

$ git clone https://github.com/jvm-profiling-tools/perf-map-agent.git
$ cd perf-map-agent
$ export JAVA_HOME=&lt;span style="color: #0000ff"&gt;$(&lt;/span&gt;/usr/libexec/java_home&lt;span style="color: #0000ff"&gt;)&lt;/span&gt;
$ cmake .
-- The C compiler identification is AppleClang 9.0.0.9000039
-- The CXX compiler identification is AppleClang 9.0.0.9000039
...
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在一个新的终端中，带 &lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt; 标记参数运行 sbt：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sbt -J-Dsbt.launcher.standby=20s -J-XX:+PreserveFramePointer exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在另一个终端中运行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cd quicktest/
$ export JAVA_HOME=&lt;span style="color: #0000ff"&gt;$(&lt;/span&gt;/usr/libexec/java_home&lt;span style="color: #0000ff"&gt;)&lt;/span&gt;
$ export FLAMEGRAPH_DIR=$HOME/work/FlameGraph
$ jps
94592 Jps
94549 sbt-launch.jar
$ $HOME/work/perf-map-agent/bin/dtrace-java-flames 94549
dtrace: system integrity protection is on, some features will not be available

dtrace: description &lt;span style="color: #a31515"&gt;&amp;#39;profile-99 &amp;#39;&lt;/span&gt; matched 2 probes
Flame graph SVG written to DTRACE_FLAME_OUTPUT=&lt;span style="color: #a31515"&gt;&amp;#39;/Users/xxx/work/quicktest/flamegraph-94549.svg&amp;#39;&lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;理论上这样会产出更全面的火焰图，不过对于 &lt;code&gt;sbt exit&lt;/code&gt;，产出的火焰图看起来可能有点凌乱。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flamegraph-2" src="https://i.loli.net/2020/07/13/s9BbWAnluTPwE3J.png"&gt;&lt;/p&gt;
&lt;p&gt;如果 sbt 操作已经经过即时编译器优化（the operations are already JITed），或者操作比较特殊（the operation is more specific），那么火焰图的效果会更好。为了得到效果更好的火焰图，我们可以将相同的操作多重复几次：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sbt -J-Dsbt.launcher.standby=20s -J-XX:+PreserveFramePointer reload reload reload reload exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样就可以产出程序的稳定态火焰图，逐步放大火焰图，就可以找到执行的热点路径。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flamegraph-3" src="https://i.loli.net/2020/07/13/93YyjxR5ATS1Dnq.png"&gt;&lt;/p&gt;
&lt;h2&gt;Flamescope&lt;/h2&gt;
&lt;p&gt;Netflix 公司近期发布了一个新的火焰图可视化工具 - &lt;a href="https://medium.com/netflix-techblog/netflix-flamescope-a57ca19d47bb"&gt;Flamescope&lt;/a&gt;，可以将火焰图过滤限制在一个特定的时间范围内。&lt;/p&gt;
&lt;p&gt;&lt;img alt="FlameScope" src="https://i.loli.net/2020/07/13/djm2hkvC98irQu7.png"&gt;&lt;/p&gt;
&lt;p&gt;Martin Spier 和 Brendan Gregg 为研究扰动以及其他时间相关的问题（perturbations and other time-based issues）而开发了这个工具。常规的火焰图是聚合了所有堆栈追踪抽样数据，如果系统中发生了一个短时小故障，就会被深埋于其他追踪信息中，这个工具就是为了解决这个问题。&lt;/p&gt;
&lt;h2&gt;JMH (sbt-jmh)&lt;/h2&gt;
&lt;p&gt;因为 JIT 存在预热等特点，增大了基准测试的困难。JMH 会将相同的测试运行多次，消除 JIT 预热等特点造成的影响，从而更准确地测量代码的性能。&lt;/p&gt;
&lt;p&gt;对于 sbt 用户而言，Lightbend 公司 Konrad Malawski 编写的 &lt;a href="https://github.com/ktoso/sbt-jmh"&gt;sbt-jmh&lt;/a&gt; 进一步简化了 JMH 测试。并且它也集成了 async-profiler。&lt;/p&gt;
&lt;h2&gt;VisualVM&lt;/h2&gt;
&lt;p&gt;我也想提一下传统的 JVM 剖析工具。因为 &lt;a href="https://visualvm.github.io/"&gt;VisualVM&lt;/a&gt; 开源了，所以就来说说它。&lt;/p&gt;
&lt;p&gt;1、先打开 VisualVM
2、在一个终端中启动 sbt
3、从 VisualVM 界面的 Local 应用目录下应该可以看到 &lt;code&gt;xsbt.boot.Boot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/13/EB7vsuo1HjaTtQw.jpg"&gt;&lt;/p&gt;
&lt;p&gt;4、打开它，选择 抽样功能（sampler） 或 剖析功能（profiler），在你想要开始的时间点点击 CPU 按钮&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/13/aoiIDfMKw9pjY4Z.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如果你对 &lt;a href="https://www.yourkit.com/"&gt;YourKit&lt;/a&gt; 比较熟悉，也可以使用它，用法比较相似。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;火焰图对堆栈跟踪抽样数据进行可视化，方便识别应用代码中的热点路径。也有助于确认代码变更是否实际影响了应用性能。&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Java"></category><category term="工具"></category><category term="问题排查"></category></entry><entry><title>博客构建环境准备</title><link href="http://youngsterxyf.github.io/2020/06/14/blog-build-env/" rel="alternate"></link><published>2020-06-14T00:00:00+08:00</published><updated>2020-06-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2020-06-14:/2020/06/14/blog-build-env/</id><summary type="html">&lt;p&gt;好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;1、Python 虚拟环境&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;virtualenv -p python3 ~/.py3
source ~/.py3/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、安装 Python 依赖包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pip install pelican[Markdown]   &lt;span style="color: #008000"&gt;# 可能需要先安装 pip：easy_install pip&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、安装主题包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;1、Python 虚拟环境&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;virtualenv -p python3 ~/.py3
source ~/.py3/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、安装 Python 依赖包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pip install pelican[Markdown]   &lt;span style="color: #008000"&gt;# 可能需要先安装 pip：easy_install pip&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、安装主题包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git clone https://github.com/youngsterxyf/my-pelican-themes.git ~/github/youngsterxyf/my-pelican-themes
pelican-themes -i ~/github/youngsterxyf/my-pelican-themes/my-gum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、构建&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;另，更新艺术字体或字集：&lt;/p&gt;
&lt;p&gt;(1) 下载 fontmin-app：https://github.com/ecomfe/fontmin-app&lt;/p&gt;
&lt;p&gt;(2) 导入字体 SentyZHAO（汉仪新蒂赵孟頫体）：https://github.com/youngsterxyf/blog-content/blob/master/new-blog/SentyZHAO.ttf&lt;/p&gt;
&lt;p&gt;&lt;img alt="fontmin" src="https://i.loli.net/2020/06/14/Xn8b9kZDIfWoLmp.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另，华戈行书字体见：http://www.foundertype.com/index.php/FontInfo/index/id/5350&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(3) 生成字体样式，并拷贝更新到目标主题包目录中：https://github.com/youngsterxyf/my-pelican-themes/tree/master/my-gum/static&lt;/p&gt;
&lt;p&gt;(4) 更新主题包：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pelican-themes -r my-gum
pelican-themes -i ~/github/youngsterxyf/my-pelican-themes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(5) 重新构建生成博客&lt;/p&gt;</content><category term="其他"></category></entry><entry><title>读文笔记：Kafka 官方设计文档</title><link href="http://youngsterxyf.github.io/2019/10/13/reading-kafka-design/" rel="alternate"></link><published>2019-10-13T00:00:00+08:00</published><updated>2019-10-13T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-10-13:/2019/10/13/reading-kafka-design/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://kafka.apache.org/documentation/#design"&gt;http://kafka.apache.org/documentation/#design&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;数据持久化&lt;/h2&gt;
&lt;h4&gt;不用惧怕文件系统&lt;/h4&gt;
&lt;p&gt;磁盘的读写速度，取决于如何读写。对于线性读写方式，操作系统做了充 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://kafka.apache.org/documentation/#design"&gt;http://kafka.apache.org/documentation/#design&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;数据持久化&lt;/h2&gt;
&lt;h4&gt;不用惧怕文件系统&lt;/h4&gt;
&lt;p&gt;磁盘的读写速度，取决于如何读写。对于线性读写方式，操作系统做了充分的优化：提前读 - 预取若干数据块，滞后写 - 将小的逻辑写操作合并成一个大的物理写操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://queue.acm.org/detail.cfm?id=1563874"&gt;研究&lt;/a&gt;表明：&lt;a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg"&gt;顺序读写磁盘（sequential disk access）的速度有些时候比随机访问内存还要快&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现代操作系统激进地尽可能将空闲内存用作磁盘缓存。所有磁盘读写都经过操作系统提供的统一缓存。这个特性没法轻易关闭，除非直接 I/O （direct I/O），因此，如果程序在用户进程中进行数据缓存，缓存的数据通常也是和操作系统页缓存重复的，缓存两遍，没啥意义，也浪费内存。&lt;/p&gt;
&lt;p&gt;而且，Kafka 是构建在 JVM 之上的，了解 Java 内存使用方式的人应该都知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象的内存开销非常高，通常是实际数据大小的2倍（甚至更多）&lt;/li&gt;
&lt;li&gt;随着堆上数据量增大，Java 的 GC 表现也会更糟糕&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，使用文件系统并依赖于操作系统内存页缓存，优于在程序中维护一块内存缓存或其它结构。至少操作系统内存页缓存的可用内存翻倍了。另外，如果使用紧凑的字节结构来缓存数据，相比使用对象，可用内存可能还会翻倍。在 32GB 内存的机器上这么搞，缓存可用到 20-30GB，还不会对 GC 造成了什么坏影响。并且，即使服务重启，这块缓存空间也是热的（除非机器重启），用户进程内的内存缓存在服务重启后得重建（10GB的数据缓存可能需要10分钟左右）。&lt;/p&gt;
&lt;p&gt;这样也可以简化代码逻辑，因为缓存和文件系统之间的一致性由操作系统来保证了。&lt;/p&gt;
&lt;p&gt;这样一分析，设计就简单了：我们反其道而行之，所有数据都直接写到文件系统上持久化日志文件中，不需要在程序中使用内存缓存，也不必确保将数据刷到磁盘。这实际意味着数据转移到了内核的内存页缓存。&lt;/p&gt;
&lt;h4&gt;常量时间就能搞定&lt;/h4&gt;
&lt;p&gt;B 树的 O(log N) 时间复杂度，对于磁盘操作来说，并不能等同于常量时间复杂度。&lt;/p&gt;
&lt;p&gt;Kafka 采用日志文件方式，确保读写操作的时间复杂度是 O(1)。&lt;/p&gt;
&lt;p&gt;Kafka 不会在消息一被消费就立即删除，而是保留一段时间，这样对于消费者来说也更灵活一些。&lt;/p&gt;
&lt;h2&gt;效率&lt;/h2&gt;
&lt;p&gt;对于 Kafka 这类系统而言，即使像前述那样消除了糟糕的磁盘访问模式，也会遇到两个导致数据效率低的问题：&lt;strong&gt;过多的小 I/O 操作&lt;/strong&gt;，以及&lt;strong&gt;过多的字节拷贝&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;小 I/O 问题在客户端与服务端之间，以及服务端内部的数据持久化操作中都会发生。对此，Kafka 协议建立在 “消息集” （即一批消息）的抽象之上，这样网络请求读写的是一批一批的消息，减少了网络往返的时间开销（注：消息处理的实时性会相对差一点）。服务端也是一次将一批消息写到日志文件中，消费者也按序一次获取一批消息。这一简单的优化可以将吞吐能力提升几个数量级。&lt;/p&gt;
&lt;p&gt;对于过多的字节拷贝问题，在消息量大的时候，影响比较明显。Kafka 采用了一种标准化的二进制消息格式，producer、broker、consumer 都使用这种格式，这样数据块在传输期间不需要变动。&lt;/p&gt;
&lt;p&gt;broker 维护的消息日志只是一个目录下的一堆文件，文件内容是按序写入的消息集，消息集的数据格式同于 producer、consumer 使用的。共用一种数据格式方便了一个重要的操作优化：持久化日志块的网络传输。对于从内存页缓存（pagecache）到网络套接字（socket）的数据传输操作，现代 UNIX 操作系统提供了一种高度优化的代码执行路径。Linux 中使用 &lt;a href="http://man7.org/linux/man-pages/man2/sendfile.2.html"&gt;sendfile 系统调用&lt;/a&gt; 可以利用这个优化。&lt;/p&gt;
&lt;p&gt;要理解 sendfile 的收益，需要先理解从文件到套接字传输数据的常规代码执行路径：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作系统从磁盘将数据读到内核空间的内存页缓存（pagecache）&lt;/li&gt;
&lt;li&gt;应用程序从内核空间减数据读到用户空间缓冲区&lt;/li&gt;
&lt;li&gt;应用程序将数据从用户空间缓冲区读到内核空间的套接字缓冲区&lt;/li&gt;
&lt;li&gt;操作系统将数据从套接字缓冲区读到 NIC 缓冲区，网卡从 NIC 缓冲区读取数据通过网络发出去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一代码执行路径，涉及 4 次数据拷贝和 2 次系统调用，很显然是低效的。使用 sendfile，可以避免内核空间和用户空间之间一些不必要的数据拷贝，操作系统可以直接将数据从内存页缓存发送到网络。&lt;/p&gt;
&lt;p&gt;进一步了解 sendfile 以及 Java 平台如何支持零拷贝，可以阅读&lt;a href="https://developer.ibm.com/articles/j-zerocopy/"&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;生产者（The Producer）&lt;/h2&gt;
&lt;h4&gt;负载均衡&lt;/h4&gt;
&lt;p&gt;消息应该发到哪个分区（partition）由客户端根据哈希算法（或者随机）决定，并且消息是直接由 producer 发到目标分区的 leader broker，没有任何中间路由层。&lt;/p&gt;
&lt;p&gt;所有 Kafka 节点都可以响应元数据请求 - 告知客户端（producer 或 consumer）哪些服务节点还存活以及某个 topic 的各个分区 leader 分别是哪个节点（疑惑：如果某个分区 leader 节点挂掉之后，客户端如何获知？何时可以获知？）&lt;/p&gt;
&lt;h2&gt;消息交付语义&lt;/h2&gt;
&lt;p&gt;producer 和 consumer 之间的消息交付语义，分 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最多消费一次 - 消息可能会丢失，但不会被重复消费&lt;/li&gt;
&lt;li&gt;最少消费一次 - 消息不会丢，但可能被重复消费&lt;/li&gt;
&lt;li&gt;仅消费一次 - 每个消息都会被消费且仅消费一次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个问题可以分成两个阶段的问题：&lt;strong&gt;producer 向 broker 发布一个消息时的持久性保证&lt;/strong&gt; 以及 &lt;strong&gt;consumer 消费一个消息时的语义保证&lt;/strong&gt; （the durability guarantees for publishing a message and the guarantees when consuming a message）。&lt;/p&gt;
&lt;p&gt;producer 向 Kafka 集群发消息时，会提供一个请求参数 &lt;code&gt;acks&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;acks=0：表示 producer 不需要等分区 leader broker 返回任何响应，将消息存入套接字缓冲区（socket buffer）就当做消息已经发送成功。所以可靠性是没有保证的。&lt;/li&gt;
&lt;li&gt;acks=1：表示 分区 leader broker 将消息写入自己的本地日志文件，就向 producer 响应成功，不必等待分区副本 broker 同步好消息。&lt;/li&gt;
&lt;li&gt;acks=-1 或 acks=all：表示 分区 leader broker 需要等待所有同步副本 broker 同步好消息并响应成功，才向 producer 响应成功&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第 2 种情况，如果分区 leader broker 挂掉/不存活，则副本未来得及同步的消息会丢失。&lt;/p&gt;
&lt;p&gt;第 3 种情况，只要有同步副本正常同步消息，那么即使 leader 挂了也不会丢数据。&lt;/p&gt;
&lt;p&gt;如果 leader 被系统判定为不存活，则会从（同步）副本中选举一个新的 leader，那么 Kafka 如何判定一个节点是否存活？存活判定依赖 2 个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点必须维持与 Zookeeper 的 session 连接（通过 Zookeeper 的心跳机制）&lt;/li&gt;
&lt;li&gt;如果是一个从节点（follower），则必须不断从 leader 节点同步消息数据，且同步进度没有落后太多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 producer 在发送消息的过程中发生网络问题，它没法判定分区 leader 是否收到消息。0.11.0.0 版本之前，producer 只能重发消息，别无他法，因此只能提供“最少消费一次的”交付语义。0.11.0.0 版本之后，Kafka producer 支持一个幂等交付功能选项，可以确保消息重发不会导致 Kafka 的消息日志中出现重复的条目：broker 为每个 producer 分配一个 ID，然后基于消息序号来去重。&lt;/p&gt;
&lt;p&gt;也是从 0.11.0.0 版本开始，Producer 支持以类事务的语义向多个 topic 分区发送消息：要么所有消息都发送成功，要么都不成功。这个能力主要用于实现 Kafka topic 之间的仅处理一次语义。&lt;/p&gt;
&lt;p&gt;从 consumer 角度来看，同一个分区的所有副本，日志数据相同，消费进度也一样。consumer 可以控制自己对分区日志数据的消费位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 consumer 读取消息后，先向 kafka 提交消费位置，再处理消息；如果该 consumer 挂掉或重启，会可能导致丢消息，从而只能满足“最多处理一次”交付语义。&lt;/li&gt;
&lt;li&gt;如果 consumer 读取消息后，是先处理，再提交消费位置；如果该 consumer 挂掉或重启，则可能导致重复消费消息，从而只能满足“最少处理一次”交付语义。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何实现“仅处理一次”语义？借助 Producer 的事务能力。&lt;/p&gt;
&lt;h2&gt;复制&lt;/h2&gt;
&lt;p&gt;复制的粒度/单元是 topic 分区。Kafka 集群中，每个分区都有一个 leader broker 节点，0个或多个从节点（follower）。分区读写都是由 leader broker 处理。&lt;/p&gt;
&lt;p&gt;如同一个普通的 consumer，从节点从 leader broker 拉取（pull）消息，然后写到自己的消息日志文件中。让从节点以 pull 的方式获取 leader 的消息数据，好处在于批量读写。&lt;/p&gt;
&lt;p&gt;对于 follower 节点而言，“是否存活”的实际含义是“是否顺利地从 leader 同步消息”，leader 节点会追踪“同步中”节点集（ISRs）。如果一个 follower 挂掉了/卡住了/同步落后太多了，则将其从这个 ISRs 中移除。follow 是否卡住或者同步落后太多，依据 &lt;code&gt;replica.lag.time.max.ms&lt;/code&gt; 配置参数判定。&lt;/p&gt;
&lt;p&gt;将某消息写到某个分区，如果该分区所有同步中副本都已经将该消息写到自己的消息日志文件中，则可以认为该消息的写操作已提交（committed），也就是真正的写成功。&lt;/p&gt;
&lt;p&gt;只有写提交的消息才会分发给 consumer。&lt;/p&gt;
&lt;p&gt;producer 可以选择是否等待消息写操作提交，在延迟（latency）和持久性（durability）之间权衡。&lt;/p&gt;
&lt;p&gt;Kafka 集群在某分区的 leader 节点挂掉之后，会快速进行失败转移（a short fail-over period），选举出新的分区 leader 节点，可用性不会受到影响。但如果发生网络分区（network partitions）问题，则无法保证可用性。CAP - C（Consistency）：一致性，A（Availability）：可用性，P（Partition Tolerance）：分区容错性 - 放弃了 分区容错性。&lt;/p&gt;
&lt;h4&gt;日志数据复制：仲裁成员集（Quorums）、同步中副本集（ISRs）和状态机&lt;/h4&gt;
&lt;p&gt;（备注：这一节我理解得还不太透彻。）&lt;/p&gt;
&lt;p&gt;一类常见的分布式系统是主从模式的，由主节点决定状态变化的顺序（the order of a series of values）。从节点通过日志复制（replicated log）方式同步状态数据。对于提交决策（commit decision）和选主（leader election），通常是基于多数人投票的机制。假设副本个数（注：个人理解包含主节点）为 2f+1，那么只有当 f+1 个副本写入成功，主节点才会将这个写操作标记为已提交（committed）。当主节点挂掉之后，基于 f 个状态最新的副本节点，可以选举出新的主节点，且状态不会有任何丢失。&lt;/p&gt;
&lt;p&gt;多数人投票方式，有一个优点：延迟取决于速度快的节点，而不是慢的。缺点是：对于实际的生产系统，抗风险能力还不够，而且不够灵活，不能让使用者做权衡。&lt;/p&gt;
&lt;p&gt;Kafka 选择仲裁成员集（quorum set）的方式与此不同，而不是基于多数人投票，而是动态维护一组同步中副本（ISR），这些副本与主节点保持同步。只有这组副本中的成员才有资格当选为主节点。ISR 集发生变化时会持久化到 Zookeeper 上。&lt;/p&gt;
&lt;p&gt;基于 ISR 模型，如果 topic 分区有 f+1 个副本，则可以容忍 f 个节点挂掉，也不会丢失任何已提交的消息。&lt;/p&gt;
&lt;p&gt;与 Kafka ISR 模型实际实现最相近的学术论文是微软的 &lt;a href="http://research.microsoft.com/apps/pubs/default.aspx?id=66814"&gt;PacificA&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;可用性和持久性保证&lt;/h4&gt;
&lt;p&gt;注意：producer 发送消息时设定 &lt;code&gt;acks=all&lt;/code&gt; 并不是要求所有的副本都确认写入成功，而是在当前同步中副本（ISR）都确认写入成功时，分区 leader 就向 producer 响应成功。例如：某个 topic 被设置为 2 个副本，然后其中一个副本节点挂掉，此时要求 &lt;code&gt;acks=all&lt;/code&gt; 的写操作也会成功。如果剩下的副本节点也挂了，那么就会丢消息啦。&lt;/p&gt;
&lt;p&gt;为了方便用户在 可用性 和 持久性 之间权衡，Kafka 提供两个 topic 级别的配置，用于 持久性 比 可用性 重要的情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://kafka.apache.org/documentation/#design_uncleanleader"&gt;禁用脏 leader 选举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;指定一个最小 ISR 集大小（&lt;code&gt;min.insync.replicas&lt;/code&gt; 参数设置）：只有当 ISR 集大小大于设定的最小值，分区 [leader] 才会接受消息写入。这个设置只有当 producer 使用 &lt;code&gt;acks=all&lt;/code&gt; 时才会生效。（注：在我们生产环境中，分区副本数通常申请为 3（包含 leader），那么 &lt;code&gt;min.insync.replicas&lt;/code&gt; 应该设定为 2，但默认是 1。使用 1，那么当分区只有一个副本（即 leader），producer 也能写入成功，但如果这个副本又挂了，就会丢数据。）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;副本管理&lt;/h4&gt;
&lt;p&gt;一个 Kafka 集群上一般会有多个 topic，每个 topic 又有多个 partition，为了节点之间负载均衡，通常以&lt;strong&gt;循环（round-robin）方式&lt;/strong&gt;在所有节点上分布 partition 和 分区 leader 角色。&lt;/p&gt;
&lt;p&gt;另外，在分区 leader 节点之后重新选出 leader 之前，存在一段不可用的时间窗口，为了缩短这个时间窗口，Kafka 会从所有 broker 中选择一个作为“控制器（controller）”，这个控制器会检测 broker 级别的问题（failures），在发现某个 broker 挂掉之后，负责为受影响的分区指定新的 leader，而不是每个分区自己负责重新选主，这样的选主过程更轻量更快。如果控制器节点挂了，还存活的 broker 中的一个会成为新的控制器。&lt;/p&gt;
&lt;h2&gt;消费者消费进度跟踪&lt;/h2&gt;
&lt;p&gt;Kafka 为每个消费组（consumer group）指定一个 broker 来存储目标 topic 各个分区的消费进度（offsets），这个 broker 称为 &lt;strong&gt;组协调器（group coordinator）&lt;/strong&gt;。这个消费组中的任一消费者实例都应该将消费进度提交到这个组协调器，或者从这个组协调器获取启动之前上次的消费进度。Kafka 基于消费组的名称为消费组分配协调器。消费者可以向任一 broker 发送 FindCoordinatorRequest 请求来查找自己的协调器，并从 FindCoordinatorResponse 响应中获取协调器的详细信息。&lt;/p&gt;
&lt;p&gt;在组协调器接收到一个 OffsetCommitRequest 请求后，会将请求数据写到一个特殊的&lt;a href="http://kafka.apache.org/documentation/#compaction"&gt;经压实的（compacted）&lt;/a&gt; Kafka topic - &lt;em&gt;__consumer_offsets&lt;/em&gt;。在目标分区的所有副本都确认收到了，协调器才会向消费者发送进度提交成功的响应。这个 topic 的消息日志数据会定期进行压实（compact），因为只需要为每个分区维护最新的消费进度。协调器也会在内存中缓存消费进度，方便快速响应消费进度查询请求。&lt;/p&gt;
&lt;p&gt;注：如果消费者/消费组特别多（例如：我们广告引擎服务，读取正排消息 topic，一个机器实例就是一个 consumer group，数量在几百到几千不等），那么组协调器的压力会比较大，那么确保组协调器的角色均匀分配到集群的所有 broker，比较关键。另外，&lt;em&gt;__consumer_offsets&lt;/em&gt; 这个 topic 的分区数量不能太少，最好和 broker 数量相同或者整数倍数量。&lt;/p&gt;</content><category term="其他"></category><category term="文章"></category><category term="笔记"></category><category term="经典"></category><category term="Kafka"></category><category term="进行中"></category></entry><entry><title>读文笔记：Photon - Fault-tolerant and Scalable Joining of Continuous Data Streams</title><link href="http://youngsterxyf.github.io/2019/10/10/reading-photon/" rel="alternate"></link><published>2019-10-10T00:00:00+08:00</published><updated>2019-10-10T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-10-10:/2019/10/10/reading-photon/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41318.pdf"&gt;Photon: Fault-tolerant and Scalable Joining of Continuous Data Streams&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Photon 是谷歌广告系统中用于 join 广告曝光日志流和点击日志流的一套系统。&lt;/p&gt;
&lt;p&gt;数据流 join 为什么没用 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41318.pdf"&gt;Photon: Fault-tolerant and Scalable Joining of Continuous Data Streams&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Photon 是谷歌广告系统中用于 join 广告曝光日志流和点击日志流的一套系统。&lt;/p&gt;
&lt;p&gt;数据流 join 为什么没用 flink 这类通用的流式处理框架？&lt;/p&gt;
&lt;p&gt;数据流 join，特别是广告数据流 join，技术上难在哪里？&lt;/p&gt;
&lt;p&gt;任一条流都可能乱序或延迟，广告点击涉及计费的问题，计费不能多算广告主的钱，也要尽可能避免漏计费，降低广告收入损失。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;该系统在谷歌生产环境中每分钟处理百万级的事件，端到端延迟小于 10 秒（注：对于广告实时竞价的广告主而言，这个延迟的长短很重要）。&lt;/p&gt;
&lt;p&gt;广告曝光、点击整体流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户搜索某个关键词时，谷歌的服务器会返回广告和搜索结果。广告服务器会将广告 query 和结果数据作为日志发送到多个日志数据中心（multiple logs-datacenters），最终持久化存储在 GFS 上。每次 query 都会被赋予一个唯一性 ID &lt;em&gt;query_id&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;对于搜索结果中的广告，用户可能会点击。广告点击会触发一次请求，谷歌的后端服务器将请求重定向到广告主的网站。在重定向之前，谷歌服务器会将点击事件记录到日志中，发送到多个日志数据中心。点击事件日志中包含广告曝光的 query_id，点击事件也会被赋予一个唯一性 ID &lt;em&gt;click_id&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计费是在点击之后，但计费所需要的广告出价等信息是在曝光请求中记录的，出于数据敏感性、带宽、请求处理延迟等多方面的考量，计费相关的信息并不会返回到用户客户端，也就是说点击请求中不会包含计费直接相关的信息，需要将 点击日志 和 曝光日志 做一次 join，得到一条完整的上下文日志，才方便做后续计费等处理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/EDOy6VKxeJUcgAW.jpg"&gt;&lt;/p&gt;
&lt;p&gt;论文中提了到该系统解决了几个技术挑战点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仅处理一次语义（exactly-once semantics）：实际上达到的是 最多处理一次语义 （At most once），也就是绝对不能多算钱，然后尽可能避免少算钱&lt;/li&gt;
&lt;li&gt;自动化的跨数据中心容错：也就是多数据中心部署，如果有一个数据中心不可用（比如 网络问题），也不会影响系统正常处理数据&lt;/li&gt;
&lt;li&gt;横向扩展性高：也就是加机器就能应对消息量增长&lt;/li&gt;
&lt;li&gt;低时延&lt;/li&gt;
&lt;li&gt;流乱序&lt;/li&gt;
&lt;li&gt;主流延迟（delayed primary stream）：这里说的”主流“是曝光日志流&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在我看来，该系统的亮点主要在前 3 点，后边细说。&lt;/p&gt;
&lt;p&gt;为解决 1、2 挑战点，系统引入一个服务模块：IdRegistry，这个服务的功能：提供点击事件 id（&lt;em&gt;click_id&lt;/em&gt;） 的存储和查询，如果某个 click_id 可以从 IdRegistry 中查到，则表示该点击事件已经处理过了，不要再次处理。&lt;/p&gt;
&lt;p&gt;并且，多数据中心都部署一套 Photon，但 IdRegistry 共享一个，多套 Photon 系统的输入相同，那么 IdRegistry 除了提供去重的功能，还提供了负载均衡的功能。正常情况下，假设 N 个数据中心，每个数据中心 Photon join 产出的日志数据量为总量的 1/N。&lt;/p&gt;
&lt;p&gt;当某个数据中心的 Photon 不可用时，相当于其负载动态地重新分配到其它数据中心，虽然总体能力上降低了，但只要处理能力有冗余，就不会影响正常处理。&lt;/p&gt;
&lt;p&gt;那么很明显，IdRegistry 很可能成为系统的短板；另外，曝光/点击的唯一性 ID 如何生成？如果由一个中心服务来提供唯一性 ID 的生成，那么这个服务也会成为系统的短板。&lt;/p&gt;
&lt;p&gt;所以，系统没有选择一个中心服务来生成唯一性 id，而是将 id 设计为包含3个部分：&lt;em&gt;ServerIP&lt;/em&gt;、&lt;em&gt;ProcessID&lt;/em&gt;、&lt;em&gt;Timestamp&lt;/em&gt;。由于日志文件中行之间大致是按照时间戳有序的，所以 id 中包含时间戳的一个额外好处是：根据 id 即可大致定位日志内容。另外，还有一个和横向扩展性相关的好处，后边细说。&lt;/p&gt;
&lt;p&gt;IdRegistry 的角色至关重要，所以将其实现为一个基于 Paxos 协议的分布式系统，根据 CAP 原则，可用性（此处是指&lt;strong&gt;吞吐能力&lt;/strong&gt;）受限。解决方案是：&lt;/p&gt;
&lt;p&gt;1、提高单机处理能力：服务端攒批处理，尽可能减少网络往返次数导致的等待（特别是：由于 IdRegistry 是跨地域分布式，部署上节点之间最大延迟是 100ms 左右）&lt;/p&gt;
&lt;p&gt;2、分片（Sharding）：根据 click_id 进行分片，但如果是固定分片，那么随着以后业务量增大，不好扩展。Photon 使用了一种基于时间段动态分片方案，这个方案基于 click_id 自带时间戳。大致逻辑是：使用一个配置，内容大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/VRlgr2CoD8zw7Mm.jpg"&gt;&lt;/p&gt;
&lt;p&gt;对于每个 click 日志，先根据 click_id 中的时间戳，判断分片数，并计算对应的分片 id。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/JMWyQvrDZCaAEdH.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;系统的模块关系图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/zghk6oVaqZ5uEs3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Photon 的 Dispatcher 模块并没有以 Kafka 这种消息队列作为输入，而是直接监听文件系统中的日志文件变更，这一点有点奇怪，不是特别理解。&lt;/p&gt;
&lt;p&gt;Joiner 负责实际的 join 工作，由于 3、4 都比较耗时，所以为了尽可能减少 Joiner 的工作量，Dispatcher 将点击事件日志发送给 Joiner，会先到 IdRegistry 中查一下该事件是否已被处理过，从而起到过滤作用。因多数据中心部署，实际过滤比为：$ \frac{N-1}{N} $。&lt;/p&gt;
&lt;p&gt;为了确保 Joiner 高可用，Joiner 是无状态的，向 Dispatcher 提供 RPC 接口，Joiner 内部有限流，以保证不会因为单个 Joiner 负载过大，导致处理时延增大。Dispatcher 调用 Joiner 失败后会重试，重试使用的是指数退避算法。但处理失败的点击事件，是另外存储在 GFS 上，应该是由另外的线程来负责重试，不会影响正常的事件处理。&lt;/p&gt;
&lt;p&gt;当 Joiner 收到一个点击事件的处理请求时，会根据点击日志数据中的 &lt;em&gt;query_id&lt;/em&gt; 从 EventStore 查询曝光日志详情，但因为曝光日志数据流可能会有延迟，所以可能会查不到，查不到且发现 click_id 中的时间戳早于某个阈值（比如是 N天前的一个事件），Joiner 会将该 click_id 标记为不可 join，然后向 Dispatcher 返回成功；如果 click_id 中的时间戳不早于阈值，则向 Dispatcher 返回失败，由 Dispatcher 来重试。&lt;/p&gt;
&lt;p&gt;为了确保不会多计费，Joiner 在将 join 结果写入 Joined Click Logs 之前，会向 IdRegistry 注册 click_id。&lt;/p&gt;
&lt;p&gt;假设注册实际上已成功，但因网络原因或 RPC 调用超时 Joiner 未收到成功响应，此时怎么办？Joiner 向 IdRegistry 注册 click_id 时，会附带一个额外的 唯一性 token，也包含3个部分：Joiner 服务器地址、进程 ID、时间戳，IdRegistry 会把这个唯一性 token 作为值存储下来，所以对于这种情况，Joiner 可以重复发注册请求，如果 IdRegistry 根据 token 发现已注册成功的 click_id 和当前收到的 click_id 来自同一个 Joiner，则也会返回注册成功。&lt;/p&gt;
&lt;p&gt;假设注册成功，合并结果写入异常，异常分为 2 种，需要解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写入之前，Joiner 节点宕机或重启&lt;/li&gt;
&lt;li&gt;合并结果实际写入成功，但因为网络原因，Joiner 未收到响应&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为尽可能减少因某个 Joiner 节点硬件异常导致的 join 结果丢失，IdRegistry 对于单个 Joiner 的请求有限流，这个限流会间接导致 Joiner 对 Dispatcher 限流。&lt;/p&gt;
&lt;p&gt;为了进一步减少因为上面2种异常情况以及其它异常导致的 Join 结果丢失，Photon 还提供一个校验系统：获取原始点击事件日志，如果该日志 click_id 在 IdRegistry 中存在，但合并结果中不存在，则根据 IdRegistry 存储的对应 click_id 的 token，判断对应的 Joiner 是否存活，如果存活，则交于该 Joiner 重新处理，如果对应的 Joiner 已不存在，则从 IdRegistry 中删除该 click_id 记录，然后交于任一 Joiner 来处理，都一样。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;EventStore 获取原始的曝光日志，向 Joiner 提供查询接口，返回原始的曝光日志内容。&lt;/p&gt;
&lt;p&gt;基于时间局部性，EventStore 内部分 2 层，第一层为 CacheEventStore - 一个类似 Memcached 的 KV 内存映射，K 是 query_id，V 是曝光日志内容，基于一致性哈希算法根据 query_id 进行分片，缓存几分钟最新的曝光日志数据，可以命中 90% 左右的查询请求。&lt;/p&gt;
&lt;p&gt;如果 CacheEventStore 查询 miss，则交于第二层 LogsEventStore 来处理。LogsEventStore 对 query_id 和 曝光日志所在的日志文件及目标起始行（因为日志文件数据大致按时间戳有序，根据 query_id 中的时间戳大致可以知道查询的起始行）建立索引（实际存储在 BigTable 中），查询时，先根据 query_id，查到目标日志文件和起始行，然后从日志文件中读取原始曝光日志内容。&lt;/p&gt;</content><category term="其他"></category><category term="论文"></category><category term="笔记"></category></entry><entry><title>读文笔记：日志 - 每个软件工程师都应该了解的实时数据统一抽象</title><link href="http://youngsterxyf.github.io/2019/10/10/reading-the-log/" rel="alternate"></link><published>2019-10-10T00:00:00+08:00</published><updated>2019-10-10T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-10-10:/2019/10/10/reading-the-log/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话概括，这篇文章细说了 Kafka 的本质原理、解决的问题、适用性等。&lt;/p&gt;
&lt;p&gt;Kafka 本质上是提供日 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话概括，这篇文章细说了 Kafka 的本质原理、解决的问题、适用性等。&lt;/p&gt;
&lt;p&gt;Kafka 本质上是提供日志数据流。&lt;/p&gt;
&lt;p&gt;日志是客观世界的事件记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A log is perhaps the simplest possible storage abstraction. It is an append-only, totally-ordered sequence of records ordered by time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志数据的特点是：只增不改，自带时间戳，数据存储的先后顺序即（大致）是实际发生的时间先后顺序。&lt;/p&gt;
&lt;p&gt;数据库可以基于日志来还原历史操作行为，并最终生成最新状态，主从同步就是这么干的。&lt;/p&gt;
&lt;p&gt;对于分布式系统而言，日志可以解决 2 个问题：按序改变状态和分发数据（ordering changes and distributing data）。&lt;/p&gt;
&lt;p&gt;状态机复制原则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If two identical, deterministic processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分布式系统中各个节点可以依据日志来同步状态，达到（最终）一致性。并且，可以依据节点处理到哪行日志即可确定/表达该节点的状态。&lt;/p&gt;
&lt;p&gt;（日志）事件流（events）和数据表（tables）是一体两面（a facinating duality）：数据表的变更操作即是一个日志事件流，基于日志事件流可以生成数据表，并将其状态不断更新到最新，数据表的状态是日志事件流的在某个时间点的切面。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;events -&amp;gt; table -&amp;gt; events = events &amp;lt;-&amp;gt; table&lt;/p&gt;
&lt;p&gt;The magic of the log is that if it is a complete log of changes, it holds not only the contents of the final version of the table, but also allows recreating all other versions that might have existed. It is, effectively, a sort of backup of every previous state of the table.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码版本控制系统（比如 git）也是基于日志实现的分布式系统，一次 commit 相当于一次日志记录。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于互联网/金融等行业的公司来说，数据是重要资产，如何尽可能发挥数据的潜在价值为公司增收，至关重要。因为管理、技术上的原因，公司通常分多个业务部门，各业务部门提供若干服务，各个服务都会产出数据，这些数据很可能需要跨部门跨服务流通，流通的速度越快，周期越短，收益越大。&lt;/p&gt;
&lt;p&gt;以前，数据的处理方式主要是批处理，并不是因为没有流处理的技术，而是数据流通的基础设施跟不上，没做到持续的数据流。&lt;strong&gt;（注：这个说法，我个人只部分认同，很多时候，批处理的时延和收益可以满足大部分需求，实时流处理的边际效益可能并不明显）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流式处理是批处理的泛化形式（stream processing is a generalization of batch processing, and, given the prevalence of real-time data, a very important generalization）。&lt;/p&gt;
&lt;p&gt;为了避免因数据流通导致各个服务之间的直接耦合，新增一个统一的数据通道中间服务，各个服务只管对数据通道进行写入或读出，不用关心数据是哪个服务写入的，或者哪些服务在消费/使用自己产出的数据。&lt;strong&gt;（解耦）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，消费者消费数据的速率可能不一样，也可能会经历异常重启等情况，让消费者来控制速率，并且多个消费者之间不会相互干扰，会更好。&lt;/p&gt;
&lt;p&gt;基于数据流通的需求和日志的理念，Linkedin 设计开发了 Kafka。&lt;/p&gt;
&lt;p&gt;因为日志数据量可能会很大，日志数据本质上是有序串行的，如果支持数据分片，分片之间并行消费，分片内日志数据全局有序，数据流通的吞吐能力就可以无限扩展。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;基于 Kafka 这类数据管道，服务之间可以实现多级串联。（注：我们现在做的服务就是这么干）&lt;/p&gt;
&lt;p&gt;这种分布式系统架构中，至少涉及 producer（生产者）、broker（中间人）、consumer（消费者）三个角色，角色之间在某些工作上如何分工也是值得思考的：&lt;/p&gt;
&lt;p&gt;生产者产生的数据应该是什么样的？ - 统一格式/编码、方便解析&lt;/p&gt;
&lt;p&gt;中间人（kafka）需要解决什么问题？- 对于单个生产者写入的数据，保证按写入顺序有序地分发给消费者；解决数据高可用，高吞吐能力；支持回溯/重复消费（因此数据需要保留指定时间长度），从而消费者出问题后可以从头消费数据恢复状态。因为支持很多消费者消费同一个数据流，所以平均下来，Kafka 服务的成本会比较低。&lt;/p&gt;
&lt;p&gt;消费者按各自的需求进行数据转换存储。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于实现高吞吐能力，除了分片，Kakfa 还充分利用了攒批处理：生产者可以批量发送，中间人将数据攒批写入磁盘日志文件 等等。&lt;/p&gt;
&lt;p&gt;此外，由于涉及大量的磁盘文件和网络之间数据读写，Kafka 还充分利用操作系统内核的零拷贝传输能力。&lt;/p&gt;</content><category term="其他"></category><category term="论文"></category><category term="笔记"></category></entry><entry><title>Lucene 查询解析器语法（译）</title><link href="http://youngsterxyf.github.io/2019/09/04/lucene-query-parser-syntax/" rel="alternate"></link><published>2019-09-04T00:00:00+08:00</published><updated>2019-09-04T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-09-04:/2019/09/04/lucene-query-parser-syntax/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description"&gt;Query Parser Syntax&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（一个词法分析器，使用 JavaCC 将一个字符串 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description"&gt;Query Parser Syntax&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（一个词法分析器，使用 JavaCC 将一个字符串翻译成一个 Lucene 查询）提供一种功能丰富的查询语言。&lt;/p&gt;
&lt;p&gt;一般来说，查询解析器支持的语法在不同发布版本之间可能会有变化。当前这个文档页面描述的是当前这个发布版本的语法。如果你正在使用一个不同版本的 Lucene，请参考该版本自带的 docs/queryparsersyntax.html 文档。&lt;/p&gt;
&lt;p&gt;在选择使用这个查询解析器之前，请考虑以下 3 点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你准备以编程的方式生成一个查询字符串，然后使用查询解析器来解析它。那么，你应该认真考虑一下是否应该直接使用查询 API 来构建查询。换句话说，查询解析器专门用于人类输入的文本，而不是程序生成的文本。&lt;/li&gt;
&lt;li&gt;不可分词（untokenized）的域（译者注：抱歉，此处没太理解）最好直接添加到查询中，而不是通过查询解析器来解析。如果一个域的值是通过应用自动生成的，那么应该为这个域自动生成查询子句。分析器（查询解析器所使用的）是专门用于将人类输入的文本转换成一些词（terms），那么程序自动生成的值，也应该由程序自动添加到查询中。&lt;/li&gt;
&lt;li&gt;从查询形式来看，如果域的值是普通文本，则应该使用查询解析器。所有其它值类型，比如：日期范围、关键词等等，最好通过查询 API 直接添加。如果一个域的值仅限于一个有限的集合（可以通过一个下拉菜单指定），则不应该添加到查询字符串（后续会被解析）中，而是应该作为一个 TermQuery 子句添加到查询中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;词（Terms）&lt;/h2&gt;
&lt;p&gt;一个查询语句可以拆解成 词（terms） 和 操作符（operators）。词又分为两种：单个词（single Terms）和短语（Phrases）。&lt;/p&gt;
&lt;p&gt;单个词是指 ”test“ 或 ”Hello“ 这类单词。&lt;/p&gt;
&lt;p&gt;短语是指以双引号包围起来的一组单词，比如：”hello dolly“。&lt;/p&gt;
&lt;p&gt;多个词（Multiple terms）可以使用布尔操作符组合在一起，实现一个更加复杂的查询（如下文所示）。&lt;/p&gt;
&lt;p&gt;备注：用于创建索引的解析器也会用于解析查询字符串中的词和短语。因此，选择合适的解析器很重要，否则解析器可能会被查询字符串中的词干扰（译者注：这句应该是指英文解析器可能无法对中文进行正确分词的问题）。&lt;/p&gt;
&lt;h2&gt;域（Fields）&lt;/h2&gt;
&lt;p&gt;Lucene 支持分多个字段/域的数据。搜索时，可以指定一个域，也可以使用默认域。域的名称以及默认域与具体实现相关。&lt;/p&gt;
&lt;p&gt;输入域的名称，后跟一个冒号（:），以及目标搜索词，即可对任意一个域进行搜索。&lt;/p&gt;
&lt;p&gt;举例来说，假设一个 Lucene 索引包含 2 个域：title 和 text，text 是默认域。若想查找标题为 ”The Right Way“ 且文本内容包含 ”don't go this way“ 的文档，可以输入：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;title:&lt;span style="color: #a31515"&gt;&amp;quot;The Right Way&amp;quot;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;AND&lt;/span&gt; &lt;span style="color: #2b91af"&gt;text&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;&lt;span style="color: #0000ff"&gt;go&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;title:&lt;span style="color: #a31515"&gt;&amp;quot;The Right Way&amp;quot;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;AND&lt;/span&gt; &lt;span style="color: #0000ff"&gt;go&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为 text 是默认域，所以域的标志可以省略。&lt;/p&gt;
&lt;p&gt;注意：指定的域仅对紧跟其后的词生效，因此，如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;title:The Right Way
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将对 title 域仅查找 ”The“，并对默认域（当前这个例子中是指 text 域）查找 ”Right“ 和 ”Way“。&lt;/p&gt;
&lt;h2&gt;词修饰语（Term Modifiers）&lt;/h2&gt;
&lt;p&gt;Lucene 支持修饰查询词（modifying query terms）来提供多种搜索方式。&lt;/p&gt;
&lt;h3&gt;通配符搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持对单个词(single terms)（不是短语查询 phrase queries）进行单个字符和多个字符的通配搜索。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;?&lt;/code&gt; 符号进行单个字符的通配搜索。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;*&lt;/code&gt; 符号进行多个字符的通配搜索。&lt;/p&gt;
&lt;p&gt;单字符通配搜索用于查找替换单个字符即可匹配的词。举例来说，若要搜索 ”text“ 或 ”test“，可以如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;te?t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多字符通配搜索用于查找替换0个或多个字符即可匹配的词。举例来说，若要搜索 ”test“、”tests“ 或 ”tester“，可以如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;test*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以对词的中间部分进行通配搜索：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;te*t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;备注：不可以将 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; 符号用作一次搜索的首个字符。&lt;/p&gt;
&lt;h3&gt;正则表达式搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持正则表达式搜索，匹配斜杠（&lt;code&gt;/&lt;/code&gt;） 之间的模式。正则表达式的语法在不同的发布版本之间可能会有差异，目前支持的语法在 &lt;a href="http://lucene.apache.org/core/8_2_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true"&gt;RegExp&lt;/a&gt; 类文档中有说明。举例来说，查找包含 ”moat“ 或 ”boat“ 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/[mb]oat/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;模糊搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持基于 Damerau-Levenshtein 编辑距离的模糊搜索。在单个词的最后添加波浪符（~）即可进行模糊搜索。举例来说，使用模糊搜索查找拼写上近似 ”roam“ 的词：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;roam~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个查询语句会找到 foam 和 roams 这类词。&lt;/p&gt;
&lt;p&gt;模糊搜索可以通过一个额外（可选）的参数来指定允许的最大编辑次数。这个参数值界于 0 和 2 之间，例如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;roam~1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果未指定该参数，则默认使用 2 个编辑距离。&lt;/p&gt;
&lt;p&gt;以前，这里还允许使用浮点数。现在这个语法已被考虑弃用，将于 Lucene 5.0 中移除。&lt;/p&gt;
&lt;h3&gt;邻近搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持查找指定距离的邻近词。在短语的最后添加拨浪符（~）即可进行邻近搜索。举例来说，在文档中搜索 ”apache“ 和 ”jakarta“ 相距 10 个词的模式：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;jakarta apache&amp;quot;~10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;范围搜索&lt;/h3&gt;
&lt;p&gt;范围查询可以要求域的值在范围查询语句指定的上下界之间。范围查询对于上下界可以包含也可以不包含。排序按照字典序进行。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mod_date:[20020101 TO 20030101]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个查询语句会查找 mod_date 域的值在 20020101 和 20030101 （包含上下界） 之间的文档。注意：范围查询并不是仅适用于日期域，也可以对非日期的域进行范围查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;title:{Aida TO Carmen}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个查询语句会查找到 title 域的值在 Aida 和 Carmen （不包含上下界）之间的所有文档。&lt;/p&gt;
&lt;p&gt;包含上下界的范围查询使用方括号来表示。不包含上下界的范围查询使用大括号来表示。&lt;/p&gt;
&lt;h3&gt;词加权（Boosting a term）&lt;/h3&gt;
&lt;p&gt;Lucene 会基于文档中找到的词对匹配到的文档提供相关性级别（译者疑问：基于向量余弦来计算相关性？）。可以在目标搜索词之后紧接一个脱字符 “^”，后跟一个加权系数（一个数字）来提升该搜索词的相关性权重。加权系统越高，查询命中的文档与该词的相关性越强。&lt;/p&gt;
&lt;p&gt;加权操作允许对词进行加权控制文档的相关性。例如，假设你正在搜索：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;jakarta apache
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后希望搜索结果和词 ”jakarta“ 更相关一些，则可以使用 ”^“ 符号后跟一个加权系数对这个词进行加权，即如下这样查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;jakarta^4 apache
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这会使得查找到的文档和词 ”jakarta“ 看起来更相关一些。也可以对短语进行加权，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;jakarta apache&amp;quot;^4 &amp;quot;Apache Lucene&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认，加权系数是 1。加权系统可以小于 1（比如：0.2），但必须大于 0。&lt;/p&gt;
&lt;h2&gt;布尔操作符&lt;/h2&gt;
&lt;p&gt;布尔操作符允许使用逻辑操作符组合多个词。Lucene 支持的布尔操作符包含 &lt;code&gt;AND&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;OR&lt;/code&gt;、&lt;code&gt;NOT&lt;/code&gt; 及 &lt;code&gt;-&lt;/code&gt;（备注：布尔操作符必须全部是大写字母）。&lt;/p&gt;
&lt;h3&gt;OR&lt;/h3&gt;
&lt;p&gt;“OR” 操作符是默认的连接操作符。这意味着如果两个词之间没有布尔操作符，则使用 “OR” 操作符。OR 操作符链接两个词，并匹配包含其中任意一个词的文档。这相当于集合的并集操作。“||” 符合可用于替代单词 “OR”。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索包含 “jakarta apache” 或仅是 “jakarta” 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;jakarta apache&amp;quot; jakarta
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;jakarta apache&amp;quot; OR jakarta
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;AND&lt;/h3&gt;
&lt;p&gt;"AND" 操作符会匹配文本内容中同时存在两个词（因为 AND 是二元操作符）的文档。这相当于集合的交集操作。“&amp;amp;&amp;amp;” 符号可用于替代单词 “AND”。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索包含 “jakarta apache” 和 “Apache Lucene” 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;jakarta apache&amp;quot; AND “Apache Lucene”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;+&lt;/h3&gt;
&lt;p&gt;“+”（必需）操作符要求文档的某个域中包含 “+” 符号之后的词。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索（必须）包含 “jakarta” 以及可能包含 “lucene”（包不包含都可以）的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;+jakarta lucene
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;NOT&lt;/h3&gt;
&lt;p&gt;若文档包含”NOT“之后的词，”NOT“ 操作会排查该文档。这相当于集合的差集操作。”!“ 符号可用于替代单词 ”NOT“。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句搜索包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档”：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;jakarta apache&amp;quot; NOT &amp;quot;Apache Lucene&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;备注：“NOT” 操作符不可以用于单个词。例如，如下搜索不会返回任何结果：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NOT &amp;quot;jakarta apache&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;-&lt;/h3&gt;
&lt;p&gt;如果文档包含”-“符号之后的词，那么”-“（禁止）操作符会排除这些文档。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来查询包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;jakarta apache&amp;quot; -&amp;quot;Apache Lucene&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;分组&lt;/h2&gt;
&lt;p&gt;Lucene 支持使用圆括号对子句进行分组，构成子查询。如果你想控制一个查询语句的布尔逻辑，这对非常有用。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索包含 “jakarta” 或 “apache”，以及 “website” 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(jakarta OR apache) AND website
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如此就消除了任何困惑，确保你想表达是：必须存在 ”website“，以及可能存在词 ”jakarta“ 或 ”apache“。&lt;/p&gt;
&lt;h2&gt;域分组&lt;/h2&gt;
&lt;p&gt;Lucene 支持使用圆括号对单个域的多个子句进行分组。&lt;/p&gt;
&lt;p&gt;例如，若想搜索一个 title 中既包含单词“return”且包含短语“pink panther”，可以使用如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;title:&lt;span style="color: #a31515"&gt;(&lt;/span&gt;+&lt;span style="color: #0000ff"&gt;return&lt;/span&gt; +&lt;span style="color: #a31515"&gt;&amp;quot;pink panther&amp;quot;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;特殊字符转义&lt;/h2&gt;
&lt;p&gt;Lucene 支持对查询语法使用的特殊字符进行转移。目前这些特殊字符如下列表所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;+ - &amp;amp;&amp;amp; || ! ( ) { } [ ] ^ &amp;quot; ~ * ? : \ /
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在特殊字符之前加 &lt;code&gt;\&lt;/code&gt; 来转义。例如，使用如下查询语句来搜索 &lt;code&gt;(1+1):2&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\(1\+1\)\:2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Lucene"></category><category term="ElasticSearch"></category><category term="Kibana"></category></entry><entry><title>一个 Python 小项目的小结</title><link href="http://youngsterxyf.github.io/2019/08/14/a-python-project-summary/" rel="alternate"></link><published>2019-08-14T00:00:00+08:00</published><updated>2019-08-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-08-14:/2019/08/14/a-python-project-summary/</id><summary type="html">&lt;p&gt;前段时间临时接手一个 Python 小项目，这个项目实现的类似一个管控平台，其中核心功能是为算法同学提供机器学习模型训 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前段时间临时接手一个 Python 小项目，这个项目实现的类似一个管控平台，其中核心功能是为算法同学提供机器学习模型训练任务的全流程管理，平台后端基于 Flask 框架实现，前端基于 Ant Design Pro 实现。&lt;/p&gt;
&lt;p&gt;代码稍微有些乱，所以做了部分代码的重构，在此做点经验小结。&lt;/p&gt;
&lt;h3&gt;1、并行化或异步化&lt;/h3&gt;
&lt;p&gt;部分请求处理逻辑，由于比较耗时，故使用线程池来加速，或者使用独立线程异步处理，或者先存储一个中间状态，由后台定时任务来完成实际的处理工作。对于异步处理结果，前端通过轮询来获取。&lt;/p&gt;
&lt;p&gt;线程池的使用，主要使用 map 方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool

input_list = [...]
pool: Pool = Pool(len(input_list))
pool.map(func, input_list)
pool.close()
pool.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;独立线程异步处理：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; multiprocessing

p = multiprocessing.Process(target=func, args=(...))
p.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;定时任务，基于 apscheduler 库实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; apscheduler.schedulers.background &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; BackgroundScheduler

scheduler = BackgroundScheduler()

scheduler.add_join(func, &lt;span style="color: #a31515"&gt;&amp;#39;interval&amp;#39;&lt;/span&gt;, seconds=1)

scheduler.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为对于 Python 应用，通常会使用 gunicorn 这种 WSGI HTTP 服务器以多进程启动多个应用实例，提升请求吞吐能力。但是对于定时任务我们希望只有一个实例，对此，如果使用 gunicorn，可以基于它的 preload 机制来实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# wsgi.py&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; app

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 注意其中的 --preload 参数&lt;/span&gt;
gunicorn --workers=4 --preload --log-level=info --access-logfile=access.log -b 0.0.0.0:8080 wsgi:app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;preload 机制简单来说，就是 import app 类所在的模块及其依赖的各个模块（import 过程中会执行其中的语句），然后 fork 出多个进程，每个进程都执行 app.run()。&lt;/p&gt;
&lt;h4&gt;2、实现一些通用方案对异常进行捕获或重试&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; exception_try(times: int = 3, sleep_then_try_seconds=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; decorator(f):
        &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; wrapper(*args, **kwargs):
            count = 0
            exception = &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; count &amp;lt; times:
                &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
                    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; f(*args, **kwargs)
                &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; Exception &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
                    exception = e
                    count += 1
                    logging.exception(&lt;span style="color: #a31515"&gt;&amp;quot;Try {} times&amp;quot;&lt;/span&gt;.format(count))
                    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (sleep_then_try_seconds &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; count &amp;lt; times:
                        time.sleep(sleep_then_try_seconds)
            &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; exception
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; wrapper
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; decorator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;@exception_try(times=3, sleep_then_try_seconds=0.5)
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; connect(self):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; pymysql.connect(host=self.host, user=self.user, password=self.password, db=self.db, charset=self.charset)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个装饰器方法用于实现异常重试，并且可以指定重试的时间间隔，实际使用下来效果较好。而且也不会因为 &lt;code&gt;try...except&lt;/code&gt; 导致大块代码缩进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确保数据库连接关闭（其它类似资源也可以这样实现）&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; with_db(db: Connection, exception_callback=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; decorator(f):
        &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; db_context(*a, **kw):
            &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; f(db, *a, **kw)
            &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; Exception &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
                logging.exception(str(e))
                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; exception_callback &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;:
                    exception_callback(e)
            &lt;span style="color: #0000ff"&gt;finally&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
                    db.close()
                &lt;span style="color: #0000ff"&gt;except&lt;/span&gt;:
                    &lt;span style="color: #0000ff"&gt;pass&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; db_context

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; decorator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 将 conf.db.connect() 对象作为 delete_task_from_job_queue 的第一个参数注入，task_id 这个参数以不定参数的方式传入 delete_task_from_job_queue&lt;/span&gt;
with_db(conf.db.connect())(delete_task_from_job_queue)(task_id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个装饰器方法用于确保数据库连接在异常发生也能正常关闭，防止资源泄露。&lt;/p&gt;
&lt;h4&gt;3、循环等待或超时&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;TimeoutCondition&lt;/span&gt;(object):

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, condition_func, timeout_seconds):
        self.condition = condition_func
        self.timeout = timeout_seconds
        self.begin = &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;
        self.timeout_false = &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;
        self.cond_true = &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __bool__(self):
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; self.begin &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;:
            self.begin = timeit.default_timer()
        self.cond_true = self.condition()
        self.timeout_false = self.timeout &amp;lt;= 0 &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; (timeit.default_timer() - self.begin) &amp;lt; self.timeout
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; self.cond_true &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; self.timeout_false

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; is_timeout(self):
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; self.cond_true &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; self.timeout_false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cond = TimeoutCondition(&lt;span style="color: #0000ff"&gt;lambda&lt;/span&gt; : len(service_list) == 0, 5)
&lt;span style="color: #0000ff"&gt;while&lt;/span&gt; cond:
    time.sleep(1)
    service_list = get_service_list()
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; cond.is_timeout():
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;TimeoutCondition&lt;/code&gt; 用于实现循环等待某个条件满足，但为了避免死循环，所以加一个超时条件判断。实例化参数第一个是原始的条件判断 lambda 语句，第二个是一个超时设置。另外，借助魔术方法 &lt;code&gt;__bool__&lt;/code&gt;，让 TimeoutCondtion 的实例用起来像是一个布尔变量，调用 &lt;code&gt;is_timeout()&lt;/code&gt; 方法可以区分循环等待退出是因为原始条件满足，还是超时退出的。&lt;/p&gt;
&lt;h4&gt;4、按部署环境配置应用的行为&lt;/h4&gt;
&lt;p&gt;应用在不同的环境（开发、测试、生产）中应该允许加载不同的配置，配置不同的行为。&lt;/p&gt;
&lt;p&gt;当前应用处于什么环境，可以通过环境变量来配置，应用初始化时最先检测当前处于什么环境，之后的初始化流程就可以依据环境配置来加载配置，定制应用行为。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# conf/__init__.py&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;AppConfig&lt;/span&gt;(object):
    app_env = os.getenv(&lt;span style="color: #a31515"&gt;&amp;#39;APP_ENV&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;development&amp;#39;&lt;/span&gt;)
    is_prod = app_env == &lt;span style="color: #a31515"&gt;&amp;#39;production&amp;#39;&lt;/span&gt;
    is_dev = app_env == &lt;span style="color: #a31515"&gt;&amp;#39;development&amp;#39;&lt;/span&gt;
    is_testing = app_env == &lt;span style="color: #a31515"&gt;&amp;#39;testing&amp;#39;&lt;/span&gt;

    &lt;span style="color: #008000"&gt;# 其余应用配置项&lt;/span&gt;
    ...

conf = AppConfig()


&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; _load_config_by_env(env: str):
    &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    不同环境加载不同的配置文件&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    配置目录结构：&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    conf/&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        __init__.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        development.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        production.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        testing.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    module = importlib.import_module(&lt;span style="color: #a31515"&gt;&amp;#39;conf.{}&amp;#39;&lt;/span&gt;.format(env))
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; hasattr(module, &lt;span style="color: #a31515"&gt;&amp;#39;Config&amp;#39;&lt;/span&gt;):
        logging.warning(&lt;span style="color: #a31515"&gt;&amp;#39;Not find {} config&amp;#39;&lt;/span&gt;.format(env))
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; name, value &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; getattr(module, &lt;span style="color: #a31515"&gt;&amp;#39;Config&amp;#39;&lt;/span&gt;).__dict__.items():
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; name.startswith(&lt;span style="color: #a31515"&gt;&amp;#39;__&amp;#39;&lt;/span&gt;):
            &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;
        conf.__dict__[name] = value
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 根据环境配置日志级别&lt;/span&gt;
log_level = logging.INFO &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; conf.is_prod &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; logging.DEBUG
logging.basicConfig(format=consts.LOG_FORMAT, level=log_level)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;5、方便排查问题的日志输出&lt;/h4&gt;
&lt;p&gt;日志是问题排查的主要信息来源，所以日志记录得好不好，很关键。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# https://github.com/python/cpython/blob/3.7/Lib/logging/__init__.py#L457&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 日志时间 - 日志级别 - 代码文件路径 - 行号 - 进程 ID - 线程名称 - 日志内容&lt;/span&gt;
LOG_FORMAT = &lt;span style="color: #a31515"&gt;&amp;#39;%(asctime)-15s - %(levelname)s - %(pathname)s - %(lineno)d - %(process)d - %(threadName)s - %(message)s&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;6、API 规范与异常提示&lt;/h4&gt;
&lt;p&gt;为了统一前端 API 响应处理，有必要对 API 响应体的结构指定标准。以我个人的习惯，所有从应用代码中返回的响应，HTTP 状态码都应该是 200，具体当前 API 请求成功还是失败，如果失败，失败的原因是什么都应该包含在响应体中，响应体大致的结构为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{
    &amp;quot;code&amp;quot;: &lt;span style="border: 1px solid #FF0000"&gt;...&lt;/span&gt;,
    &amp;quot;msg&amp;quot;: &lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;,
    &amp;quot;data&amp;quot;: &lt;span style="border: 1px solid #FF0000"&gt;...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;code 表示请求处理失败时，data 字段可选，code 表示请求处理成功时，msg 字段可选。&lt;/p&gt;
&lt;p&gt;前端配合对响应体进行统一检测和提示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; { notification } &lt;span style="color: #0000ff"&gt;from&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;antd&amp;#39;&lt;/span&gt;;

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; defaultHTTPCodeHandler(response) {
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (response.status &amp;gt;= 400) {
    &lt;span style="color: #008000"&gt;// 注意 clone&lt;/span&gt;
    response.clone().text().then(respBody =&amp;gt; {
      notification.error({message: &lt;span style="color: #a31515"&gt;&amp;#39;API 异常响应&amp;#39;&lt;/span&gt;, description: &lt;span style="color: #a31515"&gt;`${&lt;/span&gt;response.status&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;respBody&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;, duration: &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;});
      console.log(&lt;span style="color: #a31515"&gt;`${&lt;/span&gt;response.status&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;respBody&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;);
    });
  }
}

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; defaultMsgCodeHandler(response) {
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (response.status === 200) {
    &lt;span style="color: #008000"&gt;// 注意 clone&lt;/span&gt;
    response.clone().json().then(jsonBody =&amp;gt; {
      &lt;span style="color: #008000"&gt;// 0、200、10000 都属于成功响应&lt;/span&gt;
      &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (jsonBody !== &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; &amp;amp;&amp;amp; jsonBody.code !== &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; &amp;amp;&amp;amp; jsonBody.code !== 0 &amp;amp;&amp;amp; jsonBody.code !== 200 &amp;amp;&amp;amp; jsonBody.code != 10000) {
        notification.error({message: &lt;span style="color: #a31515"&gt;&amp;#39;请求失败&amp;#39;&lt;/span&gt;, description: &lt;span style="color: #a31515"&gt;`${&lt;/span&gt;jsonBody.code&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;jsonBody.msg&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;, duration: &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;});
        console.log(&lt;span style="color: #a31515"&gt;`${&lt;/span&gt;jsonBody.code&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;jsonBody.msg&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;);
      }
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;并且统一封装发起请求的逻辑：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;export&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; corsFetch(url, init, httpCodeCallback, msgCodeCallback) {
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; host = myHost();
  &lt;span style="color: #0000ff"&gt;let&lt;/span&gt; urlPrefix = host;
  &lt;span style="color: #008000"&gt;// 自带 host，则不额外补充 host 前缀&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (url.startsWith(&lt;span style="color: #a31515"&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;) || url.startsWith(&lt;span style="color: #a31515"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;)) {
    urlPrefix = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
  }
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; httpCodeHandler = httpCodeCallback === &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; ? defaultHTTPCodeHandler : httpCodeCallback;
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; msgCodeHandler = msgCodeCallback === &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; ? defaultMsgCodeHandler : msgCodeCallback;
  &lt;span style="color: #008000"&gt;// 对于线上环境或者测试环境，不跨域&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (host === PROD_ENV_HOST || host === TEST_ENV_HOST) {
    &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; promise = fetch(urlPrefix + url, init);
    promise.then((response) =&amp;gt; httpCodeHandler(response));
    promise.then((response) =&amp;gt; msgCodeHandler(response));
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; promise;
  }
  &lt;span style="color: #008000"&gt;// 对于本地测试环境，跨域访问预发环境 API 数据，方便测试&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;let&lt;/span&gt; corsInit = {
    credentials: &lt;span style="color: #a31515"&gt;&amp;#39;include&amp;#39;&lt;/span&gt;,
    mode: &lt;span style="color: #a31515"&gt;&amp;#39;cors&amp;#39;&lt;/span&gt;,
    redirect: &lt;span style="color: #a31515"&gt;&amp;#39;follow&amp;#39;&lt;/span&gt;,
  };
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (init !== &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt;) {
    corsInit = { ...corsInit, ...init };
  }
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (urlPrefix !== &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;) {
    urlPrefix = TEST_ENV_HOST;
  }
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; promise = fetch(urlPrefix + url, corsInit);
  promise.then((response) =&amp;gt; httpCodeHandler(response));
  promise.then((response) =&amp;gt; msgCodeHandler(response));
  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; promise;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中为了方便本地开发测试，允许本地开发环境跨域访问测试环境（最好不要直接跨越访问生产环境），并且自动区分，corsFetch 调用方无感知。&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category><category term="Python"></category></entry><entry><title>Reactor 官方文档翻译简化版</title><link href="http://youngsterxyf.github.io/2019/06/26/simplified-reactor-doc-zh/" rel="alternate"></link><published>2019-06-26T00:00:00+08:00</published><updated>2019-06-26T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-06-26:/2019/06/26/simplified-reactor-doc-zh/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://projectreactor.io/docs/core/release/reference/"&gt;Reactor 3 Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. 起步&lt;/h3&gt;
&lt;h4&gt;1.1 Reactor 简介&lt;/h4&gt;
&lt;p&gt;Reactor 是为 JVM 准备的一个完全非阻塞的反应式编程基础组件，支持高效的需求管理（以管理 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://projectreactor.io/docs/core/release/reference/"&gt;Reactor 3 Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. 起步&lt;/h3&gt;
&lt;h4&gt;1.1 Reactor 简介&lt;/h4&gt;
&lt;p&gt;Reactor 是为 JVM 准备的一个完全非阻塞的反应式编程基础组件，支持高效的需求管理（以管理“反压”的形式），直接与 Java 8 的函数式 API 集成，尤其是 &lt;code&gt;CompletableFuture&lt;/code&gt;、&lt;code&gt;Stream&lt;/code&gt; 以及 &lt;code&gt;Duration&lt;/code&gt;，提供可组合的异步序列 API - &lt;code&gt;Flux&lt;/code&gt;（适用于 N 个元素的序列）和 &lt;code&gt;Mono&lt;/code&gt;（适用于 0 或 1个元素的序列）--- 并且全面地（extensively）实现了 &lt;a href="https://www.reactive-streams.org/"&gt;反应式流（Reative Streams）&lt;/a&gt; 规范。&lt;/p&gt;
&lt;p&gt;借助 &lt;code&gt;reactor-netty&lt;/code&gt; 项目，Reactor 也支持进程间的非阻塞通信，适用于微服务架构。&lt;code&gt;reactor-netty&lt;/code&gt; 为 HTTP（包括 Websockets）、TCP 以及 UDP 提供支持反压的网络引擎，完全支持反应式编码解码。&lt;/p&gt;
&lt;h4&gt;1.2 理解 BOM&lt;/h4&gt;
&lt;p&gt;Reactor 3 开始采用 BOM （Bill of Materials，物料清单）发布模型（自 &lt;code&gt;reactor-core 3.0.4&lt;/code&gt; 开始，使用 &lt;code&gt;Aluminium&lt;/code&gt;（铝）版本序列），一个版本包含一组相关组件的版本，这些版本组件之间兼容性非常好，允许这些组件采用不同的版本命名方式。&lt;/p&gt;
&lt;p&gt;BOM 发布模型本身也是版本化的，以一个代号后接一个修饰词来命名一个版本序列。如下是一个示例列表：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Aluminium-RELEASE
Californium-BUILD-SNAPSHOT
Aluminium-SR1
Bismuth-RELEASE
Californium-SR32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代号等价于常规的 &lt;code&gt;大版本号.小版本号&lt;/code&gt; 形式，通常以字母升序方式取自 &lt;a href="https://en.wikipedia.org/wiki/Periodic_table#Overview"&gt;元素周期表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;按照时间顺序，修饰词分别为如下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUILD-SNAPSHOT：为开发测试构建的版本。&lt;/li&gt;
&lt;li&gt;M1 .. N：里程碑版本或者开发者预览版本。&lt;/li&gt;
&lt;li&gt;RELEASE：一个代号系列中的首个 GA（General Availability 通用）发行版。&lt;/li&gt;
&lt;li&gt;SR1 .. N：一个代号系列中的后续 GA 发行版 - 相当于一个补丁版本。（SR 代表 “Service Release”（服务版本））&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3 如何获取 Reactor&lt;/h4&gt;
&lt;h5&gt;1.3.1 以 Maven 管理依赖包&lt;/h5&gt;
&lt;p&gt;Maven 原生支持 BOM 模型概念。首先，在你的 &lt;code&gt;pom.xml&lt;/code&gt; 文件添加如下代码片段来引入 BOM：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt; 
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;reactor-bom&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;Bismuth-RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;备注：注意其中的 &lt;code&gt;dependencyManagement&lt;/code&gt; 标签，添加到 &lt;code&gt;dependencies&lt;/code&gt; 一节中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果顶部标签（&lt;code&gt;dependencyManagement&lt;/code&gt;）已经存在，则只添加上面该标签的内部内容。&lt;/p&gt;
&lt;p&gt;接下来，将依赖包添加到项目中，和一般依赖包一样，不过没有 &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;reactor-core&amp;lt;/artifactId&amp;gt; 
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;reactor-test&amp;lt;/artifactId&amp;gt; 
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;1.3.2 以 Gradle 管理依赖包&lt;/h5&gt;
&lt;p&gt;Gradle 核心并不支持 Maven BOM，不过可以借助 Spring 的 &lt;a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"&gt;gradle-dependency-management&lt;/a&gt; 插件。&lt;/p&gt;
&lt;p&gt;首先，应用插件，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;plugins {
    id &amp;quot;io.spring.dependency-management&amp;quot; version &amp;quot;1.0.6.RELEASE&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后使用它来引入 BOM，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dependencyManagement {
     imports {
          mavenBom &amp;quot;io.projectreactor:reactor-bom:Bismuth-RELEASE&amp;quot;
     }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后将依赖添加到项目中，无需指定版本号，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dependencies {
     compile &amp;#39;io.projectreactor:reactor-core&amp;#39; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2. 反应式编程简介&lt;/h3&gt;
&lt;p&gt;Reactor 是反应式编程范式的一个实现。反应式编程的定义归纳起来，如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反应式编程是一个异步编程范式，关注数据流和变化的传播。这意味着通过被采用编程语言可以轻松地表达静态（比如 数组）或动态（比如 事件发射器）数据流。 --- https://en.wikipedia.org/wiki/Reactive_programming&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反应式编程方向的首个重要工作是：微软在 .NET 生态体系中创建了反应式扩展（Rx）库，然后 RxJava 在 JVM 上实现了反应式编程。时光飞逝，经 Reative Streams 的大力推进，Java 社区终于出现了反应式编程标准，该规范定义了一组接口以及 JVM 上反应式编程库之间的交互规则。Java 9 标准库已将这组接口集成到 &lt;code&gt;Flow&lt;/code&gt; 类（译注：见&lt;a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html"&gt;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html&lt;/a&gt;）中。&lt;/p&gt;
&lt;p&gt;反应式编程范式在面向对象语言中通常表现为一个观察者设计模式的扩展。你也可以将主流的反应式流模式（reactive streams pattern）和大家熟知的迭代器设计模式做对比，所有这些库中都存在对标于 &lt;code&gt;Iterable&lt;/code&gt; - &lt;code&gt;Iterator&lt;/code&gt; 的概念（译注：比如 发布者-消费者）。主要差别在于：迭代器是基于 pull 方式，反应式流则基于 push 方式。&lt;/p&gt;
&lt;p&gt;使用迭代器是一个命令式编程的模式，即使如何访问数据（accessing values）完全是 &lt;code&gt;Iterable&lt;/code&gt; 的职责，但实际上，何时访问序列中的下一个（&lt;code&gt;next()&lt;/code&gt;）值取决于开发者的选择。在反应式流中，上述 &lt;code&gt;Iterable&lt;/code&gt; - &lt;code&gt;Iterator&lt;/code&gt; 对的等价物为 &lt;code&gt;Publisher&lt;/code&gt; - &lt;code&gt;Subscriber&lt;/code&gt;。不过，在出现新的数据/事件时，由 &lt;code&gt;Publisher&lt;/code&gt; 通知 &lt;code&gt;Subscriber&lt;/code&gt;，这个“推”特性也是实现反应式的关键之处。并且，在被推送的值上应用哪些操作是声明式表达而不是命令式表达的：程序员表达的是计算逻辑而不是描述精确的控制流。&lt;/p&gt;
&lt;p&gt;除了“推”的特性，反应式流也良好地定义了如何处理错误和结束流。一个 &lt;code&gt;Publisher&lt;/code&gt; 可以向它的 &lt;code&gt;Subscriber&lt;/code&gt; 推送新的值（通过调用订阅者的 &lt;code&gt;onNext&lt;/code&gt; 方法），也可以推送错误（调用 &lt;code&gt;onError&lt;/code&gt; 方法）或结束（调用 &lt;code&gt;onComplete&lt;/code&gt;方法）信号。错误和结束信号都可以终结事件序列。简而言之，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;onNext x 0..N [onError | onComplete]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个方式非常灵活。这个模式支持“没有值”、“一个值”或“n个值”（包括值无限的序列，比如时钟的持续滴答事件）的各种使用场景。&lt;/p&gt;
&lt;p&gt;但是，起初，我们为什么需要这样一个异步的反应式的编程库？&lt;/p&gt;
&lt;h4&gt;2.1 阻塞即是资源浪费&lt;/h4&gt;
&lt;p&gt;现代的软件应用，并发用户量非常巨大，即使现代硬件的处理能力一直在提升，软件的性能仍旧是一个关键问题。&lt;/p&gt;
&lt;p&gt;宽泛来讲，提升一个程序的性能，有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;并行化&lt;/strong&gt; 使用更多的线程和更多的硬件资源。&lt;/li&gt;
&lt;li&gt;对于当前的硬件资源，&lt;strong&gt;寻求更高效的使用方式&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，Java 开发者会使用阻塞性的代码编写程序，这种代码编写方式容易触及性能瓶颈，然后引入更多的线程来运行相似的阻塞性代码。但是，这种资源利用的扩展方式很快就会引发竞态（contention）和并发的问题。&lt;/p&gt;
&lt;p&gt;更糟糕的是，阻塞就意味着浪费资源。如果你稍加分析，就会发现一旦程序牵涉一些等待延迟（尤其是 I/0 操作，比如等待一个数据库请求或者一个网络调用），资源就会被浪费，因为此时线程（可能是大量线程）是空闲的，等待着数据。&lt;/p&gt;
&lt;p&gt;因此，并行化方式并非银弹。为了压榨出硬件的全部能力，并行化是必要的，但并行化的代码理解（reason about）起来也非常复杂，实际威力也会因为资源浪费而大打折扣。&lt;/p&gt;
&lt;h4&gt;2.2 异步可以解决问题吗？&lt;/h4&gt;
&lt;p&gt;前面提到的第二种方式 - 寻求更高效的使用方式 - 是资源浪费问题的一个解决方案。通过编写异步非阻塞的代码，在发生阻塞等待时，切换执行另一个活跃任务，活跃任务使用的是相同的底层资源，然后在异步处理过程结束后再切回到当前进程来执行。&lt;/p&gt;
&lt;p&gt;但是我们如何编写在 JVM 上异步执行的代码？ Java 提供了两种异步编程模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回调&lt;/strong&gt;：异步方法没有返回值，但接受一个额外的 &lt;code&gt;callback（回调）&lt;/code&gt;参数（一个 lambda 表达式或匿名类），在得到异步处理结果时会调用这个回调。一个众所周知的例子是 Swing 的 &lt;code&gt;EventListener&lt;/code&gt; 派生类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Future&lt;/strong&gt;：这种异步方法在调用时会&lt;em&gt;即刻&lt;/em&gt;返回一个 &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;。这个异步过程会计算出一个 &lt;code&gt;T&lt;/code&gt; 类型的值，不过需要通过 &lt;code&gt;Future&lt;/code&gt; 对象来访问。计算出来的值不能立即可用，可以对 &lt;code&gt;Future&lt;/code&gt; 对象进行探询直到值计算出来。例如：&lt;code&gt;ExecutorService&lt;/code&gt; 运行 &lt;code&gt;Callable&amp;lt;T&amp;gt;&lt;/code&gt; 任务就是提供 &lt;code&gt;Future&lt;/code&gt; 对象来获取异步结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这两种技术方案就足够好了吗？在很多使用场景下并不理想，这两种方式都有局限。&lt;/p&gt;
&lt;p&gt;多个回调难以组合使用，容易导致代码难以阅读和维护（就是所谓的“回调地狱”）。&lt;/p&gt;
&lt;p&gt;来看一个例子：在界面上为用户显示他最喜爱的5个物件，如果用户还没有任何喜欢的物件，则给出建议物件。这个逻辑涉及3个服务（第一个服务提供物件 ID，第二个服务获取物件的详细信息，第三个服务提供建议物件的详细信息），如下所示：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;回调地域的示例&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userService.getFavorites(userId, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Callback&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onSuccess(List&amp;lt;String&amp;gt; list) { &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (list.isEmpty()) { &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            suggestionService.getSuggestions(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Callback&amp;lt;List&amp;lt;Favorite&amp;gt;&amp;gt;() {
                &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onSuccess(List&amp;lt;Favorite&amp;gt; list) { &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
                    UiUtils.submitOnUiThread(() -&amp;gt; { &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
                        list.stream()
                            .limit(5)
                            .forEach(uiList::show); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;
                    })
                }

                &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onError(Throwable error) { &lt;span style="color: #008000"&gt;// 7&lt;/span&gt;
                    UiUtils.errorPopup(error);
                }
            });
        } &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; {
            list.stream() &lt;span style="color: #008000"&gt;// 8&lt;/span&gt;
                .limit(5)
                .forEach(favId -&amp;gt; favoriteService.getDetails(favId, &lt;span style="color: #008000"&gt;// 9&lt;/span&gt;
                    &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Callback&amp;lt;Favorite&amp;gt;() {
                        &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onSuccess(Favorite details) {
                            UiUtils.submitOnUiThread(() -&amp;gt; uiList.show(details));
                        }

                        &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onError(Throwable error) {
                            UiUtils.errorPopup(error);
                        }
                    }
                ));
        }
    }

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onError(Throwable error) {
        UiUtils.errorPopup(error);
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;基于回调的服务：&lt;code&gt;Callback&lt;/code&gt; 接口定义了两个方法，异步处理成功时调用其中的 &lt;code&gt;onSuccess&lt;/code&gt;，异步处理发生错误时调用 &lt;code&gt;onError&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第一个服务以其结果 - 喜爱物件的 ID 列表 - 调用回调方法。&lt;/li&gt;
&lt;li&gt;如果列表为空，则必须转到 &lt;code&gt;suggestionService&lt;/code&gt; 来处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;suggestionService&lt;/code&gt; 向第二个回调传递一个 &lt;code&gt;List&amp;lt;Favorite&amp;gt;&lt;/code&gt; 列表。&lt;/li&gt;
&lt;li&gt;对于 UI 渲染，必须让消费数据的代码运行在 UI 的线程中。&lt;/li&gt;
&lt;li&gt;这里我们使用了 Java 8 的 &lt;code&gt;Stream&lt;/code&gt; 将建议物件的数量限制为5个，然后在 UI 中渲染成一个图形化列表。&lt;/li&gt;
&lt;li&gt;在每个回调层级，我们都以相同的方式处理错误：在弹出框中显示错误信息。&lt;/li&gt;
&lt;li&gt;回到 喜爱物件 ID 列表的层级。如果 &lt;code&gt;userService&lt;/code&gt; 服务返回一个不为空的 ID 列表，则转到 &lt;code&gt;favoriteService&lt;/code&gt; 去获取带详细信息的 &lt;code&gt;Favorite&lt;/code&gt; 对象。因为只需要5个喜爱物件，所以先使用流式处理将 ID 数量限制为 5 个。&lt;/li&gt;
&lt;li&gt;再一次，使用一个回调。这一次我们获取到完整的 &lt;code&gt;Favorite&lt;/code&gt; 对象，并在 UI 线程中将其在 UI 上渲染出来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看看有多少代码，理解起来也有点困难，其中也有一些重复的代码片段。再来看看使用 Reactor 如何来实现这段逻辑：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;和回调实现方式等价的 Reactor 实现&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userService.getFavorite(userId) &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
            .flatMap(favoriteService::getDetails) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
            .switchIfEmpty(suggestionService.getSuggestions()) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            .take(5) &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
            .publishOn(UiUtils.uiThreadScheduler()) &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
            .subscribe(uiList::show, UiUtils::errorPopup); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;开启一个喜爱物件 ID 的流。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;异步地&lt;/em&gt;将 ID 转换成带详细信息的 &lt;code&gt;Favorite&lt;/code&gt; 对象（&lt;code&gt;flatMap&lt;/code&gt;）。至此我们得到一个 &lt;code&gt;Favorite&lt;/code&gt; 对象流。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;Favorite&lt;/code&gt; 流为空，则切换到备选处理方式 &lt;code&gt;suggestionService&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;我们只关注产出流中的前（最多）5个元素。&lt;/li&gt;
&lt;li&gt;最后，在 UI 线程中处理每份数据。&lt;/li&gt;
&lt;li&gt;真正触发流的处理：描述了如何处理最终的数据（显示为一个 UI 列表），以及在发生错误时如何处理（显示一个弹出框）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果希望确保在 800ms 以内获取到喜爱物件 ID 列表，如果超时，则从缓存中获取数据，如何实现？基于回调的代码实现，这是一个复杂的任务。使用 Reactor，只需在操作链中添加一个 &lt;code&gt;timeout&lt;/code&gt; 算子就能轻松搞定，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;超时回退处理的 Reactor 代码示例&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userService.getFavorites(userId)
            .timeout(Duration.ofMillis(800)) &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
            .onErrorResume(cacheService.cachedFavoritesFor(userId)) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
            .flatMap(favoriteService::getDetails)
            .switchIfEmpty(suggestionService.getSuggestions())
            .take(5)
            .publishOn(UiUtils.uiThreadScheduler())
            .subscribe(uiList::show, UiUtils::errorPopup);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;如果前置处理超过 800ms 还没输出任何事件，则下发一个错误。&lt;/li&gt;
&lt;li&gt;在收到错误事件时，回退到调用 &lt;code&gt;cacheService&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;操作链的余下部分和前一个例子类似。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;Future&lt;/code&gt; 对象相比回调更好一点，不过组合使用起来也不太方便，尽管 Java 8 引入 &lt;code&gt;CompletableFuture&lt;/code&gt; 改善了这一问题。将多个 &lt;code&gt;Future&lt;/code&gt; 对象组织在一起，可行但并不容易。另外，&lt;code&gt;Future&lt;/code&gt; 还有其它问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易碰到另一个阻塞的情况：调用 &lt;code&gt;Future&lt;/code&gt; 对象的 &lt;code&gt;get()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;不支持惰性计算。&lt;/li&gt;
&lt;li&gt;对多个值的处理和高级错误处理缺乏支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看看另一个例子：先获取一个 ID 列表，然后根据 ID 获取一个名字以及获取一个统计数值，再将名字和统计数值组合起来使用，这几个步骤都必须是异步的。如下示例以一组 &lt;code&gt;CompletableFuture&lt;/code&gt; 来实现这个逻辑：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CompletableFuture&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; ids = ifhIds(); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

CompletableFuture&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; results = ids.thenComposeAsync(l -&amp;gt; { &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
    Stream&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; zip = 
            l.stream().map(i -&amp;gt; { &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
                CompletableFuture&amp;lt;String&amp;gt; nameTask = ifhName(i); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
                CompletableFuture&amp;lt;Integer&amp;gt; statTask = ifhStat(i); &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; nameTask.thenCombineAsync(statTask, (name, stat) -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;Name &amp;quot;&lt;/span&gt; + name + &lt;span style="color: #a31515"&gt;&amp;quot; has stats &amp;quot;&lt;/span&gt; + stat); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;
            });
    List&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; combinationList = zip.collect(Collectors.toList()); &lt;span style="color: #008000"&gt;// 7&lt;/span&gt;
    CompletableFuture&amp;lt;String&amp;gt;[] combinationArray = combinationList.toArray(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CompletableFuture[combinationList.size()]);

    CompletableFuture&amp;lt;Void&amp;gt; allDone = CompletableFuture.allOf(combinationArray); &lt;span style="color: #008000"&gt;// 8&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; allDone.thenApply(v -&amp;gt; combinationList.stream()
                    .map(CompletableFuture::join) &lt;span style="color: #008000"&gt;// 9&lt;/span&gt;
                    .collect(Collectors.toList()));
});

List&amp;lt;String&amp;gt; results = result.join(); &lt;span style="color: #008000"&gt;// 10&lt;/span&gt;
assertThat(results).contains(
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameJoe has stats 103&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameBart has stats 104&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameHenry has stats 105&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameNicole has stats 106&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;一开始获得一个 &lt;code&gt;Future&lt;/code&gt; 结果 - 为后续处理提供一个 &lt;code&gt;id&lt;/code&gt; 列表。&lt;/li&gt;
&lt;li&gt;一旦获得 &lt;code&gt;id&lt;/code&gt; 列表就可以开始进一步的异步处理。&lt;/li&gt;
&lt;li&gt;逐个处理列表中的元素。&lt;/li&gt;
&lt;li&gt;异步获取关联的名字。&lt;/li&gt;
&lt;li&gt;异步获取关联的统计数值。&lt;/li&gt;
&lt;li&gt;组合两个异步结果。&lt;/li&gt;
&lt;li&gt;至此我们得到一个 &lt;code&gt;Future&lt;/code&gt; 对象列表，表示所有的组合任务。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;Future&lt;/code&gt; 对象数组传给 &lt;code&gt;CompletableFuture.allOf&lt;/code&gt; 方法，这个方法会输出一个 &lt;code&gt;Future&lt;/code&gt; 对象，当 &lt;code&gt;Future&lt;/code&gt; 对象数组代表的异步任务都完成时，这个 &lt;code&gt;Future&lt;/code&gt; 对象代表的异步任务也就完成了。&lt;/li&gt;
&lt;li&gt;此处的特殊之处在于：在（&lt;code&gt;allOf&lt;/code&gt; 返回的）&lt;code&gt;CompletableFuture&amp;lt;Void&amp;gt;&lt;/code&gt; 对象表示的异步任务结束时，遍历 &lt;code&gt;Future&lt;/code&gt; 对象列表（combinationList），使用 &lt;code&gt;join()&lt;/code&gt; 方法（此次不会阻塞，因为 &lt;code&gt;allOf&lt;/code&gt; 会确保所有异步任务都已完成）获取收集异步任务结果。&lt;/li&gt;
&lt;li&gt;触发执行整个异步处理流水线（调用 &lt;code&gt;join()&lt;/code&gt; 方法），然而等着异步处理完成并返回一个结果列表，就可以进行断言判断了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Reactor 自带了很多组合算子，可以简化这个处理过程的实现，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; ids = ifhrIds(); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

Flux&amp;lt;String&amp;gt; combinations = 
        ids.flatMap(id -&amp;gt; { &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
            Mono&amp;lt;String&amp;gt; nameTask = ifhrName(id); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            Mono&amp;lt;Integer&amp;gt; statTask = ifhrStat(id); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;

            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; nameTask.zipWith(statTask, &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
                    (name, stat) -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;Name &amp;quot;&lt;/span&gt; + name + &lt;span style="color: #a31515"&gt;&amp;quot; has stats &amp;quot;&lt;/span&gt; + stat);
        });

Mono&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = combinations.collectList(); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;

List&amp;lt;String&amp;gt; results = result.block(); &lt;span style="color: #008000"&gt;// 7&lt;/span&gt;
assertThat(results).containsExactly( &lt;span style="color: #008000"&gt;// 8&lt;/span&gt;
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameJoe has stats 103&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameBart has stats 104&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameHenry has stats 105&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameNicole has stats 106&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&amp;quot;&lt;/span&gt;
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;这次，一开始我们得到一个异步提供的字符串序列（&lt;code&gt;ids&lt;/code&gt;）（一个 &lt;code&gt;Flux&amp;lt;String&amp;gt;&lt;/code&gt; 对象）。&lt;/li&gt;
&lt;li&gt;对于序列中的每个元素，异步处理两次（在 &lt;code&gt;flatMap&lt;/code&gt; 的 lambda 参数值中）。&lt;/li&gt;
&lt;li&gt;获取关联的名字。&lt;/li&gt;
&lt;li&gt;获取关联的统计值。&lt;/li&gt;
&lt;li&gt;异步组合两个值&lt;/li&gt;
&lt;li&gt;在异步处理的结果可用时，将它们聚合到一个 &lt;code&gt;List&lt;/code&gt; 对象中。&lt;/li&gt;
&lt;li&gt;在实际项目中，我们通常会继续异步处理 &lt;code&gt;Flux&lt;/code&gt;，比如：异步组合使用它或者直接订阅它。最可能的是，返回这个 &lt;code&gt;Mono&lt;/code&gt; 类型的 &lt;code&gt;result&lt;/code&gt;。因为这里只是个测试，所以使用了 block，等待处理结束，直接返回值的聚合列表。&lt;/li&gt;
&lt;li&gt;对结果进行断言判断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用回调和 &lt;code&gt;Future&lt;/code&gt; 对象的问题是类似的，反应式编程以 &lt;code&gt;发布者（Publisher）- 订阅者（Subscriber）&lt;/code&gt; 解决了这些问题。 &lt;/p&gt;
&lt;h4&gt;2.3 从命令式到反应式编程&lt;/h4&gt;
&lt;p&gt;反应式编程库，比如 Reactor，目标是解决 JVM 上“经典”异步处理方式的弊端，同时也专注于提供以下几个方面的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可组合性&lt;/strong&gt; 和 &lt;strong&gt;代码可读性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将数据视作一个&lt;strong&gt;流&lt;/strong&gt;，并提供丰富的&lt;strong&gt;算子&lt;/strong&gt;来操作流&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;订阅（subscriber）&lt;/strong&gt;之前不会实际做任何事情&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反压&lt;/strong&gt; 或者说 消费者通知生产者流速过高的能力&lt;/li&gt;
&lt;li&gt;与并发无关（concurrency-agnostic）的&lt;strong&gt;高阶（high level）&lt;/strong&gt;抽象，&lt;strong&gt;适用性强（high value）&lt;/strong&gt;（译注：并发无关是指这种抽象对于并发非并发的场景都适用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. Reactor 核心特性&lt;/h3&gt;
&lt;p&gt;Reactor 项目的主要成果是 &lt;code&gt;reactor-core&lt;/code&gt; - 一个遵循&lt;a href="https://www.reactive-streams.org/"&gt;反应式流&lt;/a&gt;规范并支持 Java 8 的反应式编程库。&lt;/p&gt;
&lt;p&gt;Reactor 引入 2 个可组合的反应式类型（实现了 &lt;code&gt;Publisher&lt;/code&gt; 接口并且提供丰富的算子）： &lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt;。一个 &lt;code&gt;Flux&lt;/code&gt; 对象代表包含 0 到 N 个元素的反应式序列，&lt;code&gt;Mono&lt;/code&gt; 对象代表单值或空（0或1个元素）的结果。&lt;/p&gt;
&lt;h4&gt;3.1 Flux - 0-N 个值的异步序列&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/oKMX4rTvUViZRHj.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;3.2 Mono - 包含 0 或 1 个值的异步结果&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/8WxGgH9UkcQwuX4.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;3.3 创建一个 Flux 或 Mono 并进行订阅的一些简单方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 的类中包含大量的工厂方法，上手使用 Reactor 最简单的方式是从中选择一个用起来。&lt;/p&gt;
&lt;p&gt;例如，创建一个 &lt;code&gt;String&lt;/code&gt; 序列，可以逐个列举出这些字符串，或者将这些字符串放到一个集合中，然后基于这个集合创建一个 Flux，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;&lt;span style="border: 1px solid #FF0000"&gt;&lt;/span&gt;String&amp;gt; seq1 = Flux.just(&lt;span style="color: #a31515"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;);

List&amp;lt;String&amp;gt; iterable = Arrays.asList(&lt;span style="color: #a31515"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;);
Flux&amp;lt;String&amp;gt; seq2 = Flux.fromIterable(iterable);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其它一些工厂方法的使用示例如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Mono&amp;lt;String&amp;gt; noData = Mono.empty();
Mono&amp;lt;String&amp;gt; data = Mono.just(&lt;span style="color: #a31515"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;);
Flux&amp;lt;Integer&amp;gt; numbersFromFiveToSeven = Flux.range(5, 3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于订阅操作，&lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 借助了 Java 8 的 lambda 表达式。有大量 &lt;code&gt;.subscribe()&lt;/code&gt; 的重载方法/变种方法（variants）可选选择使用，使用 lambda 表达式来实现回调的不同组合，如下所示是这些方法的签名：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Flux 中基于 lambda 表达式的订阅方法变种&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;subscribe();

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer);

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Throwable&amp;gt; errorConsumer);

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Throwable&amp;gt; errorConsumer,
          Runnable completeConsumer);

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Throwable&amp;gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Subscription&amp;gt; subscriptionConsumer);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;这些订阅方法都会返回一个订阅操作的引用，当不再需要更多的数据时，可以使用这个引用来取消订阅。一旦取消，数据源就应该停止产出数据，并清理使用的所有资源。这一 “取消并清理” 行为在 Reactor 中以通用的 &lt;code&gt;Disposable&lt;/code&gt; 接口来表现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;3.3.1 lambda 表达式的替代方案：BaseSubscriber&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 提供了一个相比上面那么订阅方法更通用的 &lt;code&gt;subscribe&lt;/code&gt; 方法，其参数是一个完整的 &lt;code&gt;Subscriber&lt;/code&gt; 实例，而不是根据几个 lambda 表达式组合出一个 &lt;code&gt;Subscriber&lt;/code&gt; 实例。为了方便实现这样的一个 &lt;code&gt;Subscriber&lt;/code&gt;，Reactor 提供了一个名为 &lt;code&gt;BaseSubscriber&lt;/code&gt; 的可扩展的抽象类。&lt;/p&gt;
&lt;p&gt;下面来实现一个，我们将其命名为 &lt;code&gt;SampleSubscriber&lt;/code&gt;。如下示例演示了如何将其应用到一个 &lt;code&gt;Flux&lt;/code&gt; 序列上：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;SampleSubscriber&amp;lt;Integer&amp;gt; ss = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SampleSubscriber&amp;lt;Integer&amp;gt;();
Flux&amp;lt;Integer&amp;gt; ints = Flux.range(1, 4);
&lt;span style="color: #008000"&gt;//&lt;/span&gt;
ints.subscribe(i -&amp;gt; System.out.println(i),
    error -&amp;gt; System.err.println(&lt;span style="color: #a31515"&gt;&amp;quot;Error &amp;quot;&lt;/span&gt; + error),
    () -&amp;gt; {System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;Done&amp;quot;&lt;/span&gt;);},
    s -&amp;gt; s.request(10));
&lt;span style="color: #008000"&gt;//&lt;/span&gt;
ints.subscribe(ss);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如下示例演示了 &lt;code&gt;SampleSubscriber&lt;/code&gt; 继承自 &lt;code&gt;BaseSubscriber&lt;/code&gt; 的一个最简化实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;package&lt;/span&gt; io.projectreactor.samples;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.reactivestreams.Subscription;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; reactor.core.publisher.BaseSubscriber;

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;SampleSubscriber&lt;/span&gt;&amp;lt;T&amp;gt; &lt;span style="color: #0000ff"&gt;extends&lt;/span&gt; BaseSubscriber&amp;lt;T&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnSubscribe(Subscription subscription) {
        System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;Subscribed&amp;quot;&lt;/span&gt;);
        request(1);
    }

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnNext(T value) {
        System.out.println(value);
        request(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;BaseSubscriber&lt;/code&gt; 还提供了一个 &lt;code&gt;requestUnbounded()&lt;/code&gt; 方法来切换到无限消费模式（相当于 &lt;code&gt;request(Long.MAX_VALUES)&lt;/code&gt;），另外也提供了一个 &lt;code&gt;cancel()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;hookOnSubscribe&lt;/code&gt; 和 &lt;code&gt;hookOnNext&lt;/code&gt;，&lt;code&gt;BaseSubscriber&lt;/code&gt; 还提供了其他钩子方法（方法体为空，提供继承重写）：&lt;code&gt;hookOnComplete&lt;/code&gt;、&lt;code&gt;hookOnError&lt;/code&gt;、&lt;code&gt;hookOnCancel&lt;/code&gt; 以及 &lt;code&gt;hookFinally&lt;/code&gt;（当事件/消息序列（流）终止时，一定会调用该方法，调用时会传入一个 &lt;code&gt;SignalType&lt;/code&gt; 类型参数表示终止的类型）。&lt;/p&gt;
&lt;h5&gt;3.3.2 关于反压和调整请求量的方式&lt;/h5&gt;
&lt;p&gt;在 Reactor 中实现反压，是通过向上游算子发送一个 &lt;code&gt;请求（request）&lt;/code&gt;来逐级传播消费者的压力，直到数据源。当前请求的总量有时又称为当前的“需求量” 或者 “待满足（pending）的请求量”。需求量的上限是 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;，表示一个无限量的请求（意思是“尽快产出数据“ - 反压也就失效了）。&lt;/p&gt;
&lt;p&gt;最终的订阅者在订阅之前会发出首个请求，订阅所有消息/数据最直接的方式是即刻触发一个无限量（Long.MAX_VALUE）的请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;subscribe()&lt;/code&gt; 以及大部分基于 lambda 表达式的变种方法（除了那个接受 &lt;code&gt;Consumer&amp;lt;Subscription&amp;gt;&lt;/code&gt; 类型参数的方法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;block()&lt;/code&gt;、&lt;code&gt;blockFirst()&lt;/code&gt; 和 &lt;code&gt;blockLast()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;toIterable()&lt;/code&gt; 或 &lt;code&gt;toStream()&lt;/code&gt; 进行遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对首个请求进行定制的最简单方式是以一个 &lt;code&gt;BaseSubscriber&lt;/code&gt; 派生类实例来 &lt;code&gt;subscribe&lt;/code&gt;，派生类重写 &lt;code&gt;BaseSubscriber&lt;/code&gt; 的 &lt;code&gt;hookOnSubscribe&lt;/code&gt; 方法，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.range(1, 10)
    .doOnRequest(r -&amp;gt; System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;request of &amp;quot;&lt;/span&gt; + r))
    .subscribe(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; BaseSubscriber&amp;lt;Integer&amp;gt;() {

      @Override
      &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnNext(Integer integer) {
        System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;Cancelling after having received &amp;quot;&lt;/span&gt; + integer);
        cancel();
      }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面这个代码片段输出如下内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;request of 1
Cancelling after having received 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;改变下游需求量的算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谨记：订阅时指定的需求量，上游操作链中的每个算子都可以对其作出调整。一个典型案例是 &lt;code&gt;buffer(N)&lt;/code&gt; 算子：如果它收到一个 &lt;code&gt;request(2)&lt;/code&gt; 请求，它会理解为2个缓冲区的请求量。因为缓冲区需要 N 个元素才认为是满的，所以 &lt;code&gt;buffer&lt;/code&gt; 算子将请求量调整成了 &lt;code&gt;2 x N&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你也许也注意到某些算子存在这样的变种 - 接受一个名为 &lt;code&gt;prefetch&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 类型参数。这是另外一类修改下游请求量的算子。这类算子（比如 &lt;code&gt;flatMap&lt;/code&gt;）通常是处理内部序列（inner sequences），从每个进入的元素派生出一个 &lt;code&gt;Publisher&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;预取（prefetch）&lt;/code&gt;是调整内部序列请求量的一个方式。如果未指定，多数这类算子会以 32 为初始需求量。&lt;/p&gt;
&lt;p&gt;这类算子通常也会实现一个&lt;strong&gt;填补优化方案&lt;/strong&gt;：算子一旦看到 25% 的预取请求量已完成，就会向上游再发起 25% 的请求量。这是一个启发式优化，如此这类算子就可以主动地为即将到来的请求量做好准备。&lt;/p&gt;
&lt;p&gt;最后，再介绍一对直接用于调整请求量的算子：&lt;code&gt;limitRate&lt;/code&gt; 和 &lt;code&gt;limitRequest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;limitRate(N)&lt;/code&gt; 把下游的请求量拆分成多个更小量的请求向上游传播。例如，一个 &lt;code&gt;100&lt;/code&gt; 的请求传到算子 &lt;code&gt;limitRate(10)&lt;/code&gt;，则会变成 10 次请求，一次请求 10，传播到上游。注意：&lt;code&gt;limitRate&lt;/code&gt; 实际上以这种形式实现了前面提到的填补优化方案。&lt;/p&gt;
&lt;p&gt;这个算子有一个变种，允许开发者调整预取填补量（即算子变种的 &lt;code&gt;lowTide&lt;/code&gt; 参数）：&lt;code&gt;limitRate(highTide, lowTide)&lt;/code&gt;。&lt;code&gt;lowTide&lt;/code&gt; 参数设定为 &lt;code&gt;0&lt;/code&gt; 时，会导致严格限制一次请求 &lt;code&gt;highTide&lt;/code&gt; 个，而不是经填补策略进一步调整过的一次请求量。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;limitRequest(N)&lt;/code&gt; 则是限制了下游最大的需求总量。它会累加请求量直到 &lt;code&gt;N&lt;/code&gt;。如果一次请求没有让需求总量超过 &lt;code&gt;N&lt;/code&gt;，则这次请求会完整地传播到上游（译注：意思是如果一次请求让需求总量超过了 &lt;code&gt;N&lt;/code&gt;，这次请求的请求量会被裁剪）。如果数据源发出的数据总量达到了限制的总量，&lt;code&gt;limitRequest&lt;/code&gt; 则认为这个序列可以结束了，向下游发送一个 &lt;code&gt;onComplete&lt;/code&gt; 信号，并取消数据源。&lt;/p&gt;
&lt;h4&gt;3.4 动态地（programmatically）创建一个序列&lt;/h4&gt;
&lt;h5&gt;3.4.1 同步的 generate&lt;/h5&gt;
&lt;p&gt;动态创建一个 &lt;code&gt;Flux&lt;/code&gt; 最简单的方式是借助 &lt;code&gt;generate&lt;/code&gt; 方法，该方法接受一个生成器函数。&lt;/p&gt;
&lt;p&gt;这一方式可以实现&lt;strong&gt;同步的&lt;/strong&gt;且&lt;strong&gt;一个接一个&lt;/strong&gt;地下发数据，这意味着接收方（sink）是一个 &lt;code&gt;SynchronousSink&lt;/code&gt;，其 &lt;code&gt;next()&lt;/code&gt; 方法在一次回调方法调用中最多只能调用一次。可以在其后再调用 &lt;code&gt;error(Throwable)&lt;/code&gt; 或 &lt;code&gt;complete()&lt;/code&gt;，视你的需求而定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;generate&lt;/code&gt; 方法变种的这个应该是最有用的：允许保持一个状态，在调用接收方的 &lt;code&gt;next&lt;/code&gt; 方法时可以基于这个状态来决定下发什么数据。那么这个生成器函数就成了一个 &lt;code&gt;BiFunction&amp;lt;S, SynchronousSink&amp;lt;T&amp;gt;, S&amp;gt;&lt;/code&gt; 实例，其中 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 即是状态对象的类型。对于初始状态，可以提供一个 &lt;code&gt;Supplier&amp;lt;S&amp;gt;&lt;/code&gt; 来获取，这样生成器函数每轮调用都会返回一个新的状态。&lt;/p&gt;
&lt;p&gt;例如，可以使用一个 &lt;code&gt;int&lt;/code&gt; 实例作为状态：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;基于状态的 &lt;code&gt;generate&lt;/code&gt; 方法使用示例&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; flux = Flux.generate(
    () -&amp;gt; 0, &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
    (state, sink) -&amp;gt; {
        sink.next(&lt;span style="color: #a31515"&gt;&amp;quot;3 x &amp;quot;&lt;/span&gt; + state + &lt;span style="color: #a31515"&gt;&amp;quot; = &amp;quot;&lt;/span&gt; + 3*state); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (state == 10) sink.complete(); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; state + 1; &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;以 0 作为初始状态。&lt;/li&gt;
&lt;li&gt;基于状态（state）决定下发什么消息/数据。&lt;/li&gt;
&lt;li&gt;基于状态决定何时可以停止流/序列。&lt;/li&gt;
&lt;li&gt;返回一个新状态，下次调用时可以使用（除非在这次调用时已经终止序列）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以使用一个 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 类型的可变对象。比如，上面的示例可以使用一个 &lt;code&gt;AtomicLong&lt;/code&gt; 实例作为状态来重写，每轮调用都会改变它的值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; flux = Flux.generate(
    AtomicLong::&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;,
    (state, sink) -&amp;gt; {
        &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; i = state.getAndIncrement();
        sink.next(&lt;span style="color: #a31515"&gt;&amp;quot;3 x &amp;quot;&lt;/span&gt; + i + &lt;span style="color: #a31515"&gt;&amp;quot; = &amp;quot;&lt;/span&gt; + 3*i);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (i == 10) sink.complete();
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; state;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;如果状态对象在序列终止时需要清理一些资源，则应该使用 &lt;code&gt;generate(Supplier&amp;lt;S&amp;gt;, BiFunction, Consumer&amp;lt;S&amp;gt;)&lt;/code&gt; 变种方法来清理最后的状态实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下示例使用的 &lt;code&gt;generate&lt;/code&gt; 方法接受一个 &lt;code&gt;Consumer&lt;/code&gt; 类型参数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; flux = Flux.generate(
    AtomicLong::&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;,
    (state, sink) -&amp;gt; {
        &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; i = state.getAndIncrement();
        sink.next(&lt;span style="color: #a31515"&gt;&amp;quot;3 x &amp;quot;&lt;/span&gt; + i + &lt;span style="color: #a31515"&gt;&amp;quot; = &amp;quot;&lt;/span&gt; + 3*i);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (i == 10) sink.complete();
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; state;
    }, (state) -&amp;gt; System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;state: &amp;quot;&lt;/span&gt; + state));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;3.4.2 异步多线程的 create&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;create&lt;/code&gt; 是动态创建一个 &lt;code&gt;Flux&lt;/code&gt; 的更高级的方式，适用于每轮下发多个数据，甚至是从多个线程中下发数据。&lt;/p&gt;
&lt;p&gt;这个方法会向回调方法传入一个 &lt;code&gt;FluxSink&lt;/code&gt; 实例参数，在回调方法体中可以调用这个参数的 &lt;code&gt;next&lt;/code&gt;、&lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;complete&lt;/code&gt; 方法。与 &lt;code&gt;generate&lt;/code&gt; 不同，它没有基于状态的变种方法。另外，回调方法中，可以多线程地触发事件（trigger multi-threaded events）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;create&lt;/code&gt; 非常适用于将一个已有的 API （比如：一个基于监听器的异步 API）桥接到反应式上下文中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;create&lt;/code&gt; 并不会自动并行化执行你的代码，也不会让处理过程自动变成异步的，即使它可以配合异步 API 使用。如果在 &lt;code&gt;create&lt;/code&gt; 的 lambda 表达式中发生阻塞，就会存在死锁或者其它副作用的风险。即使借助 &lt;code&gt;subscribeOn&lt;/code&gt;，也要当心 &lt;code&gt;create&lt;/code&gt; lambda 表达式中长时间的阻塞（比如无限循环调用 &lt;code&gt;sink.next(t)&lt;/code&gt;）锁住流水线处理： （译注：异步的）数据请求可能根本得不到执行，因为（译注：线程池只有一个线程）同一个线程一直被无限循环占用着。使用 &lt;code&gt;subscribeOn(Scheduler, false)&lt;/code&gt; 变种方法：&lt;code&gt;requestOnSeparateThread = false&lt;/code&gt; 将使用 &lt;code&gt;Scheduler&lt;/code&gt; 的线程来执行 &lt;code&gt;create&lt;/code&gt; 方法的回调，在原始的线程中执行 &lt;code&gt;request&lt;/code&gt;，从而让数据仍然可以流动起来。（译注：此处逻辑有点绕，也可能是因为 subscribeOn 方法本身语义就不太直观）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们要使用一个基于监听器的 API，它按块处理数据，提供两类事件：（1）来了一块数据，（2）处理可以结束了（终止事件），如下 &lt;code&gt;MyEventListener&lt;/code&gt; 接口定义所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;MyEventListener&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onDataChunk(List&amp;lt;T&amp;gt; chunk);
    &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processComplete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们使用 &lt;code&gt;create&lt;/code&gt; 将这个 API 桥接到一个 &lt;code&gt;Flux&amp;lt;T&amp;gt;&lt;/code&gt; 实例上：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; bridge = Flux.create(sink -&amp;gt; {
    myEventProcessor.register(  &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MyEventListener&amp;lt;String&amp;gt;() { &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onDataChunk(List&amp;lt;String&amp;gt; chunk) {
                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(String s : chunk) {
                    sink.next(s); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
                }
            }

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processComplete() {
                sink.complete(); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            }
        }
    );
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;桥接到 &lt;code&gt;MyEventListener&lt;/code&gt; API&lt;/li&gt;
&lt;li&gt;数据块中每个元素都成了 &lt;code&gt;Flux&lt;/code&gt; 中的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;processComplete&lt;/code&gt; 事件转换成了 &lt;code&gt;onComplete&lt;/code&gt; 事件。&lt;/li&gt;
&lt;li&gt;所有这些逻辑都是在 &lt;code&gt;myEventProcessor&lt;/code&gt; 执行时异步完成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外，因为 &lt;code&gt;create&lt;/code&gt; 可以桥接异步 API，并管理反压，通过指定一个 &lt;code&gt;OverflowStrategy&lt;/code&gt; 策略，可以调整如何智能地处理反压：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IGNORE&lt;/code&gt; 完全忽略下游的反压请求。这一策略在下游的队列满时（when queues get full downstream）会导致 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常抛出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ERROR&lt;/code&gt; 在下游处理不过来时会下发（onError）一个 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常消息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DROP&lt;/code&gt; 如果下游还没准备好接收当前事件，则直接丢弃。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BUFFER&lt;/code&gt; （默认策略）如果下游处理不过来，则将所有事件放入缓冲区。（缓冲区大小无限制，所以可能会导致内存溢出&lt;code&gt;OutOfMemoryError&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Mono&lt;/code&gt; 也有一个 &lt;code&gt;create&lt;/code&gt; 生成器方法。Mono 的 create 方法传入回调的 &lt;code&gt;MonoSink&lt;/code&gt; 参数不允许下发多个消息，在第一个消息之后它会丢弃所有的消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;3.4.3 异步单线程的 push&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;push&lt;/code&gt; 的功能介于 &lt;code&gt;generate&lt;/code&gt; 和 &lt;code&gt;create&lt;/code&gt; 之间，适用于处理来自单个生产者的事件。&lt;code&gt;push&lt;/code&gt; 也可以是异步的，也可以使用 &lt;code&gt;create&lt;/code&gt; 支持的超限策略来管理反压，然而，同时（at a time）只能有一个生产线程调用 &lt;code&gt;next&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; bridge = Flux.push(sink -&amp;gt; {
    myEventProcessor.register(
        &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SingleThreadEventListener&amp;lt;String&amp;gt;() { &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onDataChunk(List&amp;lt;String&amp;gt; chunk) {
                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (String s: chunk) {
                    sink.next(&lt;span style="border: 1px solid #FF0000"&gt;&lt;/span&gt;s); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
                }
            }

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processComplete() {
                sink.complete(); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            }

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processError(Throwable e) {
                sink.error(e); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
            }
        }
    );
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;桥接到 &lt;code&gt;SingleThreadEventListener&lt;/code&gt; 的 API。&lt;/li&gt;
&lt;li&gt;在单个监听器线程中使用 &lt;code&gt;next&lt;/code&gt; 向下游（sink - 接收方）推送事件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;complete&lt;/code&gt; 事件也是由同一个监听器线程发出的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;error&lt;/code&gt; 事件也是由同一个监听器线程发出的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;推/拉 混合模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多数 Reactor 算子，比如 &lt;code&gt;create&lt;/code&gt;，都遵从 &lt;strong&gt;推/拉（push/pull）&lt;/strong&gt; 混合模型。这意味着尽管大部分的处理过程都是异步的（暗指“推”的方式），也存在小部分逻辑是 &lt;em&gt;拉（pull）&lt;/em&gt;方式：数据请求。&lt;/p&gt;
&lt;p&gt;消费者从数据源&lt;em&gt;拉取&lt;/em&gt;数据，意指：数据源在消费者首次请求后才会发出数据，然后只有要数据就会推送给消费者，不过数据量不会超过消费者请求的量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;push()&lt;/code&gt; 和 &lt;code&gt;create()&lt;/code&gt; 都可以配置（set up）一个 &lt;code&gt;onRequest&lt;/code&gt; 事件消费者来管理请求量，并且确保仅当存在已发起的请求，数据才会推送给下游。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; bridge = Flux.create(sink -&amp;gt; {
    myMessageProcessor.register(
        &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MyMessageListener&amp;lt;String&amp;gt;() {

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onMessage(List&amp;lt;String&amp;gt; messages) {
                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (String s: messages) {
                    sink.next(s); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
                }
            }
        }
    );
    sink.onRequest(n -&amp;gt; {
        List&amp;lt;String&amp;gt; messages = myMessageProcessor.getHistory(n); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (String s: messages) {
            sink.next(s); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
        }
    });    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;译者注：上面这个示例有点问题，实际并不存在这样一个 create 方法，并且 sink.onRequest 实际代表一个无限量（n = Long.MAX_VALUE）的请求。&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在请求发起后，拉取消息。&lt;/li&gt;
&lt;li&gt;如果即刻有消息了，则推送给下游。&lt;/li&gt;
&lt;li&gt;后续异步到达的消息也会推送给下游。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;3.5 多线程 和 调度器 （Threading and Schedulers）&lt;/h4&gt;
&lt;p&gt;Reactor，与 RxJava 类似，可以认为是&lt;strong&gt;并发无关的&lt;/strong&gt;，也就是说，Reactor 并不强制使用并发（a concurrency
 model），而是，让开发者按需决定是否使用并发。然而，Reactor 也提供一些功能方便开启并发。&lt;/p&gt;
&lt;p&gt;获取到一个 &lt;code&gt;Flux&lt;/code&gt; 或 &lt;code&gt;Mono&lt;/code&gt; 处理流，并不意味着它在一个专用（dedicated）的线程（&lt;code&gt;Thread&lt;/code&gt;） 中运行。相反，多数算子也是运行在前一个算子运行的线程中。除非特意指定，首个（topmost）算子（数据源）就运行在执行 &lt;code&gt;subscribe()&lt;/code&gt; 方法调用的线程中。如下示例在一个新建线程中运行一个 &lt;code&gt;Mono&lt;/code&gt; 处理流。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; main(String[] args) {
    &lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Mono&amp;lt;String&amp;gt; mono = Mono.just(&lt;span style="color: #a31515"&gt;&amp;quot;Hello &amp;quot;&lt;/span&gt;); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Thread(() -&amp;gt; mono
        .map(msg -&amp;gt; msg + &lt;span style="color: #a31515"&gt;&amp;quot;thread &amp;quot;&lt;/span&gt;)
        .subscribe(v -&amp;gt; &lt;span style="color: #008000"&gt;// 2 &lt;/span&gt;
            System.out.println(v + Thread.currentThread().getName()) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
        )
    ).join();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Mono&amp;lt;String&amp;gt;&lt;/code&gt; 是在主（&lt;code&gt;main&lt;/code&gt;）线程中装配的（assembled）。&lt;/li&gt;
&lt;li&gt;然而， 订阅操作发生在 &lt;code&gt;Thread-0&lt;/code&gt; 线程中。&lt;/li&gt;
&lt;li&gt;因而，&lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;onNext&lt;/code&gt; 的回调（译注：&lt;code&gt;onNext&lt;/code&gt; 的回调即 subscribe 方法传入的 lambda 表达式）实际上也是在 &lt;code&gt;Thread-0&lt;/code&gt; 上执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述的代码会输出如下内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;hello thread Thread-0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Reactor 中，运行模型以及实际的运行过程发生在什么地方由使用什么 &lt;code&gt;Scheduler&lt;/code&gt; 决定。&lt;a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; 类似于 &lt;code&gt;ExecutorService&lt;/code&gt;，负有调度职责，但具备一个专用的抽象，功能更强大，充当一个时钟的角色，可用的实现更多。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"&gt;&lt;code&gt;Schedulers&lt;/code&gt;&lt;/a&gt; 类提供了一些静态方法来访问这些运行上下文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前线程（&lt;code&gt;Schedulers.immediate()&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;单个可复用的线程（&lt;code&gt;Schedulers.single()&lt;/code&gt;）。注意：这个方法会为所有调用方（译注：调用 Schedulers.single()）复用同一个线程，指导 &lt;code&gt;Scheduler&lt;/code&gt; 销毁（disposed）。如果期望每次调用返回一个专用线程，则应该使用 &lt;code&gt;Schedulers.newSingle()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;一个弹性的线程池（&lt;code&gt;Schedulers.elastic()&lt;/code&gt;）。这个 Scheduler 会按需创建新的工作者线程池（worker pool），并复用空闲的工作者线程池。如果工作者线程池空闲时间太长（默认 60s）则会被销毁。对于 I/O 阻塞工作而言这是一个好选择。&lt;code&gt;Schedulers.elastic()&lt;/code&gt; 可以简便地为阻塞处理过程提供独立的线程（its own thread），这样阻塞操作就不会占用（tie up）其他资源。详情请参考 &lt;a href="https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking"&gt;如何包装一个同步阻塞的调用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;固定数量工作者的（译注：我暂时的理解 - 工作者（worker）也是一个线程池）一个池，专门为并行处理工作做过调优（Schedulers.parallel()）。它会创建和 CPU 核心数量相同的工作者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，也可以使用 &lt;code&gt;Schedulers.fromExecutorService(ExecutorService)&lt;/code&gt; 基于已有的 ExecutorService 创建一个 Scheduler。（也可以基于一个 Executor 来创建，但不建议这么干（译注：因为 Executor 不能销毁释放））&lt;/p&gt;
&lt;p&gt;也可以使用 &lt;strong&gt;newXXX&lt;/strong&gt; 这类方法创建各种调度器（scheduler）类型的全新实例。例如，使用 &lt;code&gt;Schedulers.newElastic(yourScheduleName)&lt;/code&gt; 创建一个名为 &lt;code&gt;yourScheduleName&lt;/code&gt; 的全新的弹性调度器（elastic scheduler）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;elastic&lt;/code&gt; 调度器用于兼容处理不可避免的历史遗留的阻塞性代码，但 &lt;code&gt;single&lt;/code&gt; 和 &lt;code&gt;parallel&lt;/code&gt; 调度器不行，因而，如果在 &lt;code&gt;single&lt;/code&gt; 或 &lt;code&gt;parallel&lt;/code&gt; 调度器上使用 Reactor 的阻塞性 API（&lt;code&gt;block()&lt;/code&gt;、&lt;code&gt;blockFirst()&lt;/code&gt;、&lt;code&gt;blockLast()&lt;/code&gt;，或者进行 &lt;code&gt;toIterable()&lt;/code&gt; 或 &lt;code&gt;toStream()&lt;/code&gt; 迭代），会导致抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;如果自定义调度器所创建的线程实例实现了 &lt;code&gt;NonBlocking&lt;/code&gt; 标记性接口（marker interface），那么这个调度器也可以被标记为”仅适用于非阻塞性使用（non blocking only）“。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;某些算子默认会从 &lt;code&gt;Schedulers&lt;/code&gt; 选择一个特定的调度器来使用（通常也支持选择其他的）。例如，调用工厂方法 &lt;code&gt;Flux.interval(Duration.ofMills(300))&lt;/code&gt; 会生成一个 &lt;code&gt;Flux&amp;lt;Long&amp;gt;&lt;/code&gt; 实例 - 每 300 ms 输出一个滴答事件。这个方法底层实现默认使用 &lt;code&gt;Schedulers.parallel()&lt;/code&gt;。如下代码行演示了如何将调度器修改成类似于 &lt;code&gt;Schedulers.single()&lt;/code&gt; 的调度器新实例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.interval(Duration.ofMillis(300), Schedulers.newSingle(&lt;span style="color: #a31515"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Reactor 提供了两种方式来切换反应式链中的执行上下文（或者说 &lt;code&gt;调度器&lt;/code&gt;）：&lt;code&gt;publishOn&lt;/code&gt; 和 &lt;code&gt;subscribeOn&lt;/code&gt;。两者都是接受一个 &lt;code&gt;Scheduler&lt;/code&gt; 类型参数并将执行上下文切换到这个调度器。不过，链中 &lt;code&gt;publishOn&lt;/code&gt; 所处的位置很关键，而 &lt;code&gt;subscribeOn&lt;/code&gt; 处于哪个位置都无所谓。要理解这个差别的原因，得先理解 &lt;a href="https://projectreactor.io/docs/core/release/reference/#reactive.subscribe"&gt;订阅之前实际什么都没有发生&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Reactor，串接算子，就是将很多 &lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 的实现一个套一个，逐层封装。一旦订阅，就创建了一个 &lt;code&gt;Subscriber&lt;/code&gt; 对象链，沿链回溯即可找到第一个发布者。这些实现细节是隐藏在接口背后，开发者可见的是最外层的那个 &lt;code&gt;Flux&lt;/code&gt;（或 &lt;code&gt;Mono&lt;/code&gt;）以及 &lt;code&gt;Subscription&lt;/code&gt;（译注：Reactor 中 Subscription 是一个接口类型，是 &lt;code&gt;Subscriber&lt;/code&gt; 接口中 &lt;code&gt;onSubscribe&lt;/code&gt; 方法参数的类型 - &lt;code&gt;public void onSubscribe(Subscription s)&lt;/code&gt;，用于向生产者请求数据 或者 取消订阅），但这些算子特定的链中消费者是幕后功臣。&lt;/p&gt;
&lt;p&gt;有了上面这些认知，现在我们可以进一步了解 &lt;code&gt;publishOn&lt;/code&gt; 和 &lt;code&gt;subscribeOn&lt;/code&gt; 这两个算子：&lt;/p&gt;
&lt;h5&gt;3.5.1 publishOn 方法&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;publishOn&lt;/code&gt; 和其他算子的用法一样，用在订阅链的中间环节，接收来自上游的信号，然后向下游重放这些信号，不过下发事件回调（&lt;code&gt;onEvent&lt;/code&gt;、&lt;code&gt;onError&lt;/code&gt;、&lt;code&gt;onComplete&lt;/code&gt;）是在关联 &lt;code&gt;Scheduler&lt;/code&gt; 的一个工作者上执行的。因此，这个算子会影响后续算子在哪执行（直到订阅链上又串接了另一个 &lt;code&gt;publishOn&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将执行上下文切换到 &lt;code&gt;Scheduler&lt;/code&gt; 选择的一个线程上&lt;/li&gt;
&lt;li&gt;根据规范（as per the specification），&lt;code&gt;onNext&lt;/code&gt; 是按时序依次调用下发事件的，所以是占用一个线程（译注：这句不太理解，onNext happen in sequence, so this uses up a single thread）&lt;/li&gt;
&lt;li&gt;除非算子工作在一个特定的 &lt;code&gt;Scheduler&lt;/code&gt; 上（译注：某些算子的内部实现决定了这一点），&lt;code&gt;publishOn&lt;/code&gt; 之后的算子都是在同一个线程上执行&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Scheduler s = Schedulers.newParallel(&lt;span style="color: #a31515"&gt;&amp;quot;parallel-scheduler&amp;quot;&lt;/span&gt;, 4); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Flux&amp;lt;String&amp;gt; flux = Flux
    .range(1, 2)
    .map(i -&amp;gt; 10 + i) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
    .publishOn(s) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
    .map(i -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;value &amp;quot;&lt;/span&gt; + i); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Thread(() -&amp;gt; flux.subscribe(System.out::println));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;创建一个新的 &lt;code&gt;Scheduler&lt;/code&gt;，内含 4 个线程&lt;/li&gt;
&lt;li&gt;第一个 &lt;code&gt;map&lt;/code&gt; 运行在 &amp;lt;第5步&amp;gt; 的匿名线程上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;publishOn&lt;/code&gt; 将整个序列的后续处理切换到从 &amp;lt;第1步&amp;gt; 选出的线程上&lt;/li&gt;
&lt;li&gt;第二个 &lt;code&gt;map&lt;/code&gt; 运行在上面说的从 &amp;lt;第1步&amp;gt; 选出的线程上&lt;/li&gt;
&lt;li&gt;这个匿名线程是 &lt;em&gt;订阅&lt;/em&gt; 操作发生的地方。打印语句发生在 &lt;code&gt;publishOn&lt;/code&gt; 切换的最新执行上下文上&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;3.5.2 subscribeOn 方法&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;subscribeOn&lt;/code&gt; 在构造反向链时应用于订阅处理过程（译注：所谓构造反向链时，是指调用 subscribe 方法时）。因此，无论你将 &lt;code&gt;subscribeOn&lt;/code&gt; 放在算子链的何处，&lt;strong&gt;它始终会影响源头下发数据的执行上下文&lt;/strong&gt;。然而，这并不会影响 &lt;code&gt;publishOn&lt;/code&gt; 之后算子调用的行为，它们仍然会切换到 &lt;code&gt;publishOn&lt;/code&gt; 指定的执行上下文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从订阅操作发生时整个算子链所在的线程切换到新的线程&lt;/li&gt;
&lt;li&gt;从指定 &lt;code&gt;Scheduler&lt;/code&gt; 中选择一个线程&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;只有链中最早的 &lt;code&gt;subscribeOn&lt;/code&gt; 调用会发生实际作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Scheduler s = Schedulers.newParallel(&lt;span style="color: #a31515"&gt;&amp;quot;parallel-scheduler&amp;quot;&lt;/span&gt;, 4); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Flux&amp;lt;String&amp;gt; flux = Flux
    .range(1, 2)
    .map(i -&amp;gt; 10 + i) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
    .subscribeOn(s) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
    .map(i -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;value &amp;quot;&lt;/span&gt; + i); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Thread(() -&amp;gt; flux.subscribe(System.out::println)); &lt;span style="color: #008000"&gt;// 5 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;创建一个新的 &lt;code&gt;Scheduler&lt;/code&gt;，内含 4 个线程&lt;/li&gt;
&lt;li&gt;第一个 &lt;code&gt;map&lt;/code&gt; 运行在这 4 个线程中的某个线程上&lt;/li&gt;
&lt;li&gt;...因为 &lt;code&gt;subscribeOn&lt;/code&gt; 将整个序列处理链从订阅操作发生时的执行上下文（第5步）切换到了新的上下文&lt;/li&gt;
&lt;li&gt;第二个 &lt;code&gt;map&lt;/code&gt; 和第一个 &lt;code&gt;map&lt;/code&gt; 运行在同一个线程上&lt;/li&gt;
&lt;li&gt;这个匿名线程是 &lt;em&gt;订阅操作&lt;/em&gt; 一开始发生的地方的，但是 &lt;code&gt;subscribeOn&lt;/code&gt; 即刻将上下文切换到调度器4个线程中的一个上&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;4. 高级特性和概念&lt;/h3&gt;
&lt;h4&gt;4.1 使用 ConnectableFlux 将消息广播到多个订阅者&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;以后有空再翻译&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;4.2 3种分批处理方式&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;以后有空再翻译&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;4.3 使用 ParallelFlux 并行化处理&lt;/h4&gt;
&lt;p&gt;如今多核架构已是下里巴人，相应地，轻松实现并行化工作的工具手段很关键。Reactor 提供了一个特殊类型 - &lt;code&gt;ParallelFlux&lt;/code&gt; - 帮助实现并行化处理。&lt;code&gt;ParallelFlux&lt;/code&gt; 提供的算子是为并行化工作优化过的。&lt;/p&gt;
&lt;p&gt;对任意 &lt;code&gt;Flux&lt;/code&gt; 实例调用 &lt;code&gt;parallel()&lt;/code&gt;算子就能得到一个 &lt;code&gt;ParallelFlux&lt;/code&gt; 实例。这个方法本身并不能实现并行化工作，而是将工作负载拆分到多个“轨道”（默认“轨道”数量等于 CPU 核数）&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;为了告知产出的 ParallelFlux 实例每个“轨道”在哪执行（以及如何并行执行“轨道”），则必须使用 &lt;code&gt;runOn(Scheduler)&lt;/code&gt;。注意：对于并行工作，推荐使用一个专用调度器 - &lt;code&gt;Schedulers.parallel()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对比如下两个示例，第一个示例的代码如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.range(1, 10)
    .parallel(2) &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
    .subscribe(i -&amp;gt; System.out.println(Thread.currentThread().getName() + &lt;span style="color: #a31515"&gt;&amp;quot; -&amp;gt; &amp;quot;&lt;/span&gt; + i));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;这里强制指定了“轨道”数量，而不依赖于 CPU 核数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二个示例的代码如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.range(1, 10)
    .parallel(2)
    .runOn(Schedulers.parallel())
    .subscribe(i -&amp;gt; System.out.println(Thread.currentThread().getName() + &lt;span style="color: #a31515"&gt;&amp;quot; -&amp;gt; &amp;quot;&lt;/span&gt; + i));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一个示例输出如下内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;main -&amp;gt; 1
main -&amp;gt; 2
main -&amp;gt; 3
main -&amp;gt; 4
main -&amp;gt; 5
main -&amp;gt; 6
main -&amp;gt; 7
main -&amp;gt; 8
main -&amp;gt; 9
main -&amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二个示例正确地在两个线程上实现了并行化，输入如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-1 -&amp;gt; 1
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-2 -&amp;gt; 2
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-1 -&amp;gt; 3
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-2 -&amp;gt; 4
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-1 -&amp;gt; 5
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-2 -&amp;gt; 6
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-1 -&amp;gt; 7
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-1 -&amp;gt; 9
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-2 -&amp;gt; 8
&lt;span style="color: #0000ff"&gt;parallel&lt;/span&gt;-2 -&amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果数据序列&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;已经在并行化处理，而你又想将其转回一个 “常规的” &lt;code&gt;Flux&lt;/code&gt; 实例，然后串行执行算子链余下的部分，则可以使用 &lt;code&gt;ParallelFlux&lt;/code&gt; 的 &lt;code&gt;sequential()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;注意：如果直接使用一个 &lt;code&gt;Subscriber&lt;/code&gt; 类型参数而不是 lambda 表达式来调用 &lt;code&gt;subscribe&lt;/code&gt; 方法，那么内部实现会隐式地调用 &lt;code&gt;sequential()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;由此也要注意：&lt;code&gt;subscribe(Subscriber&amp;lt;T&amp;gt;)&lt;/code&gt; 会合并所有数据“轨道”，而 &lt;code&gt;subscribe(Consumer&amp;lt;T&amp;gt;)&lt;/code&gt; 是运行所有的数据“轨道”。如果以 lambda 表达式调用 &lt;code&gt;subscribe&lt;/code&gt; 方法，那么每个 lambda 表达式都会被复制成多个实例（数量等于“轨道”数量）去执行&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;译注：这里的“轨道”其实不太直白。在实现上，&lt;code&gt;ParallelFlux&lt;/code&gt; 会将最后 &lt;code&gt;subscribe&lt;/code&gt; 的 onNext 回调按并行度（默认等于 CPU 核数 N）复制成 N 个，那么最终调用 ParallelFlux 的 N 个 Subscriber，从 ParallelFlux 实例到一个 Subscriber 的数据流路径可以理解为一个“轨道”，ParallelFlux 在接收到上游消息后按照 round-robin 方式选择一个 Subscriber 调用其 &lt;code&gt;onNext&lt;/code&gt; 下发消息，但 &lt;code&gt;onNext&lt;/code&gt; 是运行在什么线程上，是由 runOn 算子决定的，如果不使用 runOn 算子，那么所有 Subscriber 的 &lt;code&gt;onNext&lt;/code&gt; 方法调用都是同步运行在主线程上的。&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;译注：原文中用了多个词来表达相近的意思：sequence（序列）、stream（流）、flow（流），阅读时可以相互替代理解。此外，还有 event（事件）、data（数据）、message（消息），在当前上下文中，可以看成是等价的。&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;译注：这话写得真蠢。详细解释见脚注 1。&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Reactor"></category><category term="Reactive"></category></entry><entry><title>Java System.getProperty VS. System.getenv（译）</title><link href="http://youngsterxyf.github.io/2019/06/25/java-prop-env/" rel="alternate"></link><published>2019-06-25T00:00:00+08:00</published><updated>2019-06-25T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-06-25:/2019/06/25/java-prop-env/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://www.baeldung.com/java-system-get-property-vs-system-getenv"&gt;Java System.getProperty vs System.getenv&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1、简介&lt;/h2&gt;
&lt;p&gt;Java 应用代码中会自动引入 &lt;code&gt;java.lang&lt;/code&gt; 包。这个包包含很多常用的类，包括 &lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;java.lang.System&lt;/code&gt; 类 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://www.baeldung.com/java-system-get-property-vs-system-getenv"&gt;Java System.getProperty vs System.getenv&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1、简介&lt;/h2&gt;
&lt;p&gt;Java 应用代码中会自动引入 &lt;code&gt;java.lang&lt;/code&gt; 包。这个包包含很多常用的类，包括 &lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;java.lang.System&lt;/code&gt; 类是一个 final 类，这意味着开发者无法继承它，其所有方法都是静态的（static）。&lt;/p&gt;
&lt;p&gt;System 类中有两个方法，分别来&lt;strong&gt;读取系统属性（system properties）和环境变量（environment variables）&lt;/strong&gt;，下面我们来看看这两者的区别。&lt;/p&gt;
&lt;h2&gt;2、使用 System.getProperty()&lt;/h2&gt;
&lt;p&gt;Java 平台使用一个 &lt;code&gt;Properties&lt;/code&gt; 对象来提供&lt;strong&gt;本地系统相关的信息和配置&lt;/strong&gt;，我们称之为 &lt;strong&gt;系统属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;系统属性包括当前用户、当前 Java 运行时版本 以及 文件路径分隔符诸如此类的信息。&lt;/p&gt;
&lt;p&gt;如下代码中，我们使用 &lt;code&gt;System.getProperty("log_dir")&lt;/code&gt; 来读取 &lt;em&gt;log_dir&lt;/em&gt; 属性值。我们也会使用默认值参数，这样如果属性不存在，&lt;code&gt;getProperty&lt;/code&gt; 则返回 &lt;em&gt;/tmp/log&lt;/em&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;String log_dir = System.getProperty(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;/tmp/log&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果希望在运行时变更系统属性，则可以使用 &lt;code&gt;System.setProperty&lt;/code&gt; 方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;System.setProperty(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;/tmp/log&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以以如下格式使用命令行参数向应用传递指定属性或配置值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;java -jar jarName -DpropertyName=value
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;比如 将 app.jar 的 foo 属性值设置为 bar：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;java -jar app -Dfoo=&amp;quot;bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;System.getProperty 返回的一定是一个字符串。&lt;/p&gt;
&lt;h2&gt;3、使用 System.getenv()&lt;/h2&gt;
&lt;p&gt;环境变量是类似 Properties 的一些 键/值 对。许多操作系统都提供环境变量的方式向应用传递配置信息。&lt;/p&gt;
&lt;p&gt;设置环境变量的方式，各操作系统之间有所不同。例如，Windows 中，我们使用控制面板中的系统工具（System Utility）应用来设置，而 Unix 系统则使用 shell 脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个进程时，该进程默认会从其父进程继承一个克隆的上下文环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下代码片段演示：使用一个 lambda 表达式来输出所有环境变量。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;System.getenv().forEach((k, v) -&amp;gt; {
    System.out.println(k + &lt;span style="color: #a31515"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + v);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;getenv() 返回一个只读的 &lt;code&gt;Map&lt;/code&gt;&lt;/strong&gt;。尝试向该映射中添加值，会抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;可以使用变量名称作为参数调用 &lt;code&gt;getenv&lt;/code&gt; 来获取单个变量值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;String log_dir = System.getenv(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此外，我们可以在应用中创建一个新进程，并向其上下文环境中添加新的环境变量。&lt;/p&gt;
&lt;p&gt;Java 中，我们使用 &lt;code&gt;ProcessBuilder&lt;/code&gt; 类来创建新进程，该类有一个名为 &lt;code&gt;environment&lt;/code&gt; 的方法，此方法返回一个 &lt;code&gt;Map&lt;/code&gt;，不过这个映射不是只读的，这样就可以向其添加新元素：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ProcessBuilder pb = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ProcessBuilder(args);
Map&amp;lt;String, String&amp;gt; env = pb.environment();
env.put(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;/tmp/log&amp;quot;&lt;/span&gt;);
Process process = pb.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4、区别&lt;/h2&gt;
&lt;p&gt;这两者本质上都是提供 字符串类型 键值 信息的映射，区别在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们可以在运行时变更 系统属性（Properties），但是 环境变量（Environment Variables）仅是操作系统环境变量的一个不可变拷贝。&lt;/li&gt;
&lt;li&gt;仅 Java 平台包含这个 系统属性 特性，而 环境变量 则是操作系统层面提供，全局可用的 - 运行在同一个机器上的所有应用都可以访问。&lt;/li&gt;
&lt;li&gt;系统属性 在打包应用时就必须存在&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;，而 环境变量 则任意时刻都可以在操作系统中创建。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;5、总结一下&lt;/h2&gt;
&lt;p&gt;虽然这两者在概念上比较相似，但是 系统属性 和 环境变量 的应用方式差别很大。&lt;/p&gt;
&lt;p&gt;二选一通常考量的是生效范围。使用 环境变量，同一个应用可以部署到多个机器上运行不同的实例，并在操作系统级别或者在 AWS / Azure 云平台控制台中进行配置，以免更新配置时还得重新构建应用（&lt;strong&gt;译注：其实使用 系统属性 也可以实现这个效果，比如在 shell 脚本中获取系统环境变量，然后作为系统属性通过 Java 命令行参数传递给应用&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getProperty&lt;/code&gt; 方法名称是驼峰风格，但 &lt;code&gt;getenv&lt;/code&gt; 不是，谨记！&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;原文是这么写的，但我认为这句话有问题。系统属性明明可以在应用运行时通过命令行参数指定，也可以将属性文件打包到应用包中，在运行时加载（通过 &lt;code&gt;System.getProperties().load&lt;/code&gt; 方法）。&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Java"></category></entry><entry><title>Java 单测伴侣 - mockito</title><link href="http://youngsterxyf.github.io/2019/06/17/mockito/" rel="alternate"></link><published>2019-06-17T00:00:00+08:00</published><updated>2019-06-17T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-06-17:/2019/06/17/mockito/</id><summary type="html">&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码还挺难的，挺花时间，其中最麻烦的是待测代码可能会访问外部资源（比如数据库、HTTP API），如果不能方便地进模拟访问这些外部资源，那么测试起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;但，对于复杂逻辑，如果不经过严格测试，发布到生产环境，又有些不放心，没底气，或者在代码重构时，如果没有覆盖全面的测试，很难评估代码变动带来的影响。&lt;/p&gt;
&lt;p&gt;直到遇到 &lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt;，我才觉得是时候认真写写测试代码了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt; 提供两种对象模拟方式：&lt;strong&gt;mock&lt;/strong&gt; 和 &lt;strong&gt;spy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，mock 模拟的对象是一个完全假的对象，只是具备指定类型的接口，以 &lt;code&gt;java.util.List&lt;/code&gt; 为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.mock;

List mockedList = mock(List.class);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然 List 是一个 interface，也可以模拟出一个对象实例，这个 mockedList 对象具备 List 接口定义的所有方法，但所有方法都不具备实际的行为操作，对于有返回值的方法，则默认返回方法返回类型的默认值，没有返回值的方法，则纯粹是一个空方法。比如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// mockedList 并不会真的把 1 存下来&lt;/span&gt;
mockedList.add(1);
&lt;span style="color: #008000"&gt;// 所以，size() 返回默认值，输出 0&lt;/span&gt;
System.out.println(mockedList.size());
&lt;span style="color: #008000"&gt;// 输出 null&lt;/span&gt;
System.out.println(mockedList.get(0));
&lt;span style="color: #008000"&gt;// 输出 null&lt;/span&gt;
System.out.println(mockedList.get(1));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于模拟出来的对象，可以任意指定其方法的返回值，比如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.when;

&lt;span style="color: #008000"&gt;// 调用 size() 方法时，返回 10&lt;/span&gt;
when(mockedList.size()).willReturn(10);
when(mockedList.get(0)).willReturn(&lt;span style="color: #a31515"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;);
when(mockedList.get(1)).thenReturn(&lt;span style="color: #a31515"&gt;&amp;quot;您好！&amp;quot;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// 输出 10&lt;/span&gt;
System.out.println(mockedList.size());
&lt;span style="color: #008000"&gt;// 输出 Hello World!&lt;/span&gt;
System.out.println(mockedList.get(0));
&lt;span style="color: #008000"&gt;// 输出 您好！&lt;/span&gt;
System.out.println(mockedList.get(1));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然我们写测试代码时，并不会使用 System.out.println，然后看输出，而是使用&lt;strong&gt;断言&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.junit.Assert.assertEquals;

assertEquals(10, mockedList.size());
assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;, mockedList.get(0));
assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;您好！&amp;quot;&lt;/span&gt;, mockedList.get(1));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;断言方法非常多，不仅仅只是 assertEquals。&lt;/p&gt;
&lt;p&gt;对于同一个方法，可以模拟多次调用返回不同的值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 会覆盖之前 mock 的行为：when(mockedList.size()).willReturn(10);&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 或者这么写：when(mockedList.size()).willReturn(0, -1, 10);&lt;/span&gt;
when(mockedList.size()).thenReturn(0).thenReturn(-1).thenReturn(10);
assertEquals(0, mockedList.size());
assertEquals(-1, mockedList.size());
assertEquals(10, mockedList.size());
&lt;span style="color: #008000"&gt;// 第 3 次之后的 mockedList.size() 调用都返回 10&lt;/span&gt;
assertEquals(10, mockedList.size());

Iterator iterator = mock(Iterator.class);
&lt;span style="color: #008000"&gt;// 或者这么写：when(iterator.next()).thenReturn(0, 1, 10, 1000);&lt;/span&gt;
when(iterator.next()).thenReturn(0).thenReturn(1).thenReturn(10).thenReturn(1000);
assertEquals(0, iterator.next());
assertEquals(1, iterator.next());
assertEquals(10, iterator.next());
assertEquals(1000, iterator.next());
&lt;span style="color: #008000"&gt;// 第 4 次之后的 iterator.next() 调用都返回 1000&lt;/span&gt;
assertEquals(1000, iterator.next());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还可以模拟异常抛出：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;List mockedList = mock(List.class);

when(mockedList.get(-1000)).thenThrow(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; RuntimeException(&lt;span style="color: #a31515"&gt;&amp;quot;参数异常！&amp;quot;&lt;/span&gt;));
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt; {
    mockedList.get(-1000);
} &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt; (Exception e) {
    assertTrue(e &lt;span style="color: #0000ff"&gt;instanceof&lt;/span&gt; RuntimeException);
    assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;参数异常！&amp;quot;&lt;/span&gt;, e.getMessage());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以基于复杂的逻辑来构造返回值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.invocation.InvocationOnMock;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.stubbing.Answer;

List&amp;lt;Integer&amp;gt; mockedList = mock(List.class);
when(mockedList.get(anyInt())).thenAnswer(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; EchoAnswer());

assertTrue(1 == mockedList.get(1));
assertTrue(10 == mockedList.get(10));

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;EchoAnswer&lt;/span&gt; &lt;span style="color: #0000ff"&gt;implements&lt;/span&gt; Answer&amp;lt;Integer&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; Integer answer(InvocationOnMock var) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; var.getArgument(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了 &lt;code&gt;when(...).thenReturn(...)&lt;/code&gt; 风格的测试模拟方式，还有 BDD（Behavior Driven Development 行为驱动开发）风格的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.BDDMockito.given;

&lt;span style="color: #008000"&gt;// given&lt;/span&gt;
given(mockedList.get(0)).willReturn(100);
&lt;span style="color: #008000"&gt;// when&lt;/span&gt;
&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; v = (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) mockedList.get(0);
&lt;span style="color: #008000"&gt;// then&lt;/span&gt;
assertEquals(100, v);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果方法没有返回值，或者其它奇葩的需求，则没法使用 when.thenReturn / willReturn 这样的模拟方法，可以使用 &lt;code&gt;doReturn(...).when(...)...&lt;/code&gt;：
&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.doThrow;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.doReturn;

ArrayList mockedList = mock(ArrayList.class);
&lt;span style="color: #008000"&gt;// clear 方法无返回值&lt;/span&gt;
doThrow(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; RuntimeException(&lt;span style="color: #a31515"&gt;&amp;quot;清除失败&amp;quot;&lt;/span&gt;)).when(mockedList).clear();

&lt;span style="color: #0000ff"&gt;try&lt;/span&gt; {
    mockedList.clear();
} &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt; (Exception e) {
    assertTrue(e &lt;span style="color: #0000ff"&gt;instanceof&lt;/span&gt; RuntimeException);
    assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;清除失败&amp;quot;&lt;/span&gt;, e.getMessage());
}

&lt;span style="color: #008000"&gt;// 没有意义，因为没法使用 断言 来验证，实际运行时会抛异常&lt;/span&gt;
doReturn(10).when(mockedList).clear();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从示例代码可以看出，&lt;code&gt;doReturn(...).when(...)....&lt;/code&gt; 不会做类型校验，mockedList.clear() 返回值类型为 void，但我们模拟让其返回 10；所以，正常情况应该尽可能使用 &lt;code&gt;when(...).thenReturn(...)&lt;/code&gt; 或 &lt;code&gt;given(...).willReturn(...)&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;前述代码示例中，模拟方法的参数都做了硬编码，实际情况通常都不是这么测试，而是模拟方法的参数符合一定的要求即可，比如：在某个范围之内、符合类型的任何值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.anyInt;

&lt;span style="color: #008000"&gt;/*&lt;/span&gt;
&lt;span style="color: #008000"&gt;以任何 int 类型的参数调用 mockedList.get 方法，都返回 100&lt;/span&gt;

&lt;span style="color: #008000"&gt;如果写成 when(mockedList.get(0)).thenReturn(100)，则只有以 0 为参数调用 mockedList.get 方法，才会返回100，其他参数值，返回的都是默认值 0&lt;/span&gt;
&lt;span style="color: #008000"&gt;*/&lt;/span&gt;
when(mockedList.get(anyInt())).thenReturn(100);

assertEquals(100, mockedList.get(0));
assertEquals(100, mockedList.get(1000));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可用的参数匹配器，见 org.mockito.ArgumentMatchers 类的静态方法列表，也可以自己实现 ArgumentMatcher 接口：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;package&lt;/span&gt; org.mockito;

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;ArgumentMatcher&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; matches(T var1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.ArgumentMatcher;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.intThat;

when(mockedList.get(intThat(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; LimitedInt()))).thenReturn(10);

assertEquals(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, mockedList.get(-1));
assertEquals(10, mockedList.get(1));
assertEquals(10, mockedList.get(99));
assertEquals(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, mockedList.get(100));

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;LimitedInt&lt;/span&gt; &lt;span style="color: #0000ff"&gt;implements&lt;/span&gt; ArgumentMatcher&amp;lt;Integer&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; matches(Integer var) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; &lt;span style="border: 1px solid #FF0000"&gt;&amp;gt; 0 &amp;amp;&amp;amp; &lt;/span&gt;var &amp;lt; 100;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果被模拟的方法包含多个参数，那么这些参数要么全部使用匹配器，要么全部不使用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;模拟某些类（A）的方法，通常会将 mock 出来的对象注入到依赖该类实例的其他类（B）中，来替代真实的依赖，这种方式的目的是为了测试类 B 的行为是否符合预期。&lt;/p&gt;
&lt;p&gt;另一个测试需求是，测试某个类 A' 在某个上下文环境中的行为是否符合预期，比如： A' 的某个方法是否被调用过、调用过几次、调用参数是否符合预期、几个方法之间的调用次序是否符合预期、方法调用耗时是否符合预期等等。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.verify;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.times;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.never;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.verifyZeroInteractions;

List mocked = mock(List.class);

Caller caller = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Caller();
caller.setList(mocked);

&lt;span style="color: #008000"&gt;// 调用 0 次&lt;/span&gt;
caller.run(0);
&lt;span style="color: #008000"&gt;// 验证是否从来没调用过 mocked.size()&lt;/span&gt;
verify(mocked, never()).size();
&lt;span style="color: #008000"&gt;// 验证 没有和 mocked 产生过任何交互&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 因为 Caller.run 中调用了 list.isEmpty()，实际产生了交互，所以这行测试会失败&lt;/span&gt;
verifyZeroInteractions(mocked);

&lt;span style="color: #008000"&gt;// 调用 10 次&lt;/span&gt;
caller.run(10);
&lt;span style="color: #008000"&gt;// 验证是否调用 mocked.size() 10 次&lt;/span&gt;
verify(mocked, times(10)).size();

&lt;span style="color: #008000"&gt;// 再调用一次&lt;/span&gt;
caller.run(1);
&lt;span style="color: #008000"&gt;// 所以是 11 次了&lt;/span&gt;
verify(mocked, times(11)).size();

@Data
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Caller&lt;/span&gt; {
    List list;

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; run(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; count) {
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; idx=0; idx &amp;lt; count; idx++) {
            list.size();
        }
        &lt;span style="color: #008000"&gt;//&lt;/span&gt;
        list.isEmpty();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;List mocked = mock(List.class);

mocked.add(1);
mocked.add(2);

verify(mocked).add(1);

&lt;span style="color: #008000"&gt;// 是否有其他交互没有验证过？因为 mocked 还调用过 mocked.add(2)，所以这句测试会失败&lt;/span&gt;
verifyNoMoreInteractions(mocked);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.InOrder;

&lt;span style="color: #008000"&gt;// 也可以验证调用次序&lt;/span&gt;
List mocked1 = mock(List.class);
List mocked2 = mock(List.class);

mocked1.size();
mocked1.isEmpty();
mocked2.isEmpty();

&lt;span style="color: #008000"&gt;// 会记录 mocked1、mocked2 中方法的调用/交互次序，要求：与 mocked1 的交互先于 mocked2&lt;/span&gt;
InOrder inOrder = inOrder(mocked1, mocked2);
&lt;span style="color: #008000"&gt;// mocked1、mocked2 的交互顺序必须和 inOrder.verify 之间的顺序一致&lt;/span&gt;
inOrder.verify(mocked1).size();
inOrder.verify(mocked1).isEmpty();
inOrder.verify(mocked2).isEmpty();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;也可以验证某个方法被调用时所使用的参数是否符合预期：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.ArgumentCaptor;

List mockedlist = mock(List.class);

Caller caller = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Caller();
caller.setList(mockedlist);
caller.run();

&lt;span style="color: #008000"&gt;// 捕获 mockedList.add 的调用参数&lt;/span&gt;
ArgumentCaptor&amp;lt;Integer&amp;gt; argumentCaptor = ArgumentCaptor.forClass(Integer.class);
verify(mockedlist).add(argumentCaptor.capture());
assertTrue(100 == argumentCaptor.getValue());

@Data
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Caller&lt;/span&gt; {
    List list;

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; run() {
        list.add(100);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;前面的内容都是以 mock 为例，我们再来说说 spy，与 mock 的区别：&lt;/p&gt;
&lt;p&gt;mock 出来的对象是一个完全假的对象，但 spy 通常是基于一个具体的类或类实例，对其篡改某些方法，对于被篡改方法之外的方法，其行为都和调用真实对象的方法一样，不过并没有调用真实对象的方法，也不会对真实对象产生影响：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 基于一个实际的类实例&lt;/span&gt;
List&amp;lt;Integer&amp;gt; realList = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(10);
List&amp;lt;Integer&amp;gt; spy = spy(realList);

spy.add(1);

&lt;span style="color: #008000"&gt;// 被窃听的对象并没有发生变化&lt;/span&gt;
assertEquals(0, realList.size());
&lt;span style="color: #008000"&gt;// 间谍对象确实将 1 存了下来&lt;/span&gt;
assertEquals(1, spy.size());
&lt;span style="color: #008000"&gt;// 这句会抛出 java.lang.IndexOutOfBoundsException，因为 realList 还是为空&lt;/span&gt;
assertTrue(1 == realList.get(0));
assertTrue(1 == spy.get(0));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以基于一个具体的类来构造 spy，但这样无法使用带参数的构造方法，也无法指定类型参数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; = spy(ArrayList.class);
assertEquals(0, spy.size());
spy.add(100);
assertEquals(1, spy.size());
assertTrue(100 == spy.get(0));

&lt;span style="color: #008000"&gt;// 篡改方法&lt;/span&gt;
when(spy.size()).thenReturn(-1);
assertEquals(-1, spy.size());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上，mock 也可以基于具体的类来构造，这时可以指定某些方法实际调用具体类的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;除了使用 mock、spy 方法来构造模拟对象，还可以通过注解来构造，但这样的话得指定 JUnit 的 Runner 为 &lt;code&gt;org.mockito.junit.MockitoJUnitRunner&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.junit.Test;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.junit.runner.RunWith;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.Mock;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.Spy;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.junit.MockitoJUnitRunner;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.ArrayList;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.when;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.junit.Assert.assertTrue;

@RunWith(MockitoJUnitRunner.class)
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;testTester&lt;/span&gt; {

    @Mock
    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; mocked;

    @Spy
    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; spyed;

    @Test
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; test() {
        when(mocked.isEmpty()).thenReturn(&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);
        when(spyed.isEmpty()).thenReturn(&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);

        assertTrue(!mocked.isEmpty());
        assertTrue(!spyed.isEmpty());

        mocked.add(0);
        spyed.add(0);

        assertTrue(0 == mocked.size());
        assertTrue(1 == spyed.size());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Java"></category><category term="mockito"></category><category term="单测"></category></entry><entry><title>编写漂亮的 shell 代码</title><link href="http://youngsterxyf.github.io/2018/05/16/beautiful-shell-code/" rel="alternate"></link><published>2018-05-16T00:00:00+08:00</published><updated>2018-05-16T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-05-16:/2018/05/16/beautiful-shell-code/</id><summary type="html">&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is true, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

map() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
}

reduce() {
    operator=$1
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    list=($2)
    list_len=&lt;span style="color: #a31515"&gt;${#&lt;/span&gt;list[@]&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    result=&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list_len&lt;span style="color: #a31515"&gt;}&lt;/span&gt; -gt 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        result=&lt;span style="color: #a31515"&gt;${&lt;/span&gt;list[0]&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list_len&lt;span style="color: #a31515"&gt;}&lt;/span&gt; -gt 1 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list[@]:1&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
            result=&lt;span style="color: #0000ff"&gt;$(&lt;/span&gt;&lt;span style="color: #a31515"&gt;${&lt;/span&gt;operator&lt;span style="color: #a31515"&gt;}&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;result&lt;span style="color: #a31515"&gt;}&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;&lt;span style="color: #0000ff"&gt;)&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    echo &lt;span style="color: #a31515"&gt;${&lt;/span&gt;result&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
}

filter() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
}

sum() {
    v=0
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; arg &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;$@&lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        v=&lt;span style="color: #0000ff"&gt;$((&lt;/span&gt;$v+&lt;span style="color: #a31515"&gt;${&lt;/span&gt;arg&lt;span style="color: #a31515"&gt;}&lt;/span&gt;&lt;span style="color: #0000ff"&gt;))&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
    echo $v
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Bash"></category></entry><entry><title>配置 Maven 自动化构建 protobuf 代码依赖</title><link href="http://youngsterxyf.github.io/2018/05/14/maven-protobuf/" rel="alternate"></link><published>2018-05-14T00:00:00+08:00</published><updated>2018-05-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-05-14:/2018/05/14/maven-protobuf/</id><summary type="html">&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin.version&amp;gt;
    &amp;lt;maven-dependency-plugin.version&amp;gt;3.0.2&amp;lt;/maven-dependency-plugin.version&amp;gt;
    &amp;lt;os-maven-plugin.version&amp;gt;1.5.0.Final&amp;lt;/os-maven-plugin.version&amp;gt;
    &amp;lt;protobuf.version&amp;gt;2.5.0&amp;lt;/protobuf.version&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.添加 protobuf-java 库依赖&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${protobuf.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.添加 maven 扩展：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;extensions&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- provides os.detected.classifier (i.e. linux-x86_64, osx-x86_64) property --&amp;gt;&lt;/span&gt;
        &amp;lt;extension&amp;gt;
            &amp;lt;groupId&amp;gt;kr.motd.maven&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;os-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${os-maven-plugin.version}&amp;lt;/version&amp;gt;
        &amp;lt;/extension&amp;gt;
    &amp;lt;/extensions&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.配置构建插件：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- copy protoc binary into build directory --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${maven-dependency-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;copy-protoc&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;copy&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;artifactItems&amp;gt;
                            &amp;lt;artifactItem&amp;gt;
                                &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;protoc&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;${protobuf.version}&amp;lt;/version&amp;gt;
                                &amp;lt;classifier&amp;gt;${os.detected.classifier}&amp;lt;/classifier&amp;gt;
                                &amp;lt;type&amp;gt;exe&amp;lt;/type&amp;gt;
                                &amp;lt;overWrite&amp;gt;true&amp;lt;/overWrite&amp;gt;
                                &amp;lt;outputDirectory&amp;gt;${project.build.directory}&amp;lt;/outputDirectory&amp;gt;
                            &amp;lt;/artifactItem&amp;gt;
                        &amp;lt;/artifactItems&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- compile proto buffer files using copied protoc binary --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-antrun-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${maven-antrun-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;exec-protoc&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;target&amp;gt;
                            &amp;lt;property name=&lt;span style="color: #a31515"&gt;&amp;quot;protoc.filename&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;protoc-${protobuf.version}-${os.detected.classifier}.exe&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;property name=&lt;span style="color: #a31515"&gt;&amp;quot;protoc.filepath&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;${project.build.directory}/${protoc.filename}&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;chmod file=&lt;span style="color: #a31515"&gt;&amp;quot;${protoc.filepath}&amp;quot;&lt;/span&gt; perm=&lt;span style="color: #a31515"&gt;&amp;quot;ugo+rx&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;mkdir dir=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.output.directory}&amp;quot;&lt;/span&gt; /&amp;gt;
                            &amp;lt;path id=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths.path&amp;quot;&lt;/span&gt;&amp;gt;
                                &amp;lt;fileset dir=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.directory}&amp;quot;&lt;/span&gt;&amp;gt;
                                    &amp;lt;include name=&lt;span style="color: #a31515"&gt;&amp;quot;**/*.proto&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;/fileset&amp;gt;
                            &amp;lt;/path&amp;gt;
                            &amp;lt;pathconvert pathsep=&lt;span style="color: #a31515"&gt;&amp;quot; &amp;quot;&lt;/span&gt; property=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths&amp;quot;&lt;/span&gt; refid=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths.path&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;exec executable=&lt;span style="color: #a31515"&gt;&amp;quot;${protoc.filepath}&amp;quot;&lt;/span&gt; failonerror=&lt;span style="color: #a31515"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;-I&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.directory}&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;--java_out&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.output.directory}&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg line=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.filepaths}&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;/exec&amp;gt;
                        &amp;lt;/target&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;run&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- add generated proto buffer classes into the package --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;build-helper-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${build-helper-maven-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;add-classes&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;add-source&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;sources&amp;gt;
                            &amp;lt;source&amp;gt;${protobuf.output.directory}&amp;lt;/source&amp;gt;
                        &amp;lt;/sources&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://vlkan.com/blog/post/2015/11/27/maven-protobuf/&lt;/p&gt;
&lt;p&gt;http://www.chendan.me/2017/07/02/maven-protobuf/&lt;/p&gt;</content><category term="其他"></category><category term="java"></category><category term="maven"></category><category term="protobuf"></category></entry><entry><title>《Python 编程之美》译者序</title><link href="http://youngsterxyf.github.io/2018/04/01/the-python-guide/" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-04-01:/2018/04/01/the-python-guide/</id><summary type="html">&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语言包括：Python、PHP、Go、Java、JavaScript 等。&lt;/p&gt;
&lt;p&gt;虽说编程语言各异，但我使用它们来写各种项目的代码却一直坚持两点：代码可读性和自解释性/自文档性（self-documentation）。这很大程度上应该是受到 Python 语言设计哲学的影响 - 追求简单易读易懂的代码。&lt;/p&gt;
&lt;p&gt;很多人可能会认为这两点其实是一点 - 代码可读性，但我想做点区分：代码可读性突出对代码阅读者视觉上的影响，是否存在不必要的理解干扰，比如：必要的空行、变量定义与使用之间的距离、函数体/逻辑分支是否过长、逻辑表达是否直观等等。可读性高的代码通常都非常漂亮、赏心悦目。自解释性代码则更突出语义层面，比如：变量名称/函数名称/类名是否恰当、函数/方法/API 是否单一职责、工程目录结构/包/模块拆分是否符合“高内聚低耦合”原则等等。长期追求这两点，可以极大地提升个人，特别是团队的工作效率和工作质量。&lt;/p&gt;
&lt;p&gt;本书作者 Kenneth Reitz 于 2011 年发布 Requests 这个 HTTP 请求工具库，提出“for humans”的理念，强调软件/工具库应该对人类友好易用，这一理念本质上是对 Python 哲学（特别是上述两点）的一种引申和发扬。之后 Reitz 在一些 Python大会上做技术分享，宣扬“for humans”理念，对 Python 社区产生巨大影响。我在第一次用过 Requests 库之后，便很少使用 Python 标准库中的 urllib 和 urllib2，现在标准库文档中也特别建议开发者使用 Requests。&lt;/p&gt;
&lt;p&gt;因为对“for humans”理念的认同，也因为经常使用 Requests，所以当 Reitz 在 Github 上邀请我翻译 Requests 文档中文版时，我欣然接受，和另一个 Python 开发者共同翻译了 Requests 文档的首个官方中文翻译版。这“另一个 Python 开发者”也就是本书的另一个译者。&lt;/p&gt;
&lt;p&gt;在 Reitz 发起 “The Hitchhiker's Guide to Python!” 项目（也就是本书的社区开源版）后，我一直持续跟进阅读，收获巨大。后来得知这本开源书籍正式出版，欣喜若狂，辗转咨询多人，联系到刘皎老师 ，申请了本书的翻译工作。&lt;/p&gt;
&lt;p&gt;但是，后来发现翻译的工作量远远超出预估，除了个人的一些主观原因，主要因为本书内容的广度和深度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度：本书由 Python 社区数百人共同创作而成，可以视作 Python 小百科全书。1-3章指导读者按照自己的需求选择安装配置 Python 版本/发行版、开发环境等。7-11章则针对不同的应用场景，从多个维度甄选对比了大量的 Python 库，读者可以“按图索骥”地做出自己的选择，从而节约大量的时间精力。因为译者的 Python 开发经验主要集中在 Web 开发和数据处理，对于很多应用场景下的 Python 库不太熟悉，所以翻译之前花费了大量时间来学习理解。&lt;/li&gt;
&lt;li&gt;深度：针对 Python 中手的核心需求，本书探讨了大量的最佳实践。其中4-5章通过大量示例具体地阐释了“Python 之禅”的句句箴言，如何编写高质量的 Python 代码，并精选若干高质量的知名 Python 开源项目，详细介绍如何通过阅读源码来提升编程技术水平。虽说 Python 社区几乎人人皆知“Python 之禅”，但如何落地到开发实践估计极少有人说得清楚。对照书中的实例阐释，译者几经调整推敲“Python 之禅”的译文，最终敲定的译文也不是特别令自己满意。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比原计划，本书最终延期近一年才得以翻译完成。除了歉意，我内心满是感谢：感谢邦杰中途友情加入，帮忙翻译了4-6章初稿，这三章的难度和长度都非常大；感谢编辑老师刘皎对我拖稿的次次容忍和耐心等待；感谢妻儿的理解，我对你们缺少了太多的陪伴。&lt;/p&gt;
&lt;p&gt;虽说我已尽自己所能地保证译文质量，但错误瑕疵难免，在此也请读者原谅。希望你们阅读愉快！&lt;/p&gt;
&lt;p&gt;至此，我如释重负。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;夏永锋&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;写于上海&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="书籍"></category></entry><entry><title>《精通Python设计模式》译者序</title><link href="http://youngsterxyf.github.io/2016/07/01/mpdp/" rel="alternate"></link><published>2016-07-01T00:00:00+08:00</published><updated>2016-07-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-07-01:/2016/07/01/mpdp/</id><summary type="html">&lt;p&gt;在我读大学那几年，设计模式可谓火极一时，各大公司校招面试也几乎都会考设计模式，反观现在，则似乎很少有人聊设计 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在我读大学那几年，设计模式可谓火极一时，各大公司校招面试也几乎都会考设计模式，反观现在，则似乎很少有人聊设计模式的话题。是因为设计模式过时了吗？还是只是一个错误的概念？从个人这几年的开发经验来看，答案是否定的，设计模式并未过时，更不是一个错误的概念。从曾经的“红极一时”到如今的“门可罗雀”，只是说明软件开发行业以更加客观理性的态度来看待设计模式。软件开发领域的技术概念也似乎总是遵循这样的流行度变迁，最终一次又一次地证明不存在“银弹”。&lt;/p&gt;
&lt;p&gt;正确看待设计模式的前提是明白什么是设计模式。正如本书一开始就强调的：“设计模式的本质是在已有的方案之上发现更好的方案（而不是全新发明）”，这是一种务实的态度，设计模式并非是一种高大上或者神秘的东西，而是一些常见的软件工程设计问题的最佳实践方案。&lt;/p&gt;
&lt;p&gt;那么应该如何学习设计模式？个人认为软件开发技术的学习都应该以实践为前提，只有理解实践过程中遇到的种种问题，才能明白那些技术的本质和目的是什么，每种新技术都是因某个/某些问题而出现的，软件开发高手一般都反对新手一开始就一股脑地学习设计模式。有些新手学了点设计模式的理论后，甚至在软件开发过程中生搬硬套，结果是适得其反。因此，软件开发人员应该在积累了一定的开发经验，再系统地学习设计模式，效果往往也能事半功倍。&lt;/p&gt;
&lt;p&gt;现在有些积累一定开发经验的软件开发人员，在谈起设计模式时，一脸鄙夷。我想这也不是一种客观务实的态度。软件开发不是简单的累积代码，在实现业务功能的同时应该仔细考虑如何控制软件的复杂度。软件的复杂度分为两个层面：业务逻辑复杂度和代码实现复杂度。对同一个业务系统，不同的软件开发人员会有不同的实现，复杂度也不同，相应地实现的易理解性、可维护性、可扩展性也不同。软件开发人员应该不断学习如何控制软件的复杂度，学习并恰当地使用设计模式是应对软件复杂度的有效方法。&lt;/p&gt;
&lt;p&gt;然而，设计模式并非是固定不变的（如，《设计模式-可复用面向对象软件的基础》一书总结的23种模式），使用不同的编程语言来编写代码，需要学习的设计模式也不一样。一方面因为软件开发领域迅猛发展，一些新的软件工程问题也随之出现，另一方面则是新的语言新的平台会把一些常见设计模式吸收为内置特性。所以，软件开发人员因以实际问题为驱动，不断更新设计模式方面的知识。&lt;/p&gt;
&lt;p&gt;本书以Python编程语言为例，针对目前的软件开发领域，分三大类讲解了16种常用设计模式。使用Python语言编写示例代码，我认为作者主要是考虑到Python的抽象层次高、应用范围广，读者不会被一些实现细节的干扰，从而能快速直接地掌握模式的要领。&lt;/p&gt;
&lt;p&gt;全书始终保持务实的态度，列举了大量现实生活的例子和软件开发的例子，并为每个模式提供完整可运行的示例代码。虽然看起来在书中完整地给出所有示例代码，似乎没什么必要，但个人认为作者的用意是希望读者能动手照示例代码写一遍并运行起来看结果，实践为王，加强学习的效果。&lt;/p&gt;
&lt;p&gt;虽然是示例，作者还是坚持以地道的Python风格编写代码，以此说明不同语言不同平台要求软件开发人员学习的设计模式也有所不同。另外，开发人员也能从示例代码中学习到一些Python语言的高级特性，所以把本书当做Python开发进阶书籍也无不可。&lt;/p&gt;
&lt;p&gt;本书是个人正式翻译的第一本书。虽然以前翻译过很多文章，有些译文还有点影响，但毕竟与正式出版的有些不同，所以接手本书的翻译工作，我内心是有些忐忑的。我把翻译过程分为以下几个阶段进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大致地预读一遍全书，整体上把握原书内容&lt;/li&gt;
&lt;li&gt;将原书翻译成初稿，此阶段基本保证译文的正确性&lt;/li&gt;
&lt;li&gt;通读审校初稿，此阶段确保译文的流畅性，以及用词和逻辑的一致性&lt;/li&gt;
&lt;li&gt;对着译稿，翻译相关图表中的单词；整理示例代码，并确保运行无误&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;希望通过这种方式基本保证译稿的质量。但因为个人精力有限能力不足，译稿中可能还是有些疏漏甚至错误之处，敬请原谅，也请将问题反馈给出版社，以便在下一版本中更正。&lt;/p&gt;
&lt;p&gt;另外，本书的示例代码已经存到Github的一个代码库（见&lt;a href="https://github.com/youngsterxyf/mpdp-code"&gt;https://github.com/youngsterxyf/mpdp-code&lt;/a&gt;）中，如有需要，可下载。&lt;/p&gt;
&lt;p&gt;因个人私事，本书推延了一段时间才得以翻译完成，感谢图灵朱巍老师的体谅。译书是件费时费力的事情，感谢妻子郑荣的体谅和支持，也感谢公司领导贾磊和同事的支持，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;夏永锋&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;于上海百度研发中心&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="书籍"></category></entry><entry><title>应用MySQL InnoDB全文索引</title><link href="http://youngsterxyf.github.io/2016/06/11/mysql-fulltext-application/" rel="alternate"></link><published>2016-06-11T00:00:00+08:00</published><updated>2016-06-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-06-11:/2016/06/11/mysql-fulltext-application/</id><summary type="html">&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;之前涉及的一项工作要求对某些数据做全文索引，并以API向其他内部系统提供搜索查询服务。&lt;/p&gt;
&lt;p&gt;由于需要建全文索引的数据量并不大，且已有的数据都以 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;之前涉及的一项工作要求对某些数据做全文索引，并以API向其他内部系统提供搜索查询服务。&lt;/p&gt;
&lt;p&gt;由于需要建全文索引的数据量并不大，且已有的数据都以InnoDB引擎存储，简单起见，我们选择MySQL InnoDB引擎的全文索引特性来实现。MySQL从版本5.6开始支持InnoDB引擎的全文索引，不过“从5.7.6版本开始才提供一种内建的全文索引ngram parser，支持CJK字符集（中文、日文、韩文，CJK有个共同点就是单词不像英语习惯那样根据空格进行分解的，因此传统的内建分词方式无法准确的对类似中文进行分词）”，我们使用的MySQL版本为5.6.28，并且需要建全文索引的数据部分是中文，所以这是个问题。&lt;/p&gt;
&lt;h2&gt;方案&lt;/h2&gt;
&lt;p&gt;我们先把这项工作按“分治”的思想拆分成几个小问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于版本5.6.28的MySQL不支持中文的全文索引，那么可以对需要建全文索引的数据进行预处理 - 分词，并以空格为间隔将分词结果拼接成一个字符串。&lt;/li&gt;
&lt;li&gt;但经过第1步仍是不够的 - MySQL的系统变量&lt;code&gt;ft_min_word_len&lt;/code&gt;、&lt;code&gt;ft_max_word_len&lt;/code&gt;分别规定了全文检索被编入索引单词的最小长度和最大长度，默认的最小值为4个字符，默认的最大值取决于使用的MySQL版本。为了不改变这个默认值同时也是兼考虑这个值对于英文的意义，则需要通过编码（&lt;code&gt;urlencode&lt;/code&gt;、&lt;code&gt;base64&lt;/code&gt;、&lt;code&gt;汉字转拼音&lt;/code&gt;等）将中文词变长。将经过编码后的分词结果存入建全文索引的数据表字段。&lt;/li&gt;
&lt;li&gt;API调用时，也对搜索关键词做1、2步处理，然后使用SQL的全文索引匹配语法进行查询。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第1步，我们选择公司内部的分词服务，当然也可以选择一些开源的分词方案，如：结巴中文分词、SCWS分词等。&lt;/p&gt;
&lt;p&gt;对于第2步，我们选择urlencode编码，并过滤掉编码后的&lt;code&gt;%&lt;/code&gt;，因为它也是分界符。&lt;/p&gt;
&lt;h2&gt;举个栗子&lt;/h2&gt;
&lt;p&gt;假设已有一个数据表&lt;code&gt;apps&lt;/code&gt;，其有个字段&lt;code&gt;name&lt;/code&gt;，需要对这个字段做基于全文索引的查询。&lt;/p&gt;
&lt;p&gt;为了不变更已有数据，我们对该数据表新增一个字段&lt;code&gt;seg_name&lt;/code&gt;，使用脚本批量地对&lt;code&gt;name&lt;/code&gt;字段进行分词编码，将结果存入该字段。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;ALTER&lt;/span&gt; &lt;span style="color: #0000ff"&gt;TABLE&lt;/span&gt; `apps` &lt;span style="color: #0000ff"&gt;ADD&lt;/span&gt; &lt;span style="color: #0000ff"&gt;COLUMN&lt;/span&gt; `seg_name` VARCHAR(1024) &lt;span style="color: #0000ff"&gt;DEFAULT&lt;/span&gt; &lt;span style="color: #0000ff"&gt;NULL&lt;/span&gt; &lt;span style="color: #0000ff"&gt;COMMENT&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;name字段分词编码后的结果&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;ALTER&lt;/span&gt; &lt;span style="color: #0000ff"&gt;TABLE&lt;/span&gt; `apps` &lt;span style="color: #0000ff"&gt;ADD&lt;/span&gt; FULLTEXT &lt;span style="color: #0000ff"&gt;INDEX&lt;/span&gt; (`seg_name`);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;API中对搜索关键词也进行分词并经编码，以下面的SQL来查询即可：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# &lt;span style="border: 1px solid #FF0000"&gt;其中&lt;/span&gt;%s用搜索关键词分词编码后的结果进行替换
&lt;span style="color: #0000ff"&gt;SELECT&lt;/span&gt; * &lt;span style="color: #0000ff"&gt;FROM&lt;/span&gt; `apps` &lt;span style="color: #0000ff"&gt;WHERE&lt;/span&gt; &lt;span style="color: #0000ff"&gt;MATCH&lt;/span&gt; (seg_name) AGAINST (&lt;span style="color: #a31515"&gt;&amp;#39;%s&amp;#39;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;IN&lt;/span&gt; &lt;span style="color: #0000ff"&gt;NATURAL&lt;/span&gt; &lt;span style="color: #0000ff"&gt;LANGUAGE&lt;/span&gt; &lt;span style="color: #0000ff"&gt;MODE&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到我们选择了“  自然语言模式（IN NATURAL LANGUAGE MODE），即通过MATCH AGAINST传递某个特定的字符串来进行检索”。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://mysql.taobao.org/monthly/2015/10/01/"&gt;MySQL · 引擎特性 · InnoDB 全文索引简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/martinzhang/p/3220345.html"&gt;MySQL中文全文检索demoSQL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="MySQL"></category><category term="笔记"></category></entry><entry><title>关于并发的一个小技巧</title><link href="http://youngsterxyf.github.io/2016/06/10/a-simple-concurrency-trick/" rel="alternate"></link><published>2016-06-10T00:00:00+08:00</published><updated>2016-06-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-06-10:/2016/06/10/a-simple-concurrency-trick/</id><summary type="html">&lt;p&gt;前段时间在参与实现一个新业务系统的Demo。该系统集成了多个已有系统的数据，涉及的数据量较大，但由于人力少，时间短 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前段时间在参与实现一个新业务系统的Demo。该系统集成了多个已有系统的数据，涉及的数据量较大，但由于人力少，时间短，没法专门做一个数据处理子系统，所以只能写了很多数据处理的脚本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="a-simple-concurrency-trick" src="https://i.loli.net/2020/06/14/9Q1r52Cq3ZTOXt6.png"&gt;&lt;/p&gt;
&lt;p&gt;为了复用一些代码，这些数据处理脚本和业务系统一样都是使用PHP实现。在某些数据上报API写入的数据较快较多时，脚本处理不过来（特别在脚本涉及一些网络请求时），只能搞起并发处理 - 在我们的情况下，最简单的并发方式就是多运行几个脚本实例。&lt;/p&gt;
&lt;p&gt;但一切没那么简单：脚本从数据库中取出未经处理的多行数据，逐行处理数据，并将处理后的数据更新到原来的数据行中，运行多个脚本实例时，为了避免更新冲突，只好加事务，但加事务后就会频繁发生事务回滚，数据处理速度还是上不去。&lt;/p&gt;
&lt;p&gt;那么该怎么办呢？&lt;/p&gt;
&lt;p&gt;参考哈希的思路，我对脚本做了一点调整，下面举例说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设对同一脚本运行&lt;code&gt;5&lt;/code&gt;个实例，为每个实例进程分配一个ID，依次为：0、1、2、3、4&lt;/li&gt;
&lt;li&gt;对脚本实例获取数据的SQL，增加选择条件：&lt;code&gt;MOD(id, 5)=SID&lt;/code&gt;（SID为当前脚本实例的ID） - 即使用数据行的&lt;code&gt;id&lt;/code&gt;对实例数取模，如果结果等于实例的ID，则取出来。这样多个实例之间不会取到相同的数据行，也就不会发生冲突回滚。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写个SHELL脚本来启动脚本的多个实例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;#!/usr/bin/env bash&lt;/span&gt;

pn=5
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; id &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; 0 1 2 3 4
&lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
/path/to/bin/php /path/to/script.php $pn $id &amp;gt; script-$id.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;嗯，这只是一个小技巧。&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="SQL"></category></entry><entry><title>关于API访问频率限制的一个问题</title><link href="http://youngsterxyf.github.io/2016/06/05/frequency-limitation/" rel="alternate"></link><published>2016-06-05T00:00:00+08:00</published><updated>2016-06-05T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-06-05:/2016/06/05/frequency-limitation/</id><summary type="html">&lt;p&gt;工作中涉及一些对外开放的无需特殊权限的API，用户会因为某些需求而通过程序来频繁访问这些API，导致系统的负载陡 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;工作中涉及一些对外开放的无需特殊权限的API，用户会因为某些需求而通过程序来频繁访问这些API，导致系统的负载陡增，可能影响系统其它功能的正常使用。虽然做了一些优化让这种API尽可能地轻量，但仍然不够，因此需要进行访问频率的限制。&lt;/p&gt;
&lt;p&gt;由于这样的API并不多，所以我们并没有在Nginx这样的反向代理接入层中实现频率限制，而是API自己去实现，而且实现方案比较粗糙 - 基于Memcached的缓存自动过期特性。&lt;/p&gt;
&lt;p&gt;方案的PHP示例实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// 每个IP一分钟10次
$limit = 10;

$cache = new Memcached();
$cache-&amp;gt;addServer(&amp;#39;127.0.0.1&amp;#39;, 11211);

$key = __FUNCTION__.$_SERVER[&amp;#39;REMOTE_ADDR&amp;#39;];
$requestNum = $cache-&amp;gt;get($key);

if ($requestNum !== FALSE &amp;amp;&amp;amp; $requestNum &amp;gt; 10) {
    echo json_encode(array(
        &amp;#39;code&amp;#39; =&amp;gt; 403,
        &amp;#39;message&amp;#39; =&amp;gt; &amp;#39;请求太频繁，请一分钟后再试&amp;#39;,
    ));
    return;
}

$cache-&amp;gt;add($key, 0, time()+60);
$cache-&amp;gt;increment($key, 1);

// ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很明显这种方案有不少问题 --- 高并发时限制不严格，或者服务器内存不足时访问次数值尚未过期就已被剔除。&lt;/p&gt;
&lt;p&gt;但本文想详述的是另一个问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;根据访问来源IP进行频率限制，如果API中取到的来源IP是错误的，那么就瞎限制了。&lt;/p&gt;
&lt;p&gt;先来看看一张架构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="api-request-limitation" src="https://i.loli.net/2020/06/14/KgHvYRDF7smy61h.png"&gt;&lt;/p&gt;
&lt;p&gt;一眼就能看出图中“服务器C”的特别之处。&lt;/p&gt;
&lt;p&gt;由于一些特殊的问题，我们把到服务器C的请求通过Nginx反向代理到另外两台服务器的Nginx进行处理。&lt;/p&gt;
&lt;p&gt;可能有人会疑惑：为什么不直接把服务器C从负载均衡中下线？&lt;/p&gt;
&lt;p&gt;原因是：考虑到跨网络运营商的问题，我们配置负载均衡器把来自不同运营商网络的请求转发到与请求来源的运营商相同的服务器。C与A、B不同属于一个网络运营商，比如C属于“北联通”，如果把C下线，就意味着北方联通的网络用户无法访问我们的服务。&lt;/p&gt;
&lt;p&gt;所以我们临时性地把到C的服务请求转发到A、B。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;那么问题来了 - 有用户反馈访问某个API时始终提示“请求太频繁，请一分钟后再试”，但自己并未频繁访问这个API。那么是用户撒谎还是系统的问题呢？&lt;/p&gt;
&lt;p&gt;经过仔细排查，最终确定问题就出在Nginx配置C的请求被转发到A、B。对于用户客户端来说，C是服务器，对于A、B来说，C则是客户端。如果不做特殊配置，从C转发到A、B的请求在处理时，A、B拿到的请求来源IP是C的IP，也就意味着到C的API访问请求，都被A、B基于C的IP进行访问频率限制。&lt;/p&gt;
&lt;p&gt;以Nginx为例，对于从C转发到A、B的请求，如果A、B要拿到请求的真实来源IP，则需要对A、B及C的Nginx做特殊配置。为解决这个问题，Nginx提供了一个额外的模块&lt;code&gt;ngx_http_realip_module&lt;/code&gt;，这个模块默认没有编译在Nginx中，需以额外参数&lt;code&gt;--with-http_realip_module&lt;/code&gt;进行编译。&lt;/p&gt;
&lt;p&gt;并对C的Nginx反向代理配置（location块）添加一行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 把请求来源放在X-Real-IP请求头中
proxy_set_header  X-Real-IP $remote_addr;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对A、B的Nginx（server块）添加以下配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 说明需要进行真实请求来源IP替换的请求来源，即C所属的IP段或者C的IP
set_real_ip_from 10.0.0.0/8;
# 说明从哪获取真实来源IP
real_ip_header X-Real-IP;
real_ip_recursive on;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;详细的说明见Nginx文档：http://nginx.org/en/docs/http/ngx_http_realip_module.html&lt;/p&gt;</content><category term="其他"></category><category term="Nginx"></category><category term="笔记"></category><category term="工作"></category></entry><entry><title>为什么我要送掉纸质书？</title><link href="http://youngsterxyf.github.io/2016/02/28/why-preseting-book/" rel="alternate"></link><published>2016-02-28T00:00:00+08:00</published><updated>2016-02-28T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-02-28:/2016/02/28/why-preseting-book/</id><summary type="html">&lt;p&gt;小时候，不知为何喜欢读书，而又没钱买，所以在家都是翻两个哥哥的课本 - 语文、历史、地理等，都翻个遍。更有甚者，竟然还从邻 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;小时候，不知为何喜欢读书，而又没钱买，所以在家都是翻两个哥哥的课本 - 语文、历史、地理等，都翻个遍。更有甚者，竟然还从邻居家偷偷地拿了本书回来，这应该算是我品行上的污点，这事在此说起，也是第一次。&lt;/p&gt;
&lt;p&gt;因为书少，所以至今还记得爸爸第一次送给我的书 - 《一个变两个》 - 连书里的情节都没忘过。&lt;/p&gt;
&lt;p&gt;读初中时，因为读书，还和好朋友闹过一点不愉快：朋友买了一些好书，我想借来看，他不肯，我就每天比大家早起一些，偷偷从他抽屉里拿来看几页，在他到教室之前再放回去，后来“事发”，。。。当然这一切都已过去，朋友还是朋友。&lt;/p&gt;
&lt;p&gt;高中后，开始有一些零花钱/饭钱，从其中挤出部分钱来买书成了我的一个习惯，书也由此越来越多。&lt;/p&gt;
&lt;p&gt;其实我根本看不了那么多书，最终累积了大量的书没认真读过。有时觉得可惜了，就会为读书而读书，精神为读书所累。&lt;/p&gt;
&lt;p&gt;这些年，几次搬家 - 从本科学校到研究生学校、读研期间换宿舍、毕业工作 - 每次最多最重的都是书，“书生搬家 - 尽是书！”。&lt;/p&gt;
&lt;p&gt;工作后租的房子没那么宽敞，导致到处塞的都是书。结婚后，东西更多，东西一多就容易乱，需要经常整理，生活又有些为书所累。&lt;/p&gt;
&lt;p&gt;毕业后，我一直想从一个学生“学”的状态转变为“做”的状态 - 解决问题、创造价值，才是一个人在社会上的价值体现。计算机专业工作强“实践”的特点，也让我把书看得淡了些。&lt;/p&gt;
&lt;p&gt;工作结婚后，自己的时间更加零碎，要想利用零碎时间阅读，就要求书更“便携”，随时可用，这一点纸质书是很难满足的，慢慢地更多的是阅读电子书，买了kindle，手机里也装了阅读软件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="kindle" src="https://i.loli.net/2020/06/14/4YgU8AeIWBaQyfu.png"&gt;&lt;/p&gt;
&lt;p&gt;在现在看来，从小对于书籍的渴求，之后形成藏书的习惯，说得不好听是一种“病”，得治，说得好听点，是一种“情怀”，得适当保留。&lt;/p&gt;
&lt;p&gt;我们在买书时一般都有各种想法、各种计划，但这些想法计划有很多都会搁浅（当然有些人执行力强，买一本看一本）。人生不能缺少计划，但计划不是人生，所以过日子就像写代码一样，需要适时地进行重构，去除那些当下或可见未来不需要的东西，让你所持有的更适合你的生活，而不被你无用的拥有所累。&lt;/p&gt;
&lt;p&gt;所以，我第一次有了清理纸质书的想法，但买的每本书都包含着一段记忆、一个想法、一个我，因此不愿意把这些书当废纸卖掉。虽然我预计可见的未来不会阅读它们，但它们自有其价值，也许在其他人那能实现其价值，所以低价卖掉/送掉/捐掉是一个好的选择。&lt;/p&gt;
&lt;p&gt;稳妥起见，我现在只对计算机专业书籍下手。原因其一家里只有我是程序员，如果我不读，那么就没有其他人会去读这些计算机专业书籍；其二编程是个实践的活，工作一定时间之后，多数专业书籍的价值没那么大；其三工作之后发现一个人的精力是有限的，要想积累快出成果，最好尽可能聚焦自己的精力在一两个点上；其四需要为自己多留一些思考的时间，而不是一味地学习；。。。。。。&lt;/p&gt;
&lt;p&gt;&lt;img alt="book-list" src="https://i.loli.net/2020/06/14/8Y97s42XBzVuZMj.jpg"&gt;&lt;/p&gt;
&lt;p&gt;当我告诉大家准备清理掉部分专业书籍时，部分朋友比较惊讶，出于关心或搞笑，就原因给出了自己的猜测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你是要挪窝换房子了吗？&lt;/li&gt;
&lt;li&gt;没钱过日子了吗？养娃不容易啊&lt;/li&gt;
&lt;li&gt;你这是要转行了吗？不再写代码了吗？&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，有了这篇文章，解释一下，也谈谈我的一点思考。&lt;/p&gt;
&lt;p&gt;清理出来的书籍，出手得都比较快，虽然部分书籍标价出售，但最终绝大多数都是赠送的。卖书的本意不在于钱，而在于书的去处。&lt;/p&gt;
&lt;p&gt;谢谢朋友们的支持！&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="生活"></category><category term="感悟"></category></entry><entry><title>如何杀死defunct进程（译）</title><link href="http://youngsterxyf.github.io/2016/02/18/kill-defunct/" rel="alternate"></link><published>2016-02-18T00:00:00+08:00</published><updated>2016-02-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-02-18:/2016/02/18/kill-defunct/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://kenno.wordpress.com/2007/04/04/how-to-kill-defunct-process/"&gt;How to kill defunct process&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;defunct进程是指出错损坏的进程，父子进程之间不会再通信。有时，它们会演变成“僵尸进程”，存留在你的系统中，直到系统重启。可以 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://kenno.wordpress.com/2007/04/04/how-to-kill-defunct-process/"&gt;How to kill defunct process&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;defunct进程是指出错损坏的进程，父子进程之间不会再通信。有时，它们会演变成“僵尸进程”，存留在你的系统中，直到系统重启。可以尝试 “kill -9” 命令来清除，但多数时候不管用。&lt;/p&gt;
&lt;p&gt;为了杀死这些defunct进程，你有两个选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重启你的计算机&lt;/li&gt;
&lt;li&gt;继续往下读...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先看看系统中是否存在defunct进程：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps -A | grep defunct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;假设得到的输出如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;8328 &lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt; 00:00:00 mono &amp;lt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt;unct&amp;gt;
8522 &lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt; 00:00:01 mono &amp;lt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt;unct&amp;gt;
13132 &lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt; 00:00:00 mono &amp;lt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt;unct&amp;gt;
25822 &lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt; 00:00:00 ruby &amp;lt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt;unct&amp;gt;
28383 &lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt; 00:00:00 ruby &amp;lt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt;unct&amp;gt;
18803 &lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt; 00:00:00 ruby &amp;lt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt;unct&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这意味着存在6个defunct进程：3个mono进程，以及3个ruby进程。这些进程之所以存在，可能是因为应用程序写得很烂或者用户做了不常见的操作，在我这，一定是我写的mono C#程序存在严重问题 :smile: 。&lt;/p&gt;
&lt;p&gt;现在，我们来看看这些进程的ID及其父进程ID：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ps -ef | grep defunct | more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上命令的输出如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;UID PID PPID ...
---------------------------------------------------------------

kenno 8328 6757 0 Mar22 ? 00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00 [mono] &amp;lt;defunct&amp;gt;
kenno 8522 6757 0 Mar22 ? 00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;01 [mono] &amp;lt;defunct&amp;gt;
kenno 13132 6757 0 Mar23 ? 00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00 [mono] &amp;lt;defunct&amp;gt;
kenno 25822 25808 0 Mar27 ? 00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00 [ruby] &amp;lt;defunct&amp;gt;
kenno 28383 28366 0 Mar27 ? 00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00 [ruby] &amp;lt;defunct&amp;gt;
kenno 18803 18320 0 Apr02 ? 00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;00 [ruby] &amp;lt;defunct&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;UID：用户ID&lt;/li&gt;
&lt;li&gt;PID：进程ID&lt;/li&gt;
&lt;li&gt;PPID：父进程ID&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你使用命令 “kill -9 8328” 尝试杀死ID为8328的进程，可能会没效果。要想成功杀死该进程，需要对其父进程（ID为6757）执行kill命令（&lt;code&gt;$ kill -9 6757&lt;/code&gt;）。对所有这些进程的父进程ID应用kill命令，并验证结果（&lt;strong&gt;$ ps -A | grep defunct&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;如果前一个命令显示无结果，那么搞定！否则，可能你需要重启一下系统。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://wagoneers.com/UNIX/KILL/Kill.html"&gt;http://wagoneers.com/UNIX/KILL/Kill.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cts.wustl.edu/~allen/kill-defunct-process.html"&gt;http://www.cts.wustl.edu/~allen/kill-defunct-process.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;译注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行命令 &lt;code&gt;ps aux | grep defunct&lt;/code&gt;，如果进程为defunct，则其第8列为 &lt;code&gt;Z&lt;/code&gt; 。如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13391  0.1  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;23 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13393  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;15 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13394  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;15 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13395  0.1  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;28 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13396  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;15 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13397  0.1  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;23 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13398  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;15 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13399  0.1  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;22 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13400  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;15 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13401  0.1  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;22 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13402  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;16 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13403  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;14 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13404  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;15 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13405  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;15 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13406  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;16 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13407  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;02 [python] &amp;lt;defunct&amp;gt;
&lt;span style="color: #0000ff"&gt;work&lt;/span&gt;     13408  0.0  0.0      0     0 pts/0    Z    10&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;50   0&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;14 [python] &amp;lt;defunct&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Linux"></category></entry><entry><title>Base64编码原理与应用</title><link href="http://youngsterxyf.github.io/2016/01/24/base64-encoding/" rel="alternate"></link><published>2016-01-24T00:00:00+08:00</published><updated>2016-01-24T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-01-24:/2016/01/24/base64-encoding/</id><summary type="html">&lt;p&gt;2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用&lt;code&gt;Base64 URL&lt;/code&gt;对这些数据进行编 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用&lt;code&gt;Base64 URL&lt;/code&gt;对这些数据进行编码，其提供的编码解码算法示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// php版本
function base64_URL_encode($data) {
  return rtrim(strtr(base64_encode($data), &amp;#39;+/&amp;#39;, &amp;#39;-_&amp;#39;), &amp;#39;=&amp;#39;);
}
function base64_URL_decode($data) {
  return base64_decode(str_pad(strtr($data, &amp;#39;-_&amp;#39;, &amp;#39;+/&amp;#39;), 
                            strlen($data) % 4, &amp;#39;=&amp;#39;, STR_PAD_RIGHT));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看出，&lt;code&gt;Base64 URL&lt;/code&gt; 是标准Base64编码的一个变种，分别用 &lt;code&gt;-&lt;/code&gt;、&lt;code&gt;_&lt;/code&gt; 替换标准Base64编码结果中的 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; ，并删除结果最后的 &lt;code&gt;=&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在实现 “百度云观测” 青云应用时，我在想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要使用Base64编码？&lt;/li&gt;
&lt;li&gt;Base64编码算法是什么样的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是围绕这两个问题思考和实践的结果。&lt;/p&gt;
&lt;p&gt;我认为，理解Base64或其他类似编码的关键有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机最终存储和执行的是01二进制序列，这个二进制序列的含义则由解码程序/解释程序决定&lt;/li&gt;
&lt;li&gt;很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须是ASCII编码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以青云应用为例，简单解释这两点。青云平台通过POST一个表单来获取iframe，表单有 &lt;code&gt;payload&lt;/code&gt; 和 &lt;code&gt;signature&lt;/code&gt; 两项， &lt;code&gt;payload&lt;/code&gt; 原本是一个JSON对象，其中的键值可能包含一些特殊字符，比如 &lt;code&gt;&amp;amp;&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt; 等，由于青云设计的一种通用的请求交互方案，需要考虑iframe服务方服务器端的各种可能实现，有些服务器端实现没有考虑表单值有这些特殊字符，或者POST请求被中间服务器转换成GET请求再次发出，对于URL来说，&lt;code&gt;&amp;amp;&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;都是具有特殊含义的字符，所以需要对请求数据进行特殊编码避免这些字符出现 - 数据发送方对数据按规则进行编码，接收方对应地按规则解码数据。&lt;/p&gt;
&lt;h2&gt;Base64编码原理&lt;/h2&gt;
&lt;p&gt;Base64编码之所以称为Base64，是因为其使用64个字符来对任意数据进行编码，同理有Base32、Base16编码。标准Base64编码使用的64个字符为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/XHFMRvxfez4OVtr.jpg"&gt;&lt;/p&gt;
&lt;p&gt;这64个字符是各种字符编码（比如ASCII编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64编码又有很多变种，比如Base64 URL编码。&lt;/p&gt;
&lt;p&gt;Base64编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续6比特（2的6次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。&lt;/p&gt;
&lt;p&gt;假设我们要对 &lt;code&gt;Hello!&lt;/code&gt; 进行Base64编码，按照ASCII表，其转换过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/tJnClQsjc4WMGhB.jpg"&gt;&lt;/p&gt;
&lt;p&gt;可知 &lt;code&gt;Hello!&lt;/code&gt; 的Base64编码结果为 &lt;code&gt;SGVsbG8h&lt;/code&gt; ，原始字符串长度为6个字符，编码后长度为8个字符，每3个原始字符经Base64编码成4个字符，编码前后长度比4/3，这个长度比很重要 - 比原始字符串长度短，则需要使用更大的编码字符集，这并不我们想要的；长度比越大，则需要传输越多的字符，传输时间越长。Base64应用广泛的原因是在字符集大小与长度比之间取得一个较好的平衡，适用于各种场景。&lt;/p&gt;
&lt;p&gt;是不是觉得Base64编码原理很简单？&lt;/p&gt;
&lt;p&gt;但这里需要注意一个点：Base64编码是每3个原始字符编码成4个字符，如果原始字符串长度不能被3整除，那怎么办？使用0值来补充原始字符串。&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;Hello!!&lt;/code&gt; 为例，其转换过程为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/5URB8nVis9ljwYe.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：图表中蓝色背景的二进制0值是额外补充的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hello!!&lt;/code&gt; Base64编码的结果为 &lt;code&gt;SGVsbG8hIQAA&lt;/code&gt; 。最后2个零值只是为了Base64编码而补充的，在原始字符中并没有对应的字符，那么Base64编码结果中的最后两个字符 &lt;code&gt;AA&lt;/code&gt; 实际不带有效信息，所以需要特殊处理，以免解码错误。&lt;/p&gt;
&lt;p&gt;标准Base64编码通常用 &lt;code&gt;=&lt;/code&gt; 字符来替换最后的 &lt;code&gt;A&lt;/code&gt;，即编码结果为 &lt;code&gt;SGVsbG8hIQ==&lt;/code&gt;。因为 &lt;code&gt;=&lt;/code&gt; 字符并不在Base64编码索引表中，其意义在于结束符号，在Base64解码时遇到 &lt;code&gt;=&lt;/code&gt; 时即可知道一个Base64编码字符串结束。&lt;/p&gt;
&lt;p&gt;如果Base64编码字符串不会相互拼接再传输，那么最后的 &lt;code&gt;=&lt;/code&gt; 也可以省略，解码时如果发现Base64编码字符串长度不能被4整除，则先补充 &lt;code&gt;=&lt;/code&gt; 字符，再解码即可。&lt;/p&gt;
&lt;p&gt;解码是对编码的逆向操作，但注意一点：&lt;strong&gt;对于最后的两个 &lt;code&gt;=&lt;/code&gt; 字符，转换成两个 &lt;code&gt;A&lt;/code&gt; 字符，再转成对应的两个6比特二进制0值，接着转成原始字符之前，需要将最后的两个6比特二进制0值丢弃，因为它们实际上不携带有效信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了理解Base64编码解码过程，个人实现了一个非常简陋的Base64编码解码程序，见：&lt;a href="https://github.com/youngsterxyf/xiaBase64"&gt;youngsterxyf/xiaBase64&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于Base64应用广泛，所以很多编程语言的标准库都内置Base64编码解码包，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP：&lt;a href="http://php.net/manual/en/function.base64-encode.php"&gt;base64_encode&lt;/a&gt;、&lt;a href="http://php.net/manual/en/function.base64-decode.php"&gt;base64_decode&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Python：&lt;a href="https://docs.python.org/2/library/base64.html"&gt;base64包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go：&lt;a href="https://golang.org/pkg/encoding/base64/"&gt;encoding/base64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Base64编码应用&lt;/h2&gt;
&lt;p&gt;本文开始提到的青云应用例子只是Base64编码的应用场景之一。由于Base64编码在字符集大小与编码后数据长度之间做了较好的平衡，以及Base64编码变种形式的多样，使得Base64编码的应用场景非常广泛。下面举2个常用常见的例子。&lt;/p&gt;
&lt;h3&gt;HTML内嵌Base64编码图片&lt;/h3&gt;
&lt;p&gt;前端在实现页面时，对于一些简单图片，通常会选择将图片内容直接内嵌在页面中，避免不必要的外部资源加载，增大页面加载时间，但是图片数据是二进制数据，该怎么嵌入呢？&lt;a href="http://caniuse.com/#search=Data%20URI"&gt;绝大多数现代浏览器&lt;/a&gt;都支持一种名为 &lt;code&gt;Data URLs&lt;/code&gt; 的特性，允许使用Base64对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。以百度搜索首页为例，其中语音搜索的图标是个背景图片，其内容以 &lt;code&gt;Data URLs&lt;/code&gt; 形式直接写在css中，这个css内容又直接嵌在HTML页面中，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/oa6rsPSwgMzv87l.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data URLs&lt;/code&gt; 格式为：&lt;code&gt;url(data:文件类型;编码方式,编码后的文件内容)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然，也可以直接基于image标签嵌入图片，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;img alt=&lt;span style="color: #a31515"&gt;&amp;quot;Embedded Image&amp;quot;&lt;/span&gt; src=&lt;span style="color: #a31515"&gt;&amp;quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIA...&amp;quot;&lt;/span&gt; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但请注意：如果图片较大，图片的色彩层次比较丰富，则不适合使用这种方式，因为其Base64编码后的字符串非常大，会明显增大HTML页面，影响加载速度。&lt;/p&gt;
&lt;h3&gt;MIME（多用途互联网邮件扩展）&lt;/h3&gt;
&lt;p&gt;我们的电子邮件系统，一般是使用SMTP（简单邮件传输协议）将邮件从客户端发往服务器端，邮件客户端使用POP3（邮局协议，第3版本）或IMAP（交互邮件访问协议）从服务器端获取邮件。&lt;/p&gt;
&lt;p&gt;SMTP协议一开始是基于纯ASCII文本的，对于二进制文件（比如邮件附件中的图像、声音等）的处理并不好，所以后来新增MIME标准来编码二进制文件，使其能够通过SMTP协议传输。&lt;/p&gt;
&lt;p&gt;举例来说，我给自己发封邮件，正文为空，带一个名为hello.txt的附件，内容为 &lt;code&gt;您好！世界！&lt;/code&gt;。导出邮件源码，其关键部分如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/c8wIeoij9HWt4Ph.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MIME-Version: 1.0&lt;/code&gt;：表示当前使用MIME标准1.0版本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Content-Type: text/plain; name="hello.txt"&lt;/code&gt;：表示附件文件名为 &lt;code&gt;hello.txt&lt;/code&gt; ，格式为纯文本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Content-Transfer-Encoding: base64&lt;/code&gt;：表示附件文件内容使用base64编码后传输。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5oKo5aW977yM5LiW55WM77yB&lt;/code&gt;：则是文件内容 &lt;code&gt;您好，世界！&lt;/code&gt; Base64编码后的结果。&lt;/p&gt;
&lt;p&gt;不过，MIME使用的不是标准Base64编码。&lt;/p&gt;
&lt;h2&gt;切忌误用&lt;/h2&gt;
&lt;p&gt;可能会有人在不理解Base64编码的情况下，将其误用于数据加密或数据校验。&lt;/p&gt;
&lt;p&gt;Base64是一种数据编码方式，目的是让数据符合传输协议的要求。标准Base64编码解码无需额外信息即完全可逆，即使你自己自定义字符集设计一种类Base64的编码方式用于数据加密，在多数场景下也较容易破解。&lt;/p&gt;
&lt;p&gt;对于数据加密应该使用专门的&lt;strong&gt;目前还没有有效方式快速破解的&lt;/strong&gt;加密算法。比如：对称加密算法&lt;code&gt;AES-128-CBC&lt;/code&gt;，对称加密需要密钥，只要密钥没有泄露，通常难以破解；也可以使用非对称加密算法，如 &lt;code&gt;RSA&lt;/code&gt;，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。&lt;/p&gt;
&lt;p&gt;对于数据校验，也应该使用专门的消息认证码生成算法，如 &lt;code&gt;HMAC&lt;/code&gt; - 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。&lt;/p&gt;
&lt;p&gt;那么针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？&lt;/p&gt;
&lt;p&gt;答案是：在注册时，根据用户设置的登录密码，生成其消息认证码，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。&lt;/p&gt;
&lt;p&gt;当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在HMAC算法中使用SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。&lt;/p&gt;
&lt;p&gt;另外，也可以使用加入随机salt的哈希算法来存储校验用户密码。这里暂不细述。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Base64兼顾字符集大小和编码后数据长度，并且可以灵活替换字符集的最后两个字符，以应对多样的需求，使其适用场景非常广泛。&lt;/p&gt;
&lt;p&gt;当然，很多场景下有多种编码方式可选择，并非Base64编码不可，视需求，权衡利弊而定。&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="编码"></category></entry><entry><title>基于Github的pull request流程做开源贡献</title><link href="http://youngsterxyf.github.io/2016/01/18/github-fork-pull-request/" rel="alternate"></link><published>2016-01-18T00:00:00+08:00</published><updated>2016-01-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2016-01-18:/2016/01/18/github-fork-pull-request/</id><summary type="html">&lt;p&gt;最近给 &lt;a href="https://github.com/astaxie/beego"&gt;beego&lt;/a&gt; 提了几个 pull request （简称PR），都已被接受。在使用pull request的过程中，遇到了一点小问题，才知以前并非真的理解这个流程，故在此做点 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近给 &lt;a href="https://github.com/astaxie/beego"&gt;beego&lt;/a&gt; 提了几个 pull request （简称PR），都已被接受。在使用pull request的过程中，遇到了一点小问题，才知以前并非真的理解这个流程，故在此做点记录整理。&lt;/p&gt;
&lt;p&gt;我以 &lt;a href="https://github.com/astaxie/beego"&gt;beego&lt;/a&gt; 为例，将pull request的整体使用流程绘图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fork-pull-request" src="https://i.loli.net/2020/06/14/yFkLXVAHKxmwjq9.jpg"&gt;&lt;/p&gt;
&lt;p&gt;beego代码库有两个长期分支 &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;develop&lt;/code&gt;，&lt;code&gt;master&lt;/code&gt;为稳定分支，&lt;code&gt;develop&lt;/code&gt;为开发分支，所有PR都要求提交到 &lt;code&gt;develop&lt;/code&gt; 分支。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先将 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 代码库 fork 一份到自己的名下（如我的 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;把 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; clone 到本地机器上做开发。因为PR要提到 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 的 develop 分支，所以最好对应地在你fork的代码库的 develop 分支做开发。在本地开发测试完成后，将commit push到 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; 。&lt;/li&gt;
&lt;li&gt;在 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; 页面点击 “New pull request”，会跳转到 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 创建一个新的PR，在页面中需要选择&lt;code&gt;base fork&lt;/code&gt;的目标分支（这里为 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 的 develop 分支）和&lt;code&gt;head fork&lt;/code&gt;的目标分支（这里为 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; 的 develop 分支）。PR提交后，等待 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 代码库的协作者来review我的PR。&lt;/li&gt;
&lt;li&gt;如果其他人也给 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 提了PR（或者直接在 develop 上做了变更），我会把 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; 的 develop 分支同步到最新状态，便于我进行新的开发，同步的流程为：&lt;ol&gt;
&lt;li&gt;在本地代码库添加一个新的remote，名为 &lt;code&gt;beego&lt;/code&gt; ： &lt;code&gt;git remote add beego https://github.com/astaxie/beego.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;develop&lt;/code&gt; 分支上执行 &lt;code&gt;git pull beego develop&lt;/code&gt;，这会获取 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; develop 分支最新的状态，并 merge 到本地代码库的 develop 分支&lt;/li&gt;
&lt;li&gt;将本地代码库的 develop 分支 push 到 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; ：&lt;code&gt;git push origin develop&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在发布新的版本时, &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 的 &lt;code&gt;develop&lt;/code&gt; 分支会先 merge 到其 master 分支，然后打上新的 tag 。这时我也会把 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; 的 master 分支同步到最新状态，流程与 develop 分支相同。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;在第3步中，如果发现&lt;code&gt;base fork&lt;/code&gt;的目标分支和&lt;code&gt;head fork&lt;/code&gt;的目标分支之间有代码冲突，则需要先在本地代码库对应的分支上解决这个冲突，然后 push 到 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; ，再提PR。&lt;/p&gt;</content><category term="其他"></category><category term="github"></category><category term="笔记"></category><category term="git"></category><category term="开源"></category></entry><entry><title>关于Redis与Memcached的一点澄清（译）</title><link href="http://youngsterxyf.github.io/2015/12/01/redis-vs-memcached/" rel="alternate"></link><published>2015-12-01T00:00:00+08:00</published><updated>2015-12-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-12-01:/2015/12/01/redis-vs-memcached/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://antirez.com/news/94"&gt;Clarifications about Redis and Memcached&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;译注：本文为Redis的作者所写&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你了解我，就会知道我并不是那种认为竞品是一件坏事的人。实际上我喜欢用 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://antirez.com/news/94"&gt;Clarifications about Redis and Memcached&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;译注：本文为Redis的作者所写&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你了解我，就会知道我并不是那种认为竞品是一件坏事的人。实际上我喜欢用户有选择的空间，因此我很少做将Redis与其他技术做对比这类事情。&lt;/p&gt;
&lt;p&gt;然而，为了选择正确的方案，用户必须获取正确的知识，这一点也是理所应当的。&lt;/p&gt;
&lt;p&gt;本文的起因是读了Mike Perham写的一篇博文，你也许知道他是Sidekiq这一流行程序库的作者，Sidekiq又恰好使用Redis做后端。因此我毫不认为Mike是一个“反对”Redis的人。但在博文（你可以在 &lt;a href="http://www.mikeperham.com/2015/09/24/storing-data-with-redis/"&gt;http://www.mikeperham.com/2015/09/24/storing-data-with-redis/&lt;/a&gt; 找到这篇博文）中，他陈述到：要用缓存，“你可能应该选择Memcached（而不是Redis）”。这样看来，Mike确实简单地相信Redis不适合用做缓存，在文章中他是这样论述的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1) Memcached专为缓存而设计&lt;/li&gt;
&lt;li&gt;2) 它根本不会有磁盘I/O操作&lt;/li&gt;
&lt;li&gt;3) 它是多线程的，在多核上能线性扩展到每秒处理100,000个请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我会一一辩驳以上陈述，之后会提供进一步的信息，这些信息在上面的句子中并没有得到表达，但在我看来与缓存用户及用例更加相关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memcached专为缓存而设计&lt;/strong&gt;：我会跳过这个，因为这并不是一个论点。我同样可以说“Redis专为缓存而设计”。因此，就这一点而言，它们是一样的，我们接着来看下一个论点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它根本不会有磁盘I/O操作&lt;/strong&gt;：使用Redis时，你可以按需求禁用磁盘I/O，所有操作就是纯内存的了。此外，若你确实需要，可以只在重启Redis之时持久化数据库，例如：使用“SHUTDOWN SAVE”命令。再怎么说，即使你根本不使用Redis持久化功能，它也是一个附加值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它是多线程的&lt;/strong&gt;：确实如此。我的目标是把Redis的I/O线程化（像Memcached那样，从根本上说数据访问本身不是线程化的）。然而，Redis，特别是使用流水线（pipeling）模式后，每个线程每秒能处理超大量的请求（使用密集的流水线，通常能达到每秒50万左右；不使用流水线，也能达到每秒10万左右）。在普通的缓存场景中 - 每个Redis实例是一样的、角色为主、禁用磁盘操作、分区由客户端决定（像“Memcached分区模型”那样） - 每个系统上运行多个Redis进程并不可怕。一旦你这样做，得到的就是一套无共享多线程的设置，那么关键看的是单个线程能够处理的操作量了。上一次我检验Redis时，每个线程至少是和Memached一样快的。内部实现随着时间在改变，因此如今最新版可能有所出入，但我敢打赌两者的性能是相近的，因为它们都竭尽所能利用了能够使用的资源。Memcached的多线程仍然是个优势，因为它让一切更易于使用和管理，但我认为这不是关键性的部分。&lt;/p&gt;
&lt;p&gt;再说一点。Mike在谈及每秒执行的操作时，并未说明操作的 *质量*。在Redis与Memached这类系统中，相比真正地获取内存数据结构中的数据，命令分发和I/O的代价是主要的。因此本质上在Redis中执行一个简单的GET、SET或一个复杂操作如ZRANK操作，其代价基本是相同的。但是从应用层的角度来看，通过复杂操作能节省很多工作。也许无需分5次获取缓存数据，你只要发送一个简短的Lua脚本就能搞定。因此这两个系统实际的“可扩展性”有许多维度，你能得到是其中之一。&lt;/p&gt;
&lt;p&gt;Mike关注的几点问题，我认为唯一有根据的是多线程那个，如果我们将特殊用例下的Redis看做是Memcached的替代品，执行多个Redis进程也能反驳“Memcached多线程更好”这个观点，或者简单地执行一个Redis进程也行，因为做Memcached那样的操作要想打满一个线程是非常非常难的。&lt;/p&gt;
&lt;h2&gt;真正的区别&lt;/h2&gt;
&lt;p&gt;现在是时候谈论两个系统之间的真正区别了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一点Memcached曾比Redis做得好。在一个被设计为用字典化字符串存储普通字符串的系统中，更好地利用内存相对会更简单。这一区别并不显著，而且大约有5年我没去检验这一点了，但曾经是值得注意的。&lt;/p&gt;
&lt;p&gt;然而，如果我们考虑一个长期运行的进程的内存效率，事情就有些不同了。具体细节请读下一节。&lt;/p&gt;
&lt;p&gt;但是在真正评估内存效率时，你应该记得考虑：Redis中特殊编码的小型聚合值内存效率非常高。例如：小整数集合在内存存储为一个8、16、32或64位整数的数组，当需要检查某些整数是否存在时，对数级时间就能访问到，因为这个数组是有序的，因为可以使用二分查找。&lt;/p&gt;
&lt;p&gt;当你使用哈希来存储对象而不是借助JSON时，同样如此。因此，真正的内存效率必须基于手头的应用案例来评估。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis LRU vs Slab内存分配器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从内存利用的角度来看，Memcached并不完美。如果你恰好有个应用随着时间会改变缓存数据的尺寸大小，很可能会导致严重的内存碎片问题，而唯一的解决方法就是重启应用。从这一视角来看，Redis对内存的利用不会变化莫测。&lt;/p&gt;
&lt;p&gt;此外，Redis的LRU最近优化了很多，现在非常接近真正的LRU。进一步的信息可阅读：&lt;a href="http://redis.io/topics/lru-cache"&gt;http://redis.io/topics/lru-cache&lt;/a&gt;。如果我没理解错的话，Memcached的LRU依旧是根据它的slab分配器来判断数据过期的，因此有时其行为与真正的LRU相差甚远，但我希望这方面的专家能够针对这个问题说点什么。如果你想测试Redis的LRU，在最近几个版本的Redis中可以使用redis-cli的LRU测试模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;智能缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想把Redis用作缓存，并且像Memcached那样使用，那你就真的要错失一些东西了。在我看来，这是Mike那篇博文中的最大错误。越来越多的人从Memcached切换到Redis，是因为他们发现可以以更有用的方式来表现缓存数据。如何保持只缓存某个东西的最新N项数据？使用“脱帽”列表（原文为：capped list）。想获取一个缓存的流行指数？使用一个有序集合，等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持久化和复制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若你需要，那它们就是重要的优势。例如：使用这一模型扩展高负载的缓存读操作就非常简单；基于持久化 - 按期快照缓存数据 - 重启服务而不丢缓存数据也很简单；诸如此类等等。但是对有些用法来说，这两个特性确实无关紧要。这里我想表达的是存在一些“纯缓存”的应用案例，其中持久化和复制也很重要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可观测性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis提供了很多方式以便于观测Redis运行时的行为状态。它提供大量内部度量的详细报告，你可以扫描数据集，观察对象的有效期。可以调优LRU算法。可以为客户端连接命名并使用&lt;code&gt;CLIENT LIST&lt;/code&gt;来查看关于它们的报告。可以使用&lt;code&gt;MONITOR&lt;/code&gt;命令来调试你的应用，以及其他高级事项。我相信这是一大优势。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lua脚本编程能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我相信在很多缓存应用案例中，Lua脚本编程能力都是一大助力。例如：如果你有一个JSON缓存数据块，使用一个Lua命令可以抽取其中某个字段并将其返回给客户端，而不需要传输所有东西（从概念上来说，直接使用Redis哈希来表现对象，也可以做到）。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;Memcached是一个伟大的软件，我多次阅读其源码，对于我们产业来说，它是一个革命，你应该自己查明对你来说，相比Redis，Memcached是否是更好的选择。然而，一切事物都必须如实评估。读到Mike的报告或这些年来读到的类似报告都让我有些恼怒了，所以我决定亮一亮自己的观点。如果你发现有些事情事实上我说得不对，请联系我，我会以“校订”一节来更新这篇博文。&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Redis"></category><category term="Memcached"></category></entry><entry><title>青云 iframe 应用开发</title><link href="http://youngsterxyf.github.io/2015/11/20/qingcloud-iframe-app/" rel="alternate"></link><published>2015-11-20T00:00:00+08:00</published><updated>2015-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-11-20:/2015/11/20/qingcloud-iframe-app/</id><summary type="html">&lt;p&gt;上周的主要工作是将产品的功能集成到青云。青云提供 iframe 的方式来集成第三方服务，这是一种互利的做法，而且对于青云 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上周的主要工作是将产品的功能集成到青云。青云提供 iframe 的方式来集成第三方服务，这是一种互利的做法，而且对于青云来说，实现的代价也非常小。&lt;/p&gt;
&lt;p&gt;先上图，看看集成的效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ygc-in-qingcloud" src="https://i.loli.net/2020/06/14/qA1UVlSXrx2iJHo.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于青云来说，一个iframe应用就是一个URL，由应用开发者提供这个URL，当青云用户访问应用所在的页面时，页面先自动向应用服务器的URL发送数据请求，请求会携带认证信息，应用服务端需要先校验请求确实来自青云，并获取请求中的用户信息，最终响应一个HTML页面内容，青云应用页面收到响应数据后将其置于一个iframe标签中，之后青云用户在iframe页面中的操作都是直接与应用服务器交互。&lt;/p&gt;
&lt;p&gt;&lt;img alt="qingcloud-iframe-interaction" src="https://i.loli.net/2020/06/14/r4AVfQZnlw3YH1C.png"&gt;&lt;/p&gt;
&lt;p&gt;上图交互流程的第&lt;strong&gt;2&lt;/strong&gt;步中，青云服务器向用户响应的内容最终会生成一个包含以下内容的页面：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;form method=&lt;span style="color: #a31515"&gt;&amp;quot;POST&amp;quot;&lt;/span&gt; action=&lt;span style="color: #a31515"&gt;&amp;quot;URL&amp;quot;&lt;/span&gt; target=&lt;span style="color: #a31515"&gt;&amp;quot;appframe&amp;quot;&lt;/span&gt;&amp;gt;
    &amp;lt;input type=&lt;span style="color: #a31515"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt; name=&lt;span style="color: #a31515"&gt;&amp;quot;payload&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&amp;gt;
    &amp;lt;input type=&lt;span style="color: #a31515"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt; name=&lt;span style="color: #a31515"&gt;&amp;quot;signature&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;iframe id=&lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt; name=&lt;span style="color: #a31515"&gt;&amp;quot;appframe&amp;quot;&lt;/span&gt; width=&lt;span style="color: #a31515"&gt;&amp;quot;100%&amp;quot;&lt;/span&gt; height=&lt;span style="color: #a31515"&gt;&amp;quot;100%&amp;quot;&lt;/span&gt; frameborder=&lt;span style="color: #a31515"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&amp;gt;
&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code&gt;form&lt;/code&gt;的&lt;code&gt;target&lt;/code&gt;属性指定在何处打开&lt;code&gt;action&lt;/code&gt;属性值URL。&lt;code&gt;form&lt;/code&gt;表单会被自动提交到应用服务器的URL，应用服务器响应的页面内容会被置于&lt;code&gt;target&lt;/code&gt;属性所指定的iframe中展示给用户。&lt;/p&gt;
&lt;p&gt;注意：这里form的target属性值与iframe的name属性值应一致；&lt;code&gt;action&lt;/code&gt;属性值即应用开发者提交给青云的URL。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;form&lt;/code&gt;表单包含两个数据项：&lt;code&gt;payload&lt;/code&gt; 和 &lt;code&gt;signature&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;payload&lt;/code&gt; 是一个JSON字符串经过base64 URL编码后的结果，JSON字符串包含user_id、access_token、action等字段，其中&lt;code&gt;user_id&lt;/code&gt;是用户在青云的唯一性ID，而 &lt;code&gt;access_token&lt;/code&gt; 则是调用青云API获取用户相关详细信息时需要的授权码，因为&lt;code&gt;payload&lt;/code&gt;并没有包含用户相关的详细信息，所以应用服务器在处理URL请求时，如果需要用户的详细信息，则需要经第&lt;strong&gt;4&lt;/strong&gt;步来获取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;signature&lt;/code&gt; 是由base64 URL编码后的payload按HmacSHA256签名，并base64 URL编码得到。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为了增强整个交互过程中的数据安全性，青云本身使用HTTPS协议，并且要求应用的URL也必须使用HTTPS协议。&lt;/p&gt;
&lt;p&gt;另外，如上所述，为了防止请求伪造，form表单包含一个签名数据项&lt;code&gt;signature&lt;/code&gt;，应用服务器在处理URL请求时应先校验签名，确认请求来自青云页面。&lt;/p&gt;
&lt;p&gt;form表单使用的编码算法和签名生成算法，见&lt;a href="https://docs.qingcloud.com/app/common/tutorial.html"&gt;青云文档&lt;/a&gt;，其PHP、Python实现如下所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// base64 URL编码
function base64_URL_encode($data) {
  return rtrim(strtr(base64_encode($data), &amp;#39;+/&amp;#39;, &amp;#39;-_&amp;#39;), &amp;#39;=&amp;#39;);
}

// HmacSHA256签名
hash_hmac(&amp;#39;sha256&amp;#39;, $payload, $secret_app_key, true)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# base64 URL编码&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; base64

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; base64_URL_encode(data):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; base64.urlsafe_b64encode(str(data)).rstrip(&lt;span style="color: #a31515"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;)

&lt;span style="color: #008000"&gt;# HmacSHA256签名&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; hmac
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; hashlib &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; sha256

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; hmac_sha256(data, secret_app_key):
    hmac_256 = hmac.new(secret_app_key, digestmod=sha256)
    hmac_256.update(data)
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; hmac_256.digest()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中HmacSHA256签名算法需要参数 &lt;code&gt;secret_app_key&lt;/code&gt; ，这个参数值应为青云为你的iframe应用分配的密钥&lt;code&gt;secret_app_key&lt;/code&gt;，同时，青云会为每个iframe应用分配一个唯一性ID。&lt;/p&gt;
&lt;p&gt;如果你的应用需要经第&lt;strong&gt;4&lt;/strong&gt;步获取用户相关详细信息，则还需从青云后台获取API密钥（包含&lt;code&gt;qy_access_key_id&lt;/code&gt; 和 &lt;code&gt;qy_secret_access_key&lt;/code&gt; 两项），API请求数据也使用了签名算法，并且算法与上述form表单数据所使用的签名算法相同，青云官方文档对于这一点貌似叙述有误。详细信息见 &lt;a href="https://docs.qingcloud.com/app/common/tutorial.html#api"&gt;青云文档&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在开发青云 iframe 应用过程中，我们遇到了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户可能会在浏览器中只刷新iframe内容，比如chrome浏览器中，在iframe内容区域右击鼠标选择“重新加载框架”。之前说过用户在iframe中的操作都是直接与应用服务器交互的，刷新iframe其实是直接向iframe应用URL发送HTTP请求，而不是提交form表单到应用URL，所以请求中没有携带校验信息，无法判断请求是否来自青云。&lt;/li&gt;
&lt;li&gt;由于我们的应用服务器有多台，并且未使用集中式session管理，那么如果使用传统的session中记录用户ID的方式，当首次iframe请求之后的请求由不同的服务器来处理，就无法识别出用户。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个问题我们都使用了cookie来解决。&lt;/p&gt;
&lt;p&gt;对于第1个问题，在处理form表单请求响应结果之前，将表单的payload和signature写入cookie，cookie的路径为应用的相对URL，这样每次用户刷新iframe，这个cookie会自动被发送到应用服务器，服务器端处理请求时，先校验是否存在合法的表单字段payload和signature，如果没有，则检查cookie中是否存在这两个字段值，从而实现兼容。&lt;/p&gt;
&lt;p&gt;对于第2个问题，在form表单请求成功处理，识别出当前用户后，将用户的基本信息经过对称加密后存入cookie，cookie的路径为&lt;code&gt;/&lt;/code&gt;，用户在iframe中操作时产生的所有AJAX请求，应用服务器处理请求时都会先解密该cookie值识别出当前用户。这个过程中涉及的加密方和解密方都是应用服务器，所以虽然使用了对称加密，但并不需要网络传输密钥。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;青云用户在首次使用我们产品的iframe应用时，系统会自动为青云用户创建一个特定类型的账号X，用户在iframe中操作产生的数据都会被绑到该账号X下。可能存在某些青云用户同时已有我们产品的账号Y，为了方便这种用户，我们的iframe应用允许用户将账号X绑定到账号Y，绑定的过程只需要在iframe应用中登录一次我们产品的账号Y，而这背后的实现是识别出X和Y，将X下的数据绑定到Y，账号绑定之后，用户在iframe中操作产生的数据都是绑定到账号Y的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;软件应用肯定需要经过测试才能发布上线（总不能让用户帮你测试吧，哈哈），那么青云iframe应用该如何测试呢？&lt;/p&gt;
&lt;p&gt;青云iframe应用在创建之后，需要经过青云官网审核才会上线，上线之后用户才可见。在创建之后、提交审核之前，你可以修改应用的配置信息（比如URL），这一阶段应用只对你自己可见可用，所以你可以将这个阶段作为测试阶段。更重要的是，在青云后台创建应用时，青云服务器并不会检测iframe的URL是否可访问，而且对该URL的请求也是由用户浏览器发起的，这样在测试阶段完全可以配置一个局域网内可访问的URL，测试完成在应用提交审核之前再将URL改成正式的外网可访问的URL即可。&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="工作"></category><category term="总结"></category></entry><entry><title>又一次系统故障</title><link href="http://youngsterxyf.github.io/2015/11/16/another-system-fault/" rel="alternate"></link><published>2015-11-16T00:00:00+08:00</published><updated>2015-11-16T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-11-16:/2015/11/16/another-system-fault/</id><summary type="html">&lt;p&gt;上周五早上9点多，我还在上班的路上，接到技术leader的电话：线上突然出故障了；接着发来一张故障信息页面截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="system-fault-err-page" src="https://i.loli.net/2020/06/14/L4fVgPGAb3Whznr.png"&gt;&lt;/p&gt;
&lt;p&gt;截图包含的信息是：数 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上周五早上9点多，我还在上班的路上，接到技术leader的电话：线上突然出故障了；接着发来一张故障信息页面截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="system-fault-err-page" src="https://i.loli.net/2020/06/14/L4fVgPGAb3Whznr.png"&gt;&lt;/p&gt;
&lt;p&gt;截图包含的信息是：数据库中没找到数据表&lt;code&gt;Users&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但同事检查过数据库，Users数据表是存在的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我快速地回忆了一下最近的代码发布和环境变更 - 前一天有个同事对线上机器做了点改动。因此，让同事赶紧检查一下之前的改动是否有问题，经检查确认改动没有问题，而且稍微思考一下就应该明白不是配置的问题，如果是配置的问题，那么问题应该早就出现了，而不是在早上9点多时候才发生。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我翻了翻手机中最近收到的几条告警短信，去除重复告警短信，只有两条告警：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某台Web服务器上出现大量的500错误&lt;/li&gt;
&lt;li&gt;某台数据库服务器的磁盘使用率为98.99%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可以推测两个故障原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;那台Web服务器上应用的数据库配置有问题 - 但检查之后确认没有问题&lt;/li&gt;
&lt;li&gt;由于那台数据库服务器磁盘满导致的问题，虽然一时还想不到其中的关联 - 同事在检查之后，确认那台机器的磁盘确实已满，但通过内网的数据库管理后台，可以正常访问数据库，所以认为应该不是磁盘满导致的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如此，一时我也没想明白故障的原因。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接着，同事发来消息：只有登录用户才会遇到这个问题！&lt;/p&gt;
&lt;p&gt;这时，基于之前的线索，基本能断定故障原因是 - 数据库服务器磁盘满。为什么呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库管理后台默认是&lt;strong&gt;只读&lt;/strong&gt;：读数据表列表、数据表结构、单个表的若干条数据&lt;/li&gt;
&lt;li&gt;我们应用在实现上有这样的逻辑：登录用户的每次访问需要登录权限的页面都会自动更新用户的最新的访问时间，即Users数据表的updated_time字段，也即会写Users数据表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于磁盘已满，所以写会失败，故障信息提示“数据库中找不到Users数据表”，估计和MySQL的写实现有关。&lt;/p&gt;
&lt;p&gt;之后清理了磁盘，故障立即恢复。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我一直认为：排除故障/解决问题时，我们就像侦探一样 - 收集信息、思考信息之间的关联、透过现象看本质。故障现象很多时候会导致迷惑，如何能破除迷惑？- 全面地掌握系统的信息并作出思考。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;但是，故障发生时，我们首先要考虑的是恢复故障，尽可能减小对SLA的影响。大多数时候，我们都暂时无法找到故障原因，而且“找到故障原因”并非是“故障恢复”的必要条件，所以故障发生时，不要只顾着查找原因，先看看如何恢复故障。比如：本文所述的这个故障，如果没有想明白原因，可以先把排查过程中发现的所有异常 - 磁盘满 - 都解决了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;再来说说这个故障的原因 - 磁盘满。个人认为这个故障原因是比较低级的，可见我们监控运维的缺失。为什么磁盘使用率到了98.88%才告警？大量占用磁盘的日志文件是否可以定期自动清理？后来，我们&lt;strong&gt;将磁盘告警的阈值修改为85%，并且定期删除一段时间之前的日志文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;故障解决之后，我了解到数据库服务器上占用磁盘最多的竟然是&lt;strong&gt;数据库代理服务的日志&lt;/strong&gt;。数据库代理服务会将每个网络请求的信息记录在日志中，在网络请求量大时，日志会快速增长 &lt;em&gt;（这样的日志信息除了在故障发生时帮助排查故障，没有其他用处，完全可以定期清除）&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;那么数据库服务、数据库代理服务是如何部署的呢？前一篇文章给出了一张系统架构图，其中数据库代理服务和数据库服务我们运维的同学实际上是这样部署的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="db-proxy-deployment" src="https://i.loli.net/2020/06/14/H1MhZn6Nj52moiR.png"&gt;&lt;/p&gt;
&lt;p&gt;这样的部署徒增别人的迷惑，增大故障排除的难度，而且主MySQL与数据库代理服务之间会存在资源竞争，特别是在数据量访问量大的时候。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;导致这种低级故障和部署混乱的原因又是什么呢？- 在我们团队中，运维同事是与另一个业务部门共享的，由于另一个业务部门做的是公司的重点业务，运维同事的KPI是根据它们业务来定，也就是说运维同事在我们这完全是友情支持，又能花多少时间来帮我们做运维呢？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;（完）&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="故障"></category></entry><entry><title>记一次系统故障</title><link href="http://youngsterxyf.github.io/2015/10/02/note-of-a-system-fault/" rel="alternate"></link><published>2015-10-02T00:00:00+08:00</published><updated>2015-10-02T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-10-02:/2015/10/02/note-of-a-system-fault/</id><summary type="html">&lt;p&gt;前段时间，工作中遭遇一次故障，虽然不算什么“疑难杂症”，倒也花了不少时间才真正找到故障的原因，故也值得记录一下。&lt;/p&gt;
&lt;p&gt;为 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前段时间，工作中遭遇一次故障，虽然不算什么“疑难杂症”，倒也花了不少时间才真正找到故障的原因，故也值得记录一下。&lt;/p&gt;
&lt;p&gt;为方便读者快速理解故障，先给出系统大致的架构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gxt-tech-arch" src="https://i.loli.net/2020/06/14/2ZBQgfPqMUnhVzY.png"&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每台Web服务器上开启12个PHP-FPM实例，并配置到Nginx的upstream，每个实例最多可以开启10个子进程&lt;/li&gt;
&lt;li&gt;“Database Proxy”的代理规则为：写操作及事务中的所有SQL操作都交给主MySQL处理，其余的读操作都交给任意一台从MySQL处理&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;故障所表现的现象包括：&lt;/p&gt;
&lt;p&gt;1.大量请求响应为502，但每次故障发生时，错误响应一般集中在一台Web服务器，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx-502-error" src="https://i.loli.net/2020/06/14/cPmFMn8gKZdzVoB.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx-server-502-count" src="https://i.loli.net/2020/06/14/CSRj4ILYVlU21Es.jpg"&gt;&lt;/p&gt;
&lt;p&gt;2.（一台或多台）MySQL数据库服务器CPU使用率飙升（但并非总是一起表现故障），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mysql-slave-server-idle" src="https://i.loli.net/2020/06/14/H5gqL8BeQpKXOla.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;故障刚开始出现时，重启/关闭出现故障现象的MySQL服务，或将出现故障的Web服务器上所有PHP-FPM重启，也能解一时的问题，但治不了本，故障还是频繁出现。&lt;/p&gt;
&lt;p&gt;在故障发生时，从相关服务器上收集到的信息如下所示：&lt;/p&gt;
&lt;p&gt;1.出现故障现象的Web服务器 - CPU使用率、内存使用率等系统指标均正常，但PHP-FPM子进程数达到上限（12 x 10 = 120），并且PHP-FPM进程与数据库代理服务器之间的网络连接数量较多（与PHP-FPM子进程数大致相当）&lt;/p&gt;
&lt;p&gt;2.出现故障现象的MySQL服务器 - CPU使用率飙升，主要为MySQL进程占用；MySQL进程与数据库代理服务器之间的网络连接较多&lt;/p&gt;
&lt;p&gt;3.继而，对出现故障现象的MySQL服务器上的数据库执行命令&lt;code&gt;SHOW PROCESSLIST&lt;/code&gt;（查看当前MySQL实例运行着哪些线程），结果如下所示（截图只是一部分结果）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mysql-show-processlist" src="https://i.loli.net/2020/06/14/jLbvVOZEKlCdkgI.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先来分析一下&lt;code&gt;SHOW PROCESSLIST&lt;/code&gt;的执行结果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt;字段，表示当前线程正在执行的任务类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;db&lt;/strong&gt;字段，表示当前线程所执行任务涉及的数据库是哪个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;State&lt;/strong&gt;字段，表示当前线程所处的状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;字段，表示当前线程处于State字段持续的时间，单位为秒&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Info&lt;/strong&gt;字段，表示如果当前线程是在执行查询操作（Query），那么查询的语句是什么样的，如非查询操作，则该字段为NULL&lt;/p&gt;
&lt;p&gt;结果中，有两种任务线程：“Binlog Dump”和“Query”，其中“Query”数量占绝大多数（和MySQL进程与数据库代理服务器之间的网络连接数大致相当）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binlog Dump：该任务线程表明当前MySQL实例为主MySQL，并且其状态表明主从同步已顺利完成&lt;/li&gt;
&lt;li&gt;Query：表明当前线程正在执行一次SQL查询操作。该SQL为&lt;code&gt;SELECT h.host, p.result, p.update_time FROM PIXIU p join Host h using(host_id) WHERE ...&lt;/code&gt;，线程所处状态为“Sorting result”（正在创建排序索引），持续时间为86-99秒左右。很明显，这句SQL语句花费的时间过长，存在问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合上面所述，可以引出一个猜测：由于这条SQL查询需耗费较长时间，并且被频繁执行，涉及该SQL的请求需要较长时间完成，大量SQL线程排队无响应，阻塞了大量PHP-FPM进程，在某些时候会达到PHP-FPM并发子进程数上限（更何况某个会被频繁访问的页面请求涉及该SQL，导致情况更糟），PHP-FPM无法处理新的请求，对于已有的请求也会因为超时导致Nginx响应502。&lt;/p&gt;
&lt;p&gt;那么针对该猜测，可以做两个优化来解决故障：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化这条SQL&lt;/li&gt;
&lt;li&gt;使用缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这条SQL的完整语句为： &lt;code&gt;SELECT h.host,p.result,p.update_time FROM Pixiu p join Host h using(host_id) WHERE result!='[]' order by update_time desc&lt;/code&gt; ，其中字段p.result的类型为 &lt;code&gt;mediumtext NOT NULL&lt;/code&gt; ，字段p.update_time的类型为 &lt;code&gt;timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;由于业务逻辑并不要求该SQL的结果是排序的，所以我们将该SQL中的排序条件&lt;code&gt;order by update_time desc&lt;/code&gt;删除，经测试发现查询时间大幅度降低到9ms左右（原来的平均查询时间为600多-700ms左右），另外，由于业务逻辑对于该条SQL涉及的数据的实时性要求不高，我们使用Memcached缓存了该SQL的查询结果。&lt;/p&gt;
&lt;p&gt;重新部署，压测，并线上运行观察，之后故障再未发生。事后回想，故障也确实是在涉及该SQL的功能模块上线之后才发生的。&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://dev.mysql.com/doc/refman/5.6/en/show-processlist.html"&gt;MySQL官方文档 - SHOW PROCESSLIST Syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dev.mysql.com/doc/refman/5.6/en/thread-commands.html"&gt;MySQL官方文档 - Thread Command Values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dev.mysql.com/doc/refman/5.6/en/master-thread-states.html"&gt;MySQL官方文档 - Replication Master Thread States&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dev.mysql.com/doc/refman/5.6/en/general-thread-states.html"&gt;MySQL官方文档 - General Thread States&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.nginx.cn/102.html"&gt;nginx+php-fpm出现502 bad gateway错误解决方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="笔记"></category><category term="故障"></category></entry><entry><title>Xhprof安装与使用</title><link href="http://youngsterxyf.github.io/2015/09/15/xhprof-installation-and-usage/" rel="alternate"></link><published>2015-09-15T00:00:00+08:00</published><updated>2015-09-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-09-15:/2015/09/15/xhprof-installation-and-usage/</id><summary type="html">&lt;p&gt;前两天遇到一个PHP代码的bug，分析的结果是：因为要处理的数据量过大，内存分配超出了限制（&lt;code&gt;php.ini&lt;/code&gt;中配置项&lt;code&gt;memory_limit&lt;/code&gt;，默认是128M）。长期使用Python …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前两天遇到一个PHP代码的bug，分析的结果是：因为要处理的数据量过大，内存分配超出了限制（&lt;code&gt;php.ini&lt;/code&gt;中配置项&lt;code&gt;memory_limit&lt;/code&gt;，默认是128M）。长期使用Python/PHP做Web开发，对于内存使用关注较少，这个事情让我重新关注起代码的内存占用问题，所以为工作中使用的测试开发环境配置Xhprof，进行性能数据收集分析（注：我们项目是用PHP开发的）。之所以选择Xhprof，是因为比较轻量，对性能影响较小，甚至可以一定方式用于生产环境，安装使用也方便。&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;Xhprof是一个PHP扩展，安装方式与一般PHP扩展一致。&lt;/p&gt;
&lt;p&gt;1.从&lt;a href="https://pecl.php.net/package/xhprof"&gt;这里&lt;/a&gt;下载最新的源码包。假设解压缩后的文件夹为xhprof&lt;/p&gt;
&lt;p&gt;2.编译安装&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cd xhprof/extension
/path/to/php/bin/phpize
./configure --with-php-config=/path/to/php/bin/php-config
make
make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.配置php.ini，添加以下几行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;[xhprof]&lt;/span&gt;
extension=&lt;span style="color: #a31515"&gt;xhprof.so&lt;/span&gt;
xhprof.output_dir=&lt;span style="color: #a31515"&gt;&amp;quot;/path/to/output/dir&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.执行&lt;code&gt;/path/to/php/bin/php -i | grep "xhprof"&lt;/code&gt;，确认xhprof扩展能成功加载&lt;/p&gt;
&lt;p&gt;5.xhprof会将收集到的性能数据按文件（一次数据收集存放一个文件）存放在&lt;code&gt;xhprof.output_dir&lt;/code&gt;指定的目录（注意添加写权限）下，并通过&lt;code&gt;xhprof/xhprof_html&lt;/code&gt;目录下的PHP脚本程序提供网页形式的展示，所以还需配置web服务提供对该脚本程序的访问，以Nginx为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;server {
    listen 8080;
    server_name localhost;

    root /path/to/xhprof/xhprof_html;
    location / {
        index index.html index.php;
        try_files $uri /index.php&lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt;$query_string;
    }
    location ~ \.php$ {
        fastcgi_split_path_info ^(.+.php)(/.+)$;
        fastcgi_pass unix:/&lt;span style="color: #0000ff"&gt;var&lt;/span&gt;/run/php5-fpm.sock;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_index index.php;
        include fastcgi_params;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.重启PHP-FPM与Nginx&lt;/p&gt;
&lt;p&gt;7.xhprof_html提供的Web展示功能可以提供代码调用逻辑图，但依赖于工具dot（即该逻辑图是使用dot语言写的），所以需要额外安装依赖graphviz，例如在CentOS上：&lt;code&gt;yum install graphviz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;8.要对目标PHP程序进行性能分析，需要在程序中注入xhprof提供的方法调用，来收集性能数据，然后通过命令行执行或HTTP请求来触发&lt;/p&gt;
&lt;h3&gt;使用&lt;/h3&gt;
&lt;p&gt;以Yii应用为例，xhprof方法调用注入示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 启动xhprof性能数据收集&lt;/span&gt;
xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);


&lt;span style="color: #008000"&gt;// 加载Yii应用代码，处理请求&lt;/span&gt;
defined(&lt;span style="color: #a31515"&gt;&amp;#39;YII_DEBUG&amp;#39;&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; define(&lt;span style="color: #a31515"&gt;&amp;#39;YII_DEBUG&amp;#39;&lt;/span&gt;,&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;require_once&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;path/to/yii/framework/yii.php&amp;#39;&lt;/span&gt;);
$configFile=&lt;span style="color: #a31515"&gt;&amp;#39;path/to/config/file.php&amp;#39;&lt;/span&gt;;
Yii::createWebApplication($configFile)-&amp;gt;run();


&lt;span style="color: #008000"&gt;// 结束收集&lt;/span&gt;
$xhprof_data = xhprof_disable();

$XHPROF_ROOT = &lt;span style="color: #a31515"&gt;&amp;quot;/path/to/xhprof/&amp;quot;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;include_once&lt;/span&gt; $XHPROF_ROOT . &lt;span style="color: #a31515"&gt;&amp;quot;/xhprof_lib/utils/xhprof_lib.php&amp;quot;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;include_once&lt;/span&gt; $XHPROF_ROOT . &lt;span style="color: #a31515"&gt;&amp;quot;/xhprof_lib/utils/xhprof_runs.php&amp;quot;&lt;/span&gt;;

$xhprof_runs = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; XHProfRuns_Default();
&lt;span style="color: #008000"&gt;// 将此次收集的性能数据存放到xhprof.output_dir目录&lt;/span&gt;
$run_id = $xhprof_runs-&amp;gt;save_run($xhprof_data, &lt;span style="color: #a31515"&gt;&amp;quot;xhprof_yii&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中函数&lt;code&gt;xhprof_enable&lt;/code&gt;有两个可选参数&lt;code&gt;$flags&lt;/code&gt;和&lt;code&gt;$options&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$flags&lt;/code&gt;有3个可选值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;XHPROF_FLAGS_NO_BUILTINS&lt;/strong&gt;：使得跳过所有内置（内部）函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XHPROF_FLAGS_CPU&lt;/strong&gt;：使输出的性能数据中添加 CPU 数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XHPROF_FLAGS_MEMORY&lt;/strong&gt;：使输出的性能数据中添加内存数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以组合使用三个可选值：&lt;code&gt;xhprof_enable(XHPROF_FLAGS_NO_BUILTINS | XHPROF_FLAGS_CPU | XHPROF_FLAGS_MEMORY);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$options&lt;/code&gt;是数组类型，可传入键为&lt;code&gt;ignored_functions&lt;/code&gt;的值，表示忽略性能分析中的某些函数，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;xhprof_enable(0, array(
    &amp;#39;ignored_functions&amp;#39; =&amp;gt;  array(
                                &amp;#39;call_user_func&amp;#39;,
                                &amp;#39;call_user_func_array&amp;#39;
                            )
    )
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了&lt;code&gt;xhprof_enable&lt;/code&gt;和&lt;code&gt;xhprof_disable&lt;/code&gt;，还有另一对函数&lt;code&gt;xhprof_sample_enable&lt;/code&gt;和&lt;code&gt;xhprof_sample_disable&lt;/code&gt;，相比前一对，后者是以采样模式启动xhprof性能分析，更适合生产环境。&lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;“原生” xhprof 有两个小问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要在应用程序中注入xhprof的函数调用，在某些情况下，这并不太合适&lt;/li&gt;
&lt;li&gt;每次收集到的性能数据是以单个文件的方式存储，xhprof_html提供的Web展示功能每次只能分析展示单个文件的内容，无法关联多次收集的性能数据进行分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以开源社区有一些xhprof的衍生版本，相比”原生”xhprof，区别主要在数据存储与分析。&lt;/p&gt;
&lt;h3&gt;XHProf UI&lt;/h3&gt;
&lt;p&gt;针对上述的两点问题，我选择 &lt;a href="https://github.com/preinheimer/xhprof"&gt;XHProf UI&lt;/a&gt; 进行额外部署，步骤如下：&lt;/p&gt;
&lt;p&gt;1.从 GitHub 上克隆代码库：&lt;code&gt;git clone https://github.com/preinheimer/xhprof.git xhprof-ui&lt;/code&gt;（注：这里指定了克隆的目标目录为xhprof-ui，以区分原来部署的原生xhprof）&lt;/p&gt;
&lt;p&gt;2.依照原生XHprof安装步骤的2-7操作&lt;/p&gt;
&lt;p&gt;3.因为XHProf UI默认使用MySQL来存储性能数据，所以需要进行数据库配置。将文件&lt;code&gt;/path/to/xhprof-ui/xhprof_lib/&lt;/code&gt;目录下的&lt;code&gt;config.sample.php&lt;/code&gt;重命名为&lt;code&gt;config.php&lt;/code&gt;，然后修改如下配置项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// Change these:
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dbtype&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;mysql&amp;#39;&lt;/span&gt;; // Only relevant for PDO
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dbhost&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;;
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dbuser&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;;
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dbpass&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;password&amp;#39;&lt;/span&gt;;
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dbname&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;xhprof&amp;#39;&lt;/span&gt;;
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dbadapter&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;Pdo&amp;#39;&lt;/span&gt;;
// 注意&lt;span style="border: 1px solid #FF0000"&gt;：&lt;/span&gt;这里有个坑&lt;span style="border: 1px solid #FF0000"&gt;，&lt;/span&gt;$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;servername&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt;的值不能超过三个字符&lt;span style="border: 1px solid #FF0000"&gt;，&lt;/span&gt;这个配置项即对应数据表details的server_id字段
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;servername&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;myserver&amp;#39;&lt;/span&gt;;
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;namespace&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;myapp&amp;#39;&lt;/span&gt;;
$_xhprof&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;url&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;#39;http://url/to/xhprof/xhprof_html&amp;#39;&lt;/span&gt;;

//These are good for linux and its derivatives.
&lt;span style="color: #008000"&gt;/*&lt;/span&gt;
&lt;span style="color: #008000"&gt;$_xhprof&lt;/span&gt;&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dot_binary&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt;&lt;span style="color: #008000"&gt;  = &amp;#39;/usr/bin/dot&amp;#39;;&lt;/span&gt;
&lt;span style="color: #008000"&gt;$_xhprof&lt;/span&gt;&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dot_tempdir&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt;&lt;span style="color: #008000"&gt; = &amp;#39;/tmp&amp;#39;;&lt;/span&gt;
&lt;span style="color: #008000"&gt;$_xhprof&lt;/span&gt;&lt;span style="color: #0000ff"&gt;[&lt;/span&gt;&lt;span style="color: #a31515"&gt;&amp;#39;dot_errfile&amp;#39;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;]&lt;/span&gt;&lt;span style="color: #008000"&gt; = &amp;#39;/tmp/xh_dot.err&amp;#39;;&lt;/span&gt;
&lt;span style="color: #008000"&gt;*/&lt;/span&gt;

// $controlIPs = false; //Disables access controlls completely. 
$controlIPs = array();
$controlIPs&lt;span style="color: #0000ff"&gt;[]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;;   // localhost, you&lt;span style="border: 1px solid #FF0000"&gt;&amp;#39;&lt;/span&gt;ll want to add your own ip here
$controlIPs&lt;span style="color: #0000ff"&gt;[]&lt;/span&gt; = &lt;span style="color: #a31515"&gt;&amp;quot;::1&amp;quot;&lt;/span&gt;;         // localhost IP v6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;并创建相应的数据库&lt;code&gt;xhprof&lt;/code&gt;和数据表&lt;code&gt;details&lt;/code&gt;，其中创建数据表&lt;code&gt;details&lt;/code&gt;的SQL语句见文件&lt;code&gt;/path/to/xhprof-ui/xhprof_lib/utils/xhprof_runs.php&lt;/code&gt;，也可见 &lt;a href="https://github.com/toomasr/xhprof/blob/master/xhprof_lib/utils/xhprof_runs.php#L109"&gt;这里&lt;/a&gt; ，&lt;a href="https://github.com/preinheimer/xhprof"&gt;XHProf UI&lt;/a&gt; 代码的&lt;code&gt;README.markdown&lt;/code&gt;有文档说明。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;前面说过“原生”xhprof的问题之一是：“需要在应用程序中注入xhprof的函数调用，在某些情况下，这并不太合适”。那么XHProf UI是怎么解决这个问题的呢？&lt;/p&gt;
&lt;p&gt;配置文件php.ini中有对配置项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto_prepend_file&lt;/code&gt;：指定的脚本文件会在目标脚本执行&lt;strong&gt;之前&lt;/strong&gt;自动解析执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_append_file&lt;/code&gt;：指定的脚本文件会在目标脚本执行&lt;strong&gt;之后&lt;/strong&gt;自动解析执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XHProf UI提供脚本&lt;code&gt;/path/to/xhprof-ui/external/header.php&lt;/code&gt;用于配置&lt;code&gt;auto_prepend_file&lt;/code&gt;，即在所有目标PHP程序运行之前自动注入xhprof性能数据收集能力。&lt;/p&gt;
&lt;p&gt;配置&lt;code&gt;auto_prepend_file&lt;/code&gt;的方式有两种：一种是直接修改php.ini的&lt;code&gt;auto_prepend_file&lt;/code&gt;配置项，另一种是通过Nginx/Apache等HTTP服务器传送配置指令给PHP-FPM进程，如在Nginx的目标server配置块中添加一行：&lt;code&gt;fastcgi_param PHP_VALUE "auto_prepend_file=/path/to/xhprof-ui/external/header.php";&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;默认XHProf UI不会对PHP Web应用收集性能分析数据，可以在请求Web应用的任意URL时，添加GET参数&lt;code&gt;_profile=1&lt;/code&gt;来启用，&lt;code&gt;/path/to/xhprof-ui/external/header.php&lt;/code&gt;脚本会检查&lt;code&gt;_profile&lt;/code&gt;参数，并将参数值写到cookie中&lt;code&gt;setcookie('_profile', $_GET['_profile']);&lt;/code&gt;（这样就不用每次请求都带GET参数&lt;code&gt;_profile=1&lt;/code&gt;，并且cookie是针对域名的，这样也就同域名下的其他URL请求启用了性能分析），然后对目标URL去掉参数&lt;code&gt;_profile&lt;/code&gt;后发起重定向；对于不带GET参数&lt;code&gt;_profile&lt;/code&gt;的URL请求，&lt;code&gt;header.php&lt;/code&gt;会继续检查是否存在名为&lt;code&gt;_profile&lt;/code&gt;的cookie，如果存在且值为布尔真，则设置条件变量启用性能分析，否则不启用。若想要对已启用性能分析的域名禁用性能分析，则可以通过对URL请求添加GET参数&lt;code&gt;_profile=0&lt;/code&gt;来禁用，因为&lt;code&gt;header.php&lt;/code&gt;在检查cookie时发现&lt;code&gt;_profile&lt;/code&gt;值为布尔假（0），所以不会启用性能分析。&lt;/p&gt;
&lt;h3&gt;术语&lt;/h3&gt;
&lt;p&gt;在查看 Xhprof 或 XHProf UI 展示的性能数据时，会遇到以下几个术语，其含义对应如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Calls / Call Count：函数/方法被调用的次数&lt;/li&gt;
&lt;li&gt;Incl. Wall Time / Wall Time：执行该函数/方法实际耗费的时间&lt;/li&gt;
&lt;li&gt;Incl. MemUse / Memory Usage：该函数/方法当前占用的内存&lt;/li&gt;
&lt;li&gt;Incl. PeakMemUse / Peak Memory Usage：函数/方法占用内存的峰值（注：我也不知道这个峰值是怎么算的）&lt;/li&gt;
&lt;li&gt;Incl. CPU / CPU：执行该函数/方法，花费的CPU时间&lt;/li&gt;
&lt;li&gt;Excl. Wall Time / Exclusive Wall Time&lt;/li&gt;
&lt;li&gt;Excl. MemUse / Exclusive Memory Usage&lt;/li&gt;
&lt;li&gt;Excl. PeakMemUse / Exclusive Peak Memory Usage&lt;/li&gt;
&lt;li&gt;Exclusive CPU&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;术语中的&lt;code&gt;Incl&lt;/code&gt;表示&lt;code&gt;Inclusive&lt;/code&gt;，&lt;code&gt;Excl&lt;/code&gt;表示&lt;code&gt;Exclusive&lt;/code&gt;。&lt;code&gt;Inclusive&lt;/code&gt;表示测量到的数据是&lt;strong&gt;函数/方法本身及所有调用的子函数/方法总共耗费占用的资源&lt;/strong&gt;，&lt;code&gt;Exclusive&lt;/code&gt;则表示&lt;strong&gt;不包含调用的子函数/方法耗费占用的资源&lt;/strong&gt;。另外，所有测量值都是每个函数/方法调用在次数上的叠加。&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/zh/book.xhprof.php"&gt;PHP手册-层次式性能分析器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.engineyard.com/2014/profiling-with-xhprof-xhgui-part-1"&gt;Profiling PHP Part 1: Intro to Xhprof &amp;amp; Xhgui&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.engineyard.com/2014/profiling-with-xhprof-xhgui-part-2"&gt;Profiling PHP Part 2: Xhgui In-Depth&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="PHP"></category><category term="笔记"></category><category term="Xhprof"></category></entry><entry><title>Yii源码阅读笔记 - 错误/异常处理</title><link href="http://youngsterxyf.github.io/2015/09/14/read-yii-code-10/" rel="alternate"></link><published>2015-09-14T00:00:00+08:00</published><updated>2015-09-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-09-14:/2015/09/14/read-yii-code-10/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;PHP区分“错误”（Error）和“异常”（Exception）。“错误”通常是由PHP内部函数抛出，表示运行时问题，当然也可以通过函数&lt;code&gt;trigger_error&lt;/code&gt;或&lt;code&gt;user_error&lt;/code&gt;抛出一个用户级别的error/warning/notice信息。但在 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;PHP区分“错误”（Error）和“异常”（Exception）。“错误”通常是由PHP内部函数抛出，表示运行时问题，当然也可以通过函数&lt;code&gt;trigger_error&lt;/code&gt;或&lt;code&gt;user_error&lt;/code&gt;抛出一个用户级别的error/warning/notice信息。但在引入面向对象之后，相比使用&lt;code&gt;trigger_error&lt;/code&gt;抛出错误，使用throw抛出异常更常用。&lt;/p&gt;
&lt;p&gt;对于“错误”，PHP允许配置报告哪些级别/类型错误、是否（向用户）展示错误、是否对错误记录日志、错误日志记到哪，分别对应php.ini中的配置项：&lt;code&gt;error_reporting&lt;/code&gt;、&lt;code&gt;display_errors&lt;/code&gt;、&lt;code&gt;log_errors&lt;/code&gt;、&lt;code&gt;error_log&lt;/code&gt;。详细信息见&lt;a href="http://php.net/manual/zh/language.errors.basics.php"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于应用程序内层调用抛出的“异常”，一般可以在外层中使用try...catch来捕获并自定义处理过程。但对于“错误”（PHP运行时抛出或者应用程序使用trigger_error抛出的）或者对于-无法使用try...catch来捕获可能的异常/为了做到即使忘记捕获的异常也能得到自定义处理-的情况，该怎么办？对此，PHP提供了函数&lt;code&gt;set_error_handler&lt;/code&gt;和&lt;code&gt;set_exception_handler&lt;/code&gt;来注册错误/异常自定义处理过程。如果在程序的执行流中先后多次调用了&lt;code&gt;set_error_handler&lt;/code&gt;或&lt;code&gt;set_exception_handler&lt;/code&gt;，后一次注册的处理过程会覆盖前一次的，但可以通过函数&lt;code&gt;restore_error_handler&lt;/code&gt;或&lt;code&gt;restore_exception_handler&lt;/code&gt;来恢复前一次注册的异常处理过程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;之所以写这篇文章，是因为最近在工作中犯了一个低级错误：应用程序中有个API对于不合法的请求参数直接抛出异常（&lt;code&gt;throw new Exception("xxx")&lt;/code&gt;），却忘了try...catch捕捉，导致异常被Yii框架（我们的应用基于Yii开发）通过set_exception_handler注册的方法处理 - 响应500，之后这个API被一个扫描器拼命扫，导致出现很多500响应，触发了告警。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;我们来看看Yii框架在哪个地方注册错误/异常处理过程？处理过程是什么样的？&lt;/p&gt;
&lt;p&gt;Yii框架在请求处理初始化过程中，在&lt;code&gt;CApplication&lt;/code&gt;类（见文件&lt;code&gt;base/CApplication.php&lt;/code&gt;）的构造方法中调用了：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$this-&amp;gt;initSystemHandlers();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;initSystemHandlers&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #a31515"&gt;/**&lt;/span&gt;
&lt;span style="color: #a31515"&gt; * Initializes the class autoloader and error handlers.&lt;/span&gt;
&lt;span style="color: #a31515"&gt; */&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; initSystemHandlers()
{
    &lt;span style="color: #008000"&gt;// 注：如果不想使用Yii框架注册的handleException，可以在初始化应用实例之前，定义常量YII_ENABLE_EXCEPTION_HANDLER值为false&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(YII_ENABLE_EXCEPTION_HANDLER)
        set_exception_handler(&lt;span style="color: #0000ff"&gt;array&lt;/span&gt;($this,&lt;span style="color: #a31515"&gt;&amp;#39;handleException&amp;#39;&lt;/span&gt;));
    &lt;span style="color: #008000"&gt;// 注：YII_ENABLE_ERROR_HANDLER也是如此&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(YII_ENABLE_ERROR_HANDLER)
        set_error_handler(&lt;span style="color: #0000ff"&gt;array&lt;/span&gt;($this,&lt;span style="color: #a31515"&gt;&amp;#39;handleError&amp;#39;&lt;/span&gt;),error_reporting());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中注册的方法&lt;code&gt;handleException&lt;/code&gt;和&lt;code&gt;handleError&lt;/code&gt;实现分别如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; handleException($exception)
{
    &lt;span style="color: #008000"&gt;// disable error capturing to avoid recursive errors&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// 这句注释是啥意思？&lt;/span&gt;
    restore_error_handler();
    restore_exception_handler();

    &lt;span style="color: #008000"&gt;// 生成并记录日志信息&lt;/span&gt;
    $category=&lt;span style="color: #a31515"&gt;&amp;#39;exception.&amp;#39;&lt;/span&gt;.get_class($exception);
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($exception instanceof CHttpException)
        $category.=&lt;span style="color: #a31515"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;.$exception-&amp;gt;statusCode;
    &lt;span style="color: #008000"&gt;// php &amp;lt;5.2 doesn&amp;#39;t support string conversion auto-magically&lt;/span&gt;
    $message=$exception-&amp;gt;__toString();
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(isset($_SERVER[&lt;span style="color: #a31515"&gt;&amp;#39;REQUEST_URI&amp;#39;&lt;/span&gt;]))
        $message.=&lt;span style="color: #a31515"&gt;&amp;quot;\nREQUEST_URI=&amp;quot;&lt;/span&gt;.$_SERVER[&lt;span style="color: #a31515"&gt;&amp;#39;REQUEST_URI&amp;#39;&lt;/span&gt;];
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(isset($_SERVER[&lt;span style="color: #a31515"&gt;&amp;#39;HTTP_REFERER&amp;#39;&lt;/span&gt;]))
        $message.=&lt;span style="color: #a31515"&gt;&amp;quot;\nHTTP_REFERER=&amp;quot;&lt;/span&gt;.$_SERVER[&lt;span style="color: #a31515"&gt;&amp;#39;HTTP_REFERER&amp;#39;&lt;/span&gt;];
    $message.=&lt;span style="color: #a31515"&gt;&amp;quot;\n---&amp;quot;&lt;/span&gt;;
    Yii::log($message,CLogger::LEVEL_ERROR,$category);

    &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;
    {
        &lt;span style="color: #008000"&gt;// 将异常封装成事件，并触发事件，从而触发监听该事件的处理过程&lt;/span&gt;
        $event=&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CExceptionEvent($this,$exception);
        $this-&amp;gt;onException($event);
        &lt;span style="color: #008000"&gt;// 如果事件并没有被处理（即没有监听该事件的处理过程）或者所有处理过程都没有将事件的handled属性置为true，则还得自己处理一下&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!$event-&amp;gt;handled)
        {
            &lt;span style="color: #008000"&gt;// try an error handler&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(($handler=$this-&amp;gt;getErrorHandler())!==&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
                $handler-&amp;gt;handle($event);
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
                $this-&amp;gt;displayException($exception);
        }
    }
    &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt;(Exception $e)
    {
        $this-&amp;gt;displayException($e);
    }

    &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;
    {
        &lt;span style="color: #008000"&gt;// 尝试触发onEndRequest事件&lt;/span&gt;
        $this-&amp;gt;end(1);
    }
    &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt;(Exception $e)
    {
        &lt;span style="color: #008000"&gt;// use the most primitive way to log error&lt;/span&gt;
        $msg = get_class($e).&lt;span style="color: #a31515"&gt;&amp;#39;: &amp;#39;&lt;/span&gt;.$e-&amp;gt;getMessage().&lt;span style="color: #a31515"&gt;&amp;#39; (&amp;#39;&lt;/span&gt;.$e-&amp;gt;getFile().&lt;span style="color: #a31515"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;.$e-&amp;gt;getLine().&lt;span style="color: #a31515"&gt;&amp;quot;)\n&amp;quot;&lt;/span&gt;;
        $msg .= $e-&amp;gt;getTraceAsString().&lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
        $msg .= &lt;span style="color: #a31515"&gt;&amp;quot;Previous exception:\n&amp;quot;&lt;/span&gt;;
        $msg .= get_class($exception).&lt;span style="color: #a31515"&gt;&amp;#39;: &amp;#39;&lt;/span&gt;.$exception-&amp;gt;getMessage().&lt;span style="color: #a31515"&gt;&amp;#39; (&amp;#39;&lt;/span&gt;.$exception-&amp;gt;getFile().&lt;span style="color: #a31515"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;.$exception-&amp;gt;getLine().&lt;span style="color: #a31515"&gt;&amp;quot;)\n&amp;quot;&lt;/span&gt;;
        $msg .= $exception-&amp;gt;getTraceAsString().&lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
        $msg .= &lt;span style="color: #a31515"&gt;&amp;#39;$_SERVER=&amp;#39;&lt;/span&gt;.var_export($_SERVER,&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);
        error_log($msg);
        &lt;span style="color: #0000ff"&gt;exit&lt;/span&gt;(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; handleError($code,$message,$file,$line)
{
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($code &amp;amp; error_reporting())
    {
        &lt;span style="color: #008000"&gt;// disable error capturing to avoid recursive errors&lt;/span&gt;
        restore_error_handler();
        restore_exception_handler();

        &lt;span style="color: #008000"&gt;// 生成并记录日志信息&lt;/span&gt;
        $log=&lt;span style="color: #a31515"&gt;&amp;quot;$message ($file:$line)\nStack trace:\n&amp;quot;&lt;/span&gt;;

        &lt;span style="color: #008000"&gt;// debug_backtrace() 产生一条 PHP 的回溯跟踪&lt;/span&gt;
        $trace=debug_backtrace();
        &lt;span style="color: #008000"&gt;// skip the first 3 stacks as they do not tell the error position&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(count($trace)&amp;gt;3)
            $trace=array_slice($trace,3);
        &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($trace &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $i=&amp;gt;$t)
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]))
                $t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]))
                $t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]=0;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]))
                $t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;
            $log.=&lt;span style="color: #a31515"&gt;&amp;quot;#$i {&lt;/span&gt;$t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}({&lt;/span&gt;$t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}): &amp;quot;&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]) &amp;amp;&amp;amp; is_object($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]))
                $log.=get_class($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]).&lt;span style="color: #a31515"&gt;&amp;#39;-&amp;gt;&amp;#39;&lt;/span&gt;;
            $log.=&lt;span style="color: #a31515"&gt;&amp;quot;{&lt;/span&gt;$t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}()\n&amp;quot;&lt;/span&gt;;
        }
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(isset($_SERVER[&lt;span style="color: #a31515"&gt;&amp;#39;REQUEST_URI&amp;#39;&lt;/span&gt;]))
            $log.=&lt;span style="color: #a31515"&gt;&amp;#39;REQUEST_URI=&amp;#39;&lt;/span&gt;.$_SERVER[&lt;span style="color: #a31515"&gt;&amp;#39;REQUEST_URI&amp;#39;&lt;/span&gt;];
        Yii::log($log,CLogger::LEVEL_ERROR,&lt;span style="color: #a31515"&gt;&amp;#39;php&amp;#39;&lt;/span&gt;);

        &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;
        {
            &lt;span style="color: #008000"&gt;// 将错误封装成事件，并触发&lt;/span&gt;
            Yii::import(&lt;span style="color: #a31515"&gt;&amp;#39;CErrorEvent&amp;#39;&lt;/span&gt;,&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);
            $event=&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CErrorEvent($this,$code,$message,$file,$line);
            $this-&amp;gt;onError($event);
            &lt;span style="color: #008000"&gt;// 如果错误事件未被处理&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!$event-&amp;gt;handled)
            {
                &lt;span style="color: #008000"&gt;// try an error handler&lt;/span&gt;
                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(($handler=$this-&amp;gt;getErrorHandler())!==&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
                    $handler-&amp;gt;handle($event);
                &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
                    $this-&amp;gt;displayError($code,$message,$file,$line);
            }
        }
        &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt;(Exception $e)
        {
            $this-&amp;gt;displayException($e);
        }

        &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;
        {
            &lt;span style="color: #008000"&gt;// 尝试触发onEndRequest事件&lt;/span&gt;
            $this-&amp;gt;end(1);
        }
        &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt;(Exception $e)
        {
            &lt;span style="color: #008000"&gt;// use the most primitive way to log error&lt;/span&gt;
            $msg = get_class($e).&lt;span style="color: #a31515"&gt;&amp;#39;: &amp;#39;&lt;/span&gt;.$e-&amp;gt;getMessage().&lt;span style="color: #a31515"&gt;&amp;#39; (&amp;#39;&lt;/span&gt;.$e-&amp;gt;getFile().&lt;span style="color: #a31515"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;.$e-&amp;gt;getLine().&lt;span style="color: #a31515"&gt;&amp;quot;)\n&amp;quot;&lt;/span&gt;;
            $msg .= $e-&amp;gt;getTraceAsString().&lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
            $msg .= &lt;span style="color: #a31515"&gt;&amp;quot;Previous error:\n&amp;quot;&lt;/span&gt;;
            $msg .= $log.&lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
            $msg .= &lt;span style="color: #a31515"&gt;&amp;#39;$_SERVER=&amp;#39;&lt;/span&gt;.var_export($_SERVER,&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);
            error_log($msg);
            &lt;span style="color: #0000ff"&gt;exit&lt;/span&gt;(1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上面代码可以看到，方法&lt;code&gt;handleException&lt;/code&gt;的关键部分（&lt;code&gt;handleError&lt;/code&gt;类似）为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 将异常封装成事件，并触发事件，从而触发监听该事件的处理过程&lt;/span&gt;
$event=&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CExceptionEvent($this,$exception);
$this-&amp;gt;onException($event);
&lt;span style="color: #008000"&gt;// 如果事件并没有被处理（即没有监听该事件的处理过程）或者所有处理过程都没有将事件的handled属性置为true，则还得自己处理一下&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!$event-&amp;gt;handled)
{
    &lt;span style="color: #008000"&gt;// try an error handler&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(($handler=$this-&amp;gt;getErrorHandler())!==&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
        $handler-&amp;gt;handle($event);
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        $this-&amp;gt;displayException($exception);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法&lt;code&gt;onException&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; onException($event)
{
    $this-&amp;gt;raiseEvent(&lt;span style="color: #a31515"&gt;&amp;#39;onException&amp;#39;&lt;/span&gt;,$event);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;raiseEvent&lt;/code&gt;方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; raiseEvent($name,$event)
{
    &lt;span style="color: #008000"&gt;// 根据事件名称，如onException，找到注册到该事件的处理过程，逐个触发调用。&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// 所有该事件注册的处理过程存放在$this-&amp;gt;_e[$name]中&lt;/span&gt;
    $name=strtolower($name);
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(isset($this-&amp;gt;_e[$name]))
    {
        &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($this-&amp;gt;_e[$name] &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $handler)
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(is_string($handler))
                call_user_func($handler,$event);
            &lt;span style="color: #0000ff"&gt;elseif&lt;/span&gt;(is_callable($handler,&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;))
            {
                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(is_array($handler))
                {
                    &lt;span style="color: #008000"&gt;// an array: 0 - object, 1 - method name&lt;/span&gt;
                    &lt;span style="color: #0000ff"&gt;list&lt;/span&gt;($object,$method)=$handler;
                    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(is_string($object))  &lt;span style="color: #008000"&gt;// static method call&lt;/span&gt;
                        call_user_func($handler,$event);
                    &lt;span style="color: #0000ff"&gt;elseif&lt;/span&gt;(method_exists($object,$method))
                        $object-&amp;gt;$method($event);
                    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
                        &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CException(Yii::t(&lt;span style="color: #a31515"&gt;&amp;#39;yii&amp;#39;&lt;/span&gt;,&lt;span style="color: #a31515"&gt;&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is attached with an invalid handler &amp;quot;{handler}&amp;quot;.&amp;#39;&lt;/span&gt;,
                            &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;{class}&amp;#39;&lt;/span&gt;=&amp;gt;get_class($this), &lt;span style="color: #a31515"&gt;&amp;#39;{event}&amp;#39;&lt;/span&gt;=&amp;gt;$name, &lt;span style="color: #a31515"&gt;&amp;#39;{handler}&amp;#39;&lt;/span&gt;=&amp;gt;$handler[1])));
                }
                &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; &lt;span style="color: #008000"&gt;// PHP 5.3: anonymous function&lt;/span&gt;
                    call_user_func($handler,$event);
            }
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
                &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CException(Yii::t(&lt;span style="color: #a31515"&gt;&amp;#39;yii&amp;#39;&lt;/span&gt;,&lt;span style="color: #a31515"&gt;&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is attached with an invalid handler &amp;quot;{handler}&amp;quot;.&amp;#39;&lt;/span&gt;,
                    &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;{class}&amp;#39;&lt;/span&gt;=&amp;gt;get_class($this), &lt;span style="color: #a31515"&gt;&amp;#39;{event}&amp;#39;&lt;/span&gt;=&amp;gt;$name, &lt;span style="color: #a31515"&gt;&amp;#39;{handler}&amp;#39;&lt;/span&gt;=&amp;gt;gettype($handler))));
            &lt;span style="color: #008000"&gt;// stop further handling if param.handled is set true&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(($event instanceof CEvent) &amp;amp;&amp;amp; $event-&amp;gt;handled)
                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;;
        }
    }
    &lt;span style="color: #0000ff"&gt;elseif&lt;/span&gt;(YII_DEBUG &amp;amp;&amp;amp; !$this-&amp;gt;hasEvent($name))
        &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CException(Yii::t(&lt;span style="color: #a31515"&gt;&amp;#39;yii&amp;#39;&lt;/span&gt;,&lt;span style="color: #a31515"&gt;&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is not defined.&amp;#39;&lt;/span&gt;,
            &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;{class}&amp;#39;&lt;/span&gt;=&amp;gt;get_class($this), &lt;span style="color: #a31515"&gt;&amp;#39;{event}&amp;#39;&lt;/span&gt;=&amp;gt;$name)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么是如何注册事件的处理过程的呢？&lt;/p&gt;
&lt;p&gt;在类&lt;code&gt;CComponent&lt;/code&gt;（见文件&lt;code&gt;base/CComponent.php&lt;/code&gt;，&lt;code&gt;CApplication&lt;/code&gt;类间接继承自该类）中定义了一对方法：&lt;code&gt;attachEventHandler&lt;/code&gt;（将处理过程绑定到某事件）和&lt;code&gt;detachEventHandler&lt;/code&gt;（将处理过程从事件解绑）。&lt;/p&gt;
&lt;p&gt;方法&lt;code&gt;attachEventHandler&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; attachEventHandler($name,$handler)
{
    $this-&amp;gt;getEventHandlers($name)-&amp;gt;add($handler);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code&gt;getEventHandlers&lt;/code&gt;实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; getEventHandlers($name)
{
    &lt;span style="color: #008000"&gt;// 可以关注一下方法hasEvent&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// 检查是否存在$name对应的事件&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($this-&amp;gt;hasEvent($name))
    {
        $name=strtolower($name);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($this-&amp;gt;_e[$name]))
            $this-&amp;gt;_e[$name]=&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CList;
        &lt;span style="color: #008000"&gt;// 返回对应事件的处理过程列表&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; $this-&amp;gt;_e[$name];
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CException(Yii::t(&lt;span style="color: #a31515"&gt;&amp;#39;yii&amp;#39;&lt;/span&gt;,&lt;span style="color: #a31515"&gt;&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is not defined.&amp;#39;&lt;/span&gt;,
            &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;{class}&amp;#39;&lt;/span&gt;=&amp;gt;get_class($this), &lt;span style="color: #a31515"&gt;&amp;#39;{event}&amp;#39;&lt;/span&gt;=&amp;gt;$name)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;回到“方法&lt;code&gt;handleException&lt;/code&gt;的关键部分”，在事件的handled属性没有置为true的情况下，会调用方法&lt;code&gt;getErrorHandler&lt;/code&gt;取到内置的一个处理过程，该方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; getErrorHandler()
{
    &lt;span style="color: #008000"&gt;// 获取名为errorHandler的组件，该组件默认会在CApplication类的registerCoreComponents方法中注册，&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// 见http://blog.xiayf.cn/2014/11/13/read-yii-code-3/一文的说明&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; $this-&amp;gt;getComponent(&lt;span style="color: #a31515"&gt;&amp;#39;errorHandler&amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;名为errorHandler的组件默认为类&lt;code&gt;CErrorHandler&lt;/code&gt;（见文件&lt;code&gt;base/CErrorHandler.php&lt;/code&gt;），当然也可以配置覆盖默认行为。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CErrorHandler&lt;/code&gt;类的&lt;code&gt;handle&lt;/code&gt;方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; handle($event)
{
    &lt;span style="color: #008000"&gt;// set event as handled to prevent it from being handled by other event handlers&lt;/span&gt;
    $event-&amp;gt;handled=&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;

    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($this-&amp;gt;discardOutput)
    {
        $gzHandler=&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;(ob_list_handlers() &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $h)
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(strpos($h,&lt;span style="color: #a31515"&gt;&amp;#39;gzhandler&amp;#39;&lt;/span&gt;)!==&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;)
                $gzHandler=&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
        }
        &lt;span style="color: #008000"&gt;// the following manual level counting is to deal with zlib.output_compression set to On&lt;/span&gt;
        &lt;span style="color: #008000"&gt;// for an output buffer created by zlib.output_compression set to On ob_end_clean will fail&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;($level=ob_get_level();$level&amp;gt;0;--$level)
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!@ob_end_clean())
                ob_clean();
        }
        &lt;span style="color: #008000"&gt;// reset headers in case there was an ob_start(&amp;quot;ob_gzhandler&amp;quot;) before&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($gzHandler &amp;amp;&amp;amp; !headers_sent() &amp;amp;&amp;amp; ob_list_handlers()===&lt;span style="color: #0000ff"&gt;array&lt;/span&gt;())
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(function_exists(&lt;span style="color: #a31515"&gt;&amp;#39;header_remove&amp;#39;&lt;/span&gt;)) &lt;span style="color: #008000"&gt;// php &amp;gt;= 5.3&lt;/span&gt;
            {
                header_remove(&lt;span style="color: #a31515"&gt;&amp;#39;Vary&amp;#39;&lt;/span&gt;);
                header_remove(&lt;span style="color: #a31515"&gt;&amp;#39;Content-Encoding&amp;#39;&lt;/span&gt;);
            }
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
            {
                header(&lt;span style="color: #a31515"&gt;&amp;#39;Vary:&amp;#39;&lt;/span&gt;);
                header(&lt;span style="color: #a31515"&gt;&amp;#39;Content-Encoding:&amp;#39;&lt;/span&gt;);
            }
        }
    }

    &lt;span style="color: #008000"&gt;// 异常和错误都可以调用handle方法&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($event instanceof CExceptionEvent)
        $this-&amp;gt;handleException($event-&amp;gt;exception);
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; &lt;span style="color: #008000"&gt;// CErrorEvent&lt;/span&gt;
        $this-&amp;gt;handleError($event);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法&lt;code&gt;handleException&lt;/code&gt;和&lt;code&gt;handleError&lt;/code&gt;实现分别如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; handleException($exception)
{
    $app=Yii::app();
    &lt;span style="color: #008000"&gt;// 如果是Web应用&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($app instanceof CWebApplication)
    {
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(($trace=$this-&amp;gt;getExactTrace($exception))===&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
        {
            $fileName=$exception-&amp;gt;getFile();
            $errorLine=$exception-&amp;gt;getLine();
        }
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        {
            $fileName=$trace[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;];
            $errorLine=$trace[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;];
        }

        $trace = $exception-&amp;gt;getTrace();

        &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($trace &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $i=&amp;gt;$t)
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]))
                $trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;

            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]))
                $trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]=0;

            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]))
                $trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;

            unset($trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]);
        }

        $this-&amp;gt;_error=$data=&lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(
            &lt;span style="color: #008000"&gt;// 如果抛出的异常是CHttpException类型，使用该异常自身的statusCode作为HTTP响应码，否则HTTP响应码为500&lt;/span&gt;
            &lt;span style="color: #008000"&gt;// 所以在有意让Yii框架来处理抛出的异常时，需要明确指定异常的类型！&lt;/span&gt;
            &lt;span style="color: #a31515"&gt;&amp;#39;code&amp;#39;&lt;/span&gt;=&amp;gt;($exception instanceof CHttpException)?$exception-&amp;gt;statusCode:500,
            &lt;span style="color: #a31515"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;=&amp;gt;get_class($exception),
            &lt;span style="color: #a31515"&gt;&amp;#39;errorCode&amp;#39;&lt;/span&gt;=&amp;gt;$exception-&amp;gt;getCode(),
            &lt;span style="color: #a31515"&gt;&amp;#39;message&amp;#39;&lt;/span&gt;=&amp;gt;$exception-&amp;gt;getMessage(),
            &lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;=&amp;gt;$fileName,
            &lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;=&amp;gt;$errorLine,
            &lt;span style="color: #a31515"&gt;&amp;#39;trace&amp;#39;&lt;/span&gt;=&amp;gt;$exception-&amp;gt;getTraceAsString(),
            &lt;span style="color: #a31515"&gt;&amp;#39;traces&amp;#39;&lt;/span&gt;=&amp;gt;$trace,
        );

        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!headers_sent())
            header(&lt;span style="color: #a31515"&gt;&amp;quot;HTTP/1.0 {&lt;/span&gt;$data[&lt;span style="color: #a31515"&gt;&amp;#39;code&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;} &amp;quot;&lt;/span&gt;.$this-&amp;gt;getHttpHeader($data[&lt;span style="color: #a31515"&gt;&amp;#39;code&amp;#39;&lt;/span&gt;], get_class($exception)));

        &lt;span style="color: #008000"&gt;// 判断异常类型&lt;/span&gt;
        &lt;span style="color: #008000"&gt;// 对于CHttpException，也按照error来处理&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($exception instanceof CHttpException || !YII_DEBUG)
            $this-&amp;gt;render(&lt;span style="color: #a31515"&gt;&amp;#39;error&amp;#39;&lt;/span&gt;,$data);
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($this-&amp;gt;isAjaxRequest())
                $app-&amp;gt;displayException($exception);
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
                $this-&amp;gt;render(&lt;span style="color: #a31515"&gt;&amp;#39;exception&amp;#39;&lt;/span&gt;,$data);
        }
    }
    &lt;span style="color: #008000"&gt;// 如果是终端应用（console application），则直接展示异常&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        $app-&amp;gt;displayException($exception);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; handleError($event)
{
    $trace=debug_backtrace();
    &lt;span style="color: #008000"&gt;// skip the first 3 stacks as they do not tell the error position&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(count($trace)&amp;gt;3)
        $trace=array_slice($trace,3);
    $traceString=&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
    &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($trace &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $i=&amp;gt;$t)
    {
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]))
            $trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;

        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]))
            $trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]=0;

        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]))
            $trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;

        $traceString.=&lt;span style="color: #a31515"&gt;&amp;quot;#$i {&lt;/span&gt;$trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}({&lt;/span&gt;$trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}): &amp;quot;&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]) &amp;amp;&amp;amp; is_object($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]))
            $traceString.=get_class($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]).&lt;span style="color: #a31515"&gt;&amp;#39;-&amp;gt;&amp;#39;&lt;/span&gt;;
        $traceString.=&lt;span style="color: #a31515"&gt;&amp;quot;{&lt;/span&gt;$trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}()\n&amp;quot;&lt;/span&gt;;

        unset($trace[$i][&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]);
    }

    $app=Yii::app();
    &lt;span style="color: #008000"&gt;// 如果是Web应用&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($app instanceof CWebApplication)
    {
        &lt;span style="color: #008000"&gt;// 判断错误类型&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;switch&lt;/span&gt;($event-&amp;gt;code)
        {
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; &lt;span style="color: #0000ff"&gt;E_WARNING&lt;/span&gt;:
                $type = &lt;span style="color: #a31515"&gt;&amp;#39;PHP warning&amp;#39;&lt;/span&gt;;
                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; E_NOTICE:
                $type = &lt;span style="color: #a31515"&gt;&amp;#39;PHP notice&amp;#39;&lt;/span&gt;;
                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; E_USER_ERROR:
                $type = &lt;span style="color: #a31515"&gt;&amp;#39;User error&amp;#39;&lt;/span&gt;;
                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; E_USER_WARNING:
                $type = &lt;span style="color: #a31515"&gt;&amp;#39;User warning&amp;#39;&lt;/span&gt;;
                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; E_USER_NOTICE:
                $type = &lt;span style="color: #a31515"&gt;&amp;#39;User notice&amp;#39;&lt;/span&gt;;
                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; E_RECOVERABLE_ERROR:
                $type = &lt;span style="color: #a31515"&gt;&amp;#39;Recoverable error&amp;#39;&lt;/span&gt;;
                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;default&lt;/span&gt;:
                $type = &lt;span style="color: #a31515"&gt;&amp;#39;PHP error&amp;#39;&lt;/span&gt;;
        }
        &lt;span style="color: #008000"&gt;// HTTP响应码为500&lt;/span&gt;
        $this-&amp;gt;_error=$data=&lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(
            &lt;span style="color: #a31515"&gt;&amp;#39;code&amp;#39;&lt;/span&gt;=&amp;gt;500,
            &lt;span style="color: #a31515"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;=&amp;gt;$type,
            &lt;span style="color: #a31515"&gt;&amp;#39;message&amp;#39;&lt;/span&gt;=&amp;gt;$event-&amp;gt;message,
            &lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;=&amp;gt;$event-&amp;gt;file,
            &lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;=&amp;gt;$event-&amp;gt;line,
            &lt;span style="color: #a31515"&gt;&amp;#39;trace&amp;#39;&lt;/span&gt;=&amp;gt;$traceString,
            &lt;span style="color: #a31515"&gt;&amp;#39;traces&amp;#39;&lt;/span&gt;=&amp;gt;$trace,
        );
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!headers_sent())
            header(&lt;span style="color: #a31515"&gt;&amp;quot;HTTP/1.0 500 Internal Server Error&amp;quot;&lt;/span&gt;);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($this-&amp;gt;isAjaxRequest())
            $app-&amp;gt;displayError($event-&amp;gt;code,$event-&amp;gt;message,$event-&amp;gt;file,$event-&amp;gt;line);
        &lt;span style="color: #0000ff"&gt;elseif&lt;/span&gt;(YII_DEBUG)
            &lt;span style="color: #008000"&gt;// 开了debug，则作为exception来处理&lt;/span&gt;
            $this-&amp;gt;render(&lt;span style="color: #a31515"&gt;&amp;#39;exception&amp;#39;&lt;/span&gt;,$data);
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
            $this-&amp;gt;render(&lt;span style="color: #a31515"&gt;&amp;#39;error&amp;#39;&lt;/span&gt;,$data);
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        $app-&amp;gt;displayError($event-&amp;gt;code,$event-&amp;gt;message,$event-&amp;gt;file,$event-&amp;gt;line);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码最终显示异常/错误信息，是通过方法&lt;code&gt;render&lt;/code&gt;、以及应用实例的&lt;code&gt;displayError&lt;/code&gt;和&lt;code&gt;displayException&lt;/code&gt;方法来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;render&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; render($view,$data)
{
    &lt;span style="color: #008000"&gt;// 注意这个地方，如果配置了errorAction，则可以指定目标controller的某个action来处理错误&lt;/span&gt;
    &lt;span style="color: #008000"&gt;/*&lt;/span&gt;
&lt;span style="color: #008000"&gt;     * 配置方式：&lt;/span&gt;
&lt;span style="color: #008000"&gt;     * &amp;#39;components&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span style="color: #008000"&gt;     *      &amp;#39;errorHandler&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span style="color: #008000"&gt;     *          &amp;#39;errorAction&amp;#39;=&amp;gt;&amp;#39;api/index/error&amp;#39;,&lt;/span&gt;
&lt;span style="color: #008000"&gt;     *     ),&lt;/span&gt;
&lt;span style="color: #008000"&gt;     *     ...&lt;/span&gt;
&lt;span style="color: #008000"&gt;     */&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($view===&lt;span style="color: #a31515"&gt;&amp;#39;error&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; $this-&amp;gt;errorAction!==&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
        Yii::app()-&amp;gt;runController($this-&amp;gt;errorAction);
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
    {
        &lt;span style="color: #008000"&gt;// additional information to be passed to view&lt;/span&gt;
        $data[&lt;span style="color: #a31515"&gt;&amp;#39;version&amp;#39;&lt;/span&gt;]=$this-&amp;gt;getVersionInfo();
        $data[&lt;span style="color: #a31515"&gt;&amp;#39;time&amp;#39;&lt;/span&gt;]=time();
        $data[&lt;span style="color: #a31515"&gt;&amp;#39;admin&amp;#39;&lt;/span&gt;]=$this-&amp;gt;adminInfo;

        &lt;span style="color: #008000"&gt;// 看看下面getViewFile的实现&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;include&lt;/span&gt;($this-&amp;gt;getViewFile($view,$data[&lt;span style="color: #a31515"&gt;&amp;#39;code&amp;#39;&lt;/span&gt;]));
    }
}

&lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; getViewFile($view,$code)
{
    $viewPaths=&lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(
        Yii::app()-&amp;gt;getTheme()===&lt;span style="color: #0000ff"&gt;null&lt;/span&gt; ? &lt;span style="color: #0000ff"&gt;null&lt;/span&gt; :  Yii::app()-&amp;gt;getTheme()-&amp;gt;getSystemViewPath(),
        Yii::app() instanceof CWebApplication ? Yii::app()-&amp;gt;getSystemViewPath() : &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;,
        YII_PATH.DIRECTORY_SEPARATOR.&lt;span style="color: #a31515"&gt;&amp;#39;views&amp;#39;&lt;/span&gt;,
    );

    &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($viewPaths &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $i=&amp;gt;$viewPath)
    {
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($viewPath!==&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
        {
             &lt;span style="color: #008000"&gt;// 看看下面getViewFileInternal的实现&lt;/span&gt;
             $viewFile=$this-&amp;gt;getViewFileInternal($viewPath,$view,$code,$i===2?&lt;span style="color: #a31515"&gt;&amp;#39;en_us&amp;#39;&lt;/span&gt;:&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;);
             &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(is_file($viewFile))
                 &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; $viewFile;
        }
    }
}

&lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; getViewFileInternal($viewPath,$view,$code,$srcLanguage=&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
{
    $app=Yii::app();
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($view===&lt;span style="color: #a31515"&gt;&amp;#39;error&amp;#39;&lt;/span&gt;)
    {
        $viewFile=$app-&amp;gt;findLocalizedFile($viewPath.DIRECTORY_SEPARATOR.&lt;span style="color: #a31515"&gt;&amp;quot;error{&lt;/span&gt;$code&lt;span style="color: #a31515"&gt;}.php&amp;quot;&lt;/span&gt;,$srcLanguage);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!is_file($viewFile))
            $viewFile=$app-&amp;gt;findLocalizedFile($viewPath.DIRECTORY_SEPARATOR.&lt;span style="color: #a31515"&gt;&amp;#39;error.php&amp;#39;&lt;/span&gt;,$srcLanguage);
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        $viewFile=$viewPath.DIRECTORY_SEPARATOR.&lt;span style="color: #a31515"&gt;&amp;quot;exception.php&amp;quot;&lt;/span&gt;;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; $viewFile;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码的逻辑是 - 对于error类型的信息，Yii会依次在以下目录中寻找名为&lt;code&gt;error{$code}.php&lt;/code&gt;文件来展示错误/异常信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WebRoot/themes/ThemeName/views/system&lt;/li&gt;
&lt;li&gt;WebRoot/protected/views/system&lt;/li&gt;
&lt;li&gt;yii/framework/views&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有找到，则以相同的次序在这些目录中查找&lt;code&gt;error.php&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;对于exception类型信息，则是查找&lt;code&gt;exception.php&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;所以如果应用开发过程需要定制4xx、5xx的错误页面，可以在&lt;code&gt;WebRoot/protected/views/system&lt;/code&gt;或&lt;code&gt;WebRoot/themes/ThemeName/views/system&lt;/code&gt;放置对应的错误模板页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;displayError&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; displayError($code,$message,$file,$line)
{
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(YII_DEBUG)
    {
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;h1&amp;gt;PHP Error [$code]&amp;lt;/h1&amp;gt;\n&amp;quot;&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;p&amp;gt;$message ($file:$line)&amp;lt;/p&amp;gt;\n&amp;quot;&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;pre&amp;gt;&amp;#39;&lt;/span&gt;;

        $trace=debug_backtrace();
        &lt;span style="color: #008000"&gt;// skip the first 3 stacks as they do not tell the error position&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(count($trace)&amp;gt;3)
            $trace=array_slice($trace,3);
        &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($trace &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $i=&amp;gt;$t)
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]))
                $t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]))
                $t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]=0;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]))
                $t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]=&lt;span style="color: #a31515"&gt;&amp;#39;unknown&amp;#39;&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;#$i {&lt;/span&gt;$t[&lt;span style="color: #a31515"&gt;&amp;#39;file&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}({&lt;/span&gt;$t[&lt;span style="color: #a31515"&gt;&amp;#39;line&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}): &amp;quot;&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(isset($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]) &amp;amp;&amp;amp; is_object($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]))
                &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; get_class($t[&lt;span style="color: #a31515"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;]).&lt;span style="color: #a31515"&gt;&amp;#39;-&amp;gt;&amp;#39;&lt;/span&gt;;
            &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;{&lt;/span&gt;$t[&lt;span style="color: #a31515"&gt;&amp;#39;function&amp;#39;&lt;/span&gt;]&lt;span style="color: #a31515"&gt;}()\n&amp;quot;&lt;/span&gt;;
        }

        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;/pre&amp;gt;&amp;#39;&lt;/span&gt;;
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
    {
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;h1&amp;gt;PHP Error [$code]&amp;lt;/h1&amp;gt;\n&amp;quot;&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;p&amp;gt;$message&amp;lt;/p&amp;gt;\n&amp;quot;&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;displayException&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; displayException($exception)
{
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(YII_DEBUG)
    {
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;h1&amp;gt;&amp;#39;&lt;/span&gt;.get_class($exception).&lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;/h1&amp;gt;\n&amp;quot;&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;p&amp;gt;&amp;#39;&lt;/span&gt;.$exception-&amp;gt;getMessage().&lt;span style="color: #a31515"&gt;&amp;#39; (&amp;#39;&lt;/span&gt;.$exception-&amp;gt;getFile().&lt;span style="color: #a31515"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;.$exception-&amp;gt;getLine().&lt;span style="color: #a31515"&gt;&amp;#39;)&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;pre&amp;gt;&amp;#39;&lt;/span&gt;.$exception-&amp;gt;getTraceAsString().&lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;/pre&amp;gt;&amp;#39;&lt;/span&gt;;
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
    {
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;h1&amp;gt;&amp;#39;&lt;/span&gt;.get_class($exception).&lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;/h1&amp;gt;\n&amp;quot;&lt;/span&gt;;
        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;p&amp;gt;&amp;#39;&lt;/span&gt;.$exception-&amp;gt;getMessage().&lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;由上述分析可知，基于Yii框架开发应用时，有以下几点注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过配置组件&lt;code&gt;errorHandler&lt;/code&gt;的&lt;code&gt;errorAction&lt;/code&gt;属性来定制异常/错误处理过程&lt;/li&gt;
&lt;li&gt;可以通过在&lt;code&gt;WebRoot/themes/ThemeName/views/system&lt;/code&gt;或&lt;code&gt;WebRoot/protected/views/system&lt;/code&gt;放置模板（名为&lt;code&gt;error{$code}.php&lt;/code&gt;）来定制错误/异常展示方式&lt;/li&gt;
&lt;li&gt;在有意抛出异常由Yii框架捕获时，需明确异常的类型是否应为&lt;code&gt;CHttpException&lt;/code&gt;，只有&lt;code&gt;CHttpException&lt;/code&gt;实例初始化时指定的code才能成为HTTP响应码&lt;/li&gt;
&lt;li&gt;可以对事件&lt;code&gt;onError&lt;/code&gt;、&lt;code&gt;onException&lt;/code&gt;绑定事件处理过程，进行额外的处理，比如记录错误/异常、触发告警等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/zh/book.errorfunc.php"&gt;PHP手册 - 错误处理和日志记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.yiiframework.com/doc/guide/1.1/en/topics.error"&gt;Error Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/assets/uploads/files/PHP-Debug-Manual-public.pdf"&gt;PHP调试技术手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>一行式并行方案（译）</title><link href="http://youngsterxyf.github.io/2015/09/11/parallelism-in-one-line/" rel="alternate"></link><published>2015-09-11T00:00:00+08:00</published><updated>2015-09-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-09-11:/2015/09/11/parallelism-in-one-line/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://chriskiehl.com/article/parallelism-in-one-line/"&gt;Parallelism in one line&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在并行处理能力方面，Python的声名并不太好。不考虑关于线程和GIL（多数情况下是合理的）的标准论据，我认为Python中关于并行的真正问题并不是一个技术问题，而是教学 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://chriskiehl.com/article/parallelism-in-one-line/"&gt;Parallelism in one line&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在并行处理能力方面，Python的声名并不太好。不考虑关于线程和GIL（多数情况下是合理的）的标准论据，我认为Python中关于并行的真正问题并不是一个技术问题，而是教学问题。围绕Python线程和多进程的常见教程，一般都写得不错，但也令人乏味 - 激烈非凡，对日常真正有用的东西却很少涉及。&lt;/p&gt;
&lt;h4&gt;沿袭的例子&lt;/h4&gt;
&lt;p&gt;在DuckDuckGo（DDG）中搜索“Python多线程教程”，简单调查一下排在前面的结果，就会发现它们给出的都是同样基于Class + Queue的示例。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;介绍threading/multiprocessing、生产者/消费者的真实示例代码：&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# coding: utf-8&lt;/span&gt;
&lt;span style="color: #008000"&gt;# Example.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;标准的多线程生产者/消费者模式&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; time 
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; threading 
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Queue 

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Consumer&lt;/span&gt;(threading.Thread): 
  &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, queue): 
    threading.Thread.__init__(self)
    self._queue = queue 

  &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; run(self):
    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;: 
      &lt;span style="color: #008000"&gt;# queue.get() 会阻塞当前线程，直到获取到一个数据项&lt;/span&gt;
      msg = self._queue.get() 
      &lt;span style="color: #008000"&gt;# 检查当前消息是否是个“毒药丸”&lt;/span&gt;
      &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; isinstance(msg, str) &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; msg == &lt;span style="color: #a31515"&gt;&amp;#39;quit&amp;#39;&lt;/span&gt;:
        &lt;span style="color: #008000"&gt;# 如果是，则退出循环&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;
      &lt;span style="color: #008000"&gt;# “处理” (这里是打印)从队列中取出的数据项&lt;/span&gt;
      print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m a thread, and I received %s!!&amp;quot;&lt;/span&gt; % msg
    &lt;span style="color: #008000"&gt;# 我始终是这么的友好&lt;/span&gt;
    print &lt;span style="color: #a31515"&gt;&amp;#39;Bye byes!&amp;#39;&lt;/span&gt;


&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; Producer():
  &lt;span style="color: #008000"&gt;# Queue用于在线程之间共享数据项&lt;/span&gt;
  queue = Queue.Queue()

  &lt;span style="color: #008000"&gt;# 创建一个工作实例&lt;/span&gt;
  worker = Consumer(queue)
  &lt;span style="color: #008000"&gt;# start方法会调用内部的run()方法来开启线程&lt;/span&gt;
  worker.start() 

  &lt;span style="color: #008000"&gt;# 变量，用于追踪开始的时间&lt;/span&gt;
  start_time = time.time() 
  &lt;span style="color: #008000"&gt;# 在5秒之内&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; time.time() - start_time &amp;lt; 5: 
    &lt;span style="color: #008000"&gt;# “生产”一块工作，放入队列中，由消费者来处理&lt;/span&gt;
    queue.put(&lt;span style="color: #a31515"&gt;&amp;#39;something at %s&amp;#39;&lt;/span&gt; % time.time())
    &lt;span style="color: #008000"&gt;# 睡眠一会儿，以避免过多的消息&lt;/span&gt;
    time.sleep(1)

  &lt;span style="color: #008000"&gt;# 这是杀死线程的“毒药丸”方式&lt;/span&gt;
  queue.put(&lt;span style="color: #a31515"&gt;&amp;#39;quit&amp;#39;&lt;/span&gt;)
  &lt;span style="color: #008000"&gt;# 等待线程关闭&lt;/span&gt;
  worker.join()


&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
  Producer()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;嗯...闻闻，代码中一股子Java的气息。&lt;/p&gt;
&lt;p&gt;我不想让大家觉得好像我认为生产者/消费者是处理线程/多进程的错误方式 - 因为确实不是。实际上，对多种问题来说，这种方式非常适合。然而，我认为：对于日常的脚本程序来说，这种方式并非是最有用的。&lt;/p&gt;
&lt;h4&gt;问题（我认为的）&lt;/h4&gt;
&lt;p&gt;其一，为了做点有用的事情，你得搞一个公式化的类；其二，你得维护一个队列（Queue），用于传送对象；这些齐备之后，在队列管道的两端还得准备方法来做真正的工作（如果希望有两种方式来通信或者准备存储结果，可能还得引入另一个队列）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多的工作者，更多的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于此，下一件你想要做的事情就是搞一个工作者类的池，来加速你的Python程序。在关于线程的IBM教程中，给出了一个示例代码，以下是其变种。这是一个常见的应用场景 - 在多个线程上分配获取网页的任务。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# coding: utf-8&lt;/span&gt;
&lt;span style="color: #008000"&gt;# Example2.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;一个更加实际的线程池示例&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; time 
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; threading 
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Queue 
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; urllib2 

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Consumer&lt;/span&gt;(threading.Thread): 
  &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, queue): 
    threading.Thread.__init__(self)
    self._queue = queue 

  &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; run(self):
    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;: 
      content = self._queue.get() 
      &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; isinstance(content, str) &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; content == &lt;span style="color: #a31515"&gt;&amp;#39;quit&amp;#39;&lt;/span&gt;:
        &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;
      response = urllib2.urlopen(content)
    print &lt;span style="color: #a31515"&gt;&amp;#39;Bye byes!&amp;#39;&lt;/span&gt;


&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; Producer():
  urls = [
    &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;http://www.yahoo.com&amp;#39;&lt;/span&gt;
    &lt;span style="color: #a31515"&gt;&amp;#39;http://www.scala.org&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;http://www.google.com&amp;#39;&lt;/span&gt;
    &lt;span style="color: #008000"&gt;# 等等... &lt;/span&gt;
  ]
  queue = Queue.Queue()
  worker_threads = build_worker_pool(queue, 4)
  start_time = time.time()

  &lt;span style="color: #008000"&gt;# 加入待处理的URL&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; url &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; urls: 
    queue.put(url)
  &lt;span style="color: #008000"&gt;# 加入毒药丸&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; worker &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; worker_threads:
    queue.put(&lt;span style="color: #a31515"&gt;&amp;#39;quit&amp;#39;&lt;/span&gt;)
  &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; worker &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; worker_threads:
    worker.join()

  print &lt;span style="color: #a31515"&gt;&amp;#39;Done! Time taken: {}&amp;#39;&lt;/span&gt;.format(time.time() - start_time)

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; build_worker_pool(queue, size):
  workers = []
  &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; _ &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range(size):
    worker = Consumer(queue)
    worker.start() 
    workers.append(worker)
  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; workers

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
  Producer()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;奏效了，但是你看看这些代码！准备（setup）方法、一组要追踪的线程，最糟糕的是，若有任何地方易发生死锁，就会产生一堆的join状态说明。自此，一切只会更复杂！&lt;/p&gt;
&lt;p&gt;到目前为止，完成了些什么？啥都没有。上面的代码纯粹只是把所有东西像用纸糊起来一样（Just about everything in the above code is pure plumbing，如何翻译？）。这是另一种公式化的写法，也易发生错误（嘿，在写这个代码时，我甚至忘了在队列对象上调用task_done()（我懒得去解决这个问题然后再搞个截图）），付出很多，得到的却很少。幸运的是，我们有更好的方式。&lt;/p&gt;
&lt;h2&gt;引入：Map&lt;/h2&gt;
&lt;p&gt;Map是一个酷酷的小东西，也是在Python代码轻松引入并行的关键。对此不熟悉的人会认为map是从函数式语言（如Lisp）借鉴来的东西。map是一个函数 - 将另一个函数映射到一个序列上。例如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;urls = [&lt;span style="color: #a31515"&gt;&amp;#39;http://www.yahoo.com&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;http://www.reddit.com&amp;#39;&lt;/span&gt;]
results = map(urllib2.urlopen, urls)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码在传入序列的每个元素上应用方法&lt;em&gt;urlopen&lt;/em&gt;，并将所有结果存入一个列表中。大致与下面这段代码的逻辑相当：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;results = []
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; url &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; urls: 
    results.append(urllib2.urlopen(url))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Map会为我们处理在序列上的迭代，应用函数，最后将结果存入一个方便使用的列表。&lt;/p&gt;
&lt;p&gt;这为什么重要呢？因为利用恰当的库，map让并行处理成为小事一桩！&lt;/p&gt;
&lt;p&gt;&lt;img alt="map-function" src="https://i.loli.net/2020/06/14/kqumnip3B7M2dcQ.png"&gt;&lt;/p&gt;
&lt;p&gt;Python标准库中&lt;em&gt;multiprocessing&lt;/em&gt;模块，以及极少人知但同样出色的子模块&lt;em&gt;multiprocessing.dummy&lt;/em&gt;，提供了map函数的并行版本。&lt;/p&gt;
&lt;p&gt;题外话：这是啥？你从未听说过这名为dummy的mulprocessing模块的线程克隆版本？我也是最近才知道的。在multiprocessing文档页中仅有一句提到这个子模块，而这句话基本可以归结为“哦，是的，存在这样一个东西”。完全低估了这个模块的价值！&lt;/p&gt;
&lt;p&gt;Dummy是multiprocessing模块的精确克隆，唯一的区别是：multiprocessing基于进程工作，而dummy模块使用线程（也就带来了常见的Python限制）。因此，任何东西可套用到一个模块，也就可以套用到另一个模块。在两个模块之间来回切换也就相当容易，当你不太确定一些框架调用是IO密集型还是CPU密集型时，想做探索性质的编程，这一点会让你觉得非常赞！&lt;/p&gt;
&lt;h4&gt;开始&lt;/h4&gt;
&lt;p&gt;为了访问map函数的并行版本，首先需要导入包含它的模块：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 以下两行引入其一即可&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; ThreadPool
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;并实例化池对象：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 译注：这里其实是以dummy模块为例&lt;/span&gt;
pool = ThreadPool()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这一句代码处理了example2.py中7行的&lt;em&gt;build_worker_pool&lt;/em&gt;函数完成的所有事情。如名所示，这句代码会创建一组可用的工作者，启动它们来准备工作，并将它们存入变量中，方便访问。&lt;/p&gt;
&lt;p&gt;pool对象可以有若干参数，但目前，只需关注第一个：进程/线程数量。这个参数用于设置池中的工作者数目。如果留空，默认为机器的CPU核数。&lt;/p&gt;
&lt;p&gt;一般来说，如果为CPU密集型任务使用进程池（multiprocessing pool），更多的核等于更快的速度（但有一些注意事项）。然而，当使用线程池（threading）处理网络密集型任务时，情况就很不一样了，因此最好试验一下池的最佳大小。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pool = ThreadPool(4) &lt;span style="color: #008000"&gt;# 将池的大小设置为4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果运行了过多的线程，就会浪费时间在线程切换上，而不是做有用的事情，所以可以把玩把玩直到找到最适合任务的线程数量。&lt;/p&gt;
&lt;p&gt;现在池对象创建好了，简单的并行也是弹指之间的事情了，那来重写example2.py吧。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; urllib2 
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; ThreadPool 

urls = [
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org&amp;#39;&lt;/span&gt;, 
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org/about/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org/doc/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org/download/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org/getit/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org/community/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;https://wiki.python.org/moin/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://planet.python.org/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;https://wiki.python.org/moin/LocalUserGroups&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org/psf/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://docs.python.org/devguide/&amp;#39;&lt;/span&gt;,
  &lt;span style="color: #a31515"&gt;&amp;#39;http://www.python.org/community/awards/&amp;#39;&lt;/span&gt;
  &lt;span style="color: #008000"&gt;# 等等...&lt;/span&gt;
  ]

&lt;span style="color: #008000"&gt;# 创建一个工作者线程池&lt;/span&gt;
pool = ThreadPool(4) 
&lt;span style="color: #008000"&gt;# 在各个线程中打开url，并返回结果&lt;/span&gt;
results = pool.map(urllib2.urlopen, urls)
&lt;span style="color: #008000"&gt;#close the pool and wait for the work to finish&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 关闭线程池，等待工作结束&lt;/span&gt;
pool.close() 
pool.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看看！真正做事情的代码仅有4行，其中3行只是简单的辅助功能。&lt;em&gt;map&lt;/em&gt;调用轻松搞定了之前示例40行代码做的事情！觉得好玩，我对两种方式进行了时间测量，并使用了不同的池大小。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 译注：我觉得与串行处理方式对比意义不大，应该和队列的方式进行性能对比&lt;/span&gt;
results = [] 
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; url &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; urls:
  result = urllib2.urlopen(url)
  results.append(result)

&lt;span style="color: #008000"&gt;# # ------- 对比 ------- # &lt;/span&gt;


&lt;span style="color: #008000"&gt;# # ------- 池的大小为4 ------- # &lt;/span&gt;
pool = ThreadPool(4) 
results = pool.map(urllib2.urlopen, urls)

&lt;span style="color: #008000"&gt;# # ------- 池的大小为8 ------- # &lt;/span&gt;

pool = ThreadPool(8) 
results = pool.map(urllib2.urlopen, urls)

&lt;span style="color: #008000"&gt;# # ------- 池的大小为13 ------- # &lt;/span&gt;

pool = ThreadPool(13) 
results = pool.map(urllib2.urlopen, urls)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;单线程&lt;/span&gt;: 14.4 &lt;span style="border: 1px solid #FF0000"&gt;秒&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;池大小为&lt;/span&gt;4&lt;span style="border: 1px solid #FF0000"&gt;时：&lt;/span&gt;3.1 &lt;span style="border: 1px solid #FF0000"&gt;秒&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;池大小为&lt;/span&gt;8&lt;span style="border: 1px solid #FF0000"&gt;时：&lt;/span&gt;1.4 &lt;span style="border: 1px solid #FF0000"&gt;秒&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;池大小为&lt;/span&gt;13&lt;span style="border: 1px solid #FF0000"&gt;时：&lt;/span&gt;1.3&lt;span style="border: 1px solid #FF0000"&gt;秒&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;真是呱呱叫啊！也说明了试验不同的池大小是有必要的。在我的机器上，池的大小大于9后会导致性能退化（译注：咦，结果不是显示13比8的性能要好么？）。&lt;/p&gt;
&lt;h2&gt;现实中的Example 2&lt;/h2&gt;
&lt;p&gt;为千张图片创建缩略图。&lt;/p&gt;
&lt;p&gt;来做点CPU密集型的事情！对于我，在工作中常见的任务是操作大量的图片目录。其中一种图片转换是创建缩略图。这项工作适于并行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本的单进程设置&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool 
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; PIL &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Image

SIZE = (75,75)
SAVE_DIRECTORY = &lt;span style="color: #a31515"&gt;&amp;#39;thumbs&amp;#39;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; get_image_paths(folder):
  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (os.path.join(folder, f) 
      &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; f &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; os.listdir(folder) 
      &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;jpeg&amp;#39;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; f)

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; create_thumbnail(filename): 
  im = Image.open(filename)
  im.thumbnail(SIZE, Image.ANTIALIAS)
  base, fname = os.path.split(filename) 
  save_path = os.path.join(base, SAVE_DIRECTORY, fname)
  im.save(save_path)

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
  folder = os.path.abspath(
    &lt;span style="color: #a31515"&gt;&amp;#39;11_18_2013_R000_IQM_Big_Sur_Mon__e10d1958e7b766c3e840&amp;#39;&lt;/span&gt;)
  os.mkdir(os.path.join(folder, SAVE_DIRECTORY))

  images = get_image_paths(folder)

  &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; image &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; images: 
    create_thumbnail(image)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;示例代码中用了一些技巧，但大体上是：向程序传入一个目录，从目录中获取所有图片，然后创建缩略图，并将缩略图存放到各自的目录中。&lt;/p&gt;
&lt;p&gt;在我的机器上，这个程序处理大约6000张图片，花费27.9秒。&lt;/p&gt;
&lt;p&gt;如果使用一个并行的map调用来替换&lt;em&gt;for&lt;/em&gt;循环：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool 
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; PIL &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Image

SIZE = (75,75)
SAVE_DIRECTORY = &lt;span style="color: #a31515"&gt;&amp;#39;thumbs&amp;#39;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; get_image_paths(folder):
  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (os.path.join(folder, f) 
      &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; f &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; os.listdir(folder) 
      &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;jpeg&amp;#39;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; f)

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; create_thumbnail(filename): 
  im = Image.open(filename)
  im.thumbnail(SIZE, Image.ANTIALIAS)
  base, fname = os.path.split(filename) 
  save_path = os.path.join(base, SAVE_DIRECTORY, fname)
  im.save(save_path)

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
  folder = os.path.abspath(
    &lt;span style="color: #a31515"&gt;&amp;#39;11_18_2013_R000_IQM_Big_Sur_Mon__e10d1958e7b766c3e840&amp;#39;&lt;/span&gt;)
  os.mkdir(os.path.join(folder, SAVE_DIRECTORY))

  images = get_image_paths(folder)

  pool = Pool()
  pool.map(create_thumbnail, images)
  pool.close() 
  pool.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.6秒！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仅修改几行代码就能得到巨大的速度提升。这个程序的生产环境版本通过切分CPU密集型工作和IO密集型工作并分配到各自的进程和线程（通常是死锁代码的一个因素），获得更快的速度。然而，由于map性质清晰明确，无需手动管理线程，以干净、可靠、易于调试的方式混合匹配两者（译注：这里的“两者”是指什么？CPU密集型工作和IO密集型工作？），也是相当容易的。&lt;/p&gt;
&lt;p&gt;就是这样了。（几乎）一行式并行解决方案。&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="翻译"></category><category term="并行"></category></entry><entry><title>那些Python党踩过的PHP坑</title><link href="http://youngsterxyf.github.io/2015/09/05/php-trap-and-tip/" rel="alternate"></link><published>2015-09-05T00:00:00+08:00</published><updated>2015-09-05T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-09-05:/2015/09/05/php-trap-and-tip/</id><summary type="html">&lt;p&gt;一看题目貌似本文要准备吐槽PHP，但遇到“坑”主要是因为个人经验不足。&lt;/p&gt;
&lt;h4&gt;JSON反序列化 json_decode&lt;/h4&gt;
&lt;p&gt;函数 &lt;code&gt;json_decode&lt;/code&gt; 默认反序列化的结果是对象。Python党在做PHP开发用到这个方法时，很可能 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;一看题目貌似本文要准备吐槽PHP，但遇到“坑”主要是因为个人经验不足。&lt;/p&gt;
&lt;h4&gt;JSON反序列化 json_decode&lt;/h4&gt;
&lt;p&gt;函数 &lt;code&gt;json_decode&lt;/code&gt; 默认反序列化的结果是对象。Python党在做PHP开发用到这个方法时，很可能会跳进这个坑，认为结果应该是个数组，因为Python中json.loads返回的是一个字典。 &lt;code&gt;json_decode&lt;/code&gt; 的第二个参数 $assoc 可用来指定反序列化的结果为数组。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href="http://php.net/manual/zh/function.json-decode.php"&gt;http://php.net/manual/zh/function.json-decode.php&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;数组序列化&lt;/h4&gt;
&lt;p&gt;Python党初学PHP，可能类比于Python的列表和字典，认为PHP中明确区分索引数组和关联数组。但：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP 实际并不区分索引数组和关联数组，都是一种有序映射。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然很多时候索引数组和关联数组在表现上是不一样的，比如对以下两个数组进行序列化：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$arrA = &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; json_encode($arrA) . &lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;

$arrB = &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; =&amp;gt; 1, &lt;span style="color: #a31515"&gt;&amp;#39;b&amp;#39;&lt;/span&gt; =&amp;gt; 2, &lt;span style="color: #a31515"&gt;&amp;#39;c&amp;#39;&lt;/span&gt; =&amp;gt; 3);
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; json_encode($arrB) . &lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]&lt;/span&gt;
{&amp;quot;a&amp;quot;:1,&amp;quot;b&amp;quot;:2,&amp;quot;c&amp;quot;:3}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果把序列化的结果作为JSON输出到前端，对于JS来说，是两种不同的数据结构：数组和对象。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;$arrA&lt;/code&gt; 的初始化值是 &lt;code&gt;array(0 =&amp;gt; 'a', 1 =&amp;gt; 'b', 2 =&amp;gt; 'c')&lt;/code&gt; 的简写方式。&lt;/p&gt;
&lt;p&gt;再来看另一段程序：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$arrA = array(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;);
echo json_encode($arrA) . &amp;quot;\n&amp;quot;;

$arrA = array(0 =&amp;gt; &amp;#39;a&amp;#39;, 1 =&amp;gt; &amp;#39;b&amp;#39;, 2 =&amp;gt; &amp;#39;c&amp;#39;);
echo json_encode($arrA) . &amp;quot;\n&amp;quot;;

$arrA = array(1 =&amp;gt; &amp;#39;a&amp;#39;, 2 =&amp;gt; &amp;#39;b&amp;#39;, 3 =&amp;gt; &amp;#39;c&amp;#39;);
echo json_encode($arrA) . &amp;quot;\n&amp;quot;;

$arrA = array(0 =&amp;gt; &amp;#39;a&amp;#39;, 2 =&amp;gt; &amp;#39;b&amp;#39;, 3 =&amp;gt; &amp;#39;c&amp;#39;);
echo json_encode($arrA) . &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]&lt;/span&gt;
{&amp;quot;1&amp;quot;:&amp;quot;a&amp;quot;,&amp;quot;2&amp;quot;:&amp;quot;b&amp;quot;,&amp;quot;3&amp;quot;:&amp;quot;c&amp;quot;}
{&amp;quot;0&amp;quot;:&amp;quot;a&amp;quot;,&amp;quot;2&amp;quot;:&amp;quot;b&amp;quot;,&amp;quot;3&amp;quot;:&amp;quot;c&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从输出可以知道：仅当数组的key是从0开始的整数，并且key连续不间断，对其序列化的结果才是JS中的数组，也就是通常认为的PHP索引数组。&lt;/p&gt;
&lt;p&gt;这个坑可能在某些时候不小心就掉进去了，比如我曾对一个索引数组应用array_filter函数操作，然后json_encode序列化输出到前端，认为前端反序列化出来的是一个数组，没想到却是个对象。&lt;/p&gt;
&lt;p&gt;函数&lt;code&gt;array_filter&lt;/code&gt;的文档说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;array array_filter ( array $input [, callable $callback = "" ] )&lt;/p&gt;
&lt;p&gt;依次将 input 数组中的每个值传递到 callback 函数。如果 callback 函数返回 TRUE，则 input 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意是对值进行filter，结果中值原本对应的key不变，而不是使用新的key。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href="http://php.net/manual/zh/language.types.array.php"&gt;http://php.net/manual/zh/language.types.array.php&lt;/a&gt;，&lt;a href="http://php.net/manual/zh/function.array-filter.php"&gt;http://php.net/manual/zh/function.array-filter.php&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;引用传递&lt;/h4&gt;
&lt;p&gt;先来看一段代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;CommonUtils&lt;/span&gt; {
    &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; $TASK_INTERVAL_SEMANTIC_INT_MAPPER = &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(
        &lt;span style="color: #a31515"&gt;&amp;#39;PER_DAY&amp;#39;&lt;/span&gt; =&amp;gt; 86400,
        &lt;span style="color: #a31515"&gt;&amp;#39;TWO_DAY&amp;#39;&lt;/span&gt; =&amp;gt; 172800,
        &lt;span style="color: #a31515"&gt;&amp;#39;PER_WEEK&amp;#39;&lt;/span&gt; =&amp;gt; 604800,
        &lt;span style="color: #a31515"&gt;&amp;#39;TWO_WEEK&amp;#39;&lt;/span&gt; =&amp;gt; 1209600,
        &lt;span style="color: #a31515"&gt;&amp;#39;PER_MONTH&amp;#39;&lt;/span&gt; =&amp;gt; 2592000,
    );
}
$ha = array_pop(array_keys(CommonUtils::$TASK_INTERVAL_SEMANTIC_INT_MAPPER));
var_dump($ha);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code&gt;error_reporting = E_ALL&lt;/code&gt; 时，上面的代码会抛出一个严格模式错误：&lt;code&gt;Only variables should be passed by reference&lt;/code&gt; 。这是为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/zh/language.references.pass.php"&gt;PHP文档&lt;/a&gt;中说明只有三种内容可以通过引用传递：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量，例如 foo($a)&lt;/li&gt;
&lt;li&gt;New 语句，例如 foo(new foobar())&lt;/li&gt;
&lt;li&gt;从函数中返回的引用，例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; &amp;amp;bar()
{
    $a = 5;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; $a;
}
foo(bar());
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;任何其它表达式都不能通过引用传递，结果未定义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面代码中 &lt;code&gt;$ha = array_pop(array_keys(CommonUtils::$TASK_INTERVAL_SEMANTIC_INT_MAPPER));&lt;/code&gt; 一行，调用了 &lt;code&gt;array_pop&lt;/code&gt; 和 &lt;code&gt;array_keys&lt;/code&gt;，&lt;code&gt;array_pop&lt;/code&gt; 的函数签名为：&lt;code&gt;mixed array_pop ( array &amp;amp;$array )&lt;/code&gt; ，但 &lt;code&gt;array_keys&lt;/code&gt; 函数调用返回的是一个array值，不属于上面列出三种内容，所以会抛错。但 &lt;strong&gt;这个情况下这种错误&lt;/strong&gt; 的级别不同版本的PHP也不一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自 PHP 5.0.5 起导致致命错误&lt;/li&gt;
&lt;li&gt;自 PHP 5.1.1 起导致严格模式错误&lt;/li&gt;
&lt;li&gt;自 PHP 7.0 起导致 notice 信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但如果直接给 &lt;code&gt;array_pop&lt;/code&gt; 传递一个数组值，则会导致致命错误，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
array_pop(&lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(1, 2, 3, 4));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;会抛出错误：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;PHP Fatal error:  Only variables can be passed by reference &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; /Users/xiayf/test.php on line 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文档：&lt;a href="http://php.net/manual/zh/language.references.php"&gt;http://php.net/manual/zh/language.references.php&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="笔记"></category></entry><entry><title>编程名言集锦（译）</title><link href="http://youngsterxyf.github.io/2015/06/02/programming-quotes/" rel="alternate"></link><published>2015-06-02T00:00:00+08:00</published><updated>2015-06-02T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-06-02:/2015/06/02/programming-quotes/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://quotes.cat-v.org/programming/"&gt;Programming Quotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C.A.R. Hoare, The 1980 ACM Turing Award Lecture&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://quotes.cat-v.org/programming/"&gt;Programming Quotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C.A.R. Hoare, The 1980 ACM Turing Award Lecture&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有两种软件设计的方式：一种是使它足够简单以致于明显没有缺陷，另一种则是使它足够复杂以致于没有明显的缺陷。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;E.W.Dijkstra&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The computing scientist's main challenge is not to get confused by the complexities of his own making.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;计算科学家的主要挑战是不要被他自己造成的复杂性搞糊涂了。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gordon Bell&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The cheapest, fastest, and most reliable components are those that aren't there.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最廉价，最快速，并且最可靠的部件是那些还没被使用的。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="http://genius.cat-v.org/ken-thompson/"&gt;Ken Thompson&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;One of my most productive days was throwing away 1000 lines of code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我最多产的一天抛弃了1000行代码。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="http://genius.cat-v.org/ken-thompson/"&gt;Ken Thompson&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;When in doubt, use brute force.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若无把握，暴力破解。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Jeff Sickel&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Deleted code is debugged code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要调试的代码都应该删除。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Brian W. Kernighan, P. J. Plauger&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调试的难度两倍于一开始的写代码。因此，如果你尽可能巧妙地编写代码，根据定义，说明你还不具备足够的智商来调试它。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Brian W. Kernighan&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The most effective debugging tool is still careful thought, coupled with judiciously placed print statements.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最有效的调试工具是静下心来仔细思考，辅之审慎地放置打印语句。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Brian W. Kernighan&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Controlling complexity is the essence of computer programming. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;计算机编程的本质是控制复杂度。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;David Gelernter&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Beauty is more important in computing than anywhere else in technology because software is so complicated. Beauty is the ultimate defence against complexity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相比其他技术领域，美对于计算来说更为重要，因为软件超乎寻常的复杂，而美是对复杂性的一种终极防御。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Doug Gwyn&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;UNIX was not designed to stop its users from doing stupid things, as that would also stop them from doing clever things.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UNIX并不会阻止用户干蠢事，因为那样也会阻碍用户做些聪明的事情。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;John Carmack&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;If you're willing to restrict the flexibility of your approach, you can almost always do something better. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限制方法的灵活性几乎总会让你把事情做得更好。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;John Osterhout&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;A program that produces incorrect result twice as fast is infinitely slower.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果不对，程序再快都顶个屁用。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Geer et al.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The central enemy of reliability is complexity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可靠的最大敌人是复杂。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Edsger W. Dijkstra&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Simplicity is prerequisite for reliability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单是可靠的先决条件。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Peter Deutsch&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The Eight Fallacies of Distributed Computing&lt;/p&gt;
&lt;p&gt;Essentially everyone, when they first build a distributed application, makes the following eight assumptions. All prove to be false in the long run and all cause big trouble and painful learning experiences.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The network is reliable&lt;/li&gt;
&lt;li&gt;Latency is zero&lt;/li&gt;
&lt;li&gt;Bandwidth is infinite&lt;/li&gt;
&lt;li&gt;The network is secure&lt;/li&gt;
&lt;li&gt;Topology doesn't change&lt;/li&gt;
&lt;li&gt;There is one administrator&lt;/li&gt;
&lt;li&gt;Transport cost is zero&lt;/li&gt;
&lt;li&gt;The network is homogeneous&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;分布式计算的八大谬误&lt;/p&gt;
&lt;p&gt;实际上，每个人，当他第一次构建分布式应用时，都会作出如下八个假设。长远来看，这些假设都被证明是错误的，并且都造成了巨大的麻烦和沉痛的经验教训。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络可靠&lt;/li&gt;
&lt;li&gt;零延迟&lt;/li&gt;
&lt;li&gt;带宽无限&lt;/li&gt;
&lt;li&gt;安全网络&lt;/li&gt;
&lt;li&gt;拓扑不变&lt;/li&gt;
&lt;li&gt;有个管理者&lt;/li&gt;
&lt;li&gt;传输代价为零&lt;/li&gt;
&lt;li&gt;网络同构&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Jon Bentley, Doug Mcllroy&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The key to performance is elegance, not battalions of special cases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;性能的关键是优雅，而不是大堆的特殊情况。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bill Gates&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Measuring programming progress by lines of code is like measuring aircraft building progress by weight.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以代码行数来衡量程序设计的进度，就好比以重量来衡量飞机的制造进度。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;John Johnson&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;First, solve the problem. Then, write the code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，解决问题。而后，编写代码。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ken Thompson&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;You can't trust code that you did not totally create yourself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你不能信任非你完全自己写的代码。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sean Parent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Good code is short, simple, and symmetrical - the challenge is figuring out how to get there.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好的代码，短小、简洁，并且匀称 - 而真正的挑战在于弄清如何达到这些目标。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Voltaire&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The best is the enemy of the good.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;追求完美是优秀软件的敌人。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dr. Pamela Zave&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The purpose of software engineering is to control complexity, not to create it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件工程的目标是控制复杂度，而不是增加复杂性。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Olin Shivers&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;I object to doing things that computers can do.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我反对去做那些计算机可以做的事情。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;merb motto&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;No code is faster than no code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有什么代码会比没有代码速度更快。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dave Parnas&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;As a rule, software systems do not work well until they have been used, and have failed repeatedly, in real applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般说来，软件系统只有得到实际应用，并且经历多次失败，才能工作得很好。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RnRS&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序语言的设计不应该是特性的堆叠，而应该去除那些使得额外的特性显得必要的弱点和局限。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ryan Singer&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;So much complexity in software comes from trying to make one thing do two things.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件中如此多的复杂性皆来自于想在做一件事的同时多做几件事。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;未完待续&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="感悟"></category></entry><entry><title>Go并发编程基础（译）</title><link href="http://youngsterxyf.github.io/2015/05/20/fundamentals-of-concurrent-programming/" rel="alternate"></link><published>2015-05-20T00:00:00+08:00</published><updated>2015-05-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-05-20:/2015/05/20/fundamentals-of-concurrent-programming/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/"&gt;Fundamentals of concurrent programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是一篇并发编程方面的入门文章，以&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;编写示例代码，内容涵盖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行期并发线程（goroutines）&lt;/li&gt;
&lt;li&gt;基本的同步 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/"&gt;Fundamentals of concurrent programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是一篇并发编程方面的入门文章，以&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;编写示例代码，内容涵盖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行期并发线程（goroutines）&lt;/li&gt;
&lt;li&gt;基本的同步技术（管道和锁）&lt;/li&gt;
&lt;li&gt;Go语言中基本的并发模式&lt;/li&gt;
&lt;li&gt;死锁和数据竞争&lt;/li&gt;
&lt;li&gt;并行计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在开始阅读本文之前，你应该知道如何编写简单的Go程序。如果你熟悉的是C/C++、Java或Python之类的语言，那么 &lt;a href="http://tour.golang.org/welcome/1"&gt;Go语言之旅&lt;/a&gt; 能提供所有必要的背景知识。也许你还有兴趣读一读 &lt;a href="http://code.google.com/p/go-wiki/wiki/GoForCPPProgrammers"&gt;为C++程序员准备的Go语言教程&lt;/a&gt; 或 &lt;a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/"&gt;为Java程序员准备的Go语言教程&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;1. 运行期线程&lt;/h4&gt;
&lt;p&gt;Go允许使用&lt;code&gt;go&lt;/code&gt;语句开启一个新的运行期线程，即 &lt;a href="http://golang.org/ref/spec#Go_statements"&gt;goroutine&lt;/a&gt;，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。&lt;/p&gt;
&lt;p&gt;Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。&lt;/p&gt;
&lt;p&gt;下面所示程序会输出“Hello from main goroutine”。也可能会输出“Hello from another goroutine”，具体依赖于两个goroutine哪个先结束。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Hello from another goroutine&amp;quot;&lt;/span&gt;)
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Hello from main goroutine&amp;quot;&lt;/span&gt;)

    &lt;span style="color: #008000"&gt;// 至此，程序运行结束，&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// 所有活跃的goroutine被杀死&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/goroutine1.go"&gt;goroutine1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来的这个程序，多数情况下，会输出“Hello from main goroutine”和“Hello from another goroutine”，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Hello from another goroutine&amp;quot;&lt;/span&gt;)
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Hello from main goroutine&amp;quot;&lt;/span&gt;)

    time.Sleep(time.Second)        &lt;span style="color: #008000"&gt;// 等待1秒，等另一个goroutine结束&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/goroutine2.go"&gt;goroutine2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 函数Publish在给定时间过期后打印text字符串到标准输出&lt;/span&gt;
   &lt;span style="color: #008000"&gt;// 该函数并不会阻塞而是立即返回&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Publish(text &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, delay time.Duration) {
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
        time.Sleep(delay)
        fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;BREAKING NEWS:&amp;quot;&lt;/span&gt;, text)
    }()    &lt;span style="color: #008000"&gt;// 注意这里的括号。必须调用匿名函数&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish1.go"&gt;publish1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可能会这样使用&lt;code&gt;Publish&lt;/code&gt;函数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    Publish(&lt;span style="color: #a31515"&gt;&amp;quot;A goroutine starts a new thread of execution.&amp;quot;&lt;/span&gt;, 5*time.Second)
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Let’s hope the news will published before I leave.&amp;quot;&lt;/span&gt;)

    &lt;span style="color: #008000"&gt;// 等待发布新闻&lt;/span&gt;
    time.Sleep(10 * time.Second)

    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Ten seconds later: I’m leaving now.&amp;quot;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish1.go"&gt;publish1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ go run publish1.go
Let’s hope the news will published before I leave.
BREAKING NEWS: A goroutine starts a new thread of execution.
Ten seconds later: I’m leaving now.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 - 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。&lt;/p&gt;
&lt;h4&gt;2. 管道（channel）&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Sushi conveyor belt" src="http://www.nada.kth.se/~snilsson/concurrency/sushi-conveyor-belt.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/spec#Channel_types"&gt;管道&lt;/a&gt;是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;code&gt;&amp;lt;-&lt;/code&gt;用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; Sushi        &lt;span style="color: #008000"&gt;// 可用来发送和接收Sushi类型的值&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt;&amp;lt;- &lt;span style="color: #2b91af"&gt;float64&lt;/span&gt;    &lt;span style="color: #008000"&gt;// 仅可用来发送float64类型的值&lt;/span&gt;
&amp;lt;-&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;        &lt;span style="color: #008000"&gt;// 仅可用来接收int类型的值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;管道是引用类型，基于make函数来分配。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ic := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;)    &lt;span style="color: #008000"&gt;// 不带缓冲的int类型管道&lt;/span&gt;
wc := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; *Work, 10)    &lt;span style="color: #008000"&gt;// 带缓冲的Work类型指针管道&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果通过管道发送一个值，则将&lt;code&gt;&amp;lt;-&lt;/code&gt;作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ic &amp;lt;- 3        &lt;span style="color: #008000"&gt;// 往管道发送3&lt;/span&gt;
work := &amp;lt;-wc    &lt;span style="color: #008000"&gt;// 从管道接收一个指向Work类型值的指针&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭管道（Close）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/spec#Close"&gt;close&lt;/a&gt; 函数标志着不会再往某个管道发送值。在调用&lt;code&gt;close&lt;/code&gt;之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ch := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;)
&lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
    ch &amp;lt;- &lt;span style="color: #a31515"&gt;&amp;quot;Hello!&amp;quot;&lt;/span&gt;
    close(ch)
}()
fmt.Println(&amp;lt;-ch)    &lt;span style="color: #008000"&gt;// 输出字符串&amp;quot;Hello!&amp;quot;&lt;/span&gt;
fmt.Println(&amp;lt;-ch)    &lt;span style="color: #008000"&gt;// 输出零值 - 空字符串&amp;quot;&amp;quot;，不会阻塞&lt;/span&gt;
fmt.Println(&amp;lt;-ch)    &lt;span style="color: #008000"&gt;// 再次打印输出空字符串&amp;quot;&amp;quot;&lt;/span&gt;
v, ok := &amp;lt;-ch        &lt;span style="color: #008000"&gt;// 变量v的值为空字符串&amp;quot;&amp;quot;，变量ok的值为false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一个带有&lt;code&gt;range&lt;/code&gt;子句的&lt;code&gt;for&lt;/code&gt;语句会依次读取发往管道的值，直到该管道关闭：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    &lt;span style="color: #008000"&gt;// 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; ch &amp;lt;-&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; Sushi = Producer()
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; s := &lt;span style="color: #0000ff"&gt;range&lt;/span&gt; ch {
        fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Consumed&amp;quot;&lt;/span&gt;, s)
    }
}

&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Producer() &amp;lt;-&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; Sushi {
    ch := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; Sushi)
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;(){
        ch &amp;lt;- Sushi(&lt;span style="color: #a31515"&gt;&amp;quot;海老握り&amp;quot;&lt;/span&gt;)    &lt;span style="color: #008000"&gt;// Ebi nigiri&lt;/span&gt;
        ch &amp;lt;- Sushi(&lt;span style="color: #a31515"&gt;&amp;quot;鮪とろ握り&amp;quot;&lt;/span&gt;) &lt;span style="color: #008000"&gt;// Toro nigiri&lt;/span&gt;
        close(ch)
    }()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ch
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/sushi.go"&gt;sushi.go&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;3. 同步&lt;/h4&gt;
&lt;p&gt;下一个示例中，我们让&lt;code&gt;Publish&lt;/code&gt;函数返回一个管道 - 用于在发布text变量值时广播一条消息：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 在给定时间过期时，Publish函数会打印text变量值到标准输出&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 在text变量值发布后，该函数会关闭管道wait&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Publish(text &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, delay time.Duration) (wait &amp;lt;-&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt;{}) {
    ch := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt;{})
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
        time.Sleep(delay)
        fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;BREAKING NEWS:&amp;quot;&lt;/span&gt;, text)
        close(ch)    &lt;span style="color: #008000"&gt;// 广播 - 一个关闭的管道都会发送一个零值&lt;/span&gt;
    }()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ch
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish2.go"&gt;publish2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：我们使用了一个空结构体的管道：&lt;code&gt;struct{}&lt;/code&gt;。这明确地指明该管道仅用于发信号，而不是传递数据。&lt;/p&gt;
&lt;p&gt;我们可能会这样使用这个函数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    wait := Publish(&lt;span style="color: #a31515"&gt;&amp;quot;Channels let goroutines communicate.&amp;quot;&lt;/span&gt;, 5*time.Second)
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Waiting for the news...&amp;quot;&lt;/span&gt;)
    &amp;lt;-wait
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;The news is out, time to leave.&amp;quot;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish2.go"&gt;publish2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ go run publish2.go
Waiting for the news...
BREAKING NEWS: Channels let goroutines communicate.
The news is out, time to leave.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4. 死锁&lt;/h4&gt;
&lt;p&gt;&lt;img alt="traffic jam" src="http://www.nada.kth.se/~snilsson/concurrency/traffic-jam.jpg"&gt;&lt;/p&gt;
&lt;p&gt;现在我们在&lt;code&gt;Publish&lt;/code&gt;函数中引入一个bug：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Publish(text &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, delay time.Duration) (wait &amp;lt;-&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt;{}) {
    ch := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt;{})
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
        time.Sleep(delay)
        fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;BREAKING NEWS:&amp;quot;&lt;/span&gt;, text)
        &lt;span style="color: #008000"&gt;// 译注：注意这里将close函数调用注释掉了&lt;/span&gt;
        &lt;span style="color: #008000"&gt;//close(ch)&lt;/span&gt;
    }()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ch
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时&lt;code&gt;Publish&lt;/code&gt;函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    wait := Publish(&lt;span style="color: #a31515"&gt;&amp;quot;Channels let goroutines communicate.&amp;quot;&lt;/span&gt;, 5*time.Second)
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Waiting for the news...&amp;quot;&lt;/span&gt;)
    &lt;span style="color: #008000"&gt;// 译注：注意下面这一句&lt;/span&gt;
    &amp;lt;-wait
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;The news is out, time to leave.&amp;quot;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;死锁是线程之间相互等待，其中任何一个都无法向前运行的情形。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Waiting for the news...
BREAKING NEWS: Channels let goroutines communicate.
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
    .../goroutineStop.go:11 +0xf6

goroutine 2 [syscall]:
created by runtime.main
    .../go/src/pkg/runtime/proc.c:225

goroutine 4 [timer goroutine (idle)]:
created by addtimer
    .../go/src/pkg/runtime/ztime_linux_amd64.c:73
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。&lt;/p&gt;
&lt;h4&gt;5. 数据竞争（data race）&lt;/h4&gt;
&lt;p&gt;死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当两个线程并发地访问同一个变量，并且其中至少一个访问是写操作时，数据竞争就发生了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; race() {
    wait := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt;{})
    n := 0
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
        &lt;span style="color: #008000"&gt;// 译注：注意下面这一行&lt;/span&gt;
        n++ &lt;span style="color: #008000"&gt;// 一次访问: 读, 递增, 写&lt;/span&gt;
        close(wait)
    }()
    &lt;span style="color: #008000"&gt;// 译注：注意下面这一行&lt;/span&gt;
    n++ &lt;span style="color: #008000"&gt;// 另一次冲突的访问&lt;/span&gt;
    &amp;lt;-wait
    fmt.Println(n) &lt;span style="color: #008000"&gt;// 输出：未指定&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go"&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码中的两个goroutine（假设命名为&lt;code&gt;g1&lt;/code&gt;和&lt;code&gt;g2&lt;/code&gt;）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g1&lt;/code&gt; 从 &lt;code&gt;n&lt;/code&gt; 中获取值0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g2&lt;/code&gt; 从 &lt;code&gt;n&lt;/code&gt; 中获取值0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g1&lt;/code&gt; 将值从0增大到1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g1&lt;/code&gt; 将1写到 &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g2&lt;/code&gt; 将值从0增大到1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g2&lt;/code&gt; 将1写到 &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;程序输出 n 的值，当前为1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mid action" src="http://www.nada.kth.se/~snilsson/concurrency/mid-action.jpg"&gt;&lt;/p&gt;
&lt;p&gt;避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（&lt;a href="http://golang.org/pkg/sync/"&gt;sync&lt;/a&gt;和&lt;a href="http://golang.org/pkg/sync/atomic/"&gt;sync/atomic&lt;/a&gt;包中还有更低层次的机制可供使用，但本文中不做讨论）。&lt;/p&gt;
&lt;p&gt;Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; sharingIsCaring() {
    ch := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
        n := 0 &lt;span style="color: #008000"&gt;// 仅为一个goroutine可见的局部变量.&lt;/span&gt;
        n++
        ch &amp;lt;- n &lt;span style="color: #008000"&gt;// 数据从一个goroutine离开...&lt;/span&gt;
    }()
    n := &amp;lt;-ch   &lt;span style="color: #008000"&gt;// ...然后安全到达另一个goroutine.&lt;/span&gt;
    n++
    fmt.Println(n) &lt;span style="color: #008000"&gt;// 输出: 2&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go"&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上代码中的管道肩负双重责任 - 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/mem"&gt;Go语言内存模型&lt;/a&gt; - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。&lt;/p&gt;
&lt;h4&gt;6. 互斥锁&lt;/h4&gt;
&lt;p&gt;&lt;img alt="lock" src="http://www.nada.kth.se/~snilsson/concurrency/lock.jpg"&gt;&lt;/p&gt;
&lt;p&gt;有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - &lt;a href="http://golang.org/pkg/sync/#Mutex"&gt;sync.Mutex&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。&lt;/p&gt;
&lt;p&gt;因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，&lt;code&gt;AtomicInt&lt;/code&gt;，用于存储一个整型值。任意数量的goroutine都能通过&lt;code&gt;Add&lt;/code&gt;和&lt;code&gt;Value&lt;/code&gt;方法安全地访问这个数值。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// AtomicInt是一个并发数据结构，持有一个整数值&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 该数据结构的零值为0&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;type&lt;/span&gt; AtomicInt &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; {
    mu sync.Mutex &lt;span style="color: #008000"&gt;// 锁，一次仅能被一个goroutine持有。&lt;/span&gt;
    n  &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;
}

&lt;span style="color: #008000"&gt;// Add方法作为一个原子操作将n加到AtomicInt&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; (a *AtomicInt) Add(n &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) {
    a.mu.Lock() &lt;span style="color: #008000"&gt;// 等待锁释放，然后持有它&lt;/span&gt;
    a.n += n
    a.mu.Unlock() &lt;span style="color: #008000"&gt;// 释放锁&lt;/span&gt;
}

&lt;span style="color: #008000"&gt;// Value方法返回a的值&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; (a *AtomicInt) Value() &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; {
    a.mu.Lock()
    n := a.n
    a.mu.Unlock()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n
}

&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; lockItUp() {
    wait := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt;{})
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; n AtomicInt
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
        n.Add(1) &lt;span style="color: #008000"&gt;// 一个访问&lt;/span&gt;
        close(wait)
    }()
    n.Add(1) &lt;span style="color: #008000"&gt;// 另一个并发访问&lt;/span&gt;
    &amp;lt;-wait
    fmt.Println(n.Value()) &lt;span style="color: #008000"&gt;// 输出: 2&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go"&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;7. 检测数据竞争&lt;/h4&gt;
&lt;p&gt;竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出&lt;code&gt;55555&lt;/code&gt;。尝试一下，也许你会得到一个不同的结果。（&lt;a href="http://golang.org/pkg/sync/#WaitGroup"&gt;sync.WaitGroup&lt;/a&gt;是Go语言标准库的一部分；用于等待一组goroutine结束运行。）&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; race() {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; wg sync.WaitGroup
    wg.Add(5)
    &lt;span style="color: #008000"&gt;// 译注：注意下面这行代码中的i++&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i := 0; i &amp;lt; 5; i++ {
        &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
            &lt;span style="color: #008000"&gt;// 注意下一行代码会输出什么？为什么？&lt;/span&gt;
            fmt.Print(i) &lt;span style="color: #008000"&gt;// 6个goroutine共享变量i&lt;/span&gt;
            wg.Done()
        }()
    }
    wg.Wait() &lt;span style="color: #008000"&gt;// 等待所有（5个）goroutine运行结束&lt;/span&gt;
    fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go"&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于输出&lt;code&gt;55555&lt;/code&gt;，一个貌似合理的解释是：执行&lt;code&gt;i++&lt;/code&gt;的goroutine在其他goroutine执行打印语句之前就完成了5次&lt;code&gt;i++&lt;/code&gt;操作。实际上变量&lt;code&gt;i&lt;/code&gt;更新后的值为其他goroutine所见纯属巧合。&lt;/p&gt;
&lt;p&gt;一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; correct() {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; wg sync.WaitGroup
    wg.Add(5)
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i := 0; i &amp;lt; 5; i++ {
        &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;(n &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) { &lt;span style="color: #008000"&gt;// 使用局部变量&lt;/span&gt;
            fmt.Print(n)
            wg.Done()
        }(i)
    }
    wg.Wait()
    fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go"&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次代码就对了，程序会输出期望的结果，如：&lt;code&gt;24031&lt;/code&gt;。注意：goroutine之间的运行顺序是不确定的。&lt;/p&gt;
&lt;p&gt;仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; alsoCorrect() {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; wg sync.WaitGroup
    wg.Add(5)
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i := 0; i &amp;lt; 5; i++ {
        n := i &lt;span style="color: #008000"&gt;// 为每个闭包创建一个独有的变量&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
            fmt.Print(n)
            wg.Done()
        }()
    }
    wg.Wait()
    fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go"&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据竞争自动检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的&lt;a href="http://tip.golang.org/doc/articles/race_detector.html"&gt;数据竞争检测器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个工具用起来也很简单：只要在使用&lt;code&gt;go&lt;/code&gt;命令时加上&lt;code&gt;-race&lt;/code&gt;标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ go run -race raceClosure.go
Race:
==================
WARNING: DATA RACE
Read by goroutine 2:
    main.func·001()
      ../raceClosure.go:22 +0x65

Previous write by goroutine 0:
    main.race()
        ../raceClosure.go:20 +0x19b
    main.main()
        ../raceClosure.go:10 +0x29
    runtime.main()
        ../go/src/pkg/runtime/proc.c:248 +0x91

Goroutine 2 (running) created at:
    main.race()
      ../raceClosure.go:24 +0x18b
    main.main()
      ../raceClosure.go:10 +0x29
     runtime.main()
      ../go/src/pkg/runtime/proc.c:248 +0x91

==================
55555
Correct:
01234
Also correct:
01324
Found 1 data race(s)
exit status 66
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。&lt;/p&gt;
&lt;p&gt;注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导）&lt;/p&gt;
&lt;h4&gt;8. Select语句&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/spec#Select_statements"&gt;select语句&lt;/a&gt;是Go语言并发工具集中的终极工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。&lt;/p&gt;
&lt;p&gt;以下是一个玩具示例，演示&lt;code&gt;select&lt;/code&gt;语句如何用于实现一个随机数生成器：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// RandomBits函数 返回一个管道，用于产生一个比特随机序列&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; RandomBits() &amp;lt;-&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; {
    ch := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;() {
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; {
            &lt;span style="color: #0000ff"&gt;select&lt;/span&gt; {
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; ch &amp;lt;- 0: &lt;span style="color: #008000"&gt;// 注意：分支没有对应的处理语句&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; ch &amp;lt;- 1:
            }
        }
    }()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ch
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/randBits.go"&gt;randBits.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;select&lt;/span&gt; {
&lt;span style="color: #0000ff"&gt;case&lt;/span&gt; news := &amp;lt;-NewsAgency:
    fmt.Println(news)
&lt;span style="color: #0000ff"&gt;case&lt;/span&gt; &amp;lt;-time.After(time.Minute):
    fmt.Println(&lt;span style="color: #a31515"&gt;&amp;quot;Time out: no news in one minute.&amp;quot;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数 &lt;a href="http://golang.org/pkg/time/#After"&gt;time.After&lt;/a&gt; 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。&lt;/p&gt;
&lt;h4&gt;9. 综合所有示例&lt;/h4&gt;
&lt;p&gt;&lt;img alt="couples" src="http://www.nada.kth.se/~snilsson/concurrency/couples.jpg"&gt;&lt;/p&gt;
&lt;p&gt;花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。&lt;/p&gt;
&lt;p&gt;这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    people := []&lt;span style="color: #2b91af"&gt;string&lt;/span&gt;{&lt;span style="color: #a31515"&gt;&amp;quot;Anna&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;Cody&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;Dave&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;Eva&amp;quot;&lt;/span&gt;}
    match := make(&lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, 1) &lt;span style="color: #008000"&gt;// 为一个未匹配的发送操作提供空间&lt;/span&gt;
    wg := new(sync.WaitGroup)
    wg.Add(len(people))
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; _, name := &lt;span style="color: #0000ff"&gt;range&lt;/span&gt; people {
        &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; Seek(name, match, wg)
    }
    wg.Wait()
    &lt;span style="color: #0000ff"&gt;select&lt;/span&gt; {
    &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; name := &amp;lt;-match:
        fmt.Printf(&lt;span style="color: #a31515"&gt;&amp;quot;No one received %s’s message.\n&amp;quot;&lt;/span&gt;, name)
    &lt;span style="color: #0000ff"&gt;default&lt;/span&gt;:
        &lt;span style="color: #008000"&gt;// 没有待处理的发送操作&lt;/span&gt;
    }
}

&lt;span style="color: #008000"&gt;// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait group&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Seek(name &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, match &lt;span style="color: #0000ff"&gt;chan&lt;/span&gt; &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, wg *sync.WaitGroup) {
    &lt;span style="color: #0000ff"&gt;select&lt;/span&gt; {
    &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; peer := &amp;lt;-match:
        fmt.Printf(&lt;span style="color: #a31515"&gt;&amp;quot;%s sent a message to %s.\n&amp;quot;&lt;/span&gt;, peer, name)
    &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; match &amp;lt;- name:
        &lt;span style="color: #008000"&gt;// 等待某个goroutine接收我的消息&lt;/span&gt;
    }
    wg.Done()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/matching.go"&gt;matching.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ go run matching.go
Cody sent a message to Bob.
Anna sent a message to Eva.
No one received Dave’s message.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;10. 并行计算&lt;/h4&gt;
&lt;p&gt;&lt;img alt="CPUs" src="http://www.nada.kth.se/~snilsson/concurrency/cpus.jpg"&gt;&lt;/p&gt;
&lt;p&gt;并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。&lt;/p&gt;
&lt;p&gt;将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的）&lt;/li&gt;
&lt;li&gt;尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。&lt;/li&gt;
&lt;li&gt;数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;type&lt;/span&gt; Vector []&lt;span style="color: #2b91af"&gt;float64&lt;/span&gt;

&lt;span style="color: #008000"&gt;// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 先决条件：len(u) &amp;gt; 0, len(v) &amp;gt; 0&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Convolve(u, v Vector) (w Vector) {
    n := len(u) + len(v) - 1
    w = make(Vector, n)

    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; k := 0; k &amp;lt; n; k++ {
        w[k] = mul(u, v, k)
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
}

&lt;span style="color: #008000"&gt;// 函数mul 返回 Σ u[i]*v[j], i + j = k.&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; mul(u, v Vector, k &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) (res &lt;span style="color: #2b91af"&gt;float64&lt;/span&gt;) {
    n := min(k+1, len(u))
    j := min(k, len(v)-1)
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i := k - j; i &amp;lt; n; i, j = i+1, j-1 {
        res += u[i] * v[j]
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 &lt;code&gt;Convolve&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Convolve(u, v Vector) (w Vector) {
    n := len(u) + len(v) - 1
    w = make(Vector, n)

    &lt;span style="color: #008000"&gt;// 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元&lt;/span&gt;
    size := max(1, 1&amp;lt;&amp;lt;20/n)

    wg := new(sync.WaitGroup)
    wg.Add(1 + (n-1)/size)
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i := 0; i &amp;lt; n &amp;amp;&amp;amp; i &amp;gt;= 0; i += size { &lt;span style="color: #008000"&gt;// 整型溢出后 i &amp;lt; 0&lt;/span&gt;
        j := i + size
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; j &amp;gt; n || j &amp;lt; 0 { &lt;span style="color: #008000"&gt;// 整型溢出后 j &amp;lt; 0&lt;/span&gt;
            j = n
        }

        &lt;span style="color: #008000"&gt;// 这些goroutine共享内存，但是只读&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;go&lt;/span&gt; &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;(i, j &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) {
            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; k := i; k &amp;lt; j; k++ {
                w[k] = mul(u, v, k)
            }
            wg.Done()
        }(i, j)
    }
    wg.Wait()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/convolution.go"&gt;convolution.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; init() {
    numcpu := runtime.NumCPU()
    runtime.GOMAXPROCS(numcpu) &lt;span style="color: #008000"&gt;// 尝试使用所有可用的CPU&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Golang"></category></entry><entry><title>Yii源码阅读笔记 - 自定义类自动加载</title><link href="http://youngsterxyf.github.io/2015/04/10/read-yii-code-9/" rel="alternate"></link><published>2015-04-10T00:00:00+08:00</published><updated>2015-04-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-04-10:/2015/04/10/read-yii-code-9/</id><summary type="html">&lt;p&gt;前两天突然发现：之前的阅读笔记对于Yii应用中如何自动加载自定义类的问题没有解释。这里的自定义类是指非Yii框架本身的类。&lt;/p&gt;
&lt;p&gt;关于组件类的配置加载已在 &lt;a href="http://blog.xiayf.cn/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt; 一文中做了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前两天突然发现：之前的阅读笔记对于Yii应用中如何自动加载自定义类的问题没有解释。这里的自定义类是指非Yii框架本身的类。&lt;/p&gt;
&lt;p&gt;关于组件类的配置加载已在 &lt;a href="http://blog.xiayf.cn/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt; 一文中做了较为详细的说明，
所以这里不再涉及。&lt;/p&gt;
&lt;p&gt;本文主要解释以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Yii框架是如何找到请求对应的自定义控制器类？&lt;/li&gt;
&lt;li&gt;在自定义控制器类中使用其他类（如Model类、或其他任意目录下文件中定义的类）时，Yii框架是如何自动加载的？&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;在 &lt;a href="http://blog.xiayf.cn/2014/11/20/read-yii-code-7/"&gt;Yii源码阅读笔记 - 应用模块化&lt;/a&gt; 一文中介绍类 &lt;code&gt;CWebApplication&lt;/code&gt; 中的方法 &lt;code&gt;createController&lt;/code&gt; ，
该方法根据目标路由找到对应的控制器类文件并加载，方法中有行代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$basePath=$owner-&amp;gt;getControllerPath();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里的 &lt;code&gt;getControllerPath&lt;/code&gt; 会返回当前应用或模块下的控制器类的存放目录，对应应用级与模块级，其实现有两处，其一是在类 &lt;code&gt;CWebApplication&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * @return string the directory that contains the controller classes. Defaults to &amp;#39;protected/controllers&amp;#39;.
 */
public function getControllerPath()
{
    if($this-&amp;gt;_controllerPath!==null)
        return $this-&amp;gt;_controllerPath;
    else
        return $this-&amp;gt;_controllerPath=$this-&amp;gt;getBasePath().DIRECTORY_SEPARATOR.&amp;#39;controllers&amp;#39;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另一处是在类 &lt;code&gt;CWebModule&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * @return string the directory that contains the controller classes. Defaults to &amp;#39;moduleDir/controllers&amp;#39; where
 * moduleDir is the directory containing the module class.
 */
public function getControllerPath()
{
    if($this-&amp;gt;_controllerPath!==null)
        return $this-&amp;gt;_controllerPath;
    else
        return $this-&amp;gt;_controllerPath=$this-&amp;gt;getBasePath().DIRECTORY_SEPARATOR.&amp;#39;controllers&amp;#39;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这两处实现的逻辑是一样的：如果属性 &lt;code&gt;_controllerPath&lt;/code&gt; 未赋值，则&lt;strong&gt;默认&lt;/strong&gt;以应用或模块目录下的&lt;strong&gt;controllers&lt;/strong&gt;子目录作为自定义控制器类的存放目录。&lt;/p&gt;
&lt;p&gt;如果不想以该路径作为自定义控制器类的存放目录，那么就得为 &lt;code&gt;_controllerPath&lt;/code&gt; 赋值 - 与 &lt;code&gt;getControllerPath&lt;/code&gt; 对应的有方法 &lt;code&gt;setControllerPath&lt;/code&gt; （同样有两处定义，实现一样）：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * @param string $value the directory that contains the controller classes.
 * @throws CException if the directory is invalid
 */
public function setControllerPath($value)
{
    if(($this-&amp;gt;_controllerPath=realpath($value))===false || !is_dir($this-&amp;gt;_controllerPath))
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The controller path &amp;quot;{path}&amp;quot; is not a valid directory.&amp;#39;,
            array(&amp;#39;{path}&amp;#39;=&amp;gt;$value)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从 &lt;code&gt;getControllerPath&lt;/code&gt; 和 &lt;code&gt;setControllerPath&lt;/code&gt; 的命名上就能知道这两个方法是分别由魔术方法 &lt;code&gt;__get&lt;/code&gt; 和 &lt;code&gt;__set&lt;/code&gt; 间接调用的。由 &lt;a href="http://blog.xiayf.cn/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt; 一文内容可知，配置初始化的时候会调用类 &lt;code&gt;CModule&lt;/code&gt; 的方法 &lt;code&gt;configure&lt;/code&gt; ，该方法中又会触发魔术方法 &lt;code&gt;__set&lt;/code&gt; 。这也就意味着可以在应用配置中添加 &lt;code&gt;controllerPath&lt;/code&gt; 一项来声明自定义控制器类的存放目录。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;那么当自定义控制类中使用Model类或者其他辅助类时，Yii是如何自动加载的呢？&lt;/p&gt;
&lt;p&gt;以 &lt;strong&gt;在控制器类中IndexController调用Model类UserModel的getUserInfo方法获取用户信息&lt;/strong&gt; 为例，Yii是怎么找到并加载UserModel类文件的呢？&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://blog.xiayf.cn/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt; 一文的最后提到 - 类文件yii/framework/YiiBase.php的倒数第二行代码为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;spl_autoload_register(array(&amp;#39;YiiBase&amp;#39;,&amp;#39;autoload&amp;#39;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在应用初始化时，类文件 &lt;code&gt;Yii.php&lt;/code&gt; 中会require类文件 &lt;code&gt;YiiBase.php&lt;/code&gt;，从而会执行该句代码，将YiiBase类的方法autoload注册到 &lt;code&gt;SPL __autoload&lt;/code&gt; 函数队列中。&lt;/p&gt;
&lt;p&gt;而类 YiiBase 的 autoload 方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Class autoload loader.
 * This method is provided to be invoked within an __autoload() magic method.
 * @param string $className class name
 * @return boolean whether the class has been loaded successfully
 */
public static function autoload($className)
{
    // use include so that the error PHP file may appear
    // 先在 $classMap 中查找
    if(isset(self::$classMap[$className]))
        include(self::$classMap[$className]);
    // 在 $_coreClasses 中查找
    elseif(isset(self::$_coreClasses[$className]))
        include(YII_PATH.self::$_coreClasses[$className]);
    else
    {
        // 如果 $className 不带 命名空间
        // include class file relying on include_path
        if(strpos($className,&amp;#39;\\&amp;#39;)===false)  // class without namespace
        {
            if(self::$enableIncludePath===false)
            {
                foreach(self::$_includePaths as $path)
                {
                    $classFile=$path.DIRECTORY_SEPARATOR.$className.&amp;#39;.php&amp;#39;;
                    if(is_file($classFile))
                    {
                        include($classFile);
                        if(YII_DEBUG &amp;amp;&amp;amp; basename(realpath($classFile))!==$className.&amp;#39;.php&amp;#39;)
                            throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Class name &amp;quot;{class}&amp;quot; does not match class file &amp;quot;{file}&amp;quot;.&amp;#39;, array(
                                &amp;#39;{class}&amp;#39;=&amp;gt;$className,
                                &amp;#39;{file}&amp;#39;=&amp;gt;$classFile,
                            )));
                        break;
                    }
                }
            }
            else
                include($className.&amp;#39;.php&amp;#39;);
        }
        // $className 带 命名空间
        else  // class name with namespace in PHP 5.3
        {
            $namespace=str_replace(&amp;#39;\\&amp;#39;,&amp;#39;.&amp;#39;,ltrim($className,&amp;#39;\\&amp;#39;));
            if(($path=self::getPathOfAlias($namespace))!==false)
                include($path.&amp;#39;.php&amp;#39;);
            else
                return false;
        }
        return class_exists($className,false) || interface_exists($className,false);
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码中涉及的 &lt;code&gt;self::$_coreClasses&lt;/code&gt; 属性定义于类 YiiBase，其中罗列了Yii框架核心类的名称与相对路径。&lt;/p&gt;
&lt;p&gt;属性 &lt;code&gt;self::$_classMap&lt;/code&gt; ，默认是一个空数组，在类 YiiBase 的静态方法 import 中根据条件可能被赋予元素；属性 &lt;code&gt;self::$_includePaths&lt;/code&gt; 也是如此，只不过默认未赋值。静态方法 &lt;code&gt;import&lt;/code&gt; 实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public static function import($alias,$forceInclude=false)
{
    if(isset(self::$_imports[$alias]))  // previously imported
        return self::$_imports[$alias];

    if(class_exists($alias,false) || interface_exists($alias,false))
        return self::$_imports[$alias]=$alias;

    // 带 命名空间
    if(($pos=strrpos($alias,&amp;#39;\\&amp;#39;))!==false) // a class name in PHP 5.3 namespace format
    {
        $namespace=str_replace(&amp;#39;\\&amp;#39;,&amp;#39;.&amp;#39;,ltrim(substr($alias,0,$pos),&amp;#39;\\&amp;#39;));
        if(($path=self::getPathOfAlias($namespace))!==false)
        {
            $classFile=$path.DIRECTORY_SEPARATOR.substr($alias,$pos+1).&amp;#39;.php&amp;#39;;

            // 默认为false的哦
            if($forceInclude)
            {
                if(is_file($classFile))
                    require($classFile);
                else
                    throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing PHP file and the file is readable.&amp;#39;,array(&amp;#39;{alias}&amp;#39;=&amp;gt;$alias)));
                self::$_imports[$alias]=$alias;
            }
            else
                self::$classMap[$alias]=$classFile;
            return $alias;
        }
        else
        {
            // try to autoload the class with an autoloader
            if (class_exists($alias,true))
                return self::$_imports[$alias]=$alias;
            else
                throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing directory or file.&amp;#39;,
                    array(&amp;#39;{alias}&amp;#39;=&amp;gt;$namespace)));
        }
    }

    // 从后往前第一个 . 的位置
    if(($pos=strrpos($alias,&amp;#39;.&amp;#39;))===false)  // a simple class name
    {
        if($forceInclude &amp;amp;&amp;amp; self::autoload($alias))
            self::$_imports[$alias]=$alias;
        return $alias;
    }

    // 取类名部分
    $className=(string)substr($alias,$pos+1);
    // 如果类名为 * 则表示非类文件，而是目录
    $isClass=$className!==&amp;#39;*&amp;#39;;

    if($isClass &amp;amp;&amp;amp; (class_exists($className,false) || interface_exists($className,false)))
        return self::$_imports[$alias]=$className;

    if(($path=self::getPathOfAlias($alias))!==false)
    {
        // 类文件
        if($isClass)
        {
            if($forceInclude)
            {
                if(is_file($path.&amp;#39;.php&amp;#39;))
                    require($path.&amp;#39;.php&amp;#39;);
                else
                    throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing PHP file and the file is readable.&amp;#39;,array(&amp;#39;{alias}&amp;#39;=&amp;gt;$alias)));
                self::$_imports[$alias]=$className;
            }
            else
                self::$classMap[$className]=$path.&amp;#39;.php&amp;#39;;
            return $className;
        }
        // 目录
        else  // a directory
        {
            if(self::$_includePaths===null)
            {
                self::$_includePaths=array_unique(explode(PATH_SEPARATOR,get_include_path()));
                if(($pos=array_search(&amp;#39;.&amp;#39;,self::$_includePaths,true))!==false)
                    unset(self::$_includePaths[$pos]);
            }

            array_unshift(self::$_includePaths,$path);

            if(self::$enableIncludePath &amp;amp;&amp;amp; set_include_path(&amp;#39;.&amp;#39;.PATH_SEPARATOR.implode(PATH_SEPARATOR,self::$_includePaths))===false)
                self::$enableIncludePath=false;

            return self::$_imports[$alias]=$path;
        }
    }
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing directory or file.&amp;#39;,
            array(&amp;#39;{alias}&amp;#39;=&amp;gt;$alias)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;静态方法import在类CModule（CWebApplication类间接继承自该类）的方法 &lt;code&gt;setImport&lt;/code&gt; 中会被调用（当然还有其他地方也会调用import方法）：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Sets the aliases that are used in the module.
 * @param array $aliases list of aliases to be imported
 */
public function setImport($aliases)
{
    foreach($aliases as $alias)
        Yii::import($alias);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看到前缀为&lt;code&gt;set&lt;/code&gt;，就知道魔术方法 &lt;code&gt;__set&lt;/code&gt; 能间接调用该方法，如前所述，可以为应用提供名为 &lt;strong&gt;import&lt;/strong&gt; 的配置项。例如目前我们项目中有import配置项如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;import&amp;#39;=&amp;gt;array(
    &amp;#39;application.models.*&amp;#39;,
    &amp;#39;application.components.*&amp;#39;,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表示业务逻辑的代码（如自定义控制器类）中会使用到应用的子目录models和components下的类文件，需要Yii（准确地说是YiiBase类autoload方法）帮忙自动查找加载。
这样也就能任意组织项目的目录结构（&lt;strong&gt;当然不要太任性！&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;import配置项的值是一个路径别名数组，路径别名中的application表示应用的根目录，默认为与index.php同一级的protected目录，也可以通过配置项basePath来指定。对于basePath配置项，在类CApplication的构造方法 &lt;code&gt;__contruct&lt;/code&gt; 中有如下相关代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;if(isset($config[&amp;#39;basePath&amp;#39;]))
{
    $this-&amp;gt;setBasePath($config[&amp;#39;basePath&amp;#39;]);
    unset($config[&amp;#39;basePath&amp;#39;]);
}
else
    $this-&amp;gt;setBasePath(&amp;#39;protected&amp;#39;);
Yii::setPathOfAlias(&amp;#39;application&amp;#39;,$this-&amp;gt;getBasePath());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法 &lt;code&gt;setPathAlias&lt;/code&gt; 的实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public static function setPathOfAlias($alias,$path)
{
    if(empty($path))
        unset(self::$_aliases[$alias]);
    else
        self::$_aliases[$alias]=rtrim($path,&amp;#39;\\/&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;除了通过import配置项指定autoload的查找路径，从类YiiBase的autoload方法实现可以看到，对于PHP 5.3以上版本，可以使用命名空间的方式来自动查找类，命名空间字符串会被替换成路径别名，所以命名空间字符串应以 &lt;code&gt;application\&lt;/code&gt; 开始，如应这样 &lt;code&gt;application\models\UserModel&lt;/code&gt; 来引用models目录下的UserModel类文件，除非额外通过 &lt;code&gt;Yii::setPathOfAlias&lt;/code&gt;为models路径指定别名。&lt;/p&gt;
&lt;p&gt;另外，类YiiBase中提供了一个静态方法 &lt;code&gt;registerAutoloader&lt;/code&gt; ：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Registers a new class autoloader.
 * The new autoloader will be placed before {@link autoload} and after
 * any other existing autoloaders.
 * @param callback $callback a valid PHP callback (function name or array($className,$methodName)).
 * @param boolean $append whether to append the new autoloader after the default Yii autoloader.
 * Be careful using this option as it will disable {@link enableIncludePath autoloading via include path}
 * when set to true. After this the Yii autoloader can not rely on loading classes via simple include anymore
 * and you have to {@link import} all classes explicitly.
 */
public static function registerAutoloader($callback, $append=false)
{
    if($append)
    {
        self::$enableIncludePath=false;
        spl_autoload_register($callback);
    }
    else
    {
        spl_autoload_unregister(array(&amp;#39;YiiBase&amp;#39;,&amp;#39;autoload&amp;#39;));
        spl_autoload_register($callback);
        spl_autoload_register(array(&amp;#39;YiiBase&amp;#39;,&amp;#39;autoload&amp;#39;));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可通过该静态方法针对项目的目录结构添加一个自定义的自动查找加载方式。&lt;/p&gt;
&lt;h4&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/zh/function.spl-autoload-register.php"&gt;PHP手册 - spl_autoload_register&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Slim源码阅读笔记</title><link href="http://youngsterxyf.github.io/2015/03/22/read-slim/" rel="alternate"></link><published>2015-03-22T00:00:00+08:00</published><updated>2015-03-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-03-22:/2015/03/22/read-slim/</id><summary type="html">&lt;p&gt;以前读过 &lt;a href="http://www.phptherightway.com/"&gt;PHP - The Right Way&lt;/a&gt; 一文，
还翻译过其中的 &lt;a href="http://www.phptherightway.com/pages/The-Basics.html"&gt;The Baiscs&lt;/a&gt; 一节
(译文见 &lt;a href="http://blog.xiayf.cn/2013/03/08/php-basics/"&gt;这里&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;前两周读了 &lt;a href="http://www.amazon.cn/Modern-PHP-Lockhart-Josh/dp/1491905018/ref=sr_1_1?ie=UTF8&amp;amp;qid=1427031708&amp;amp;sr=8-1&amp;amp;keywords=Modern+PHP"&gt;Modern PHP - New Features and Good Practices&lt;/a&gt; 一书
（读书笔记见&lt;a href="http://blog.xiayf.cn/2015/03/12/read-modern-php/"&gt;这里&lt;/a&gt;），
甚是不 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;以前读过 &lt;a href="http://www.phptherightway.com/"&gt;PHP - The Right Way&lt;/a&gt; 一文，
还翻译过其中的 &lt;a href="http://www.phptherightway.com/pages/The-Basics.html"&gt;The Baiscs&lt;/a&gt; 一节
(译文见 &lt;a href="http://blog.xiayf.cn/2013/03/08/php-basics/"&gt;这里&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;前两周读了 &lt;a href="http://www.amazon.cn/Modern-PHP-Lockhart-Josh/dp/1491905018/ref=sr_1_1?ie=UTF8&amp;amp;qid=1427031708&amp;amp;sr=8-1&amp;amp;keywords=Modern+PHP"&gt;Modern PHP - New Features and Good Practices&lt;/a&gt; 一书
（读书笔记见&lt;a href="http://blog.xiayf.cn/2015/03/12/read-modern-php/"&gt;这里&lt;/a&gt;），
甚是不错。&lt;/p&gt;
&lt;p&gt;这篇文档和这本书的作者都是&lt;a href="https://github.com/codeguy"&gt;Josh Lockhart&lt;/a&gt;，
他写了一个Web框架&lt;a href="http://www.slimframework.com/"&gt;Slim&lt;/a&gt;，文档与书籍内容的精华都体现在这个框架中，
所以个人觉得这个框架值得一读。&lt;/p&gt;
&lt;p&gt;Slim的设计与实现都非常精简易懂，其对请求的主处理流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="slim" src="https://i.loli.net/2020/06/14/NhDueKvb59o1IMB.png"&gt;&lt;/p&gt;
&lt;p&gt;其中的核心概念包括：IoC容器、中间件、路由匹配等。&lt;/p&gt;
&lt;h4&gt;IoC容器&lt;/h4&gt;
&lt;p&gt;IoC，为Inversion of Control的缩写，中文翻译为“控制反转” - 是一种解决组件间依赖关系、配置和生命周期的设计模式，其最常见的实现方式为：依赖注入（DI）-
当系统/应用需要使用某个依赖组件时，容器根据配置信息构建一个组件对象返回给系统/应用。&lt;/p&gt;
&lt;p&gt;对于Web框架来说，基于Ioc容器可以将框架的功能拆解成多个组件，按需配置调用。&lt;/p&gt;
&lt;p&gt;Slim的IoC容器类为：&lt;code&gt;\Slim\Helper\Set&lt;/code&gt;，以单例request为例，当调用request对象时&lt;code&gt;$app-&amp;gt;request&lt;/code&gt;，先触发Slim类的魔术方法&lt;code&gt;__get&lt;/code&gt;，其实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __get($name)
{
    return $this-&amp;gt;container-&amp;gt;get($name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而容器类Set的get方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Get data value with key
 * @param  string $key     The data key
 * @param  mixed  $default The value to return if data key does not exist
 * @return mixed           The data value, or the default value
 */
public function get($key, $default = null)
{
    if ($this-&amp;gt;has($key)) {
        $isInvokable = is_object($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]) &amp;amp;&amp;amp; method_exists($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)], &amp;#39;__invoke&amp;#39;);

        // 注意这里的$this，在初始化组件时，将当前容器对象作为参数传入
        // 从这里可以看到，容器里可以存放普通的配置信息（如settings），也可以存放组件配置
        return $isInvokable ? $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]($this) : $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)];
    }

    return $default;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们再来看看单例组件的实现，以request为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// 注册单例组件request
$this-&amp;gt;container-&amp;gt;singleton(&amp;#39;request&amp;#39;, function ($c) {
    // request组件的实例化依赖于environment组件，
    // 而environment组件包含了$_SERVER以及进程标准输入的数据
    return new \Slim\Http\Request($c[&amp;#39;environment&amp;#39;]);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code&gt;singleton&lt;/code&gt;方法的实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Ensure a value or object will remain globally unique
 * @param  string   $key   The value or object name
 * @param  \Closure $value The closure that defines the object
 * @return mixed
 */
public function singleton($key, $value)
{
    $this-&amp;gt;set($key, function ($c) use ($value) {
        // 静态对象
        static $object;

        if (null === $object) {
            $object = $value($c);
        }

        return $object;
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;中间件&lt;/h4&gt;
&lt;p&gt;Slim中的中间件分两种：应用级中间件、路由级中间件。&lt;/p&gt;
&lt;p&gt;应用中间件基于Rack协议实现，可以在应用对象调用之前或之后检查、分析、或修改应用环境变量、请求对象、响应对象。&lt;/p&gt;
&lt;p&gt;每个中间件类都继承自抽象类Middleware，且需要实现其抽象方法call。所有注册的中间件组成一个中间件栈，其结构类似于一个洋葱，先注册的中间件在里层，后注册的在外层，最里层的是应用对象自身，请求从外到里逐层进行处理，任何一层都可以根据条件直接响应请求或递归调用往里一层/下一个中间件。&lt;/p&gt;
&lt;p&gt;以中间件SessionCookie与MethodOverride为例，其call方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// 中间件SessionCookie
public function call()
{
    // 加载session数据
    $this-&amp;gt;loadSession();
    // 调用下一个中间件
    $this-&amp;gt;next-&amp;gt;call();
    // 保存session数据
    $this-&amp;gt;saveSession();
}

// 中间件MethodOverride
public function call()
{
    $env = $this-&amp;gt;app-&amp;gt;environment();
    if (isset($env[&amp;#39;HTTP_X_HTTP_METHOD_OVERRIDE&amp;#39;])) {
        // Header commonly used by Backbone.js and others
        $env[&amp;#39;slim.method_override.original_method&amp;#39;] = $env[&amp;#39;REQUEST_METHOD&amp;#39;];
        $env[&amp;#39;REQUEST_METHOD&amp;#39;] = strtoupper($env[&amp;#39;HTTP_X_HTTP_METHOD_OVERRIDE&amp;#39;]);
    } elseif (isset($env[&amp;#39;REQUEST_METHOD&amp;#39;]) &amp;amp;&amp;amp; $env[&amp;#39;REQUEST_METHOD&amp;#39;] === &amp;#39;POST&amp;#39;) {
        // HTML Form Override
        $req = new \Slim\Http\Request($env);
        // $this-&amp;gt;settings[&amp;#39;key&amp;#39;] 默认为_METHOD
        $method = $req-&amp;gt;post($this-&amp;gt;settings[&amp;#39;key&amp;#39;]);
        if ($method) {
            $env[&amp;#39;slim.method_override.original_method&amp;#39;] = $env[&amp;#39;REQUEST_METHOD&amp;#39;];
            $env[&amp;#39;REQUEST_METHOD&amp;#39;] = strtoupper($method);
        }
    }
    // 调用下一个中间件
    $this-&amp;gt;next-&amp;gt;call();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;路由级中间件可以是任何可被调用的东西（&lt;code&gt;is_callable&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;）。在相关路由的回调触发之前，会逐个调用绑定到这个路由的所有路由级中间件，代码实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// 路由类Route的dispatch方法：
/**
 * Dispatch route
 *
 * This method invokes the route object&amp;#39;s callable. If middleware is
 * registered for the route, each callable middleware is invoked in
 * the order specified.
 *
 * @return bool
 */
public function dispatch()
{
    // 逐个调用绑定的路由级中间件，以当前路由对象作为参数传入
    foreach ($this-&amp;gt;middleware as $mw) {
        call_user_func_array($mw, array($this));
    }

    // 调用路由回调，并将通过路由模式从URL中正则匹配到的参数传入回调
    $return = call_user_func_array($this-&amp;gt;getCallable(), array_values($this-&amp;gt;getParams()));
    return ($return === false) ? false : true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;路由匹配&lt;/h4&gt;
&lt;p&gt;先来看看Slim应用对象的call方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Call
 *
 * This method finds and iterates all route objects that match the current request URI.
 */
public function call()
{
    try {
        if (isset($this-&amp;gt;environment[&amp;#39;slim.flash&amp;#39;])) {
            $this-&amp;gt;view()-&amp;gt;setData(&amp;#39;flash&amp;#39;, $this-&amp;gt;environment[&amp;#39;slim.flash&amp;#39;]);
        }
        $this-&amp;gt;applyHook(&amp;#39;slim.before&amp;#39;);
        ob_start();
        $this-&amp;gt;applyHook(&amp;#39;slim.before.router&amp;#39;);
        $dispatched = false;
        // 路由匹配
        $matchedRoutes = $this-&amp;gt;router-&amp;gt;getMatchedRoutes($this-&amp;gt;request-&amp;gt;getMethod(), $this-&amp;gt;request-&amp;gt;getResourceUri());
        // 逐个路由分发执行
        foreach ($matchedRoutes as $route) {
            try {
                $this-&amp;gt;applyHook(&amp;#39;slim.before.dispatch&amp;#39;);
                $dispatched = $route-&amp;gt;dispatch();
                $this-&amp;gt;applyHook(&amp;#39;slim.after.dispatch&amp;#39;);
                if ($dispatched) {
                    break;
                }
            } catch (\Slim\Exception\Pass $e) {
                continue;
            }
        }
        // 当路由的回调抛出非Pass异常时，则会响应404
        // 这貌似不好吧？
        if (!$dispatched) {
            $this-&amp;gt;notFound();
        }
        $this-&amp;gt;applyHook(&amp;#39;slim.after.router&amp;#39;);
        $this-&amp;gt;stop();
    } catch (\Slim\Exception\Stop $e) {
        $this-&amp;gt;response()-&amp;gt;write(ob_get_clean());
    } catch (\Exception $e) {
        if ($this-&amp;gt;config(&amp;#39;debug&amp;#39;)) {
            throw $e;
        } else {
            try {
                $this-&amp;gt;response()-&amp;gt;write(ob_get_clean());
                $this-&amp;gt;error($e);
            } catch (\Slim\Exception\Stop $e) {
                // Do nothing
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中用于路由匹配的Router类的getMatchedRoutes方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Return route objects that match the given HTTP method and URI
 * @param  string               $httpMethod   The HTTP method to match against
 * @param  string               $resourceUri  The resource URI to match against
 * @param  bool                 $reload       Should matching routes be re-parsed?
 * @return array[\Slim\Route]
 */
public function getMatchedRoutes($httpMethod, $resourceUri, $reload = false)
{
    if ($reload || is_null($this-&amp;gt;matchedRoutes)) {
        $this-&amp;gt;matchedRoutes = array();
        foreach ($this-&amp;gt;routes as $route) {
            // 如果当前请求的HTTP方法不被当前route支持且不是ANY，则跳过
            if (!$route-&amp;gt;supportsHttpMethod($httpMethod) &amp;amp;&amp;amp; !$route-&amp;gt;supportsHttpMethod(&amp;quot;ANY&amp;quot;)) {
                continue;
            }

            // 否则继续匹配环境变量PATH_INFO
            if ($route-&amp;gt;matches($resourceUri)) {
                $this-&amp;gt;matchedRoutes[] = $route;
            }
        }
    }

    return $this-&amp;gt;matchedRoutes;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中用于PATH_INFO匹配的Route类的matches方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Matches URI?
 *
 * Parse this route&amp;#39;s pattern, and then compare it to an HTTP resource URI
 * This method was modeled after the techniques demonstrated by Dan Sosedoff at:
 *
 * http://blog.sosedoff.com/2009/09/20/rails-like-php-url-router/
 *
 * @param  string $resourceUri A Request URI
 * @return bool
 */
public function matches($resourceUri)
{
    //Convert URL params into regex patterns, construct a regex for this route, init params
    // preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换
    $patternAsRegex = preg_replace_callback(
        &amp;#39;#:([\w]+)\+?#&amp;#39;,
        array($this, &amp;#39;matchesCallback&amp;#39;),
        // 括号中的部分表示可选
        // 如：/archive(/:year(/:month(/:day)))
        str_replace(&amp;#39;)&amp;#39;, &amp;#39;)?&amp;#39;, (string)$this-&amp;gt;pattern)
    );
    // 即使pattern最后有斜杠/，对于URL来说也是可选的
    if (substr($this-&amp;gt;pattern, -1) === &amp;#39;/&amp;#39;) {
        $patternAsRegex .= &amp;#39;?&amp;#39;;
    }

    $regex = &amp;#39;#^&amp;#39; . $patternAsRegex . &amp;#39;$#&amp;#39;;

    // 大小写不敏感
    if ($this-&amp;gt;caseSensitive === false) {
        $regex .= &amp;#39;i&amp;#39;;
    }

    //Cache URL params&amp;#39; names and values if this route matches the current HTTP request
    // 正则匹配
    if (!preg_match($regex, $resourceUri, $paramValues)) {
        return false;
    }
    foreach ($this-&amp;gt;paramNames as $name) {
        if (isset($paramValues[$name])) {
            if (isset($this-&amp;gt;paramNamesPath[$name])) {
                $this-&amp;gt;params[$name] = explode(&amp;#39;/&amp;#39;, urldecode($paramValues[$name]));
            } else {
                $this-&amp;gt;params[$name] = urldecode($paramValues[$name]);
            }
        }
    }

    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中正则搜索替换的回调方法matchesCallback的实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Convert a URL parameter (e.g. &amp;quot;:id&amp;quot;, &amp;quot;:id+&amp;quot;) into a regular expression
 * @param  array $m URL parameters
 * @return string       Regular expression for URL parameter
 */
protected function matchesCallback($m)
{
    $this-&amp;gt;paramNames[] = $m[1];
    if (isset($this-&amp;gt;conditions[$m[1]])) {
        return &amp;#39;(?P&amp;lt;&amp;#39; . $m[1] . &amp;#39;&amp;gt;&amp;#39; . $this-&amp;gt;conditions[$m[1]] . &amp;#39;)&amp;#39;;
    }
    if (substr($m[0], -1) === &amp;#39;+&amp;#39;) {
        $this-&amp;gt;paramNamesPath[$m[1]] = 1;

        return &amp;#39;(?P&amp;lt;&amp;#39; . $m[1] . &amp;#39;&amp;gt;.+)&amp;#39;;
    }

    return &amp;#39;(?P&amp;lt;&amp;#39; . $m[1] . &amp;#39;&amp;gt;[^/]+)&amp;#39;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;h4&gt;实践&lt;/h4&gt;
&lt;p&gt;上周，基于Slim框架开发了一个RSS聚合小应用，见&lt;a href="https://github.com/youngsterxyf/feed-world"&gt;这里&lt;/a&gt;。前端也尝试使用了Vue.js。&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="slim"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>读书笔记：Modern PHP - New Features and Good Practices</title><link href="http://youngsterxyf.github.io/2015/03/12/read-modern-php/" rel="alternate"></link><published>2015-03-12T00:00:00+08:00</published><updated>2015-03-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-03-12:/2015/03/12/read-modern-php/</id><content type="html">&lt;p&gt;&lt;img alt="modern-php" src="https://i.loli.net/2020/06/14/FLWAniqmMGEs8Ja.png"&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://i.loli.net/2020/06/14/FLWAniqmMGEs8Ja.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;推荐阅读！&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="PHP"></category></entry><entry><title>Yii源码阅读笔记 - 日志组件</title><link href="http://youngsterxyf.github.io/2015/03/09/read-yii-code-8/" rel="alternate"></link><published>2015-03-09T00:00:00+08:00</published><updated>2015-03-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-03-09:/2015/03/09/read-yii-code-8/</id><summary type="html">&lt;h3&gt;使用&lt;/h3&gt;
&lt;p&gt;Yii框架为开发者提供两个静态方法进行日志记录：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Yii::log($message, $level, $category);
Yii::trace($message, $category);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两者的区别在于后者依赖于应用开启调试模式，即定义常量YII_DEBUG：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;defined(&amp;#39;YII_DEBUG&amp;#39;) or define(&amp;#39;YII_DEBUG&amp;#39;, true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Yii::log方法的调用需要指定message的level和category。category是格式为“xxx.yyy.zzz …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;使用&lt;/h3&gt;
&lt;p&gt;Yii框架为开发者提供两个静态方法进行日志记录：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Yii::log($message, $level, $category);
Yii::trace($message, $category);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两者的区别在于后者依赖于应用开启调试模式，即定义常量YII_DEBUG：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;defined(&amp;#39;YII_DEBUG&amp;#39;) or define(&amp;#39;YII_DEBUG&amp;#39;, true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Yii::log方法的调用需要指定message的level和category。category是格式为“xxx.yyy.zzz”的路径别名字符串，比如日志是在yii/framework/web/CController类中记录的，那么category为“system.web.CController”。level应为以下几种之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trace：Yii::trace方法即是使用的这个level。用于跟踪执行流&lt;/li&gt;
&lt;li&gt;info：记录通用信息日志&lt;/li&gt;
&lt;li&gt;profile：用于性能分析&lt;/li&gt;
&lt;li&gt;warning：用于记录警告日志&lt;/li&gt;
&lt;li&gt;error：用于记录重大错误日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要想日志真的输出到文件、邮件、web页面等地方，还得为应用添加如下配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;array(
    ......
    &amp;#39;preload&amp;#39;=&amp;gt;array(&amp;#39;log&amp;#39;),
    &amp;#39;components&amp;#39;=&amp;gt;array(
        ......
        &amp;#39;log&amp;#39;=&amp;gt;array(
            &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CLogRouter&amp;#39;,
            &amp;#39;routes&amp;#39;=&amp;gt;array(
                array(
                    &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CFileLogRoute&amp;#39;,
                    &amp;#39;levels&amp;#39;=&amp;gt;&amp;#39;trace, info&amp;#39;,
                    &amp;#39;categories&amp;#39;=&amp;gt;&amp;#39;system.*&amp;#39;,
                ),
                array(
                    &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CEmailLogRoute&amp;#39;,
                    &amp;#39;levels&amp;#39;=&amp;gt;&amp;#39;error, warning&amp;#39;,
                    &amp;#39;emails&amp;#39;=&amp;gt;&amp;#39;admin@example.com&amp;#39;,
                ),
            ),
        ),
    ),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注册使用名为log的组件，组件对应的类为CLogRouter（见类文件yii/framework/logging/CLogRouter.php），并且需要为组件提供参数routes，
从目录yii/framework/logging可以看到可使用的日志输出目标路由有：&lt;code&gt;CDbLogRoute&lt;/code&gt;（将日志记录到数据库中）、&lt;code&gt;CEmailLogRoute&lt;/code&gt;（将日志发送到邮箱）、&lt;code&gt;CFileLogRoute&lt;/code&gt;（记录到文件中）、&lt;code&gt;CWebLogRoute&lt;/code&gt;（将日志显示在对应的网页中）、&lt;code&gt;CProfileLogRoute&lt;/code&gt;，其中CProfileLogRoute直接继承自CWebLogRoute，其他路由类都直接继承自CLogRoute类。&lt;/p&gt;
&lt;p&gt;至于为什么需要对log组件进行preload，即预先实例化，后边再说。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;先来看看Yii::log和Yii::trace的实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Writes a trace message.
 * This method will only log a message when the application is in debug mode.
 * @param string $msg message to be logged
 * @param string $category category of the message
 * @see log
 */
public static function trace($msg,$category=&amp;#39;application&amp;#39;)
{
    // 得先定义常量YII_DEBUG为true
    if(YII_DEBUG)
        // CLogger::LEVEL_TRACE
        self::log($msg,CLogger::LEVEL_TRACE,$category);
}

/**
 * Logs a message.
 * Messages logged by this method may be retrieved via {@link CLogger::getLogs}
 * and may be recorded in different media, such as file, email, database, using
 * {@link CLogRouter}.
 * @param string $msg message to be logged
 * @param string $level level of the message (e.g. &amp;#39;trace&amp;#39;, &amp;#39;warning&amp;#39;, &amp;#39;error&amp;#39;). It is case-insensitive.
 * @param string $category category of the message (e.g. &amp;#39;system.web&amp;#39;). It is case-insensitive.
 */
public static function log($msg,$level=CLogger::LEVEL_INFO,$category=&amp;#39;application&amp;#39;)
{
    if(self::$_logger===null)
        self::$_logger=new CLogger;
    // 注意这里的常量YII_TRACE_LEVEL，如果想日志中含有对应文件名、对应行，那么应该定义YII_TRACE_LEVEL大于0，
    // 这个常量的意思应该是日志追踪的深度
    if(YII_DEBUG &amp;amp;&amp;amp; YII_TRACE_LEVEL&amp;gt;0 &amp;amp;&amp;amp; $level!==CLogger::LEVEL_PROFILE)
    {
        $traces=debug_backtrace();
        $count=0;
        foreach($traces as $trace)
        {
            if(isset($trace[&amp;#39;file&amp;#39;],$trace[&amp;#39;line&amp;#39;]) &amp;amp;&amp;amp; strpos($trace[&amp;#39;file&amp;#39;],YII_PATH)!==0)
            {
                $msg.=&amp;quot;\nin &amp;quot;.$trace[&amp;#39;file&amp;#39;].&amp;#39; (&amp;#39;.$trace[&amp;#39;line&amp;#39;].&amp;#39;)&amp;#39;;
                if(++$count&amp;gt;=YII_TRACE_LEVEL)
                    break;
            }
        }
    }
    // 调用的是CLogger类的log方法
    self::$_logger-&amp;gt;log($msg,$level,$category);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CLogger类的log方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Logs a message.
 * Messages logged by this method may be retrieved back via {@link getLogs}.
 * @param string $message message to be logged
 * @param string $level level of the message (e.g. &amp;#39;Trace&amp;#39;, &amp;#39;Warning&amp;#39;, &amp;#39;Error&amp;#39;). It is case-insensitive.
 * @param string $category category of the message (e.g. &amp;#39;system.web&amp;#39;). It is case-insensitive.
 * @see getLogs
 */
public function log($message,$level=&amp;#39;info&amp;#39;,$category=&amp;#39;application&amp;#39;)
{
    $this-&amp;gt;_logs[]=array($message,$level,$category,microtime(true));
    $this-&amp;gt;_logCount++;
    // autoFlush的默认值为10000，即只有当日志的条数达到10000（或请求处理结束时），才会flush到输出，否则一直将日志存放在内存中
    if($this-&amp;gt;autoFlush&amp;gt;0 &amp;amp;&amp;amp; $this-&amp;gt;_logCount&amp;gt;=$this-&amp;gt;autoFlush &amp;amp;&amp;amp; !$this-&amp;gt;_processing)
    {
        $this-&amp;gt;_processing=true;
        // autoDump默认为false
        $this-&amp;gt;flush($this-&amp;gt;autoDump);
        $this-&amp;gt;_processing=false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CLogger类的flush方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Removes all recorded messages from the memory.
 * This method will raise an {@link onFlush} event.
 * The attached event handlers can process the log messages before they are removed.
 * @param boolean $dumpLogs whether to process the logs immediately as they are passed to log route
 * @since 1.1.0
 */
public function flush($dumpLogs=false)
{
    // 事件对象中会带有当前的CLogger对象，作为事件的发送者
    // 但在类CLogRouter的方法collectLogs和processLogs中并没有使用这个CLogger对象，
    // 而是通过Yii::getLogger()来得到同一个CLogger对象，为什么不直接使用呢？
    $this-&amp;gt;onFlush(new CEvent($this, array(&amp;#39;dumpLogs&amp;#39;=&amp;gt;$dumpLogs)));
    // 清空重置
    $this-&amp;gt;_logs=array();
    $this-&amp;gt;_logCount=0;
}

/**
 * Raises an &amp;lt;code&amp;gt;onFlush&amp;lt;/code&amp;gt; event.
 * @param CEvent $event the event parameter
 * @since 1.1.0
 */
public function onFlush($event)
{
    // 抛出onFlush事件
    // raiseEvent方法定义在CComponent类中，CLogger类继承自CComponent类
    $this-&amp;gt;raiseEvent(&amp;#39;onFlush&amp;#39;, $event);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CComponent类的raiseEvent方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Raises an event.
 * This method represents the happening of an event. It invokes
 * all attached handlers for the event.
 * @param string $name the event name
 * @param CEvent $event the event parameter
 * @throws CException if the event is undefined or an event handler is invalid.
 */
public function raiseEvent($name,$event)
{
    $name=strtolower($name);
    if(isset($this-&amp;gt;_e[$name]))
    {
        // 逐个执行与事件$name绑定的$handler
        foreach($this-&amp;gt;_e[$name] as $handler)
        {
            if(is_string($handler))
                // 会将事件对象(CEvent对象)传到$handler中
                call_user_func($handler,$event);
            elseif(is_callable($handler,true))
            {
                if(is_array($handler))
                {
                    // an array: 0 - object, 1 - method name
                    list($object,$method)=$handler;
                    if(is_string($object))  // static method call
                        call_user_func($handler,$event);
                    elseif(method_exists($object,$method))
                        $object-&amp;gt;$method($event);
                    else
                        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is attached with an invalid handler &amp;quot;{handler}&amp;quot;.&amp;#39;,
                            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name, &amp;#39;{handler}&amp;#39;=&amp;gt;$handler[1])));
                }
                else // PHP 5.3: anonymous function
                    call_user_func($handler,$event);
            }
            else
                throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is attached with an invalid handler &amp;quot;{handler}&amp;quot;.&amp;#39;,
                    array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name, &amp;#39;{handler}&amp;#39;=&amp;gt;gettype($handler))));
            // stop further handling if param.handled is set true
            if(($event instanceof CEvent) &amp;amp;&amp;amp; $event-&amp;gt;handled)
                return;
        }
    }
    elseif(YII_DEBUG &amp;amp;&amp;amp; !$this-&amp;gt;hasEvent($name))
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is not defined.&amp;#39;,
            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看到这里，你可能会很奇怪怎么都没看到真正记录日志的代码呢？在与事件绑定的各个$handler里呢，这也是log组件的routes参数配置成数组的原因，$handle就是该数组中对应类的实例化对象的日志记录方法。&lt;/p&gt;
&lt;p&gt;那么这些$handle是在哪里绑定事件的呢？&lt;/p&gt;
&lt;p&gt;既然log组件对应的是CLogRouter类，那么来看看其实现。&lt;/p&gt;
&lt;p&gt;类CLogRouter继承自类CApplicationComponent。根据&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;一文，可知组件初始化时实例化对象会调用init方法来完成一些初始化操作，类CLogRouter的init方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Initializes this application component.
 * This method is required by the IApplicationComponent interface.
 */
public function init()
{
    parent::init();
    // 实例化配置的routes参数中指定的日志路由类列表
    foreach($this-&amp;gt;_routes as $name=&amp;gt;$route)
    {
        $route=Yii::createComponent($route);
        $route-&amp;gt;init();
        $this-&amp;gt;_routes[$name]=$route;
    }
    // 将当前对象的collectLogs方法绑定到事件onFlush
    Yii::getLogger()-&amp;gt;attachEventHandler(&amp;#39;onFlush&amp;#39;,array($this,&amp;#39;collectLogs&amp;#39;));
    // 将当前对象的processLogs方法绑定到事件onEndRequest（表示请求处理结束？）
    Yii::app()-&amp;gt;attachEventHandler(&amp;#39;onEndRequest&amp;#39;,array($this,&amp;#39;processLogs&amp;#39;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而类CLogRouter的方法collectLogs和processLogs实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Collects log messages from a logger.
 * This method is an event handler to the {@link CLogger::onFlush} event.
 * @param CEvent $event event parameter
 */
public function collectLogs($event)
{
    $logger=Yii::getLogger();
    $dumpLogs=isset($event-&amp;gt;params[&amp;#39;dumpLogs&amp;#39;]) &amp;amp;&amp;amp; $event-&amp;gt;params[&amp;#39;dumpLogs&amp;#39;];
    // 遍历所有日志路由对象，执行其方法collectLogs
    foreach($this-&amp;gt;_routes as $route)
    {
        // 属性enabled默认值为true
        if($route-&amp;gt;enabled)
            // $dumpLogs默认为false，由事件对象传过来
            $route-&amp;gt;collectLogs($logger,$dumpLogs);
    }
}

/**
 * Collects and processes log messages from a logger.
 * This method is an event handler to the {@link CApplication::onEndRequest} event.
 * @param CEvent $event event parameter
 * @since 1.1.0
 */
public function processLogs($event)
{
    $logger=Yii::getLogger();
    // 遍历所有日志路由对象，执行其方法collectLogs
    foreach($this-&amp;gt;_routes as $route)
    {
        if($route-&amp;gt;enabled)
            // 注意这里参数$dumpLogs参数值始终为true
            $route-&amp;gt;collectLogs($logger,true);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以类CWebLogRoute为例来看看日志路由类的方法collectLogs，该方法定义于类CLogRoute中，实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Retrieves filtered log messages from logger for further processing.
 * @param CLogger $logger logger instance
 * @param boolean $processLogs whether to process the logs after they are collected from the logger
 */
// 事件onFlush触发时，传入的$processLogs参数值默认为false，事件onEndRequest触发时为true
public function collectLogs($logger, $processLogs=false)
{
    // 从类CLogger实例化对象的_logs属性值中过滤得到目标日志记录
    $logs=$logger-&amp;gt;getLogs($this-&amp;gt;levels,$this-&amp;gt;categories,$this-&amp;gt;except);
    $this-&amp;gt;logs=empty($this-&amp;gt;logs) ? $logs : array_merge($this-&amp;gt;logs,$logs);
    if($processLogs &amp;amp;&amp;amp; !empty($this-&amp;gt;logs))
    {
        if($this-&amp;gt;filter!==null)
            Yii::createComponent($this-&amp;gt;filter)-&amp;gt;filter($this-&amp;gt;logs);
        if($this-&amp;gt;logs!==array())
            // 调用实际route的processLogs方法
            $this-&amp;gt;processLogs($this-&amp;gt;logs);
        $this-&amp;gt;logs=array();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而类CWebLogRoute的processLogs方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Displays the log messages.
 * @param array $logs list of log messages
 */
public function processLogs($logs)
{
    $this-&amp;gt;render(&amp;#39;log&amp;#39;,$logs);
}

/**
 * Renders the view.
 * @param string $view the view name (file name without extension). The file is assumed to be located under framework/data/views.
 * @param array $data data to be passed to the view
 */
protected function render($view,$data)
{
    $app=Yii::app();
    $isAjax=$app-&amp;gt;getRequest()-&amp;gt;getIsAjaxRequest();
    $isFlash=$app-&amp;gt;getRequest()-&amp;gt;getIsFlashRequest();

    // 用firebug来显示日志信息的话？
    if($this-&amp;gt;showInFireBug)
    {
        // do not output anything for ajax and/or flash requests if needed
        if($isAjax &amp;amp;&amp;amp; $this-&amp;gt;ignoreAjaxInFireBug || $isFlash &amp;amp;&amp;amp; $this-&amp;gt;ignoreFlashInFireBug)
            return;
        $view.=&amp;#39;-firebug&amp;#39;;
        if(($userAgent=$app-&amp;gt;getRequest()-&amp;gt;getUserAgent())!==null &amp;amp;&amp;amp; preg_match(&amp;#39;/msie [5-9]/i&amp;#39;,$userAgent))
        {
            echo &amp;#39;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;#39;;
            echo file_get_contents(dirname(__FILE__).&amp;#39;/../vendors/console-normalizer/normalizeconsole.min.js&amp;#39;);
            echo &amp;quot;&amp;lt;/script&amp;gt;\n&amp;quot;;
        }
    }
    elseif(!($app instanceof CWebApplication) || $isAjax || $isFlash)
        return;

    // 渲染yii/framework/views/log.php（log-firebug.php），将结果放在实际请求页面内容的下面
    $viewFile=YII_PATH.DIRECTORY_SEPARATOR.&amp;#39;views&amp;#39;.DIRECTORY_SEPARATOR.$view.&amp;#39;.php&amp;#39;;
    include($app-&amp;gt;findLocalizedFile($viewFile,&amp;#39;en&amp;#39;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述代码可以知道日志路由类是将日志信息按照一定格式显示在实际请求页面内容的下方。&lt;/p&gt;
&lt;p&gt;再来看看方法init中调用的两个attachEventHandler，它们的定义是同一个，定义在类CComponent中（类CLogger直接继承自类CComponent），实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function attachEventHandler($name,$handler)
{
    // 将事件处理器$handler加到处理器列表中，在事件发生时会逐个处理器触发执行
    $this-&amp;gt;getEventHandlers($name)-&amp;gt;add($handler);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法EventHandlers的实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Returns the list of attached event handlers for an event.
 * @param string $name the event name
 * @return CList list of attached event handlers for the event
 * @throws CException if the event is not defined
 */
public function getEventHandlers($name)
{
    if($this-&amp;gt;hasEvent($name))
    {
        $name=strtolower($name);
        if(!isset($this-&amp;gt;_e[$name]))
            $this-&amp;gt;_e[$name]=new CList;
        return $this-&amp;gt;_e[$name];
    }
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is not defined.&amp;#39;,
            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述分析可以知道所谓事件系统，其实就是将处理函数/对象方法放到与事件ID对应的一个列表中，然后在事件触发时，逐个调用执行这些函数/对象方法。&lt;/p&gt;
&lt;p&gt;Yii框架基于事件系统，可以做到同时将日志信息写到多个目标输出中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;回到之前提到的那个问题：为什么需要对log组件进行preload？&lt;/p&gt;
&lt;p&gt;这是因为：对于日志组件的使用并不是通过&lt;code&gt;Yii::app()-&amp;gt;db&lt;/code&gt;这种形式来调用的（如果基于这种形式，那么就可以在首次调用时再做组件实例化，以实现组件延迟加载），而是通过触发事件来间接调用，但这就需要在事件触发之间将相关的处理函数/对象方法绑定到事件，这个绑定操作又是在日志log组件的init方法中执行的，一般组件类实例化时才会调用其init方法，所以需要对log组件进行预加载。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.yiiframework.com/doc/guide/1.1/en/topics.logging"&gt;Yii - topics - Logging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>又是一年</title><link href="http://youngsterxyf.github.io/2015/01/03/the-2014-is-gone/" rel="alternate"></link><published>2015-01-03T00:00:00+08:00</published><updated>2015-01-03T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-01-03:/2015/01/03/the-2014-is-gone/</id><summary type="html">&lt;p&gt;又是一年，依照惯例，得写一篇总结和计划。当然计划更多的只是一种自我鼓励，现实总是一次又一次地证明“计划赶不上变 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;又是一年，依照惯例，得写一篇总结和计划。当然计划更多的只是一种自我鼓励，现实总是一次又一次地证明“计划赶不上变化”。&lt;/p&gt;
&lt;p&gt;我的2014，可能用三个关键词就能概括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结婚&lt;/li&gt;
&lt;li&gt;换工作&lt;/li&gt;
&lt;li&gt;众成技术聚乐部&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;结婚&lt;/h4&gt;
&lt;p&gt;继13年领证，14年把婚礼也办了。由于两家离得远，婚礼也就分两次办。之间还补拍了婚纱照。虽然于我这些流程显得有点折腾，但重要的是大家都是很开心，也不希望老婆以后会有丁点遗憾。&lt;/p&gt;
&lt;p&gt;希望以后的日子总能努力让老婆开心幸福。&lt;/p&gt;
&lt;h4&gt;换工作&lt;/h4&gt;
&lt;p&gt;工作的时间并不长，本没想这么快换工作，何况我还是一个挺念旧的人。但还是那句话“计划赶不上变化”，不得已主动离职跳槽。&lt;/p&gt;
&lt;p&gt;对于目前的工作还比较满意，能做些自己喜欢做的事情，工作氛围也还不错。&lt;/p&gt;
&lt;p&gt;对于自己的要求就是踏踏实实做工作搞技术，不急不躁。&lt;/p&gt;
&lt;h4&gt;&lt;a href="http://happytechgroup.github.io/"&gt;众成技术聚乐部&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;参加过各种大大小小的会议，总觉得水太多，但如果始终自己一个人蒙头研究技术，也有可能落得个“闭门造车”、“目光短浅”的下场，技术的“理”也是越辩越明，所以找了三五同学朋友搞起自己的技术沙龙，
名为“众成技术聚乐部”，之所以为“众成”，是希望&lt;strong&gt;众人成就众人&lt;/strong&gt;，大家相互成就，之所以为“聚乐部”而不是“俱乐部”，是认为大家一起讨论分享技术应该是一件乐呵的事情，不要搞得那么严肃苦逼。&lt;/p&gt;
&lt;p&gt;聚乐部至今已搞了5次聚会，一个月一次，从我个人的角度来看，效果不错，虽然很多地方还有待改进。感谢所有成员的付出！&lt;/p&gt;
&lt;h4&gt;其他&lt;/h4&gt;
&lt;p&gt;技术上，相比上一年，有了些许进步 - 借着“众成”的技术分享，简单阅读了leveldb（Go语言版）的源码、Memcached源码等；为了把工作做得更好，又仔细地阅读了Yii框架源码，并写了&lt;a href="http://youngsterxyf.github.io/tag/yii.html"&gt;系列文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在写博客一事上，2014年我也不算太偷懒，共写了26篇，虽然文章质量不咋地，远远未达到自己的要求，但一切贵在坚持，不是么？&lt;/p&gt;
&lt;p&gt;阅读方面，书目如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;淘宝技术这十年 （3星，成为大牛也是要看机遇的）&lt;/li&gt;
&lt;li&gt;Web容量规划的艺术 （4星）&lt;/li&gt;
&lt;li&gt;世界是数字的 （5星，计算机科普）&lt;/li&gt;
&lt;li&gt;三体（三册）（1、2册5星，第3册4星）&lt;/li&gt;
&lt;li&gt;20个月赚130亿 - YouTube创始人陈士骏自传 （4星，好吧，这翻译的书名真俗气，但其实是本挺不错的书）&lt;/li&gt;
&lt;li&gt;PHP精粹-编写高效PHP代码 （3星，仔细阅读了前半部分，快速浏览了后半部分）&lt;/li&gt;
&lt;li&gt;MacTalk - 人生元编程 (3星，电子书，大致过了一遍）&lt;/li&gt;
&lt;li&gt;编写高质量代码：改进Python程序的91个建议 （4星，需再读一遍）&lt;/li&gt;
&lt;li&gt;文明之光（两册，5星，有态度的浓缩的世界文明史）&lt;/li&gt;
&lt;li&gt;了不起的Node.js（2星，浏览了一遍）&lt;/li&gt;
&lt;li&gt;Pro Git （4星，Git资料中的No.1）&lt;/li&gt;
&lt;li&gt;演讲之禅：一位技术演讲家的自白 （4星，每个技术人都应该多演讲，所以推荐每个技术人都读一下这本书）&lt;/li&gt;
&lt;li&gt;高性能PHP应用开发 （3星）&lt;/li&gt;
&lt;li&gt;翻译漫谈：怎样翻译更地道 （4星，未读完）&lt;/li&gt;
&lt;li&gt;最璀璨的银河：刘慈欣经典作品集 （4星，读完三体，意犹未尽，故找来大刘的中短篇集读读）&lt;/li&gt;
&lt;li&gt;数据之巅 （5星，数据思维，有点震撼到我，推荐，需再读一遍）&lt;/li&gt;
&lt;li&gt;大型网站技术架构:核心原理与案例分析 (4星，虽然没什么新东西，但系统地科普了Web架构方面的东西，还是值得一读的)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从书目可以看出，技术相关的还是缺乏深度和专注。&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;2015 ...&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;做好工作，多思考，多做实在的事情&lt;/li&gt;
&lt;li&gt;继续搞好众成技术聚乐部&lt;/li&gt;
&lt;li&gt;坚持写博客，向深度发展&lt;/li&gt;
&lt;li&gt;选择一两个优秀开源项目，读源码、写博客、做分享，旨在提高系统设计能力和编码能力&lt;/li&gt;
&lt;li&gt;读有想法、有深度的书&lt;/li&gt;
&lt;li&gt;考驾照 （别笑，哈哈）&lt;/li&gt;
&lt;li&gt;以讲师的身份参加一次技术会议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;（额，“计划”本不该多说，但貌似还是说多了点...）&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category></entry><entry><title>Cordova/Phonegap应用构建环境搭建</title><link href="http://youngsterxyf.github.io/2014/12/31/setup-cordova-env/" rel="alternate"></link><published>2014-12-31T00:00:00+08:00</published><updated>2014-12-31T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-12-31:/2014/12/31/setup-cordova-env/</id><summary type="html">&lt;p&gt;混合（Hybrid）移动开发将Web开发与原生开发优势互补，之后应该是一个不错的方向。Phonegap是混合移动开发的一个方案，
开发者可以使用标准的Web技术进行开发，然后使用Phonegap打包成原生APP，也可以为Phonegap开发插件来扩展APP功能。
Cordova是Apache的顶级项目，起于Adobe贡献给Apache基金会的Phonegap源码，之后Phonegap官方貌似则专注于提供Phonegap应用的云构建服务 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;混合（Hybrid）移动开发将Web开发与原生开发优势互补，之后应该是一个不错的方向。Phonegap是混合移动开发的一个方案，
开发者可以使用标准的Web技术进行开发，然后使用Phonegap打包成原生APP，也可以为Phonegap开发插件来扩展APP功能。
Cordova是Apache的顶级项目，起于Adobe贡献给Apache基金会的Phonegap源码，之后Phonegap官方貌似则专注于提供Phonegap应用的云构建服务。
Phonegap官网提供的文档与Apache Cordova文档是相同的，所以从技术上可以将Phonegap与Cordova视为同一个东西。&lt;/p&gt;
&lt;p&gt;虽然Phonegap官方提供免费的开放（public）应用以及一个私有应用构建服务。但对于应用调试或插件开发来说，
使用云构建服务上传源码下载APP还是挺耗时间的，不太方便，所以搭建本地的应用构建环境是必要的。&lt;/p&gt;
&lt;p&gt;依据Cordova文档的&lt;a href="http://cordova.apache.org/docs/en/4.0.0/guide_cli_index.md.html#The%20Command-Line%20Interface"&gt;The Command-Line Interface&lt;/a&gt;
部分，针对Android应用，在Ubuntu上搭建Cordova应用构建环境的步骤如下所示：&lt;/p&gt;
&lt;h4&gt;1. 安装Node.js和git客户端&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;a href="http://nodejs.org/download/"&gt;NodeJS官网&lt;/a&gt;下载Linux二进制压缩包，解压缩后将bin路径加入PATH环境变量，即可从命令行执行node、npm命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 安装Cordova：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo npm install -g cordova&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. 下载JDK：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install default-jdk default-jre&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4. 安装Android SDK：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从Android官网的&lt;a href="http://developer.android.com/sdk/installing/index.html"&gt;这里&lt;/a&gt;下载Android Studio或独立的SDK工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果下载Android Studio，解压缩后执行&lt;code&gt;bin/android.sh&lt;/code&gt;，Android Studio启动时需要从Google的服务器上获取一些SDK相关的文件，
由于GFW的原因，无法成功获取，也就无法顺利启动。Android Studio网络代理设置的方法（参考&lt;a href="http://stackoverflow.com/questions/27683678/android-studio-component-installation-not-working-in-proxy-security-server?lq=1"&gt;这里&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;在Android Studio首次启动后，可以在HOME目录下找到文件&lt;code&gt;~/.AndroidStudio/config/options/other.xml&lt;/code&gt;，在该文件中，可以找到如下几行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;option name=&amp;quot;PROXY_TYPE_IS_SOCKS&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;USE_HTTP_PROXY&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;USE_PROXY_PAC&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_HOST&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_PORT&amp;quot; value=&amp;quot;80&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_AUTHENTICATION&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_LOGIN&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_PASSWORD_CRYPT&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;KEEP_PROXY_PASSWORD&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果使用HTTP协议的代理，则将“USE_HTTP_PROXY”一项的value改为“true”，“PROXY_HOST”、“PROXY_PORT”的value分别设置为代理的域名和端口，
如果代理需要身份认证，则将“PROXY_AUTHENTICATION”的value改为“true”，并设置“PROXY_LOGIN”、“PROXY_PASSWORD_CRYPT”两项。&lt;/p&gt;
&lt;p&gt;重启Android Studio即可。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果下载独立的SDK工具，假设解压缩后的路径为&lt;code&gt;~/Android&lt;/code&gt;，则添加环境变量&lt;code&gt;ANDROID_HOME=~/Android&lt;/code&gt;，并将子目录tools加入PATH环境变量。&lt;/p&gt;
&lt;p&gt;执行命令 &lt;code&gt;android&lt;/code&gt; 打开Android SDK管理器，与Android Studio一样，也需要设置网络代理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开菜单项“Tools -&amp;gt; Options”，填入“HTTP Proxy Server”、“HTTP Proxy Port”两项的值，重新启动Android SDK管理器即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;由于当前Cordora构建Android应用依赖于Android API 19，即Android 4.4.2，所以需要在“Android Studio”或“Android SDK管理器”
下载“Android API 19”相关的依赖包。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：下载速度很慢，请耐心等待...&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;5. 安装ant&lt;/h4&gt;
&lt;p&gt;当前Cordora构建Android应用也依赖于ant。从&lt;a href="https://www.apache.org/dist/ant/binaries/"&gt;Apache Ant&lt;/a&gt;官网下载二进制包，
解压缩后，将子目录bin加入PATH环境变量。&lt;/p&gt;
&lt;h4&gt;6. 测试&lt;/h4&gt;
&lt;p&gt;依次执行以下命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cordova create hello com.example.hello HelloWorld&lt;/code&gt;，该命令会在当前目录下创建hello子目录；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd hello&lt;/code&gt;，进入该示例工程目录；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cordova platform add android&lt;/code&gt;，为该工程添加Android平台支持；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cordova build android&lt;/code&gt;，将该工程构建成原生Android应用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cordova emulate android&lt;/code&gt;，打开Android模拟器运行示例应用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模拟器启动后如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="cordova_demo" src="https://i.loli.net/2020/06/14/kDfRcbjigUHvQZY.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最终生成的apk文件在&lt;code&gt;hello/platforms/android/ant-build/&lt;/code&gt;路径下，默认名为“CordovaApp-debug.apk”。&lt;/p&gt;
&lt;p&gt;对于Cordora项目来说，源码目录即项目的www子目录。&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="Cordova"></category><category term="Phonegap"></category></entry><entry><title>读书笔记：演讲之禅-一个技术演讲家的自白</title><link href="http://youngsterxyf.github.io/2014/12/15/read-confessions-of-a-public-speaker/" rel="alternate"></link><published>2014-12-15T00:00:00+08:00</published><updated>2014-12-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-12-15:/2014/12/15/read-confessions-of-a-public-speaker/</id><summary type="html">&lt;p&gt;大大小小的技术会议参加过不少，关于演讲，从一个听众的角度也有一些心得；随着技术积累能力提升，也希望能够在一些 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;大大小小的技术会议参加过不少，关于演讲，从一个听众的角度也有一些心得；随着技术积累能力提升，也希望能够在一些正式场合做技术演讲。年轻的技术人应该学会经营自己，show出你自己。&lt;/p&gt;
&lt;p&gt;我并不是一个擅长表达的人，虽然私底下在朋友技术圈内做过一些技术分享，但对于正式场合的技术演讲却没什么经验。&lt;/p&gt;
&lt;p&gt;演讲是个经验活，但总归有一些可事先准备、能够提高成功概率的方法和注意事项吧？所以找来《演讲之禅-一个技术演讲家的自白》一书，看看是否能从别人的经验中学到点什么。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;毋庸置疑，这本书非常实在，值得一读。根据该书内容以及自己的一些想法，按照时间顺序整理出技术演讲相关的注意事项：&lt;/p&gt;
&lt;h4&gt;演讲前&lt;/h4&gt;
&lt;p&gt;一个成功的演讲毫无疑问是需要提前准备的，这里的“准备”不仅仅是准备幻灯片这么简单。&lt;/p&gt;
&lt;p&gt;首先，你需要搞清楚-举办方对会议或者活动的定位，与定位直接相关的即是听众-是哪些人，他们想知道什么，需要听到什么，根据这个定位来选择主题；
与主题相关的是你需要考虑自身是否有能力驾驭这个主题-待分享的技术你是否真的懂？这方面经验是否足够？不要试图分享那些自己还一知半解的技术点，否则就注定是在给自己挖坑！&lt;/p&gt;
&lt;p&gt;从听众情况和自身情况两方面来选择主题，另外还得根据演讲的时间来调整主题的范围大小。从小老师就告诉我们作文题目得小而具体，立意要新。个人认为对于演讲的题目也应如此。&lt;/p&gt;
&lt;p&gt;在确定演讲的具体题目后，个人建议可以先篇文章，在文章中将演讲题目相关的问题细节都搞清楚讲清楚，然后根据文章内容确定要分享内容中哪些方面（通常由于时间限制很难面面俱到，所以要有所选择），
定下演讲的提纲，即明确了演讲的整个大致的思路，这个“思路”决定了听众是否容易理解你演讲的内容、在演讲过程中是否能够一气呵成顺畅发挥，接下来就可以制作幻灯片了。&lt;/p&gt;
&lt;p&gt;对于幻灯片，应该每页都言简意赅，生动多图。在出现一个新的部分前最好再出现一下大纲，向听众明确“现在讲到哪了”、“接下来要讲的内容处于整个演讲的哪个位置”，避免听众迷失。&lt;/p&gt;
&lt;p&gt;不要想着把幻灯片一次性完美地做完，和文章、代码一样，优秀的幻灯片都是修改出来的。在做完幻灯片的初稿后，就可以开始演练 - 想象着站在演讲台上的场景，在心里对着幻灯片进行表述，
当然如果有人愿意做听众陪你演练那是再好不过了。演练过程中要注意：每页幻灯片的位置是否合适？其上的内容是否恰到好处？是否有助于自然地表述？如何紧凑自然地进行幻灯片之间的衔接？
这个过程通常伴随着对幻灯片的不断修改（通常删除的多增加的少），演练的最终效果应达到不看幻灯片也能清楚演讲大纲，看到一页幻灯片就能知道下一页幻灯片的内容。&lt;/p&gt;
&lt;p&gt;上面提到内容的准备要注意演讲的时间限制，练习过程要确保最终演讲所需时间不超过限制。&lt;/p&gt;
&lt;p&gt;除了内容相关的准备，注意幻灯片最好保存三份：网络存储一份、U盘一份、笔记本电脑中一份 - 带上自己的笔记本电脑去演讲现场，另外最好还打印一份纸质版的。&lt;/p&gt;
&lt;p&gt;应保证提前到场 - 熟悉环境及做好心理准备，还可以看看前面的演讲者的演讲过程。如果到演讲场地的路程较远，则应该把可能的堵车考虑在内。&lt;/p&gt;
&lt;h4&gt;演讲时&lt;/h4&gt;
&lt;p&gt;演讲时如果听众人数不多，或场地很大而听众坐得比较稀疏，则可以鼓励听众集中坐到前排来。&lt;/p&gt;
&lt;p&gt;如果预先不清楚听众的背景，那么可以先做个小的调查确定一下演讲的节奏、内容上的取舍等再开始演讲。&lt;/p&gt;
&lt;p&gt;演讲开始时简单自我介绍一下，然后设定一下演讲的步调：内容大致有哪些，所花时间为多少（当然可能听众通过会议日程已经获知），如果可以最好以一个笑话或故事开场激活一下现场氛围。&lt;/p&gt;
&lt;p&gt;注意正对听众，注意眼神交流，坦诚、自然而有激情，如果需要按照现场情况与听众进行一些小的互动。&lt;/p&gt;
&lt;p&gt;如果可以，在演讲的开始或结束告知听众的Email、社交网络ID（写在幻灯片上），以便进一步的交流或获取用户反馈。&lt;/p&gt;
&lt;p&gt;注意演讲时表达上的重读或者说声调上最好抑扬顿挫，以便听众更好地把握重点，也更容易吸引听众的注意力。&lt;/p&gt;
&lt;p&gt;适当地使用停顿 - 凝聚听众注意力、给听众留下思考和总结的空间。&lt;/p&gt;
&lt;p&gt;演讲时即使发生一些意外情况，也没什么大不了的，谨记：坦诚、自然/淡定、不卑不亢。&lt;/p&gt;
&lt;h4&gt;演讲后&lt;/h4&gt;
&lt;p&gt;为了提升自身的演讲水平，演讲后可以和听众交流一下，请他们提提意见。如果有朋友也在现场，那就最好了。&lt;/p&gt;
&lt;p&gt;如果演讲有视频记录，则也可以自己观看一下，找一下问题，查一下原因。&lt;/p&gt;
&lt;p&gt;也可以在社交网络上鼓励大家提意见（多半演讲之后会有很多人在社交网络关注你）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;细节决定成败！更多演讲相关的细节问题推荐阅读《演讲之禅-一个技术演讲家的自白》。附上该书的思维导图笔记：&lt;/p&gt;
&lt;p&gt;&lt;img alt="read-confessions-of-a-public-speaker" src="/assets/uploads/pics/read-confessions-of-a-public-speaker.png"&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/read-confessions-of-a-public-speaker.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="演讲"></category></entry><entry><title>读书笔记：高性能PHP应用开发</title><link href="http://youngsterxyf.github.io/2014/12/08/read-high-performance-php-application/" rel="alternate"></link><published>2014-12-08T00:00:00+08:00</published><updated>2014-12-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-12-08:/2014/12/08/read-high-performance-php-application/</id><content type="html">&lt;p&gt;注：&lt;em&gt;该书的部分内容过时了点 - 比如Opcode缓存：PHP 5.5之后内置一个用于缓存Opcode的组件Opcache，无需额外使用APC组件。所以需要“批判”地阅读。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mindmap-high-performance-php-application" src="/assets/uploads/pics/High-performance-php-app.png"&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/High-performance-php-app.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="笔记"></category></entry><entry><title>Yii源码阅读笔记 - 应用模块化</title><link href="http://youngsterxyf.github.io/2014/11/20/read-yii-code-7/" rel="alternate"></link><published>2014-11-20T00:00:00+08:00</published><updated>2014-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-20:/2014/11/20/read-yii-code-7/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架有个“模块（Module）”的概念，与“应用（Application）”类似，模块必须归属于一个父模块或者一个应用，模块不能单独部署，一个应用不一定要分 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架有个“模块（Module）”的概念，与“应用（Application）”类似，模块必须归属于一个父模块或者一个应用，模块不能单独部署，一个应用不一定要分模块。&lt;/p&gt;
&lt;p&gt;由此可以看到，Yii的“模块”和“应用”类似于Django框架中的“应用（App）”和“项目（Project）”。&lt;/p&gt;
&lt;p&gt;当一个应用的规模大到一定的程度 - 可能涉及多个团队来开发，就应该考虑分“模块”开发。“模块”通常对应应用的一个相对独立的功能。&lt;/p&gt;
&lt;p&gt;一个模块化的Yii框架应用的工程目录结构大致示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Yii-WebApp-Modules" src="/assets/uploads/pics/yii-webapp-modules.png"&gt;&lt;/p&gt;
&lt;p&gt;上图所示项目有一个名为“forum”的模块，该模块下也有自己的&lt;code&gt;components&lt;/code&gt;、&lt;code&gt;controllers&lt;/code&gt;、&lt;code&gt;models&lt;/code&gt;、&lt;code&gt;views&lt;/code&gt;、&lt;code&gt;extensions&lt;/code&gt;目录，与一个普通的/不分模块的Yii框架Web应用的项目结构非常相似。&lt;/p&gt;
&lt;p&gt;Yii框架模块化应用的所有模块默认都是放在&lt;code&gt;protected/modules&lt;/code&gt;目录下，每个模块的内容又各自放在以模块ID（如&lt;code&gt;forum&lt;/code&gt;）为名称的子目录下，并且在模块子目录下要有一个模块类文件，如&lt;code&gt;ForumModule.php&lt;/code&gt;，该类文件的命名规范是：模块ID首字母大写，然后拼接上字符串Module。&lt;/p&gt;
&lt;p&gt;模块化的应用需要在配置文件中配置&lt;code&gt;modules&lt;/code&gt;一项 - 指定模块列表，示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;modules&amp;#39; =&amp;gt; array(
    &amp;#39;forum&amp;#39; =&amp;gt; array(
        ...
    ),
    &amp;#39;anotherModule&amp;#39;,
    ...
),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每个模块的配置，可以只指定模块ID，也可以通过数组来指定额外的信息，如模块类、类实例化参数、params、components，以及子模块等等。Yii中模块是可以嵌套的，并且嵌套深度没有限制（有这个必要么？不要玩脱了啊）。&lt;/p&gt;
&lt;p&gt;对应某个模块中的控制器及控制器中的Action，路由中需要带模块ID前缀，如&lt;code&gt;moduleID/controllerID/actionID&lt;/code&gt;，对于嵌套的模块，路由的形式则为&lt;code&gt;parentModuleID/childModuleID/controllerID/actionID&lt;/code&gt;。路由分发逻辑会根据模块ID到配置信息中查找对应的模块，最终分发到某个模块的某个控制器的某个Action中做处理。&lt;/p&gt;
&lt;p&gt;另外，Yii框架应用的模块化并不是必须把所有功能逻辑都拆分到各个模块，而是可以部分功能逻辑归到应用，部分逻辑归到模块，即可以不彻底地模块化，但个人认为最好别这么玩（应用下的controller的id和模块的id冲突怎么办？），并且最好不要用模块嵌套，以免搞得过于复杂，降低项目的可维护性。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;先从继承关系上看看“模块”与“应用”的相似性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CWebApplication&lt;/code&gt; -&amp;gt; &lt;code&gt;CApplication&lt;/code&gt; -&amp;gt; &lt;code&gt;CModule&lt;/code&gt; -&amp;gt; &lt;code&gt;CComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自定义模块类 -&amp;gt; &lt;code&gt;CWebModule&lt;/code&gt; -&amp;gt; &lt;code&gt;CModule&lt;/code&gt; -&amp;gt; &lt;code&gt;CComponent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可以看到继承链中类&lt;code&gt;CModule&lt;/code&gt;及上溯类的属性和方法，“模块”类和“应用”都有。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt;一文可知，应用配置的加载是抽象类CApplication的构造方法中调用方法&lt;code&gt;configure&lt;/code&gt;来完成的，
该方法定义于类&lt;code&gt;CModule&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Configures the module with the specified configuration.
 * @param array $config the configuration array
 */
public function configure($config)
{
    if(is_array($config))
    {
        foreach($config as $key=&amp;gt;$value)
            $this-&amp;gt;$key=$value;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于配置项“modules”的加载，则是通过类&lt;code&gt;CComponent&lt;/code&gt;中的魔术方法&lt;code&gt;__set&lt;/code&gt;最终调用类&lt;code&gt;CModule&lt;/code&gt;中的&lt;code&gt;setModules&lt;/code&gt;方法来完成的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Configures the sub-modules of this module.
 *
 * Call this method to declare sub-modules and configure them with their initial property values.
 * The parameter should be an array of module configurations. Each array element represents a single module,
 * which can be either a string representing the module ID or an ID-configuration pair representing
 * a module with the specified ID and the initial property values.
 *
 * For example, the following array declares two modules:
 * &amp;lt;pre&amp;gt;
 * array(
 *     &amp;#39;admin&amp;#39;,                // a single module ID
 *     &amp;#39;payment&amp;#39;=&amp;gt;array(       // ID-configuration pair
 *         &amp;#39;server&amp;#39;=&amp;gt;&amp;#39;paymentserver.com&amp;#39;,
 *     ),
 * )
 * &amp;lt;/pre&amp;gt;
 *
 * By default, the module class is determined using the expression &amp;lt;code&amp;gt;ucfirst($moduleID).&amp;#39;Module&amp;#39;&amp;lt;/code&amp;gt;.
 * And the class file is located under &amp;lt;code&amp;gt;modules/$moduleID&amp;lt;/code&amp;gt;.
 * You may override this default by explicitly specifying the &amp;#39;class&amp;#39; option in the configuration.
 *
 * You may also enable or disable a module by specifying the &amp;#39;enabled&amp;#39; option in the configuration.
 *
 * @param array $modules module configurations.
 */
public function setModules($modules)
{
    foreach($modules as $id=&amp;gt;$module)
    {
        // 如果只指定了模块的id
        if(is_int($id))
        {
            $id=$module;
            $module=array();
        }
        // 如果未指定模块对应的模块类，则默认通过路径别名$id.&amp;#39;.&amp;#39;.ucfirst($id).&amp;#39;Module&amp;#39;来查找对应的模块类
        if(!isset($module[&amp;#39;class&amp;#39;]))
        {
            Yii::setPathOfAlias($id,$this-&amp;gt;getModulePath().DIRECTORY_SEPARATOR.$id);
            $module[&amp;#39;class&amp;#39;]=$id.&amp;#39;.&amp;#39;.ucfirst($id).&amp;#39;Module&amp;#39;;
        }

        // 将模块配置信息存入属性_moduleConfig中
        if(isset($this-&amp;gt;_moduleConfig[$id]))
            $this-&amp;gt;_moduleConfig[$id]=CMap::mergeArray($this-&amp;gt;_moduleConfig[$id],$module);
        else
            $this-&amp;gt;_moduleConfig[$id]=$module;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到模块列表配置信息加载后并未对模块类进行实例化初始化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;请求处理在路由解析得到目标路由后，调用方法&lt;code&gt;createController&lt;/code&gt;来做路由分发（这样表述可能不太严谨），该方法定义于类&lt;code&gt;CWebApplication&lt;/code&gt;中，实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function createController($route,$owner=null)
{
    // 如果未提供参数$owner，即未指定当前$route所属的模块，则默认当前应用对象为owner，可以将应用当做是顶级模块
    if($owner===null)
        $owner=$this;
    // 如果路由为空，则使用默认路由
    // 应用的默认路由ID是site，模块的默认路由ID为default
    if(($route=trim($route,&amp;#39;/&amp;#39;))===&amp;#39;&amp;#39;)
        $route=$owner-&amp;gt;defaultController;
    // 路由是否大小写敏感
    $caseSensitive=$this-&amp;gt;getUrlManager()-&amp;gt;caseSensitive;

    $route.=&amp;#39;/&amp;#39;;
    // 如果路由中还有斜杠
    // 注意这里是个while循环
    while(($pos=strpos($route,&amp;#39;/&amp;#39;))!==false)
    {
        // 取出第一个斜杠之前的部分，用于之后的代码看看是否有对应该ID的controller或module
        $id=substr($route,0,$pos);
        if(!preg_match(&amp;#39;/^\w+$/&amp;#39;,$id))
            return null;
        if(!$caseSensitive)
            $id=strtolower($id);
        // 取出第一个斜杠之后的部分，用于可能的下一次循环处理
        $route=(string)substr($route,$pos+1);
        // 看看是否是第一次循环处理
        // $basePath是在第一次循环处理时在这个if条件分支中才赋值的，所以第一次循环处理到这里时$basePath是未定义
        if(!isset($basePath))  // first segment
        {
            // 先从应用或模块配置的controllerMap中看看是否有$id为key的controller，若有，则直接实例化对应的controll类并返回
            if(isset($owner-&amp;gt;controllerMap[$id]))
            {
                return array(
                    Yii::createComponent($owner-&amp;gt;controllerMap[$id],$id,$owner===$this?null:$owner),
                    $this-&amp;gt;parseActionParams($route),
                );
            }

            // 看看当前应用的modules配置项中是否有以$id为key的模块，或当前模块的modules配置中是否有以$id为key的子模块，如果有则以$module为$owner参数值递归调用createController方法
            if(($module=$owner-&amp;gt;getModule($id))!==null)
                return $this-&amp;gt;createController($route,$module);

            // 当前应用或模块下的控制器类的存放目录
            $basePath=$owner-&amp;gt;getControllerPath();
            $controllerID=&amp;#39;&amp;#39;;
        }
        else
            $controllerID.=&amp;#39;/&amp;#39;;
        // 默认以$id为controller的ID，在当前应用或模块下查找是否有对应的控制器类文件
        $className=ucfirst($id).&amp;#39;Controller&amp;#39;;
        $classFile=$basePath.DIRECTORY_SEPARATOR.$className.&amp;#39;.php&amp;#39;;

        // 擦，怎么多出一个命名空间的东西？
        if($owner-&amp;gt;controllerNamespace!==null)
            $className=$owner-&amp;gt;controllerNamespace.&amp;#39;\\&amp;#39;.$className;
        // 如果有对应的控制器类文件，则尝试加载实例化
        if(is_file($classFile))
        {
            if(!class_exists($className,false))
                require($classFile);
            if(class_exists($className,false) &amp;amp;&amp;amp; is_subclass_of($className,&amp;#39;CController&amp;#39;))
            {
                $id[0]=strtolower($id[0]);
                return array(
                    new $className($controllerID.$id,$owner===$this?null:$owner),
                    $this-&amp;gt;parseActionParams($route),
                );
            }
            return null;
        }
        // 否则把$id看成普通的一级目录名
        $controllerID.=$id;
        $basePath.=DIRECTORY_SEPARATOR.$id;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述代码中可以看到，控制器类在实例化时需要传入该控制器类属于应用还是属于某个模块，这个归属记录在控制器类实例的_module属性中，如果属性值为null，则表示属于应用，_module属性定义于类&lt;code&gt;CController&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;我们来看看上述代码中调用的方法&lt;code&gt;getModule&lt;/code&gt;的实现，这个方法调用的&lt;code&gt;$owner&lt;/code&gt;可能是应用对象也可能是某个模块类对象，该方法定义于抽象类&lt;code&gt;CModule&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getModule($id)
{
    // 如果$id对应的module已经实例化好，则直接返回
    if(isset($this-&amp;gt;_modules[$id]) || array_key_exists($id,$this-&amp;gt;_modules))
        return $this-&amp;gt;_modules[$id];
    // 看是否配置了$id对应的module
    elseif(isset($this-&amp;gt;_moduleConfig[$id]))
    {
        $config=$this-&amp;gt;_moduleConfig[$id];
        if(!isset($config[&amp;#39;enabled&amp;#39;]) || $config[&amp;#39;enabled&amp;#39;])
        {
            Yii::trace(&amp;quot;Loading \&amp;quot;$id\&amp;quot; module&amp;quot;,&amp;#39;system.base.CModule&amp;#39;);
            $class=$config[&amp;#39;class&amp;#39;];
            unset($config[&amp;#39;class&amp;#39;], $config[&amp;#39;enabled&amp;#39;]);
            // 实例化module，module的$owner可能是当前应用对象，也可能是一个模块对象
            if($this===Yii::app())
                $module=Yii::createComponent($class,$id,null,$config);
            else
                $module=Yii::createComponent($class,$this-&amp;gt;getId().&amp;#39;/&amp;#39;.$id,$this,$config);
            return $this-&amp;gt;_modules[$id]=$module;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述代码可以看到，每个模块对象也会记录它的归属 - 属于应用对象，还是某个父模块对象。&lt;/p&gt;
&lt;p&gt;自定义模块类无需定义自己的构造方法，构造方法可以间接继承自抽象类&lt;code&gt;CModule&lt;/code&gt;（&lt;code&gt;CWebModule&lt;/code&gt;类并未定义自己的构造方法），其构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($id,$parent,$config=null)
{
    $this-&amp;gt;_id=$id;
    $this-&amp;gt;_parentModule=$parent;

    // set basePath at early as possible to avoid trouble
    if(is_string($config))
        $config=require($config);
    if(isset($config[&amp;#39;basePath&amp;#39;]))
    {
        $this-&amp;gt;setBasePath($config[&amp;#39;basePath&amp;#39;]);
        unset($config[&amp;#39;basePath&amp;#39;]);
    }
    Yii::setPathOfAlias($id,$this-&amp;gt;getBasePath());

    $this-&amp;gt;preinit();

    $this-&amp;gt;configure($config);
    $this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors);
    $this-&amp;gt;preloadComponents();

    $this-&amp;gt;init();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个方法与Web应用类的构造方法（定义于抽象类&lt;code&gt;CApplication&lt;/code&gt;中）实现非常相似。这两个构造方法是调用同一个&lt;code&gt;configure&lt;/code&gt;方法来加载配置的，所以很多“应用”的配置项，“模块”也都支持。
从上述模块的构造方法中可以看到当前模块属于哪个父模块是记录在属性&lt;code&gt;_parentModule&lt;/code&gt;中的，如果该属性值为null，则表示当前模块属于当前Web应用对象。这样通过获取控制器对象的&lt;code&gt;_module&lt;/code&gt;属性值，继而获取模块对象的&lt;code&gt;_parentModule&lt;/code&gt;属性值，就能知道整个归属关系链。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;注：&lt;em&gt;以下部分是对&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-2/"&gt;Yii源码阅读笔记 - 路由解析&lt;/a&gt;一文的补充。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;前面讨论的方法&lt;code&gt;createController&lt;/code&gt;中还调用了方法&lt;code&gt;parseActionParams&lt;/code&gt;来解析获取Action的ID，也定义于类&lt;code&gt;CWebApplication&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Parses a path info into an action ID and GET variables.
 * @param string $pathInfo path info
 * @return string action ID
 */
protected function parseActionParams($pathInfo)
{
    // 屌！其实就是以斜杠分割$pathInfo取第一个部分作为Action的ID
    if(($pos=strpos($pathInfo,&amp;#39;/&amp;#39;))!==false)
    {
        $manager=$this-&amp;gt;getUrlManager();
        // 第一个部分之外剩余的部分做请求参数解析
        $manager-&amp;gt;parsePathInfo((string)substr($pathInfo,$pos+1));

        $actionID=substr($pathInfo,0,$pos);
        return $manager-&amp;gt;caseSensitive ? $actionID : strtolower($actionID);
    }
    else
        // 如果$pathInfoH中不存在斜杠，则就将$pathInfo作为Action的ID
        return $pathInfo;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的&lt;code&gt;parsePathInfo&lt;/code&gt;方法，定义于类&lt;code&gt;CUrlManager&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Parses a path info into URL segments and saves them to $_GET and $_REQUEST.
 * @param string $pathInfo path info
 */
public function parsePathInfo($pathInfo)
{
    if($pathInfo===&amp;#39;&amp;#39;)
        return;
    $segs=explode(&amp;#39;/&amp;#39;,$pathInfo.&amp;#39;/&amp;#39;);
    $n=count($segs);
    for($i=0;$i&amp;lt;$n-1;$i+=2)
    {
        $key=$segs[$i];
        if($key===&amp;#39;&amp;#39;) continue;
        $value=$segs[$i+1];
        if(($pos=strpos($key,&amp;#39;[&amp;#39;))!==false &amp;amp;&amp;amp; ($m=preg_match_all(&amp;#39;/\[(.*?)\]/&amp;#39;,$key,$matches))&amp;gt;0)
        {
            $name=substr($key,0,$pos);
            for($j=$m-1;$j&amp;gt;=0;--$j)
            {
                if($matches[1][$j]===&amp;#39;&amp;#39;)
                    $value=array($value);
                else
                    $value=array($matches[1][$j]=&amp;gt;$value);
            }
            if(isset($_GET[$name]) &amp;amp;&amp;amp; is_array($_GET[$name]))
                $value=CMap::mergeArray($_GET[$name],$value);
            $_REQUEST[$name]=$_GET[$name]=$value;
        }
        else
            $_REQUEST[$key]=$_GET[$key]=$value;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;仔细看看上述代码的逻辑吧，累觉不爱啊！&lt;/p&gt;
&lt;p&gt;这个方法的作用：在目标路由去除Controller ID和Action ID两个部分后，从剩余部分中按一定规则解析出请求参数，那么规则是什么样的呢？&lt;/p&gt;
&lt;p&gt;举例来说，这个目标路由剩余部分的基本形式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;key/value/key/value/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;key&lt;/code&gt;为参数名，&lt;code&gt;value&lt;/code&gt;为参数值。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;key&lt;/code&gt;的形式可以数组取值的形式，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name[x][y][z]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种形式的&lt;code&gt;key&lt;/code&gt;对应的&lt;code&gt;value&lt;/code&gt;会从原来的字符串转换成数组形式，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;array(
    &amp;#39;x&amp;#39; =&amp;gt; array(
        &amp;#39;y&amp;#39; =&amp;gt; array(
            &amp;#39;z&amp;#39; =&amp;gt; array(&amp;#39;value&amp;#39;)
        )
    )
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多个&lt;code&gt;key&lt;/code&gt;的&lt;code&gt;name&lt;/code&gt;可以相同，如果相同，则会合并数组。如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name[a][b][c]/value1/name[A][B][C]/value2/name[x][y][z]/value3/name[a][X][f]/value4/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最终会转换成请求参数项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$_REQUEST[&amp;#39;name&amp;#39;] = $_GET[&amp;#39;name&amp;#39;] = array(
    &amp;#39;a&amp;#39; =&amp;gt; array(
        &amp;#39;b&amp;#39; =&amp;gt; array(
            &amp;#39;c&amp;#39; =&amp;gt; array(&amp;#39;value1&amp;#39;),
        ),
        &amp;#39;X&amp;#39; =&amp;gt; array(
            &amp;#39;f&amp;#39; =&amp;gt; array(&amp;#39;value4&amp;#39;),
        ),
    ),
    &amp;#39;A&amp;#39; =&amp;gt; array(
        &amp;#39;B&amp;#39; =&amp;gt; array(
            &amp;#39;C&amp;#39; =&amp;gt; array(&amp;#39;value2&amp;#39;),
        ),
    ),
    &amp;#39;x&amp;#39; =&amp;gt; array(
        &amp;#39;y&amp;#39; =&amp;gt; array(
            &amp;#39;z&amp;#39; =&amp;gt; array(&amp;#39;value3&amp;#39;),
        ),
    ),
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;擦，牛逼到死啊！&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 缓存</title><link href="http://youngsterxyf.github.io/2014/11/19/read-yii-code-6/" rel="alternate"></link><published>2014-11-19T00:00:00+08:00</published><updated>2014-11-19T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-19:/2014/11/19/read-yii-code-6/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;从之前的文章&lt;a href="http://youngsterxyf.github.io/2014/11/12/read-yii-code-2/"&gt;Yii源码阅读笔记 - 路由解析&lt;/a&gt;
及&lt;a href="http://youngsterxyf.github.io/2014/11/14/read-yii-code-4/"&gt;Yii源码阅读笔记 - Model层实现&lt;/a&gt;可以看到Yii框架对于&lt;strong&gt;解析好的路由规则&lt;/strong&gt;及&lt;strong&gt;数据表的schema&lt;/strong&gt;都会根据条件尝试读写缓存
来提高 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;从之前的文章&lt;a href="http://youngsterxyf.github.io/2014/11/12/read-yii-code-2/"&gt;Yii源码阅读笔记 - 路由解析&lt;/a&gt;
及&lt;a href="http://youngsterxyf.github.io/2014/11/14/read-yii-code-4/"&gt;Yii源码阅读笔记 - Model层实现&lt;/a&gt;可以看到Yii框架对于&lt;strong&gt;解析好的路由规则&lt;/strong&gt;及&lt;strong&gt;数据表的schema&lt;/strong&gt;都会根据条件尝试读写缓存
来提高应用性能。&lt;/p&gt;
&lt;p&gt;但缓存组件并非核心组件，需要额外的配置，默认ID为&lt;code&gt;cache&lt;/code&gt;，如果不使用该ID，那么就得注意同时配置好框架中使用缓存的组件。&lt;/p&gt;
&lt;p&gt;恰当地使用缓存组件，能明显地提高应用的性能。&lt;/p&gt;
&lt;p&gt;针对不同的缓存后端（backend），Yii框架提供了多种缓存组件，如文件缓存（CFileCache）、Memcached缓存（CMemCache）、Redis缓存（CRedisCache）等。这些缓存组件（除CDummyCache外，CDummyCache并不是一个有效的缓存组件）均直接继承自抽象类CCache（见文件&lt;code&gt;yii/framework/caching/CCache.php&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面以使用Memcached缓存为例，分析Yii框架缓存组件的实现。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;类&lt;code&gt;CMemcache&lt;/code&gt;所在的整个继承树（&lt;code&gt;CMemcache&lt;/code&gt; -&amp;gt; &lt;code&gt;CCache&lt;/code&gt; -&amp;gt; &lt;code&gt;CApplicationComponent&lt;/code&gt; -&amp;gt; &lt;code&gt;CComponent&lt;/code&gt;）上的类都没有构造方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CMemcache&lt;/code&gt;的init方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function init()
{
    // 调用父类CCache的init方法
    parent::init();
    // 获取配置的Memcached服务器列表
    $servers=$this-&amp;gt;getServers();
    // 获取一个Memcache或Memcached对象
    $cache=$this-&amp;gt;getMemCache();
    if(count($servers))
    {
        // 将配置的Memcached服务器加到池中
        foreach($servers as $server)
        {
            // 可选择使用memcached php扩展，但最好别这样，因为memcached扩展不支持一些有用的配置选项，从addServer方法的参数列表就可以看出
            // memcached扩展默认使用余数分步哈希算法，但可配置使用一致性哈希算法
            // 应使用memcache扩展
            if($this-&amp;gt;useMemcached)
                $cache-&amp;gt;addServer($server-&amp;gt;host,$server-&amp;gt;port,$server-&amp;gt;weight);
            else
                $cache-&amp;gt;addServer($server-&amp;gt;host,$server-&amp;gt;port,$server-&amp;gt;persistent,$server-&amp;gt;weight,$server-&amp;gt;timeout,$server-&amp;gt;retryInterval,$server-&amp;gt;status);
        }
    }
    // 如果没有配置服务器列表，则默认使用localhost:11211
    else
        $cache-&amp;gt;addServer(&amp;#39;localhost&amp;#39;,11211);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的父类的init方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function init()
{
    parent::init();
    // 可以为整个应用的缓存的key加一个统一的前缀，这是为了避免在同一个缓存池中，不同应用的key冲突
    if($this-&amp;gt;keyPrefix===null)
        // 如果没有配置keyPrefix，则以应用的id作为keyPrefix，这个key，可以配置，如果未配置，则`sprintf(&amp;#39;%x&amp;#39;,crc32($this-&amp;gt;getBasePath().$this-&amp;gt;name))`这样生成，
        // 其中name表示应用的名称，可配置，默认为“My Application”
        // getId方法定义于抽象类CApplication中
        $this-&amp;gt;keyPrefix=Yii::app()-&amp;gt;getId();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;CMemcache&lt;/code&gt;的init方法中调用的方法&lt;code&gt;getServers&lt;/code&gt;和&lt;code&gt;getMemcache&lt;/code&gt;，实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getMemCache()
{
    // 单例
    if($this-&amp;gt;_cache!==null)
        return $this-&amp;gt;_cache;
    else
    {
        // 还是用memcache吧
        $extension=$this-&amp;gt;useMemcached ? &amp;#39;memcached&amp;#39; : &amp;#39;memcache&amp;#39;;
        // 检测一下是否记载了所需扩展
        if(!extension_loaded($extension))
            throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;quot;CMemCache requires PHP {extension} extension to be loaded.&amp;quot;,
                array(&amp;#39;{extension}&amp;#39;=&amp;gt;$extension)));
        // 实例化
        return $this-&amp;gt;_cache=$this-&amp;gt;useMemcached ? new Memcached : new Memcache;
    }
}

public function getServers()
{
    return $this-&amp;gt;_servers;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;与&lt;code&gt;getServers&lt;/code&gt;对应的有方法&lt;code&gt;setServers&lt;/code&gt;，如果需要配置缓存服务器列表，则应该为缓存组件配置&lt;code&gt;servers&lt;/code&gt;一项，基本形式为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;servers&amp;#39;=&amp;gt;array(
    array(
        &amp;#39;host&amp;#39;=&amp;gt;&amp;#39;127.0.0.1&amp;#39;,
        &amp;#39;port&amp;#39;=&amp;gt;11211,
    ),
),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;setServers&lt;/code&gt;方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function setServers($config)
{
    foreach($config as $c)
        $this-&amp;gt;_servers[]=new CMemCacheServerConfiguration($c);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中实例化的类&lt;code&gt;CMemCacheServerConfiguration&lt;/code&gt;也定义于文件&lt;code&gt;yii/framework/caching/CMemCache.php&lt;/code&gt;中，其构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($config)
{
    if(is_array($config))
    {
        foreach($config as $key=&amp;gt;$value)
            $this-&amp;gt;$key=$value;
        if($this-&amp;gt;host===null)
            throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CMemCache server configuration must have &amp;quot;host&amp;quot; value.&amp;#39;));
    }
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CMemCache server configuration must be an array.&amp;#39;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从该构造方法可以看到该类的作用就是将一个Memcached缓存服务器的配置信息封装成一个配置类对象。该类有如下public的属性：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * @var string memcache server hostname or IP address
 */
public $host;
/**
 * @var integer memcache server port
 */
public $port=11211;
/**
 * @var boolean whether to use a persistent connection
 */
public $persistent=true;
/**
 * @var integer probability of using this server among all servers.
 */
public $weight=1;
/**
 * @var integer value in seconds which will be used for connecting to the server
 */
public $timeout=15;
/**
 * @var integer how often a failed server will be retried (in seconds)
 */
public $retryInterval=15;
/**
 * @var boolean if the server should be flagged as online upon a failure
 */
public $status=true;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这些属性也即是每台缓存服务器的可配置项，当然如果用的是memcached扩展，某些配置项就用不上了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;类&lt;code&gt;CCache&lt;/code&gt;定义了访问控制类型public的方法&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;mget&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;、&lt;code&gt;flush&lt;/code&gt;，对应Yii框架缓存组件提供的几个操作，即开发者可以使用这些方法来操作缓存。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;// 根据单个key，获取对应的value
public function get($id)
{
    // generateUniqueKey是根据$id来生成一个唯一的key，也即真正存到缓存的key并不是get方法的$id参数值
    $value = $this-&amp;gt;getValue($this-&amp;gt;generateUniqueKey($id));
    // 如果设置为不进行序列化，则直接返回取得的值
    if($value===false || $this-&amp;gt;serializer===false)
        return $value;
    // 如果未设置serializer，则说明存储时使用的是默认的序列化方法，取到数据后对应地需要使用默认的方法进行反序列化
    if($this-&amp;gt;serializer===null)
        $value=unserialize($value);
    else
        // 否则，使用指定的方法进行反序列化
        $value=call_user_func($this-&amp;gt;serializer[1], $value);
    // 依赖检查，如果依赖没有变，则说明缓存有效，
    // 否则，返回false，表示缓存无效
    // 咦，不要清掉无效的缓存项么？
    if(is_array($value) &amp;amp;&amp;amp; (!$value[1] instanceof ICacheDependency || !$value[1]-&amp;gt;getHasChanged()))
    {
        Yii::trace(&amp;#39;Serving &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; from cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));
        return $value[0];
    }
    else
        return false;
}

// 根据多个key值（$ids），获取多个value
public function mget($ids)
{
    $uids = array();
    foreach ($ids as $id)
        $uids[$id] = $this-&amp;gt;generateUniqueKey($id);

    $values = $this-&amp;gt;getValues($uids);
    $results = array();
    if($this-&amp;gt;serializer === false)
    {
        foreach ($uids as $id =&amp;gt; $uid)
            $results[$id] = isset($values[$uid]) ? $values[$uid] : false;
    }
    else
    {
        foreach($uids as $id =&amp;gt; $uid)
        {
            $results[$id] = false;
            if(isset($values[$uid]))
            {
                $value = $this-&amp;gt;serializer === null ? unserialize($values[$uid]) : call_user_func($this-&amp;gt;serializer[1], $values[$uid]);
                if(is_array($value) &amp;amp;&amp;amp; (!$value[1] instanceof ICacheDependency || !$value[1]-&amp;gt;getHasChanged()))
                {
                    Yii::trace(&amp;#39;Serving &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; from cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));
                    $results[$id] = $value[0];
                }
            }
        }
    }
    return $results;
}

// 向$id存储一个元素值为 $value
public function set($id,$value,$expire=0,$dependency=null)
{
    Yii::trace(&amp;#39;Saving &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; to cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));

    if ($dependency !== null &amp;amp;&amp;amp; $this-&amp;gt;serializer !== false)
        // 获取依赖值
        $dependency-&amp;gt;evaluateDependency();

    // 连同依赖一起序列化然后缓存起来
    // 下次获取缓存后，检查一下依赖是否发生变更，是则说明缓存已经失效
    if ($this-&amp;gt;serializer === null)
        $value = serialize(array($value,$dependency));
    elseif ($this-&amp;gt;serializer !== false)
        $value = call_user_func($this-&amp;gt;serializer[0], array($value,$dependency));

    return $this-&amp;gt;setValue($this-&amp;gt;generateUniqueKey($id), $value, $expire);
}

// 在缓存服务器之前不存在$id时， 以id作为key存储一个变量$value到缓存服务器
public function add($id,$value,$expire=0,$dependency=null)
{
    Yii::trace(&amp;#39;Adding &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; to cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));

    if ($dependency !== null &amp;amp;&amp;amp; $this-&amp;gt;serializer !== false)
        $dependency-&amp;gt;evaluateDependency();

    if ($this-&amp;gt;serializer === null)
        $value = serialize(array($value,$dependency));
    elseif ($this-&amp;gt;serializer !== false)
        $value = call_user_func($this-&amp;gt;serializer[0], array($value,$dependency));

    return $this-&amp;gt;addValue($this-&amp;gt;generateUniqueKey($id), $value, $expire);
}

// 根据id删除缓存项
public function delete($id)
{
    Yii::trace(&amp;#39;Deleting &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; from cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));
    return $this-&amp;gt;deleteValue($this-&amp;gt;generateUniqueKey($id));
}

// 清空缓存
public function flush()
{
    Yii::trace(&amp;#39;Flushing cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));
    return $this-&amp;gt;flushValues();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述代码中可以看到，每种操作方法实际上都是调用另一个方法来完成操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get -&amp;gt; getValue&lt;/li&gt;
&lt;li&gt;mget -&amp;gt; getValues&lt;/li&gt;
&lt;li&gt;set -&amp;gt; setValue&lt;/li&gt;
&lt;li&gt;add -&amp;gt; addValue&lt;/li&gt;
&lt;li&gt;delete -&amp;gt; deleteValue&lt;/li&gt;
&lt;li&gt;flush -&amp;gt; flushValues&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但抽象类&lt;code&gt;CCache&lt;/code&gt;中对于后面的这些方法并没有真正实现操作逻辑（除了getValues，其实现是循环调用getValue，也许并不是开发者想要的实现，&lt;code&gt;CMemCache&lt;/code&gt;类重写了这个方法），需要在继承类中实现。&lt;code&gt;CMemCache&lt;/code&gt;类中对这些方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;protected function getValue($key)
{
    return $this-&amp;gt;_cache-&amp;gt;get($key);
}

protected function getValues($keys)
{
    return $this-&amp;gt;useMemcached ? $this-&amp;gt;_cache-&amp;gt;getMulti($keys) : $this-&amp;gt;_cache-&amp;gt;get($keys);
}

protected function setValue($key,$value,$expire)
{
    // 注意：这个地方对于开发者来说也许是个坑
    // 该方法的参数$expire并不是一个时间点，而是一个时间间隔
    // $expire = 0表示不会超时失效
    if($expire&amp;gt;0)
        $expire+=time();
    else
        $expire=0;

    // 使用memcache扩展时，add方法的那个额外参数值0，对应参数flag，表示是否对数据使用zlib进行压缩
    return $this-&amp;gt;useMemcached ? $this-&amp;gt;_cache-&amp;gt;set($key,$value,$expire) : $this-&amp;gt;_cache-&amp;gt;set($key,$value,0,$expire);
}

protected function addValue($key,$value,$expire)
{
    if($expire&amp;gt;0)
        $expire+=time();
    else
        $expire=0;

    return $this-&amp;gt;useMemcached ? $this-&amp;gt;_cache-&amp;gt;add($key,$value,$expire) : $this-&amp;gt;_cache-&amp;gt;add($key,$value,0,$expire);
}

protected function deleteValue($key)
{
    return $this-&amp;gt;_cache-&amp;gt;delete($key, 0);
}

protected function flushValues()
{
    return $this-&amp;gt;_cache-&amp;gt;flush();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;mget&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;、&lt;code&gt;flush&lt;/code&gt;的实现有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实际存储的key并不是方法调用时提供的key，而是经过方法&lt;code&gt;generateUniqueKey&lt;/code&gt;处理的&lt;/li&gt;
&lt;li&gt;实际存储的value可能是经过序列化的，而且可能还包含依赖值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于第一点，&lt;code&gt;generateUniqueKey&lt;/code&gt;方法在抽象类&lt;code&gt;CCache&lt;/code&gt;中实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * @param string $key a key identifying a value to be cached
 * @return string a key generated from the provided key which ensures the uniqueness across applications
 */
protected function generateUniqueKey($key)
{
    return $this-&amp;gt;hashKey ? md5($this-&amp;gt;keyPrefix.$key) : $this-&amp;gt;keyPrefix.$key;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将原本的$key拼接上统一的前缀，如果需要，还进行md5哈希，这样能保证不同的应用之间不会有key冲突。属性hashKey默认值为true。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;关于第二点，缓存依赖的概念简单来说就是在取到一个缓存项后，判断该缓存项是否失效的一个条件。
以页面缓存为例，也许应用中在页面模板渲染后并没有直接将结果响应给用户，而是先缓存起来，但页面可能涉及一些动态内容，这些动态内容是从数据库中某些数据生成的，为了保证正确性，下次读取页面缓存后，还得去数据库里读一下某些相关数据看是否有变更，，如果有变更，则需要重新渲染页面模板，如果没有变更，则直接将缓存的结果返回给用户。这样对于某些变更频率不高的动态内容，在请求处理时就可以避免不必要的页面模板渲染过程。&lt;/p&gt;
&lt;p&gt;判断缓存依赖是否有变更的逻辑是：&lt;strong&gt;在写缓存时，将当时缓存依赖的结果一并存入缓存，读缓存的时候，再将最新缓存依赖的结果与之前存入缓存的依赖结果做对比，不相同，则说明有变更&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;缓存依赖类需要实现接口&lt;code&gt;ICacheDependency&lt;/code&gt;，该接口声明了两个方法&lt;code&gt;evaluateDependency&lt;/code&gt;和&lt;code&gt;getHasChanged&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以缓存依赖类&lt;code&gt;CDbCacheDependency&lt;/code&gt;为例（见文件&lt;code&gt;yii/framework/caching/dependencies/CDbCacheDependency.php&lt;/code&gt;），
该类直接继承自类&lt;code&gt;CCacheDependency&lt;/code&gt;。类&lt;code&gt;CDbCacheDependency&lt;/code&gt;的作用就是根据一条SQL语句从数据库查询数据，然后根据查询结果来判断缓存是否有效。&lt;/p&gt;
&lt;p&gt;父类&lt;code&gt;CCacheDependency&lt;/code&gt;中实现方法&lt;code&gt;evaluateDependency&lt;/code&gt;和&lt;code&gt;getHasChanged&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Evaluates the dependency by generating and saving the data related with dependency.
 * This method is invoked by cache before writing data into it.
 */
public function evaluateDependency()
{
    // 判断是否复用缓存依赖结果
    // 默认为false，可在实例化缓存依赖类时设置
    // 另外对于PHP来说，这个“复用”也只能是一次请求处理过程中的复用
    if ($this-&amp;gt;reuseDependentData)
    {
        // hash方法：求当前对象序列化结果的sha1哈希值
        $hash=$this-&amp;gt;getHash();
        if(!isset(self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]))
            // 如果没有结果可复用，则得重新生成
            self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]=$this-&amp;gt;generateDependentData();
        $this-&amp;gt;_data=self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;];
    }
    else
        $this-&amp;gt;_data=$this-&amp;gt;generateDependentData();
}

/**
 * @return boolean whether the dependency has changed.
 */
// 这个方法其实是读缓存时，从缓存数据中取出缓存依赖的部分反序列化后得到一个依赖对象，由该依赖对象调用它的这个方法来判断缓存依赖是否有变更，
// 所以它的_data属性是写缓存时的缓存依赖数据
public function getHasChanged()
{
    if ($this-&amp;gt;reuseDependentData)
    {
        $hash=$this-&amp;gt;getHash();
        if(!isset(self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]))
            self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]=$this-&amp;gt;generateDependentData();
        // 不相等，则说明发生了变更
        return self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]!=$this-&amp;gt;_data;
    }
    else
        return $this-&amp;gt;generateDependentData()!=$this-&amp;gt;_data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但父类&lt;code&gt;CCacheDependency&lt;/code&gt;并未有效实现上述两个方法中调用的&lt;code&gt;generateDependentData&lt;/code&gt;方法，在类&lt;code&gt;CDbCacheDependency&lt;/code&gt;中实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;protected function generateDependentData()
{
    if($this-&amp;gt;sql!==null)
    {
        // 获取数据库连接组件对象
        $db=$this-&amp;gt;getDbConnection();
        // 准备SQL执行，其中sql属性在构造方法中赋值
        $command=$db-&amp;gt;createCommand($this-&amp;gt;sql);
        if(is_array($this-&amp;gt;params))
        {
            // 绑定参数
            foreach($this-&amp;gt;params as $name=&amp;gt;$value)
                $command-&amp;gt;bindValue($name,$value);
        }
        // 避免从缓存中读取数据库查询结果
        if($db-&amp;gt;queryCachingDuration&amp;gt;0)
        {
            // temporarily disable and re-enable query caching
            $duration=$db-&amp;gt;queryCachingDuration;
            $db-&amp;gt;queryCachingDuration=0;
            $result=$command-&amp;gt;queryRow();
            $db-&amp;gt;queryCachingDuration=$duration;
        }
        else
            $result=$command-&amp;gt;queryRow();
        return $result;
    }
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbCacheDependency.sql cannot be empty.&amp;#39;));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 模板引擎集成</title><link href="http://youngsterxyf.github.io/2014/11/18/read-yii-code-5/" rel="alternate"></link><published>2014-11-18T00:00:00+08:00</published><updated>2014-11-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-18:/2014/11/18/read-yii-code-5/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;通常我们会使用模板引擎来渲染HTML页面，而不是使用HTML代码中插入PHP代码的方式来编写动态页面。Yii框架中模板引擎也是作为组件引入的，默认ID为viewRenderer，
但从&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;可以看到Yii Web应用加载的核心组件中并没有viewRenderer，所以需要自己配置。
Yii提供了一个直接可用的模板引擎组件类CPradoViewRenderer（见 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;通常我们会使用模板引擎来渲染HTML页面，而不是使用HTML代码中插入PHP代码的方式来编写动态页面。Yii框架中模板引擎也是作为组件引入的，默认ID为viewRenderer，
但从&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;可以看到Yii Web应用加载的核心组件中并没有viewRenderer，所以需要自己配置。
Yii提供了一个直接可用的模板引擎组件类CPradoViewRenderer（见文件&lt;code&gt;yii/framework/web/renderers/CPradoViewRenderer.php&lt;/code&gt;），该模板引擎类让开发者可以使用类Prado框架的模板语法。&lt;/p&gt;
&lt;p&gt;如果你想使用Smarty这种第三方模板引擎，有两种方式将模板引擎引入Yii中使用（以Smarty为例）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将Smarty封装成一个Yii的普通组件，然后配置加载到Yii::app()。假设组件ID为smarty，那么就可以通过&lt;code&gt;Yii::app()-&amp;gt;smarty&lt;/code&gt;来调用组件。&lt;/li&gt;
&lt;li&gt;参考CPradoViewRenderer类的实现，将Smarty封装成一个模板引擎组件，并以ID为viewRenderer进行配置加载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相比而言，第二种方式更好。原因是：第一种方式由于每种第三方模板引擎的接口不一样，如果应用要替换模板引擎，就需要修改控制器类中的代码。而第二种方式由于第三方组件统一封装成Yii框架定义的模板引擎接口形式，
所以如果要替换模板引擎，只需修改自定义模板引擎组件类的接口实现就可以了。这样调用模板引擎的代码逻辑就只依赖接口形式，而不是依赖于接口实现，从而实现解耦。&lt;/p&gt;
&lt;p&gt;本文主要分析第二种方式的实现。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;Yii中对页面模板进行渲染可以调用&lt;code&gt;CController&lt;/code&gt;类（见文件&lt;code&gt;yii/framework/web/CController.php&lt;/code&gt;）的方法&lt;code&gt;render&lt;/code&gt;，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Renders a view with a layout.
 *
 * This method first calls {@link renderPartial} to render the view (called content view).
 * It then renders the layout view which may embed the content view at appropriate place.
 * In the layout view, the content view rendering result can be accessed via variable
 * &amp;lt;code&amp;gt;$content&amp;lt;/code&amp;gt;. At the end, it calls {@link processOutput} to insert scripts
 * and dynamic contents if they are available.
 *
 * By default, the layout view script is &amp;quot;protected/views/layouts/main.php&amp;quot;.
 * This may be customized by changing {@link layout}.
 *
 * @param string $view name of the view to be rendered. See {@link getViewFile} for details
 * about how the view script is resolved.
 * @param array $data data to be extracted into PHP variables and made available to the view script
 * @param boolean $return whether the rendering result should be returned instead of being displayed to end users.
 * @return string the rendering result. Null if the rendering result is not required.
 * @see renderPartial
 * @see getLayoutFile
 */
public function render($view,$data=null,$return=false)
{
    // beforeRender默认返回true，
    // 可以在自定义controller类中重写该方法，实现渲染之前的预处理
    // 但和beforeAction一样，应该要返回true或false
    if($this-&amp;gt;beforeRender($view))
    {
        // 渲染真正的内容部分
        $output=$this-&amp;gt;renderPartial($view,$data,true);
        // 获取布局文件
        if(($layoutFile=$this-&amp;gt;getLayoutFile($this-&amp;gt;layout))!==false)
            // 渲染整个页面
            $output=$this-&amp;gt;renderFile($layoutFile,array(&amp;#39;content&amp;#39;=&amp;gt;$output),true);

        // 渲染的后处理，默认为空，在processOutput之前调用
        $this-&amp;gt;afterRender($view,$output);

        // 对渲染结果进行处理
        $output=$this-&amp;gt;processOutput($output);

        // 可以将渲染结果作为方法的返回值返回，或者直接输出到用户浏览器
        if($return)
            return $output;
        else
            echo $output;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法renderPartial的实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Renders a view.
 *
 * The named view refers to a PHP script (resolved via {@link getViewFile})
 * that is included by this method. If $data is an associative array,
 * it will be extracted as PHP variables and made available to the script.
 *
 * This method differs from {@link render()} in that it does not
 * apply a layout to the rendered result. It is thus mostly used
 * in rendering a partial view, or an AJAX response.
 *
 * @param string $view name of the view to be rendered. See {@link getViewFile} for details
 * about how the view script is resolved.
 * @param array $data data to be extracted into PHP variables and made available to the view script
 * @param boolean $return whether the rendering result should be returned instead of being displayed to end users
 * @param boolean $processOutput whether the rendering result should be postprocessed using {@link processOutput}.
 * @return string the rendering result. Null if the rendering result is not required.
 * @throws CException if the view does not exist
 * @see getViewFile
 * @see processOutput
 * @see render
 */
public function renderPartial($view,$data=null,$return=false,$processOutput=false)
{
    // 获取目标模板文件
    $viewFile=$this-&amp;gt;getViewFile($view);
    echo (basename(__FILE__).&amp;#39;:&amp;#39;.__LINE__.&amp;#39;:&amp;#39;.__FUNCTION__.&amp;#39;() $viewFile &amp;#39;. var_export($viewFile, true));
    if(($viewFile)!==false)
    {
        // 渲染
        $output=$this-&amp;gt;renderFile($viewFile,$data,true);
        // 如果$processOutput为真，则也会对结果进行后处理
        if($processOutput)
            $output=$this-&amp;gt;processOutput($output);
        if($return)
            return $output;
        else
            echo $output;
    }
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;{controller} cannot find the requested view &amp;quot;{view}&amp;quot;.&amp;#39;,
            array(&amp;#39;{controller}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{view}&amp;#39;=&amp;gt;$view)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;renderPartial&lt;/code&gt;方法并不会渲染出一个完整的页面，只是渲染页面的一部分，通常是主体部分，或者为AJAX请求渲染出响应结果。
其中调用的getViewFile方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getViewFile($viewName)
{
    // 如果未配置theme项，即表示不使用theme，那么getTheme方法返回null
    if(($theme=Yii::app()-&amp;gt;getTheme())!==null &amp;amp;&amp;amp; ($viewFile=$theme-&amp;gt;getViewFile($this,$viewName))!==false)
        return $viewFile;
    // viewPath默认为views，可配置
    $moduleViewPath=$basePath=Yii::app()-&amp;gt;getViewPath();
    echo (basename(__FILE__).&amp;#39;:&amp;#39;.__LINE__.&amp;#39;:&amp;#39;.__FUNCTION__.&amp;#39;() $moduleViewPath &amp;#39;. var_export($moduleViewPath, true)),&amp;quot;\n&amp;quot;;
    // 模块化，如果没有，则getModule返回null
    if(($module=$this-&amp;gt;getModule())!==null)
        $moduleViewPath=$module-&amp;gt;getViewPath();
    // $this-&amp;gt;getViewPath()得到的路径相比$moduleViewPath就是多了controller的ID一级
    return $this-&amp;gt;resolveViewFile($viewName,$this-&amp;gt;getViewPath(),$basePath,$moduleViewPath);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码中&lt;code&gt;$this-&amp;gt;getViewPath()&lt;/code&gt;方法的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getViewPath()
{
    if(($module=$this-&amp;gt;getModule())===null)
        $module=Yii::app();
    // $this-&amp;gt;getId()是得到当前controller的ID，这个ID是在controller实例化时构造方法中赋值给属性_id的。
    // 这也就意味着页面模板文件需要按照controller的ID分目录存放
    return $module-&amp;gt;getViewPath().DIRECTORY_SEPARATOR.$this-&amp;gt;getId();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;getViewFile&lt;/code&gt;中最后调用的方法&lt;code&gt;resolveViewFile&lt;/code&gt;实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function resolveViewFile($viewName,$viewPath,$basePath,$moduleViewPath=null)
{
    // 连模板文件名都不给，还玩个屁啊
    if(empty($viewName))
        return false;

    // 若$moduleViewPath未设置，则在应用的页面模板的根目录下找
    if($moduleViewPath===null)
        $moduleViewPath=$basePath;

    // 获取设置的模板渲染引擎，其实就是加载ID为viewRenderer的组件
    if(($renderer=Yii::app()-&amp;gt;getViewRenderer())!==null)
        // 模板文件的扩展类型默认为&amp;#39;.php&amp;#39;，可配置
        $extension=$renderer-&amp;gt;fileExtension;
    else
        $extension=&amp;#39;.php&amp;#39;;
    echo (basename(__FILE__).&amp;#39;:&amp;#39;.__LINE__.&amp;#39;:&amp;#39;.__FUNCTION__.&amp;#39;() $extension &amp;#39;. var_export($extension, true)),&amp;quot;\n&amp;quot;;
    // 如果指定的模板文件名以/开始
    if($viewName[0]===&amp;#39;/&amp;#39;)
    {
        // 如果指定的模板文件名以//开始，则表示在模板的根目录下查找
        if(strncmp($viewName,&amp;#39;//&amp;#39;,2)===0)
            $viewFile=$basePath.$viewName;
        // 否则（以单个/开始）在模块的模板目录下查找
        else
            $viewFile=$moduleViewPath.$viewName;
    }
    // 如果模板文件名中存在.且.不出现在第一个位置，则认为这是一个路径别名，需要转换真正的路径
    elseif(strpos($viewName,&amp;#39;.&amp;#39;))
        $viewFile=Yii::getPathOfAlias($viewName);
    else
        // 否则在当前controller的模板目录下找
        $viewFile=$viewPath.DIRECTORY_SEPARATOR.$viewName;

    // 可能站点是需要国际化的
    // 所以在找到默认的模板文件后，尝试找一下对应用户目标语言的模板文件
    if(is_file($viewFile.$extension))
        return Yii::app()-&amp;gt;findLocalizedFile($viewFile.$extension);
    // 如果不存在指定扩展类型的模板文件，且扩展类型不为&amp;#39;.php&amp;#39;，则看一下&amp;#39;.php&amp;#39;类型的模板文件是否存在
    elseif($extension!==&amp;#39;.php&amp;#39; &amp;amp;&amp;amp; is_file($viewFile.&amp;#39;.php&amp;#39;))
        return Yii::app()-&amp;gt;findLocalizedFile($viewFile.&amp;#39;.php&amp;#39;);
    else
        return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法&lt;code&gt;resolveViewFile&lt;/code&gt;中最后调用的方法&lt;code&gt;findLocalizedFile&lt;/code&gt;，定义于抽象类CApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function findLocalizedFile($srcFile,$srcLanguage=null,$language=null)
{
    if($srcLanguage===null)
        // sourceLanguage为public的属性，可配置，默认为en_us
        $srcLanguage=$this-&amp;gt;sourceLanguage;
    if($language===null)
        // getLanguage的实现：$this-&amp;gt;_language===null ? $this-&amp;gt;sourceLanguage : $this-&amp;gt;_language
        // 默认_language为未赋值，即null，所以取到的还是sourceLanguage属性值。
        // 但因为__set，所以也是可赋值的，这个赋值不应该是配置造成的，应该是根据用户的cookie中指定的语言选项，在请求处理时设置的，表示用户的目标语言
        $language=$this-&amp;gt;getLanguage();
    // 如果用户的目标语言（或者用户选择的是默认语言），则直接返回默认模板文件的路径
    if($language===$srcLanguage)
        return $srcFile;
    // 否则取到对应目标语言的模板文件
    $desiredFile=dirname($srcFile).DIRECTORY_SEPARATOR.$language.DIRECTORY_SEPARATOR.basename($srcFile);
    // 如果对应目标语言的模板文件不存在，则还是返回默认的模板文件
    return is_file($desiredFile) ? $desiredFile : $srcFile;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述模板文件的寻找过程可以看到，最后返回的目标模板文件的路径是一个相对路径，以动态脚本根目录（默认为protected）开始。&lt;/p&gt;
&lt;p&gt;方法&lt;code&gt;renderPartial&lt;/code&gt;中在得到目标模板文件相对路径后，即调用renderFile方法（定义于CBaseController类中）来渲染模板，该方法的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function renderFile($viewFile,$data=null,$return=false)
{
    $widgetCount=count($this-&amp;gt;_widgetStack);
    // Yii::app()-&amp;gt;getViewRenderer() 获取模板引擎组件
    if(($renderer=Yii::app()-&amp;gt;getViewRenderer())!==null &amp;amp;&amp;amp; $renderer-&amp;gt;fileExtension===&amp;#39;.&amp;#39;.CFileHelper::getExtension($viewFile))
        $content=$renderer-&amp;gt;renderFile($this,$viewFile,$data,$return);
    else
        // 如果没法用模板引擎来渲染（可能不是模板引擎的目标模板，也可能是没设置模板引擎组件），则当前普通的PHP文件（HTML代码中夹杂着PHP代码）来渲染
        $content=$this-&amp;gt;renderInternal($viewFile,$data,$return);
    if(count($this-&amp;gt;_widgetStack)===$widgetCount)
        return $content;
    else
    {
        $widget=end($this-&amp;gt;_widgetStack);
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;{controller} contains improperly nested widget tags in its view &amp;quot;{view}&amp;quot;. A {widget} widget does not have an endWidget() call.&amp;#39;,
            array(&amp;#39;{controller}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{view}&amp;#39;=&amp;gt;$viewFile, &amp;#39;{widget}&amp;#39;=&amp;gt;get_class($widget))));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;renderFile&lt;/code&gt;中&lt;code&gt;$content=$renderer-&amp;gt;renderFile($this,$viewFile,$data,$return);&lt;/code&gt;一行调用的renderFile方法，在抽象类CViewRenderer中定义如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function renderFile($context,$sourceFile,$data,$return)
{
    if(!is_file($sourceFile) || ($file=realpath($sourceFile))===false)
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;View file &amp;quot;{file}&amp;quot; does not exist.&amp;#39;,array(&amp;#39;{file}&amp;#39;=&amp;gt;$sourceFile)));
    // 尝试从runtime目录中获取已编译好的模板，如果编译好的模板不是同一存放在runtime目录下，则默认和未编译的模板文件在同一个目录下，并且文件名多一个&amp;quot;c&amp;quot;后缀
    // 得到$viewFile可能并不存在，第一次请求该模板
    $viewFile=$this-&amp;gt;getViewFile($sourceFile);
    // 如果相比已编译好的模板文件，未编译的模板已发生变更，则需要重新编译
    // 如果已编译好的模板文件不存在，则@filemtime($viewFile)返回的是false，这个条件也是返回true
    if(@filemtime($sourceFile)&amp;gt;@filemtime($viewFile))
    {
        // 抽象类CViewRenderer中generateViewFile方法并未实现，所以自己封装模板引擎组件时需要实现该方法
        $this-&amp;gt;generateViewFile($sourceFile,$viewFile);
        // 设置编译好的模板文件的访问权限，默认是0755 (owner rwx, group rx and others rx)
        @chmod($viewFile,$this-&amp;gt;filePermission);
    }
    // 编译好的模板文件其实就是一个PHP脚本（HTML代码中夹杂PHP代码），所以还需要渲染一下
    return $context-&amp;gt;renderInternal($viewFile,$data,$return);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;类&lt;code&gt;CController&lt;/code&gt;的&lt;code&gt;render&lt;/code&gt;方法在调用&lt;code&gt;renderPartial&lt;/code&gt;得到渲染结果后，取得页面布局模板文件，然后将&lt;code&gt;renderPartial&lt;/code&gt;的渲染结果作为数据渲染布局模板，从而得到一个完整HTML页面。
获取布局模板文件路径的方法&lt;code&gt;getLayoutFile&lt;/code&gt;实现如下所示（定义于类CController中）：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getLayoutFile($layoutName)
{
    if($layoutName===false)
        return false;
    if(($theme=Yii::app()-&amp;gt;getTheme())!==null &amp;amp;&amp;amp; ($layoutFile=$theme-&amp;gt;getLayoutFile($this,$layoutName))!==false)
        return $layoutFile;

    if(empty($layoutName))
    {
        $module=$this-&amp;gt;getModule();
        // 递归向父级模板查找布局文件
        while($module!==null)
        {
            if($module-&amp;gt;layout===false)
                return false;
            if(!empty($module-&amp;gt;layout))
                break;
            $module=$module-&amp;gt;getParentModule();
        }
        // 如果当前controller不属于某个module
        if($module===null)
            $module=Yii::app();
        // 默认为main，可配置
        $layoutName=$module-&amp;gt;layout;
    }
    elseif(($module=$this-&amp;gt;getModule())===null)
        $module=Yii::app();

    return $this-&amp;gt;resolveViewFile($layoutName,$module-&amp;gt;getLayoutPath(),Yii::app()-&amp;gt;getViewPath(),$module-&amp;gt;getViewPath());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其逻辑与方法&lt;code&gt;getViewFile&lt;/code&gt;类似。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由上述分析可知，将第三方模板引擎封装成Yii框架的模板引擎组件，可以继承自抽象类&lt;code&gt;CViewRenderer&lt;/code&gt;，并实现其方法&lt;code&gt;generateViewFile&lt;/code&gt;，然后配置该组件的ID为&lt;code&gt;viewRenderer&lt;/code&gt;。
对于模板文件的存放，需要考虑Web应用是否分模块、应用是否国际化、模板文件相关controller的ID等，模板文件名的扩展类型应与模板引擎组件配置的一样。&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - Model层实现</title><link href="http://youngsterxyf.github.io/2014/11/14/read-yii-code-4/" rel="alternate"></link><published>2014-11-14T00:00:00+08:00</published><updated>2014-11-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-14:/2014/11/14/read-yii-code-4/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii中，对Model层的使用，有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过类CDbConnection和CDbCommand来操作&lt;/li&gt;
&lt;li&gt;使用ORM形式：编写model类继承自抽象类CActiveRecord&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第1种方式的示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$connection = Yii::app()-&amp;gt;db;  &lt;span style="color: #008000"&gt;// 或者Yii::app()-&amp;gt;getComponent(&amp;#39;db&amp;#39;);&lt;/span&gt;
$queryResult = $connection-&amp;gt;createCommand($sql)-&amp;gt;queryRow();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第2种方式中编写的model类可能需要实现方法&lt;code&gt;getDbConnection&lt;/code&gt;、&lt;code&gt;model&lt;/code&gt;、&lt;code&gt;tableName&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在实现上，第2种方式是基于第1种方式的，即 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii中，对Model层的使用，有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过类CDbConnection和CDbCommand来操作&lt;/li&gt;
&lt;li&gt;使用ORM形式：编写model类继承自抽象类CActiveRecord&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第1种方式的示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$connection = Yii::app()-&amp;gt;db;  &lt;span style="color: #008000"&gt;// 或者Yii::app()-&amp;gt;getComponent(&amp;#39;db&amp;#39;);&lt;/span&gt;
$queryResult = $connection-&amp;gt;createCommand($sql)-&amp;gt;queryRow();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第2种方式中编写的model类可能需要实现方法&lt;code&gt;getDbConnection&lt;/code&gt;、&lt;code&gt;model&lt;/code&gt;、&lt;code&gt;tableName&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在实现上，第2种方式是基于第1种方式的，即第2种方式的抽象程度更高。Yii没有屏蔽第1种方式，这样能让开发者按需选择。
但我个人并不喜欢这样，两种方式同时存在，会导致应用的model实现稍显混乱。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;Yii框架model层的入口为CDbConnection类，该类有很多public的属性可供配置，如&lt;code&gt;connectionString&lt;/code&gt;、&lt;code&gt;username&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;根据&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;一文可知，组件初始化时会调用init方法。
类CDbConnection的init类实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function init()
{
    parent::init();
    // 属性autoConnect默认为true
    if($this-&amp;gt;autoConnect)
        $this-&amp;gt;setActive(true);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的setActive方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function setActive($value)
{
    // 当$value为true，而_active为false（表示数据库连接未打开），则打开数据库连接
    // 当$value为false, 而_active为true（表示数据库连接已打开），则关闭数据库连接
    if($value!=$this-&amp;gt;_active)
    {
        if($value)
            $this-&amp;gt;open();
        else
            $this-&amp;gt;close();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法open实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Opens DB connection if it is currently not
 * @throws CException if connection fails
 */
protected function open()
{
    if($this-&amp;gt;_pdo===null)
    {
        // 所以需要配置connectionString
        if(empty($this-&amp;gt;connectionString))
            throw new CDbException(&amp;#39;CDbConnection.connectionString cannot be empty.&amp;#39;);
        try
        {
            Yii::trace(&amp;#39;Opening DB connection&amp;#39;,&amp;#39;system.db.CDbConnection&amp;#39;);
            // 基于PDO类建立数据库连接（对于某些数据库不使用PDO）
            $this-&amp;gt;_pdo=$this-&amp;gt;createPdoInstance();
            // 设置数据库连接的一些属性，如字符编码等
            $this-&amp;gt;initConnection($this-&amp;gt;_pdo);
            // 标志位设置为已打开
            $this-&amp;gt;_active=true;
        }
        catch(PDOException $e)
        {
            // 省略
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法close实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Closes the currently active DB connection.
 * It does nothing if the connection is already closed.
 */
protected function close()
{
    Yii::trace(&amp;#39;Closing DB connection&amp;#39;,&amp;#39;system.db.CDbConnection&amp;#39;);
    $this-&amp;gt;_pdo=null;
    $this-&amp;gt;_active=false;
    $this-&amp;gt;_schema=null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;open方法中调用的方法createPdoInstance实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Creates the PDO instance.
 * When some functionalities are missing in the pdo driver, we may use
 * an adapter class to provide them.
 * @throws CDbException when failed to open DB connection
 * @return PDO the pdo instance
 */
protected function createPdoInstance()
{
    // 属性pdoClass默认为PDO
    $pdoClass=$this-&amp;gt;pdoClass;
    if(($pos=strpos($this-&amp;gt;connectionString,&amp;#39;:&amp;#39;))!==false)
    {
        // 取出数据库驱动类型
        $driver=strtolower(substr($this-&amp;gt;connectionString,0,$pos));
        if($driver===&amp;#39;mssql&amp;#39; || $driver===&amp;#39;dblib&amp;#39;)
            $pdoClass=&amp;#39;CMssqlPdoAdapter&amp;#39;;
        elseif($driver===&amp;#39;sqlsrv&amp;#39;)
            $pdoClass=&amp;#39;CMssqlSqlsrvPdoAdapter&amp;#39;;
    }

    if(!class_exists($pdoClass))
        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbConnection is unable to find PDO class &amp;quot;{className}&amp;quot;. Make sure PDO is installed correctly.&amp;#39;,
            array(&amp;#39;{className}&amp;#39;=&amp;gt;$pdoClass)));

    // 实例化类PDO，可能失败
    @$instance=new $pdoClass($this-&amp;gt;connectionString,$this-&amp;gt;username,$this-&amp;gt;password,$this-&amp;gt;_attributes);

    if(!$instance)
        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbConnection failed to open the DB connection.&amp;#39;));

    return $instance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从中可以看出，对于MySQL数据库而言，方法createPdoInstance返回的是一个PDO对象，赋值给CDbConnection对象的_pdo属性。&lt;/p&gt;
&lt;p&gt;方法initConnection的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Initializes the open db connection.
 * This method is invoked right after the db connection is established.
 * The default implementation is to set the charset for MySQL and PostgreSQL database connections.
 * @param PDO $pdo the PDO instance
 */
protected function initConnection($pdo)
{
    // 设置数据库连接的一些属性
    $pdo-&amp;gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    if($this-&amp;gt;emulatePrepare!==null &amp;amp;&amp;amp; constant(&amp;#39;PDO::ATTR_EMULATE_PREPARES&amp;#39;))
        $pdo-&amp;gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,$this-&amp;gt;emulatePrepare);
    if($this-&amp;gt;charset!==null)
    {
        $driver=strtolower($pdo-&amp;gt;getAttribute(PDO::ATTR_DRIVER_NAME));
        if(in_array($driver,array(&amp;#39;pgsql&amp;#39;,&amp;#39;mysql&amp;#39;,&amp;#39;mysqli&amp;#39;)))
            $pdo-&amp;gt;exec(&amp;#39;SET NAMES &amp;#39;.$pdo-&amp;gt;quote($this-&amp;gt;charset));
    }
    // 执行一些初始化的SQL语句
    // public $initSQLs : array list of SQL statements that should be executed right after the DB connection is established.
    if($this-&amp;gt;initSQLs!==null)
    {
        foreach($this-&amp;gt;initSQLs as $sql)
            $pdo-&amp;gt;exec($sql);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;由于第2种方式是基于第1中方式实现的，所以我们先看看第1种方式的实现。&lt;/p&gt;
&lt;p&gt;类CDbConnection中方法createCommand的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function createCommand($query=null)
{
    $this-&amp;gt;setActive(true);
    return new CDbCommand($this,$query);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中实例化的类CDbCommand的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Constructor.
 * @param CDbConnection $connection the database connection
 * @param mixed $query the DB query to be executed. This can be either
 * a string representing a SQL statement, or an array whose name-value pairs
 * will be used to set the corresponding properties of the created command object.
 *
 * For example, you can pass in either &amp;lt;code&amp;gt;&amp;#39;SELECT * FROM tbl_user&amp;#39;&amp;lt;/code&amp;gt;
 * or &amp;lt;code&amp;gt;array(&amp;#39;select&amp;#39;=&amp;gt;&amp;#39;*&amp;#39;, &amp;#39;from&amp;#39;=&amp;gt;&amp;#39;tbl_user&amp;#39;)&amp;lt;/code&amp;gt;. They are equivalent
 * in terms of the final query result.
 *
 * When passing the query as an array, the following properties are commonly set:
 * {@link select}, {@link distinct}, {@link from}, {@link where}, {@link join},
 * {@link group}, {@link having}, {@link order}, {@link limit}, {@link offset} and
 * {@link union}. Please refer to the setter of each of these properties for details
 * about valid property values. This feature has been available since version 1.1.6.
 *
 * Since 1.1.7 it is possible to use a specific mode of data fetching by setting
 * {@link setFetchMode FetchMode}. See {@link http://www.php.net/manual/en/function.PDOStatement-setFetchMode.php}
 * for more details.
 */
public function __construct(CDbConnection $connection,$query=null)
{
    $this-&amp;gt;_connection=$connection;
    if(is_array($query))
    {
        foreach($query as $name=&amp;gt;$value)
            $this-&amp;gt;$name=$value;
    }
    else
        $this-&amp;gt;setText($query);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到参数$query并不是必须提供，如果提供，则$query参数值可以是字符串也可以是数组。如果是字符串也就是一个原生的SQL语句（可能有参数需要填充），如果是数组，
则可以为CDbCommand对象的select、distinct、from等属性赋值。&lt;/p&gt;
&lt;p&gt;方法setText实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Specifies the SQL statement to be executed.
 * Any previous execution will be terminated or cancel.
 * @param string $value the SQL statement to be executed
 * @return CDbCommand this command instance
 */
public function setText($value)
{
    if($this-&amp;gt;_connection-&amp;gt;tablePrefix!==null &amp;amp;&amp;amp; $value!=&amp;#39;&amp;#39;)
        $this-&amp;gt;_text=preg_replace(&amp;#39;/{{(.*?)}}/&amp;#39;,$this-&amp;gt;_connection-&amp;gt;tablePrefix.&amp;#39;\1&amp;#39;,$value);
    else
        $this-&amp;gt;_text=$value;
    // 因为是要新执行一条语句，所以需要重置状态，将属性_statement置为null。
    $this-&amp;gt;cancel();
    return $this;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果调用类CDbConnection的createCommand方法时提供了&lt;code&gt;$query&lt;/code&gt;参数值，则在得到CDbCommand对象后，即可调用CDbCommand对象的execute方法（对于增、删、改操作）或query、queryAll、queryRow等方法（对于查询操作）来执行数据库操作。&lt;/p&gt;
&lt;p&gt;如果调用createCommand时未提供&lt;code&gt;$query&lt;/code&gt;参数值，则有3种方式来完成数据库操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于普通的数据库查询操作，得到CDbCommand对象后，链式调用方法select、from、where等（之所以能够链式调用，是因为这些方法的最后都返回了对象本身），并且链式调用的最后调用query一类方法来执行数据库操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于会对数据表结构或数据产生变更的操作，得到CDbCommand对象后，可以直接调用方法insert、update、delete、createTable等来执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在得到CDbCommand对象后，调用方法setText来设置待执行的SQL语句，setText方法的$value参数类型应为字符串。如果调用setText方法前$value参数类型是关联数组，则可以先调用方法buildQuery从关联数组生成一个SQL语句字符串，再调用setText方法；或者直接调用setSelect、setFrom、setWhere等方法来设置SQL语句的各个组成部分。最后调用execute方法或query一类方法。可以看出相比传递&lt;code&gt;$query&lt;/code&gt;参数，这种方式只不过是显式地设置SQL语句。通常这是不推荐的（搞这么麻烦，何必呢？呵呵）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样一看，类CDbCommand的实现稍显混乱。本意上额外的第3种方式应该是提供给类CActiveRecord使用的，所以不建议使用。&lt;/p&gt;
&lt;p&gt;接下来看看方法execute方法及query一类（仅以方法query、queryAll为例）方法的实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Executes the SQL statement.
 * This method is meant only for executing non-query SQL statement.
 * No result set will be returned.
 * @param array $params input parameters (name=&amp;gt;value) for the SQL execution. This is an alternative
 * to {@link bindParam} and {@link bindValue}. If you have multiple input parameters, passing
 * them in this way can improve the performance. Note that if you pass parameters in this way,
 * you cannot bind parameters or values using {@link bindParam} or {@link bindValue}, and vice versa.
 * Please also note that all values are treated as strings in this case, if you need them to be handled as
 * their real data types, you have to use {@link bindParam} or {@link bindValue} instead.
 * @return integer number of rows affected by the execution.
 * @throws CDbException execution failed
 */
public function execute($params=array())
{
    if($this-&amp;gt;_connection-&amp;gt;enableParamLogging &amp;amp;&amp;amp; ($pars=array_merge($this-&amp;gt;_paramLog,$params))!==array())
    {
        $p=array();
        foreach($pars as $name=&amp;gt;$value)
            $p[$name]=$name.&amp;#39;=&amp;#39;.var_export($value,true);
        $par=&amp;#39;. Bound with &amp;#39; .implode(&amp;#39;, &amp;#39;,$p);
    }
    else
        $par=&amp;#39;&amp;#39;;
    Yii::trace(&amp;#39;Executing SQL: &amp;#39;.$this-&amp;gt;getText().$par,&amp;#39;system.db.CDbCommand&amp;#39;);
    try
    {
        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)
            Yii::beginProfile(&amp;#39;system.db.CDbCommand.execute(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.execute&amp;#39;);

        // 以通过setText设置的SQL语句为参数间接调用PDO对象的prepare方法，并将返回的PDOStatement对象赋值给当前CDbCommand对象的_statement属性。
        $this-&amp;gt;prepare();
        if($params===array())
            // 无参执行
            $this-&amp;gt;_statement-&amp;gt;execute();
        else
            // 带参执行
            $this-&amp;gt;_statement-&amp;gt;execute($params);
        // 操作影响的数据表行数
        $n=$this-&amp;gt;_statement-&amp;gt;rowCount();

        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)
            Yii::endProfile(&amp;#39;system.db.CDbCommand.execute(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.execute&amp;#39;);

        return $n;
    }
    catch(Exception $e)
    {
        // 省略
    }
}

public function query($params=array())
{
    return $this-&amp;gt;queryInternal(&amp;#39;&amp;#39;,0,$params);
}

public function queryAll($fetchAssociative=true,$params=array())
{
    return $this-&amp;gt;queryInternal(&amp;#39;fetchAll&amp;#39;,$fetchAssociative ? $this-&amp;gt;_fetchMode : PDO::FETCH_NUM, $params);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到query一类方法都是间接调用方法queryInternal来完成操作的。queryInternal方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;private function queryInternal($method,$mode,$params=array())
{
    $params=array_merge($this-&amp;gt;params,$params);

    if($this-&amp;gt;_connection-&amp;gt;enableParamLogging &amp;amp;&amp;amp; ($pars=array_merge($this-&amp;gt;_paramLog,$params))!==array())
    {
        $p=array();
        foreach($pars as $name=&amp;gt;$value)
            $p[$name]=$name.&amp;#39;=&amp;#39;.var_export($value,true);
        $par=&amp;#39;. Bound with &amp;#39;.implode(&amp;#39;, &amp;#39;,$p);
    }
    else
        $par=&amp;#39;&amp;#39;;

    Yii::trace(&amp;#39;Querying SQL: &amp;#39;.$this-&amp;gt;getText().$par,&amp;#39;system.db.CDbCommand&amp;#39;);

    // 先尝试从缓存中读取查询结果
    // 这里涉及CDbConnection类的三个属性queryCachingCount、queryCachingDuration、queryCacheID
    // 另外对于方法query（调用queryInternal时提供的method参数为空字符串）的操作不会缓存
    if($this-&amp;gt;_connection-&amp;gt;queryCachingCount&amp;gt;0 &amp;amp;&amp;amp; $method!==&amp;#39;&amp;#39;
            &amp;amp;&amp;amp; $this-&amp;gt;_connection-&amp;gt;queryCachingDuration&amp;gt;0
            &amp;amp;&amp;amp; $this-&amp;gt;_connection-&amp;gt;queryCacheID!==false
            &amp;amp;&amp;amp; ($cache=Yii::app()-&amp;gt;getComponent($this-&amp;gt;_connection-&amp;gt;queryCacheID))!==null)
    {
        $this-&amp;gt;_connection-&amp;gt;queryCachingCount--;
        $cacheKey=&amp;#39;yii:dbquery&amp;#39;.$this-&amp;gt;_connection-&amp;gt;connectionString.&amp;#39;:&amp;#39;.$this-&amp;gt;_connection-&amp;gt;username;
        $cacheKey.=&amp;#39;:&amp;#39;.$this-&amp;gt;getText().&amp;#39;:&amp;#39;.serialize(array_merge($this-&amp;gt;_paramLog,$params));
        if(($result=$cache-&amp;gt;get($cacheKey))!==false)
        {
            Yii::trace(&amp;#39;Query result found in cache&amp;#39;,&amp;#39;system.db.CDbCommand&amp;#39;);
            return $result[0];
        }
    }

    try
    {
        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)
            Yii::beginProfile(&amp;#39;system.db.CDbCommand.query(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.query&amp;#39;);

        $this-&amp;gt;prepare();
        if($params===array())
            $this-&amp;gt;_statement-&amp;gt;execute();
        else
            $this-&amp;gt;_statement-&amp;gt;execute($params);

        // $method对应PDOStatement的结果获取方法，如果未提供$method，自然无法直接通过PDOStatement获取查询结果。
        if($method===&amp;#39;&amp;#39;)
            // 这个细看一下
            $result=new CDbDataReader($this);
        else
        {
            $mode=(array)$mode;
            call_user_func_array(array($this-&amp;gt;_statement, &amp;#39;setFetchMode&amp;#39;), $mode);
            // 调用PDOStatement对应的方法
            $result=$this-&amp;gt;_statement-&amp;gt;$method();
            $this-&amp;gt;_statement-&amp;gt;closeCursor();
        }

        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)
            Yii::endProfile(&amp;#39;system.db.CDbCommand.query(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.query&amp;#39;);

        // 如果设置了$cache和$cacheKey
        // 将查询结果存入缓存
        if(isset($cache,$cacheKey))
            $cache-&amp;gt;set($cacheKey, array($result), $this-&amp;gt;_connection-&amp;gt;queryCachingDuration, $this-&amp;gt;_connection-&amp;gt;queryCachingDependency);

        return $result;
    }
    catch(Exception $e)
    {
        // 省略
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到query方法调用queryInternal时，结果是通过CDbDataReader对象来获取的。类CDbDataReader的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct(CDbCommand $command)
{
    $this-&amp;gt;_statement=$command-&amp;gt;getPdoStatement();
    $this-&amp;gt;_statement-&amp;gt;setFetchMode(PDO::FETCH_ASSOC);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;得到CDbDataReader对象，即可通过它的read一类方法&lt;strong&gt;迭代&lt;/strong&gt;获取查询结果。这些方法实际上是调用PDOStatement的fetch一类方法来获取结果的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;再来看看Yii框架Model层的第2种使用方式。&lt;/p&gt;
&lt;p&gt;CActiveRecord的用法是，对于数据库的每个数据表，创建一个model类，如UserModel，这个类继承自CActiveRecord类。model类名可以和数据表名一致，也可以不一致，如果不一致，则需要重写CActiveRecord类的tableName方法，标明该model类对应的数据表名。方法tableName默认的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
* Returns the name of the associated database table.
* By default this method returns the class name as the table name.
* You may override this method if the table is not named after this convention.
* @return string the table name
*/
public function tableName()
{
    return get_class($this);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;假设UserModel类对应的数据表名为User，则应如下重写tableName：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function tableName()
{
    return &amp;#39;User&amp;#39;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用CActiveRecord方式，若想向数据表中插入一条新纪录，则需要实例化当前model类。以UserModel类为例，若想向User表中插入一条新纪录，则需要先实例化UserModel，得到一个对象，然后对该对象的属性进行赋值指明对应数据表新记录每个字段的值。对象的属性名即数据表的字段名，赋值完毕，调用save或insert即向数据表中存入该新纪录。&lt;/p&gt;
&lt;p&gt;CActiveRecord类的构造方法如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($scenario=&amp;#39;insert&amp;#39;)
{
    if($scenario===null) // internally used by populateRecord() and model()
        return;

    $this-&amp;gt;setScenario($scenario);
    $this-&amp;gt;setIsNewRecord(true);
    $this-&amp;gt;_attributes=$this-&amp;gt;getMetaData()-&amp;gt;attributeDefaults;

    $this-&amp;gt;init();

    $this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors());
    $this-&amp;gt;afterConstruct();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;$scenario='insert'，表示新实例化的对象处于待插入数据表的状态，在调用save等方法时，会检测该状态。在新实例化的对象插入到数据表后，该状态立即会变为"update"，表示之后对该对象的数据库写入操作，属于update操作。&lt;/p&gt;
&lt;p&gt;CActiveRecord类的save方法的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function save($runValidation=true,$attributes=null)
{
    // 若需要则对某些属性做校验
    if(!$runValidation || $this-&amp;gt;validate($attributes))
        // 如果是新纪录，则插入，否则更新
        return $this-&amp;gt;getIsNewRecord() ? $this-&amp;gt;insert($attributes) : $this-&amp;gt;update($attributes);
    else
        return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而insert、update方法的实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function insert($attributes=null)
{
    if(!$this-&amp;gt;getIsNewRecord())
        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The active record cannot be inserted to database because it is not new.&amp;#39;));
    if($this-&amp;gt;beforeSave())
    {
        Yii::trace(get_class($this).&amp;#39;.insert()&amp;#39;,&amp;#39;system.db.ar.CActiveRecord&amp;#39;);
        // ...
        $builder=$this-&amp;gt;getCommandBuilder();
        // ...
        $table=$this-&amp;gt;getMetaData()-&amp;gt;tableSchema;
        $command=$builder-&amp;gt;createInsertCommand($table,$this-&amp;gt;getAttributes($attributes));
        if($command-&amp;gt;execute())
        {
            $primaryKey=$table-&amp;gt;primaryKey;
            if($table-&amp;gt;sequenceName!==null)
            {
                if(is_string($primaryKey) &amp;amp;&amp;amp; $this-&amp;gt;$primaryKey===null)
                    $this-&amp;gt;$primaryKey=$builder-&amp;gt;getLastInsertID($table);
                elseif(is_array($primaryKey))
                {
                    foreach($primaryKey as $pk)
                    {
                        if($this-&amp;gt;$pk===null)
                        {
                            $this-&amp;gt;$pk=$builder-&amp;gt;getLastInsertID($table);
                            break;
                        }
                    }
                }
            }
            $this-&amp;gt;_pk=$this-&amp;gt;getPrimaryKey();
            $this-&amp;gt;afterSave();
            $this-&amp;gt;setIsNewRecord(false);
            $this-&amp;gt;setScenario(&amp;#39;update&amp;#39;);
            return true;
        }
    }
    return false;
}

public function update($attributes=null)
{
    if($this-&amp;gt;getIsNewRecord())
        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The active record cannot be updated because it is new.&amp;#39;));
    if($this-&amp;gt;beforeSave())
    {
        Yii::trace(get_class($this).&amp;#39;.update()&amp;#39;,&amp;#39;system.db.ar.CActiveRecord&amp;#39;);
        if($this-&amp;gt;_pk===null)
            $this-&amp;gt;_pk=$this-&amp;gt;getPrimaryKey();
        // 间接调用updateByPk来完成操作
        $this-&amp;gt;updateByPk($this-&amp;gt;getOldPrimaryKey(),$this-&amp;gt;getAttributes($attributes));
        $this-&amp;gt;_pk=$this-&amp;gt;getPrimaryKey();
        $this-&amp;gt;afterSave();
        return true;
    }
    else
        return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;insert方法中调用的getCommandBuilder方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getCommandBuilder()
{
    return $this-&amp;gt;getDbConnection()-&amp;gt;getSchema()-&amp;gt;getCommandBuilder();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中getDbConnection方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getDbConnection()
{
    if(self::$db!==null)
        return self::$db;
    else
    {
        self::$db=Yii::app()-&amp;gt;getDb();
        if(self::$db instanceof CDbConnection)
            return self::$db;
        else
            throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Active Record requires a &amp;quot;db&amp;quot; CDbConnection application component.&amp;#39;));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Yii中默认的DB组件名为db，所以如果你使用的是默认的db数据库，那么不用重写这个方法。否则，需要重写该方法，指明需要使用的数据库连接。&lt;/p&gt;
&lt;p&gt;getDbConnection方法返回的是一个CDbConnection对象，其getSchema方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getSchema()
{
    if($this-&amp;gt;_schema!==null)
        return $this-&amp;gt;_schema;
    else
    {
        // 返回数据库配置信息connectionString字段中的数据库驱动类型，如mysql
        $driver=$this-&amp;gt;getDriverName();
        /*
            driverMap属性的定义：
            public $driverMap=array(
              &amp;#39;pgsql&amp;#39;=&amp;gt;&amp;#39;CPgsqlSchema&amp;#39;,    // PostgreSQL
              &amp;#39;mysqli&amp;#39;=&amp;gt;&amp;#39;CMysqlSchema&amp;#39;,   // MySQL
              &amp;#39;mysql&amp;#39;=&amp;gt;&amp;#39;CMysqlSchema&amp;#39;,    // MySQL
              &amp;#39;sqlite&amp;#39;=&amp;gt;&amp;#39;CSqliteSchema&amp;#39;,  // sqlite 3
              &amp;#39;sqlite2&amp;#39;=&amp;gt;&amp;#39;CSqliteSchema&amp;#39;, // sqlite 2
              &amp;#39;mssql&amp;#39;=&amp;gt;&amp;#39;CMssqlSchema&amp;#39;,    // Mssql driver on windows hosts
              &amp;#39;dblib&amp;#39;=&amp;gt;&amp;#39;CMssqlSchema&amp;#39;,    // dblib drivers on linux (and maybe others os) hosts
              &amp;#39;sqlsrv&amp;#39;=&amp;gt;&amp;#39;CMssqlSchema&amp;#39;,   // Mssql
              &amp;#39;oci&amp;#39;=&amp;gt;&amp;#39;COciSchema&amp;#39;,        // Oracle driver
           );
        */
        if(isset($this-&amp;gt;driverMap[$driver]))
            // 加载对应的数据库驱动组件
            return $this-&amp;gt;_schema=Yii::createComponent($this-&amp;gt;driverMap[$driver], $this);
        else
            throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbConnection does not support reading schema for {driver} database.&amp;#39;,
                array(&amp;#39;{driver}&amp;#39;=&amp;gt;$driver)));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以mysql的CMysqlSchema为例，&lt;code&gt;Yii::createComponent($this-&amp;gt;driverMap[$driver], $this)&lt;/code&gt;一句会实例化yii/framework/db/schema/mysql/CMysqlSchema.php中定义的CMysqlSchema类。该类自身无构造方法，继承自抽象类CDbSchema，CDbSchema的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($conn)
{
    // 保存着当前CDbConnection数据库连接对象
    $this-&amp;gt;_connection=$conn;
    foreach($conn-&amp;gt;schemaCachingExclude as $name)
        $this-&amp;gt;_cacheExclude[$name]=true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;得到CMysqlSchema对象后，调用其getCommandBuilder方法，该方法定义于类CDbSchema中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getCommandBuilder()
{
    if($this-&amp;gt;_builder!==null)
        return $this-&amp;gt;_builder;
    else
        return $this-&amp;gt;_builder=$this-&amp;gt;createCommandBuilder();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的方法createCommandBuilder实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;protected function createCommandBuilder()
{
    return new CDbCommandBuilder($this);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实例化的CDbCommandBuilder类的构造方法如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($schema)
{
    $this-&amp;gt;_schema=$schema;
    $this-&amp;gt;_connection=$schema-&amp;gt;getDbConnection();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样insert方法中调用的getCommandBuilder最终返回了一个CDbCommandBuilder对象。&lt;/p&gt;
&lt;p&gt;而insert方法中&lt;code&gt;$table=$this-&amp;gt;getMetaData()-&amp;gt;tableSchema&lt;/code&gt;一句调用的getMetaData方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getMetaData()
{
    $className=get_class($this);
    if(!array_key_exists($className,self::$_md))
    {
        self::$_md[$className]=null; // preventing recursive invokes of {@link getMetaData()} via {@link __get()}
        self::$_md[$className]=new CActiveRecordMetaData($this);
    }
    return self::$_md[$className];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中实例化的类CActiveRecordMetaData，构造方法如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($model)
{
    // 当前model类名
    $this-&amp;gt;_modelClassName=get_class($model);

    // 得到表名
    $tableName=$model-&amp;gt;tableName();

    // 调用_schema（以mysql为例，其值为CMysqlSchema对象）的getTable方法
    if(($table=$model-&amp;gt;getDbConnection()-&amp;gt;getSchema()-&amp;gt;getTable($tableName))===null)
        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The table &amp;quot;{table}&amp;quot; for active record class &amp;quot;{class}&amp;quot; cannot be found in the database.&amp;#39;,
            array(&amp;#39;{class}&amp;#39;=&amp;gt;$this-&amp;gt;_modelClassName,&amp;#39;{table}&amp;#39;=&amp;gt;$tableName)));
    if($table-&amp;gt;primaryKey===null)
    {
        $table-&amp;gt;primaryKey=$model-&amp;gt;primaryKey();
        if(is_string($table-&amp;gt;primaryKey) &amp;amp;&amp;amp; isset($table-&amp;gt;columns[$table-&amp;gt;primaryKey]))
            $table-&amp;gt;columns[$table-&amp;gt;primaryKey]-&amp;gt;isPrimaryKey=true;
        elseif(is_array($table-&amp;gt;primaryKey))
        {
            foreach($table-&amp;gt;primaryKey as $name)
            {
                if(isset($table-&amp;gt;columns[$name]))
                    $table-&amp;gt;columns[$name]-&amp;gt;isPrimaryKey=true;
            }
        }
    }
    // 将数据表结构信息存于属性tableSchema
    $this-&amp;gt;tableSchema=$table;
    $this-&amp;gt;columns=$table-&amp;gt;columns;

    foreach($table-&amp;gt;columns as $name=&amp;gt;$column)
    {
        if(!$column-&amp;gt;isPrimaryKey &amp;amp;&amp;amp; $column-&amp;gt;defaultValue!==null)
            $this-&amp;gt;attributeDefaults[$name]=$column-&amp;gt;defaultValue;
    }

    foreach($model-&amp;gt;relations() as $name=&amp;gt;$config)
    {
        $this-&amp;gt;addRelation($name,$config);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的getTable方法，定义于抽象类CDbSchema中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getTable($name,$refresh=false)
{
    if($refresh===false &amp;amp;&amp;amp; isset($this-&amp;gt;_tables[$name]))
        return $this-&amp;gt;_tables[$name];
    else
    {
        if($this-&amp;gt;_connection-&amp;gt;tablePrefix!==null &amp;amp;&amp;amp; strpos($name,&amp;#39;{{&amp;#39;)!==false)
            $realName=preg_replace(&amp;#39;/\{\{(.*?)\}\}/&amp;#39;,$this-&amp;gt;_connection-&amp;gt;tablePrefix.&amp;#39;$1&amp;#39;,$name);
        else
            $realName=$name;

        // temporarily disable query caching
        if($this-&amp;gt;_connection-&amp;gt;queryCachingDuration&amp;gt;0)
        {
            $qcDuration=$this-&amp;gt;_connection-&amp;gt;queryCachingDuration;
            $this-&amp;gt;_connection-&amp;gt;queryCachingDuration=0;
        }

        // 先尝试从缓存中取数据表结构信息
        // CDbConnection类的schemaCachingDuration属性默认为0，如果不配置该属性，那么就不会使用缓存，那么每次增、删、改、查操作都需要loadTable，
        // 对数据库的压力，以及性能影响是不是很大？！但如果加了缓存，那么当对数据表的结构做变更时会不会有问题？
        if(!isset($this-&amp;gt;_cacheExclude[$name]) &amp;amp;&amp;amp; ($duration=$this-&amp;gt;_connection-&amp;gt;schemaCachingDuration)&amp;gt;0 &amp;amp;&amp;amp; $this-&amp;gt;_connection-&amp;gt;schemaCacheID!==false &amp;amp;&amp;amp; ($cache=Yii::app()-&amp;gt;getComponent($this-&amp;gt;_connection-&amp;gt;schemaCacheID))!==null)
        {
            $key=&amp;#39;yii:dbschema&amp;#39;.$this-&amp;gt;_connection-&amp;gt;connectionString.&amp;#39;:&amp;#39;.$this-&amp;gt;_connection-&amp;gt;username.&amp;#39;:&amp;#39;.$name;
            $table=$cache-&amp;gt;get($key);
            // 没取到或者需要刷新缓存，则从数据库获取，并更新缓存
            if($refresh===true || $table===false)
            {
                $table=$this-&amp;gt;loadTable($realName);
                if($table!==null)
                    $cache-&amp;gt;set($key,$table,$duration);
            }
            $this-&amp;gt;_tables[$name]=$table;
        }
        else
            // 直接从数据库获取数据表结构信息
            $this-&amp;gt;_tables[$name]=$table=$this-&amp;gt;loadTable($realName);

        if(isset($qcDuration))  // re-enable query caching
            $this-&amp;gt;_connection-&amp;gt;queryCachingDuration=$qcDuration;

        return $table;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的loadTable方法最终是通过执行SQL语句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'SHOW FULL COLUMNS FROM '.$table-&amp;gt;rawName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'SHOW CREATE TABLE '.$table-&amp;gt;rawName&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来获取数据表信息，并将信息存于一个CMysqlColumnSchema对象中（以mysql为例）。&lt;/p&gt;
&lt;p&gt;insert方法中&lt;code&gt;$command=$builder-&amp;gt;createInsertCommand($table,$this-&amp;gt;getAttributes($attributes))&lt;/code&gt;一句createInsertCommand方法定义于CDbCommandBuilder类中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function createInsertCommand($table,$data)
{
    $this-&amp;gt;ensureTable($table);
    $fields=array();
    $values=array();
    $placeholders=array();
    $i=0;
    foreach($data as $name=&amp;gt;$value)
    {
        if(($column=$table-&amp;gt;getColumn($name))!==null &amp;amp;&amp;amp; ($value!==null || $column-&amp;gt;allowNull))
        {
            $fields[]=$column-&amp;gt;rawName;
            if($value instanceof CDbExpression)
            {
                $placeholders[]=$value-&amp;gt;expression;
                foreach($value-&amp;gt;params as $n=&amp;gt;$v)
                    $values[$n]=$v;
            }
            else
            {
                $placeholders[]=self::PARAM_PREFIX.$i;
                $values[self::PARAM_PREFIX.$i]=$column-&amp;gt;typecast($value);
                $i++;
            }
        }
    }
    if($fields===array())
    {
        $pks=is_array($table-&amp;gt;primaryKey) ? $table-&amp;gt;primaryKey : array($table-&amp;gt;primaryKey);
        foreach($pks as $pk)
        {
            $fields[]=$table-&amp;gt;getColumn($pk)-&amp;gt;rawName;
            $placeholders[]=$this-&amp;gt;getIntegerPrimaryKeyDefaultValue();
        }
    }
    $sql=&amp;quot;INSERT INTO {$table-&amp;gt;rawName} (&amp;quot;.implode(&amp;#39;, &amp;#39;,$fields).&amp;#39;) VALUES (&amp;#39;.implode(&amp;#39;, &amp;#39;,$placeholders).&amp;#39;)&amp;#39;;
    $command=$this-&amp;gt;_connection-&amp;gt;createCommand($sql);

    foreach($values as $name=&amp;gt;$value)
        $command-&amp;gt;bindValue($name,$value);

    return $command;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外还有与update、delete等操作对应的方法createUpdateCommand、createDeleteCommand等。&lt;/p&gt;
&lt;p&gt;update方法与insert方法的逻辑基本是一致的。&lt;/p&gt;
&lt;p&gt;CActiveRecord中所有数据库增、删、改、查操作，在构建出目标sql语句后，都是调用CDbConnection类的方法createCommand来得到一个CDbCommand类的对象，最后调用该对象的execute、query、queryAll等方法来完成查询获取结果。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于model类实例对象的属性赋值，依赖于CActiveRecord类的方法__set，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __set($name,$value)
{
    if($this-&amp;gt;setAttribute($name,$value)===false)
    {
        if(isset($this-&amp;gt;getMetaData()-&amp;gt;relations[$name]))
            $this-&amp;gt;_related[$name]=$value;
        else
            parent::__set($name,$value);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的setAttribute方法的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function setAttribute($name,$value)
{
    if(property_exists($this,$name))
        $this-&amp;gt;$name=$value;
    elseif(isset($this-&amp;gt;getMetaData()-&amp;gt;columns[$name]))
        $this-&amp;gt;_attributes[$name]=$value;
    else
        return false;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;基于CActiveRecord类，如果想进行读取操作，那么子类需要重写model方法。CActiveRecord类的model方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Returns the static model of the specified AR class.
 * The model returned is a static instance of the AR class.
 * It is provided for invoking class-level methods (something similar to static class methods.)
 *
 * EVERY derived AR class must override this method as follows,
 * &amp;lt;pre&amp;gt;
 * public static function model($className=__CLASS__)
 * {
 *     return parent::model($className);
 * }
 * &amp;lt;/pre&amp;gt;
 *
 * @param string $className active record class name.
 * @return CActiveRecord active record model instance.
 */
public static function model($className=__CLASS__)
{
    if(isset(self::$_models[$className]))
        return self::$_models[$className];
    else
    {
        $model=self::$_models[$className]=new $className(null);
        $model-&amp;gt;attachBehaviors($model-&amp;gt;behaviors());
        return $model;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据该方法的注释可知道，所有的子类必须如下重写model方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public static function model($className = __CLASS__)
{
    return parent::model($className);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为什么必须重写model方法呢？因为&lt;code&gt;__CLASS__&lt;/code&gt;指的并不是当前对象所属的类，而是方法定义所在的类。&lt;/p&gt;
&lt;p&gt;隔壁的哥们告诉我，在 PHP 5.3 之后，如果CActiveRecord的model方法如下实现，就可以不用这样使用需要重写了。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public static function model()
{
    $className = get_called_class();
    if(isset(self::$_models[$className]))
        return self::$_models[$className];
    else
    {
        $model=self::$_models[$className]=new $className(null);
        $model-&amp;gt;attachBehaviors($model-&amp;gt;behaviors());
        return $model;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在得到$model后，就可以调用对象的query、find、findAll、findByPk、findAllByPk、findByAttributes、findAllByAttributes、findBySql、findAllBySql等方法来查询数据。其中find、findAll、findByPk、findAllByPk、findByAttributes、findAllByAttributes最终是通过调用query方法来实现查询的。query方法的第一个参数是一个CDbCriteria类实例对象，这就意味着调用query方法来实现查询的方法需要根据参数实例化一个CDbCriteria类对象。如find方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Finds a single active record with the specified condition.
 * @param mixed $condition query condition or criteria.
 * If a string, it is treated as query condition (the WHERE clause);
 * If an array, it is treated as the initial values for constructing a {@link CDbCriteria} object;
 * Otherwise, it should be an instance of {@link CDbCriteria}.
 * @param array $params parameters to be bound to an SQL statement.
 * This is only used when the first parameter is a string (query condition).
 * In other cases, please use {@link CDbCriteria::params} to set parameters.
 * @return CActiveRecord the record found. Null if no record is found.
 */
public function find($condition=&amp;#39;&amp;#39;,$params=array())
{
    Yii::trace(get_class($this).&amp;#39;.find()&amp;#39;,&amp;#39;system.db.ar.CActiveRecord&amp;#39;);
    // 实例化一个CDbCriteria对象
    $criteria=$this-&amp;gt;getCommandBuilder()-&amp;gt;createCriteria($condition,$params);
    return $this-&amp;gt;query($criteria);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而query方法的实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;protected function query($criteria,$all=false)
{
    $this-&amp;gt;beforeFind();
    $this-&amp;gt;applyScopes($criteria);

    if(empty($criteria-&amp;gt;with))
    {
        if(!$all)
            $criteria-&amp;gt;limit=1;
        // createFindCommand在上面提过
        $command=$this-&amp;gt;getCommandBuilder()-&amp;gt;createFindCommand($this-&amp;gt;getTableSchema(),$criteria,$this-&amp;gt;getTableAlias());
        return $all ? $this-&amp;gt;populateRecords($command-&amp;gt;queryAll(), true, $criteria-&amp;gt;index) : $this-&amp;gt;populateRecord($command-&amp;gt;queryRow());
    }
    else
    {
        $finder=$this-&amp;gt;getActiveFinder($criteria-&amp;gt;with);
        return $finder-&amp;gt;query($criteria,$all);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;对于查询操作，很多时候需要多表关联查询。那么基于CActiveRecord如何实现多表关联查询（隐式自动地）呢？&lt;/p&gt;
&lt;p&gt;CActiveRecord类有个方法relations()：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function relations()
{
    return array();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个方法的注释非常长，说明如何通过该方法声明当前model对应的数据表有哪些关联数据表，是何种关联关系。继承自CActiveRecord类的model类若想使用隐式的多表关联查询，则需要重写该方法。&lt;/p&gt;
&lt;p&gt;举例来说，有数据表UserContacts、Users，UserContacts中有外键字段user_id关联到Users。如果基于CActiveRecord在查询UserContacts记录时，需要便捷地获取关联Users的记录。那么可以在UserContacts数据表对应的model类中，这样重写relations方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function relations()
{
    return array(
            &amp;#39;user&amp;#39; =&amp;gt; array(self::BELONGS_TO, &amp;#39;Users&amp;#39;, &amp;#39;user_id&amp;#39;),
    );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么在得到一条记录对象（$uc）时，通过调用$uc-&amp;gt;user，即可得到与该UserContacts记录关联的Users记录。不过这条关联记录的获取可能是在调用$uc-&amp;gt;user时才去查询数据库的。&lt;/p&gt;
&lt;p&gt;若想提前将关联记录查询出来准备好，则可以再调用find、findAll等查询方法之前先调用with方法，如&lt;code&gt;self::model()-&amp;gt;with('user')-&amp;gt;find(array('usercontact_id' =&amp;gt; 1))&lt;/code&gt;，或者这样调用find方法&lt;code&gt;self::model()-&amp;gt;find(array('usercontact_id' =&amp;gt; 1, 'with' =&amp;gt; 'user'))&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么在调用&lt;code&gt;$uc-&amp;gt;user&lt;/code&gt;时，如何知道user是一个关联项，而不是一个当前对象的属性？如果当前对象对应的数据表已有一个名为user的字段，是否会屏蔽掉关联项？且看CActiveRecord类的__get方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __get($name)
{
    // 先查看当前model类对应的数据表是否有名为$name的字段
    if(isset($this-&amp;gt;_attributes[$name]))
        return $this-&amp;gt;_attributes[$name];
    elseif(isset($this-&amp;gt;getMetaData()-&amp;gt;columns[$name]))
        return null;
    // 查看是否有名为$name的关联项
    elseif(isset($this-&amp;gt;_related[$name]))
        return $this-&amp;gt;_related[$name];
    elseif(isset($this-&amp;gt;getMetaData()-&amp;gt;relations[$name]))
        return $this-&amp;gt;getRelated($name);
    else
        return parent::__get($name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;&lt;em&gt;注：本文为草稿状态&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 组件集成</title><link href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/" rel="alternate"></link><published>2014-11-13T00:00:00+08:00</published><updated>2014-11-13T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-13:/2014/11/13/read-yii-code-3/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架将各种功能封装成组件，使用时按需配置加载，从而提高应用的性能。内置的组件又分为核心组件与非核心组件，核心组件是任何Web应用和Console应用都需要的。
此外，应 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架将各种功能封装成组件，使用时按需配置加载，从而提高应用的性能。内置的组件又分为核心组件与非核心组件，核心组件是任何Web应用和Console应用都需要的。
此外，应用开发者还可以按照一定规则封装配置使用自己的功能组件。Yii会把应用需要的组件都加载到应用容器&lt;code&gt;Yii::app()&lt;/code&gt;中，使得组件的使用方式一致方便。&lt;/p&gt;
&lt;p&gt;基于Yii框架开发应用需要理解如何配置组件、如何开发自己的组件，对应着需要理解Yii是如何注册加载组件的。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;从&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt;一文可知，Yii加载组件的入口为抽象类CApplication构造方法中的以下两行代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$this-&amp;gt;registerCoreComponents();
$this-&amp;gt;configure($config);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;&lt;code&gt;registerCoreComponents&lt;/code&gt;方法定义于类CWebApplication中，用于加载Web应用的核心组件，组件列表如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;array(
    // 核心组件
    &amp;#39;coreMessages&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CPhpMessageSource&amp;#39;,
        &amp;#39;language&amp;#39;=&amp;gt;&amp;#39;en_us&amp;#39;,
        &amp;#39;basePath&amp;#39;=&amp;gt;YII_PATH.DIRECTORY_SEPARATOR.&amp;#39;messages&amp;#39;,
    ),
    &amp;#39;db&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CDbConnection&amp;#39;,
    ),
    &amp;#39;messages&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CPhpMessageSource&amp;#39;,
    ),
    &amp;#39;errorHandler&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CErrorHandler&amp;#39;,
    ),
    &amp;#39;securityManager&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CSecurityManager&amp;#39;,
    ),
    &amp;#39;statePersister&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CStatePersister&amp;#39;,
    ),
    &amp;#39;urlManager&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CUrlManager&amp;#39;,
    ),
    &amp;#39;request&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CHttpRequest&amp;#39;,
    ),
    &amp;#39;format&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CFormatter&amp;#39;,
    ),

    // 以下是Web应用额外需要的核心组件
    &amp;#39;session&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CHttpSession&amp;#39;,
    ),
    &amp;#39;assetManager&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CAssetManager&amp;#39;,
    ),
    &amp;#39;user&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CWebUser&amp;#39;,
    ),
    &amp;#39;themeManager&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CThemeManager&amp;#39;,
    ),
    &amp;#39;authManager&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CPhpAuthManager&amp;#39;,
    ),
    &amp;#39;clientScript&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CClientScript&amp;#39;,
    ),
    &amp;#39;widgetFactory&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CWidgetFactory&amp;#39;,
    ),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注册加载组件都是直接调用方法&lt;code&gt;setComponents&lt;/code&gt;，间接调用方法&lt;code&gt;setComponent&lt;/code&gt;来完成的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;configure&lt;/code&gt;方法定义于类&lt;code&gt;CModule&lt;/code&gt;中，是用于加载所有配置信息的，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function configure($config)
{
    if(is_array($config))
    {
        foreach($config as $key=&amp;gt;$value)
            $this-&amp;gt;$key=$value;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt;一文可知，配置信息的加载是基于类&lt;code&gt;CComponent&lt;/code&gt;中的魔术方法&lt;code&gt;__set&lt;/code&gt;来完成的，该方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __set($name,$value)
{
    // PHP的类名、函数名、方法名都是不区分大小写的！
    $setter=&amp;#39;set&amp;#39;.$name;
    if(method_exists($this,$setter))
        return $this-&amp;gt;$setter($value);
    elseif(strncasecmp($name,&amp;#39;on&amp;#39;,2)===0 &amp;amp;&amp;amp; method_exists($this,$name))
    {
        // duplicating getEventHandlers() here for performance
        $name=strtolower($name);
        if(!isset($this-&amp;gt;_e[$name]))
            $this-&amp;gt;_e[$name]=new CList;
        return $this-&amp;gt;_e[$name]-&amp;gt;add($value);
    }
    elseif(is_array($this-&amp;gt;_m))
    {
        foreach($this-&amp;gt;_m as $object)
        {
            if($object-&amp;gt;getEnabled() &amp;amp;&amp;amp; (property_exists($object,$name) || $object-&amp;gt;canSetProperty($name)))
                return $object-&amp;gt;$name=$value;
        }
    }
    if(method_exists($this,&amp;#39;get&amp;#39;.$name))
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is read only.&amp;#39;,
            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is not defined.&amp;#39;,
            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而类CModule中又定义了方法&lt;code&gt;setComponents&lt;/code&gt;，所以对于key为&lt;code&gt;components&lt;/code&gt;的配置项，也是调用方法&lt;code&gt;setComponents&lt;/code&gt;，间接调用方法&lt;code&gt;setComponent&lt;/code&gt;来完成的。&lt;/p&gt;
&lt;p&gt;方法&lt;code&gt;setComponent&lt;/code&gt;实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Puts a component under the management of the module.
 * The component will be initialized by calling its {@link CApplicationComponent::init() init()}
 * method if it has not done so.
 * @param string $id component ID
 * @param array|IApplicationComponent $component application component
 * (either configuration array or instance). If this parameter is null,
 * component will be unloaded from the module.
 * @param boolean $merge whether to merge the new component configuration
 * with the existing one. Defaults to true, meaning the previously registered
 * component configuration with the same ID will be merged with the new configuration.
 * If set to false, the existing configuration will be replaced completely.
 * This parameter is available since 1.1.13.
 */
public function setComponent($id,$component,$merge=true)
{
    if($component===null)
    {
        unset($this-&amp;gt;_components[$id]);
        return;
    }
    elseif($component instanceof IApplicationComponent)
    {
        $this-&amp;gt;_components[$id]=$component;

        if(!$component-&amp;gt;getIsInitialized())
            $component-&amp;gt;init();

        return;
    }
    elseif(isset($this-&amp;gt;_components[$id]))
    {
        if(isset($component[&amp;#39;class&amp;#39;]) &amp;amp;&amp;amp; get_class($this-&amp;gt;_components[$id])!==$component[&amp;#39;class&amp;#39;])
        {
            unset($this-&amp;gt;_components[$id]);
            $this-&amp;gt;_componentConfig[$id]=$component; //we should ignore merge here
            return;
        }

        foreach($component as $key=&amp;gt;$value)
        {
            if($key!==&amp;#39;class&amp;#39;)
                $this-&amp;gt;_components[$id]-&amp;gt;$key=$value;
        }
    }
    // 以configure方法为入口的组件注册可能走的分支
    elseif(isset($this-&amp;gt;_componentConfig[$id][&amp;#39;class&amp;#39;],$component[&amp;#39;class&amp;#39;])
        &amp;amp;&amp;amp; $this-&amp;gt;_componentConfig[$id][&amp;#39;class&amp;#39;]!==$component[&amp;#39;class&amp;#39;])
    {
        $this-&amp;gt;_componentConfig[$id]=$component; //we should ignore merge here
        return;
    }

    // 以configure方法为入口的组件注册可能走的分支
    if(isset($this-&amp;gt;_componentConfig[$id]) &amp;amp;&amp;amp; $merge)
        // 对组件的信息进行合并，即意味着如果是对核心组件做额外配置，可以不用指定class等信息。
        $this-&amp;gt;_componentConfig[$id]=CMap::mergeArray($this-&amp;gt;_componentConfig[$id],$component);
    else
        // 核心组件注册全走这个分支
        // 非核心组件、自定义组件注册走这个分支
        $this-&amp;gt;_componentConfig[$id]=$component;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于以registerCoreComponents方法、configure方法为入口的组件注册，调用setComponent方法时的参数$component是一个数组。&lt;/p&gt;
&lt;p&gt;注册核心组件前，应用对象的属性&lt;code&gt;_component&lt;/code&gt;和&lt;code&gt;_componentConfig&lt;/code&gt;都为空，所以核心组件注册最终走的都是&lt;strong&gt;最后一个else分支&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于可以配置与核心组件相同ID的组件，比如db，那么注册配置的组件（以configure方法为入口）走的是&lt;strong&gt;最后一个elseif分支或者最后一个if分支&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以看到以这两个方法为入口的组件注册都没有对组件进行初始化。那么什么时候初始化组件的呢？只能是调用组件的时候了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;组件是通过应用对象容器来调用的。以db组件为例，调用方式为：&lt;code&gt;Yii::app()-&amp;gt;db&lt;/code&gt;，但实际是基于魔术方法&lt;code&gt;__get&lt;/code&gt;来完成的，该魔术方法定义于类CModule中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __get($name)
{
    if($this-&amp;gt;hasComponent($name))
        return $this-&amp;gt;getComponent($name);
    else
        return parent::__get($name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;先尝试查找对应$name的组件。从这里可以看出Web应用容器中除了存组件，还可以存其他信息，如所有的配置信息。&lt;/p&gt;
&lt;p&gt;方法hasComponent实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function hasComponent($id)
{
    return isset($this-&amp;gt;_components[$id]) || isset($this-&amp;gt;_componentConfig[$id]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之所以会先查看属性_components，是因为_components中保存的组件是已经加载好的，而_componentConfig保存的是所有注册的组件，但未初始化。即_components中的组件是_componentConfig中组件的子集，检测起来会更快？我的理解是这样的。&lt;/p&gt;
&lt;p&gt;方法getComponent实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getComponent($id,$createIfNull=true)
{
    if(isset($this-&amp;gt;_components[$id]))
        return $this-&amp;gt;_components[$id];
    elseif(isset($this-&amp;gt;_componentConfig[$id]) &amp;amp;&amp;amp; $createIfNull)
    {
        $config=$this-&amp;gt;_componentConfig[$id];
        if(!isset($config[&amp;#39;enabled&amp;#39;]) || $config[&amp;#39;enabled&amp;#39;])
        {
            Yii::trace(&amp;quot;Loading \&amp;quot;$id\&amp;quot; application component&amp;quot;,&amp;#39;system.CModule&amp;#39;);
            unset($config[&amp;#39;enabled&amp;#39;]);
            $component=Yii::createComponent($config);
            $component-&amp;gt;init();
            return $this-&amp;gt;_components[$id]=$component;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;先查看属性_components中是否已保存初始化好的对应组件，是，则直接取出来返回，这样重复调用相同组件只会初始化一次；否，则对该组件进行初始化。&lt;/p&gt;
&lt;p&gt;组件初始化分为两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Yii根据组件的配置信息实例化一个组件对象，即&lt;code&gt;$component=Yii::createComponent($config)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组件对象调用自己的方法&lt;code&gt;init&lt;/code&gt;完成一些初始化操作，即&lt;code&gt;$component-&amp;gt;init()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;初始化结束后，将组件对象存入属性_components中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;静态方法&lt;code&gt;createComponent&lt;/code&gt;定义于类YiiBase中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Creates an object and initializes it based on the given configuration.
 *
 * The specified configuration can be either a string or an array.
 * If the former, the string is treated as the object type which can
 * be either the class name or {@link YiiBase::getPathOfAlias class path alias}.
 * If the latter, the &amp;#39;class&amp;#39; element is treated as the object type,
 * and the rest of the name-value pairs in the array are used to initialize
 * the corresponding object properties.
 *
 * Any additional parameters passed to this method will be
 * passed to the constructor of the object being created.
 *
 * @param mixed $config the configuration. It can be either a string or an array.
 * @return mixed the created object
 * @throws CException if the configuration does not have a &amp;#39;class&amp;#39; element.
 */
public static function createComponent($config)
{
    // 如果传入的组件配置信息是字符串类型，则认为是对象类型
    if(is_string($config))
    {
        $type=$config;
        $config=array();
    }
    // 如果是数组，则必须指定组件所对应的class
    elseif(isset($config[&amp;#39;class&amp;#39;]))
    {
        $type=$config[&amp;#39;class&amp;#39;];
        unset($config[&amp;#39;class&amp;#39;]);
    }
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Object configuration must be an array containing a &amp;quot;class&amp;quot; element.&amp;#39;));

    // 如果组件所对应的类型还没加载，则加载进来
    if(!class_exists($type,false))
        $type=Yii::import($type,true);

    // 如果除了$config，还传递了其他参数，则根据额外的参数来实例化。对于组件初始化来说，不会走这个分支
    if(($n=func_num_args())&amp;gt;1)
    {
        $args=func_get_args();
        if($n===2)
            $object=new $type($args[1]);
        elseif($n===3)
            $object=new $type($args[1],$args[2]);
        elseif($n===4)
            $object=new $type($args[1],$args[2],$args[3]);
        else
        {
            unset($args[0]);
            $class=new ReflectionClass($type);
            // Note: ReflectionClass::newInstanceArgs() is available for PHP 5.1.3+
            // $object=$class-&amp;gt;newInstanceArgs($args);
            $object=call_user_func_array(array($class,&amp;#39;newInstance&amp;#39;),$args);
        }
    }
    // 没有额外的参数，则直接实例化组件
    else
        $object=new $type;

    // $config中除了class外的其他字段都作为组件对象的属性进行赋值
    foreach($config as $key=&amp;gt;$value)
        $object-&amp;gt;$key=$value;

    return $object;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述代码可以看出，在配置组件时，如果是配置核心组件，可以不提供class字段，否则一定要提供。除了class字段，还可以为组件对象的属性赋值。按照PHP中对一个对象的属性进行赋值的规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果该对象有public的该属性，则直接赋值&lt;/li&gt;
&lt;li&gt;否则看该对象所在继承树上是否有定义魔术方法&lt;code&gt;__set&lt;/code&gt;，如果有则调用&lt;code&gt;__set&lt;/code&gt;来处理赋值过程&lt;/li&gt;
&lt;li&gt;如果连&lt;code&gt;__set&lt;/code&gt;也没有，则为该对象生成一个public的属性，然后赋值给它&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以将自定义组件类需要初始化赋值的属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义为public访问控制&lt;/li&gt;
&lt;li&gt;如果非public，则应该魔术方法&lt;code&gt;__set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;也可以不定义该属性（我觉得还是定义一下比较好，否则不好理解）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;在静态方法createComponent返回组件对象后，接着调用组件对象自身的init方法来完成一些初始化工具。这也就意味着自定义组件需要有init方法。&lt;/p&gt;
&lt;p&gt;从核心组件的定义可以看到，组件应该继承自抽象类&lt;code&gt;CApplicationComponent&lt;/code&gt;（见文件&lt;code&gt;yii/framework/base/CApplicationComponent.php&lt;/code&gt;）。该类定义了方法init和getIsInitialized。
自定义组件继承自&lt;code&gt;CApplicationComponent&lt;/code&gt;，若没有额外的初始化操作，也可以不再定义自己的init方法。如果定义自己的init方法，最好也间接调用一下父类的init方法（&lt;code&gt;parent::init()&lt;/code&gt;），
从而避免一些可能潜在的兼容问题。&lt;/p&gt;
&lt;p&gt;关于自定义组件的更多具体细节，可以参考&lt;a href="http://youngsterxyf.github.io/2014/09/06/socket.io-push-server/"&gt;基于socket.io的实时消息推送&lt;/a&gt;一文中的示例。&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 路由解析</title><link href="http://youngsterxyf.github.io/2014/11/12/read-yii-code-2/" rel="alternate"></link><published>2014-11-12T00:00:00+08:00</published><updated>2014-11-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-12:/2014/11/12/read-yii-code-2/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架的路由解析功能由核心组件urlManager来完成。路由的形式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get：通过URL中查询字符串（query string）参数r来指定路由，如：&lt;code&gt;r=controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;path：直接通过URL来指定，如：&lt;code&gt;/controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认使用get路由形式。由于Yii中controller类命名和action方法都是按照规则命名的，而路由也是按照规则 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架的路由解析功能由核心组件urlManager来完成。路由的形式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get：通过URL中查询字符串（query string）参数r来指定路由，如：&lt;code&gt;r=controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;path：直接通过URL来指定，如：&lt;code&gt;/controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认使用get路由形式。由于Yii中controller类命名和action方法都是按照规则命名的，而路由也是按照规则来匹配的，所以完全可以不用额外配置urlManager。&lt;/p&gt;
&lt;p&gt;若需要使用path方式，则可如下配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;quot;components&amp;quot; =&amp;gt; array(
    &amp;#39;urlManager&amp;#39; =&amp;gt; array(
        &amp;#39;urlFormat&amp;#39; =&amp;gt; &amp;#39;path&amp;#39;,
        &amp;#39;rules&amp;#39; =&amp;gt; array(
            ...
        ),
),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;进一步说明可参考&lt;a href="http://youngsterxyf.github.io/2014/09/06/experience-about-restful-api/"&gt;RESTful API设计的一点经验&lt;/a&gt;一文。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;在“请求处理基本流程”一篇可以看到Yii框架路由解析流程的入口在类CWebApplication的processRequest方法中：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$route=$this-&amp;gt;getUrlManager()-&amp;gt;parseUrl($this-&amp;gt;getRequest());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中getUrlManager方法定义于类CApplication中，作用是初始化获取URL管理组件（ID为urlManager），实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function getUrlManager()
{
    return $this-&amp;gt;getComponent(&amp;#39;urlManager&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在获取urlManager组件对象过程中，会对对象做初始化，调用对象的init方法，见类CUrlManager的init方法实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function init()
{
    parent::init();
    $this-&amp;gt;processRules();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中调用的方法processRules，是根据配置的rules解析创建规则对象，放到属性_rules中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;protected function processRules()
{
    // 如果未配置rules，或使用的路由形式是get，则根本无需解析路由规则
    if(empty($this-&amp;gt;rules) || $this-&amp;gt;getUrlFormat()===self::GET_FORMAT)
        return;
    // 否则尝试从缓存中读取解析好的路由规则
    if($this-&amp;gt;cacheID!==false &amp;amp;&amp;amp; ($cache=Yii::app()-&amp;gt;getComponent($this-&amp;gt;cacheID))!==null)
    {
        $hash=md5(serialize($this-&amp;gt;rules));
        if(($data=$cache-&amp;gt;get(self::CACHE_KEY))!==false &amp;amp;&amp;amp; isset($data[1]) &amp;amp;&amp;amp; $data[1]===$hash)
        {
            $this-&amp;gt;_rules=$data[0];
            return;
        }
    }
    // 否则逐条路由规则解析
    foreach($this-&amp;gt;rules as $pattern=&amp;gt;$route)
        $this-&amp;gt;_rules[]=$this-&amp;gt;createUrlRule($route,$pattern);
    // 尝试缓存解析好的路由规则
    if(isset($cache))
        $cache-&amp;gt;set(self::CACHE_KEY,array($this-&amp;gt;_rules,$hash));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述代码中，在解析创建规则对象前会先检查是否已缓存了解析创建好的规则，如果没有，则在解析创建好规则后，将这些规则缓存起来。这样就避免了每次请求处理都要解析一次rules列表。
但这里需要注意的是&lt;strong&gt;urlManager组件默认使用ID为&lt;code&gt;cache&lt;/code&gt;的缓存组件（CUrlManager类的属性cacheID默认值为cache），而核心组件并不包含ID为&lt;code&gt;cache&lt;/code&gt;的缓存组件，所以若希望缓存解析好路由规则，
则应该配置ID为cache的缓存组件，如果缓存组件的ID不是cache，则需要配置urlManager组件的cacheID属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果没有设置缓存组件，或者缓存中未找到解析好的路由规则，则需要对配置的rules逐条解析，解析过程见类CUrlManager的createUrlRule方法实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Creates a URL rule instance.
 * The default implementation returns a CUrlRule object.
 * @param mixed $route the route part of the rule. This could be a string or an array
 * @param string $pattern the pattern part of the rule
 * @return CUrlRule the URL rule instance
 * @since 1.1.0
 */
protected function createUrlRule($route,$pattern)
{
    // 说明可以配置自定义的路由规则解析类
    if(is_array($route) &amp;amp;&amp;amp; isset($route[&amp;#39;class&amp;#39;]))
        return $route;
    else
    {
        $urlRuleClass=Yii::import($this-&amp;gt;urlRuleClass,true);
        return new $urlRuleClass($route,$pattern);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以以下rules配置为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;rules&amp;#39; =&amp;gt; array(
    array(&amp;#39;industry/index&amp;#39;, &amp;#39;pattern&amp;#39; =&amp;gt; &amp;#39;/v1/partner/industry/&amp;#39;, &amp;#39;verb&amp;#39; =&amp;gt; &amp;#39;GET&amp;#39;),
    array(&amp;#39;token/create&amp;#39;, &amp;#39;pattern&amp;#39; =&amp;gt; &amp;#39;/v1/partner/token&amp;#39;, &amp;#39;verb&amp;#39; =&amp;gt; &amp;#39;POST&amp;#39;),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在处理第一条规则时，方法createUrlRule的参数$pattern的值为数组的索引0，$route的值为关联数组&lt;code&gt;array('industry/index', 'pattern' =&amp;gt; '/v1/partner/industry/', 'verb' =&amp;gt; 'GET')&lt;/code&gt;，
但因为$route里没有设置class字段，所以走的是else分支 - 先引入类CUrlRule（$this-&amp;gt;urlRuleClass的默认值），然后根据$route、$pattern实例化类CUrlRule，该类也定义在文件&lt;code&gt;yii/framework/web/CUrlManager.php&lt;/code&gt;中，
直接继承自抽象类CBaseUrlRule。CUrlRule的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($route,$pattern)
{
    if(is_array($route))
    {
        // 从这里可知$route支持&amp;#39;urlSuffix&amp;#39;, &amp;#39;caseSensitive&amp;#39;, &amp;#39;defaultParams&amp;#39;, &amp;#39;matchValue&amp;#39;, &amp;#39;verb&amp;#39;, &amp;#39;parsingOnly&amp;#39;这些配置项
        foreach(array(&amp;#39;urlSuffix&amp;#39;, &amp;#39;caseSensitive&amp;#39;, &amp;#39;defaultParams&amp;#39;, &amp;#39;matchValue&amp;#39;, &amp;#39;verb&amp;#39;, &amp;#39;parsingOnly&amp;#39;) as $name)
        {
            if(isset($route[$name]))
                $this-&amp;gt;$name=$route[$name];
        }
        // 如果$route中有pattern配置项，则将配置值赋值给$pattern
        if(isset($route[&amp;#39;pattern&amp;#39;]))
            $pattern=$route[&amp;#39;pattern&amp;#39;];
        // 而$route的第一个配置项才是真正的目标路由
        $route=$route[0];
    }
    $this-&amp;gt;route=trim($route,&amp;#39;/&amp;#39;);

    $tr2[&amp;#39;/&amp;#39;]=$tr[&amp;#39;/&amp;#39;]=&amp;#39;\\/&amp;#39;;

    if(strpos($route,&amp;#39;&amp;lt;&amp;#39;)!==false &amp;amp;&amp;amp; preg_match_all(&amp;#39;/&amp;lt;(\w+)&amp;gt;/&amp;#39;,$route,$matches2))
    {
        foreach($matches2[1] as $name)
            $this-&amp;gt;references[$name]=&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;;
    }

    // 是否带协议头
    $this-&amp;gt;hasHostInfo=!strncasecmp($pattern,&amp;#39;http://&amp;#39;,7) || !strncasecmp($pattern,&amp;#39;https://&amp;#39;,8);

    // 如果原$route有verb配置项
    // verb配置支持多个HTTP方法，以空格或逗号分隔，如：“GET,POST”
    if($this-&amp;gt;verb!==null)
        $this-&amp;gt;verb=preg_split(&amp;#39;/[\s,]+/&amp;#39;,strtoupper($this-&amp;gt;verb),-1,PREG_SPLIT_NO_EMPTY);

    // $pattern中类正则片段支持两种形式：命名的和未命名的，如“&amp;lt;id:\d+&amp;gt;”和“&amp;lt;\d+&amp;gt;”
    if(preg_match_all(&amp;#39;/&amp;lt;(\w+):?(.*?)?&amp;gt;/&amp;#39;,$pattern,$matches))
    {
        $tokens=array_combine($matches[1],$matches[2]);
        foreach($tokens as $name=&amp;gt;$value)
        {
            if($value===&amp;#39;&amp;#39;)
                $value=&amp;#39;[^\/]+&amp;#39;;
            $tr[&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;]=&amp;quot;(?P&amp;lt;$name&amp;gt;$value)&amp;quot;;
            if(isset($this-&amp;gt;references[$name]))
                $tr2[&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;]=$tr[&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;];
            else
                $this-&amp;gt;params[$name]=$value;
        }
    }
    // 好吧，之后的这段代码我还没太看懂作用
    // 就是为了将$pattern转换成一个真正的正则表达式？
    $p=rtrim($pattern,&amp;#39;*&amp;#39;);
    $this-&amp;gt;append=$p!==$pattern;
    $p=trim($p,&amp;#39;/&amp;#39;);
    $this-&amp;gt;template=preg_replace(&amp;#39;/&amp;lt;(\w+):?.*?&amp;gt;/&amp;#39;,&amp;#39;&amp;lt;$1&amp;gt;&amp;#39;,$p);
    $this-&amp;gt;pattern=&amp;#39;/^&amp;#39;.strtr($this-&amp;gt;template,$tr).&amp;#39;\/&amp;#39;;
    if($this-&amp;gt;append)
        $this-&amp;gt;pattern.=&amp;#39;/u&amp;#39;;
    else
        $this-&amp;gt;pattern.=&amp;#39;$/u&amp;#39;;

    if($this-&amp;gt;references!==array())
        $this-&amp;gt;routePattern=&amp;#39;/^&amp;#39;.strtr($this-&amp;gt;route,$tr2).&amp;#39;$/u&amp;#39;;

    if(YII_DEBUG &amp;amp;&amp;amp; @preg_match($this-&amp;gt;pattern,&amp;#39;test&amp;#39;)===false)
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The URL pattern &amp;quot;{pattern}&amp;quot; for route &amp;quot;{route}&amp;quot; is not a valid regular expression.&amp;#39;,
            array(&amp;#39;{route}&amp;#39;=&amp;gt;$route,&amp;#39;{pattern}&amp;#39;=&amp;gt;$pattern)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;在得到&lt;strong&gt;urlManager组件对象&lt;/strong&gt;后，调用其parseUrl方法，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function parseUrl($request)
{
    if($this-&amp;gt;getUrlFormat()===self::PATH_FORMAT)
    {
        $rawPathInfo=$request-&amp;gt;getPathInfo();
        $pathInfo=$this-&amp;gt;removeUrlSuffix($rawPathInfo,$this-&amp;gt;urlSuffix);
        foreach($this-&amp;gt;_rules as $i=&amp;gt;$rule)
        {
            if(is_array($rule))
                $this-&amp;gt;_rules[$i]=$rule=Yii::createComponent($rule);
            // 逐个路由规则匹配
            if(($r=$rule-&amp;gt;parseUrl($this,$request,$pathInfo,$rawPathInfo))!==false)
                // 即使匹配到了路由规则，也还是得看一下URL中是否指定了路由，是的话则优先使用URL中指定的路由
                return isset($_GET[$this-&amp;gt;routeVar]) ? $_GET[$this-&amp;gt;routeVar] : $r;
        }
        // 如果一定要匹配到某个路由规则才行，那么执行到这里就表示未有匹配的路由规则，所以就抛404错误了。
        if($this-&amp;gt;useStrictParsing)
            throw new CHttpException(404,Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Unable to resolve the request &amp;quot;{route}&amp;quot;.&amp;#39;,
                array(&amp;#39;{route}&amp;#39;=&amp;gt;$pathInfo)));
        // 否则先返回请求路径作为目标路由
        else
            return $pathInfo;
    }
    // 如果使用的是get路由形式，则从GET请求的查询字符串或POST请求的请求体找目标路由
    elseif(isset($_GET[$this-&amp;gt;routeVar]))
        return $_GET[$this-&amp;gt;routeVar];
    elseif(isset($_POST[$this-&amp;gt;routeVar]))
        return $_POST[$this-&amp;gt;routeVar];
    else
        return &amp;#39;&amp;#39;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法的参数是一个request组件对象。&lt;/p&gt;
&lt;p&gt;先判断应用使用的路由形式是否为path，如果不是，则根据路由的参数名（默认为&lt;code&gt;r&lt;/code&gt;，由于urlManager类的routeVar属性是public的，所以可以通过配置routeVar的值来修改路由参数名）获取路由。并且路由可以通过GET方法放在URL查询字符串中，也可以通过POST方法放在请求体中。&lt;/p&gt;
&lt;p&gt;对于path形式的路由，解析过程则要复杂一些。先通过request组件对象的getPathInfo方法取到请求的URL（会对原本的请求URL做一定的处理），然后根据解析好的路由规则列表逐个匹配。其中&lt;strong&gt;CUrlRule类&lt;/strong&gt;的parseUrl方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function parseUrl($manager,$request,$pathInfo,$rawPathInfo)
{
    // 先检查HTTP谓词（verb）是否匹配
    if($this-&amp;gt;verb!==null &amp;amp;&amp;amp; !in_array($request-&amp;gt;getRequestType(), $this-&amp;gt;verb, true))
        return false;
    // 是否关心大小写
    if($manager-&amp;gt;caseSensitive &amp;amp;&amp;amp; $this-&amp;gt;caseSensitive===null || $this-&amp;gt;caseSensitive)
        $case=&amp;#39;&amp;#39;;
    else
        $case=&amp;#39;i&amp;#39;;

    // urlSiffix配置项是用来干嘛的？
    if($this-&amp;gt;urlSuffix!==null)
        $pathInfo=$manager-&amp;gt;removeUrlSuffix($rawPathInfo,$this-&amp;gt;urlSuffix);

    // URL suffix required, but not found in the requested URL
    if($manager-&amp;gt;useStrictParsing &amp;amp;&amp;amp; $pathInfo===$rawPathInfo)
    {
        $urlSuffix=$this-&amp;gt;urlSuffix===null ? $manager-&amp;gt;urlSuffix : $this-&amp;gt;urlSuffix;
        if($urlSuffix!=&amp;#39;&amp;#39; &amp;amp;&amp;amp; $urlSuffix!==&amp;#39;/&amp;#39;)
            return false;
    }

    if($this-&amp;gt;hasHostInfo)
        $pathInfo=strtolower($request-&amp;gt;getHostInfo()).rtrim(&amp;#39;/&amp;#39;.$pathInfo,&amp;#39;/&amp;#39;);

    $pathInfo.=&amp;#39;/&amp;#39;;

    // 正则匹配：用pattern来匹配路径
    if(preg_match($this-&amp;gt;pattern.$case,$pathInfo,$matches))
    {
        // 可以配置defaultParams数组来为请求未提供的必要参数指定默认值
        foreach($this-&amp;gt;defaultParams as $name=&amp;gt;$value)
        {
            if(!isset($_GET[$name]))
                $_REQUEST[$name]=$_GET[$name]=$value;
        }
        $tr=array();
        foreach($matches as $key=&amp;gt;$value)
        {
            if(isset($this-&amp;gt;references[$key]))
                $tr[$this-&amp;gt;references[$key]]=$value;
            elseif(isset($this-&amp;gt;params[$key]))
                $_REQUEST[$key]=$_GET[$key]=$value;
        }
        if($pathInfo!==$matches[0]) // there&amp;#39;re additional GET params
            $manager-&amp;gt;parsePathInfo(ltrim(substr($pathInfo,strlen($matches[0])),&amp;#39;/&amp;#39;));
        if($this-&amp;gt;routePattern!==null)
            return strtr($this-&amp;gt;route,$tr);
        else
            return $this-&amp;gt;route;
    }
    else
        return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上述代码可以看出，路由解析关键是根据$pattern匹配请求URL，并&lt;strong&gt;从URL取出需要的东西作为请求参数&lt;/strong&gt;，一旦匹配，就以$route作为该次请求的目标路由。&lt;/p&gt;
&lt;p&gt;获得目标路由后，就可以根据目标路由查找调用对应的controller和action了。&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>读文笔记：An Introduction to APIs</title><link href="http://youngsterxyf.github.io/2014/11/09/an-introduction-to-apis/" rel="alternate"></link><published>2014-11-09T00:00:00+08:00</published><updated>2014-11-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-09:/2014/11/09/an-introduction-to-apis/</id><content type="html">&lt;p&gt;原文：&lt;a href="https://zapier.com/learn/apis/"&gt;An Introduction to APIs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：该文是入门级别的文章&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mind-mapping" src="/assets/uploads/pics/An-Introduction-to-APIs.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/An-Introduction-to-APIs.png"&gt;高清无码大图&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="API"></category><category term="REST"></category></entry><entry><title>Yii源码阅读笔记 - 请求处理基本流程</title><link href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/" rel="alternate"></link><published>2014-11-04T00:00:00+08:00</published><updated>2014-11-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-04:/2014/11/04/read-yii-code-1/</id><summary type="html">&lt;p&gt;对于Web框架，我认为其主要有三点作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供多人协作的基本规范&lt;/li&gt;
&lt;li&gt;避免重复造轮子&lt;/li&gt;
&lt;li&gt;开发者只需关注业务逻辑，脏活（如：基本的安 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;对于Web框架，我认为其主要有三点作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供多人协作的基本规范&lt;/li&gt;
&lt;li&gt;避免重复造轮子&lt;/li&gt;
&lt;li&gt;开发者只需关注业务逻辑，脏活（如：基本的安全防范、兼容问题）Web框架都已完成并提供设计良好的API&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但代价是学习成本 - 为了尽可能发挥Web框架的优势，需要花一些阅读文档，甚至是框架源码（特别是文档缺乏或者文档写得垃圾的），然后经过几次项目实践，一切才能了然于胸。&lt;/p&gt;
&lt;p&gt;喏，为了在工作中更好地使用、避免误用Yii框架，大致阅读了Yii框架的部分代码，然后有了这个系列的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;深入学习一个Web框架，首先要理解的是请求处理流程。对于PHP而言，处理流程也即包含了应用的初始化过程，如加载配置、初始化组件等。请求处理流程中最核心的应该是路由解析和分发，此外可能还有过滤器处理、事件处理等，直到请求处理进入具体的Controller和Action。响应生成、过滤等也可以关注。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;基于Yii框架的工程目录结构大致如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Yii-Project-Structure" src="/assets/uploads/pics/yii-project-structure.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;index.php是应用的入口&lt;/li&gt;
&lt;li&gt;protected目录是存放动态脚本的地方&lt;ul&gt;
&lt;li&gt;components子目录存放各种组件类&lt;/li&gt;
&lt;li&gt;configs存放应用的配置文件&lt;/li&gt;
&lt;li&gt;controllers存放Controller类文件&lt;/li&gt;
&lt;li&gt;models存放Model类文件&lt;/li&gt;
&lt;li&gt;runtime存放一些应用生成的临时文件或者缓存文件，如Smarty编译好的模板、日志文件&lt;/li&gt;
&lt;li&gt;views存放View模板文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;static目录存放静态文件，如CSS、JS、图片等&lt;/li&gt;
&lt;li&gt;yii目录则存放Yii框架的源码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;index.php&lt;/code&gt;文件的内容大致如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
defined(&lt;span style="color: #a31515"&gt;&amp;#39;APP_ENV&amp;#39;&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; define(&lt;span style="color: #a31515"&gt;&amp;#39;APP_ENV&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;development&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (APP_ENV == &lt;span style="color: #a31515"&gt;&amp;#39;production&amp;#39;&lt;/span&gt;) {
    ini_set(&lt;span style="color: #a31515"&gt;&amp;#39;display_errors&amp;#39;&lt;/span&gt;, 0);
    error_reporting(&lt;span style="color: #0000ff"&gt;E_ALL&lt;/span&gt;);
    define(&lt;span style="color: #a31515"&gt;&amp;#39;YII_ENABLE_ERROR_HANDLER&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);
    $yii = dirname(__FILE__) . &lt;span style="color: #a31515"&gt;&amp;#39;/yii/framework/yiilite.php&amp;#39;&lt;/span&gt;;
    defined(&lt;span style="color: #a31515"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; define(&lt;span style="color: #a31515"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;, 1);
} &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; {
    error_reporting(&lt;span style="color: #0000ff"&gt;E_ALL&lt;/span&gt;);
    $yii = dirname(__FILE__) . &lt;span style="color: #a31515"&gt;&amp;#39;/yii/framework/yii.php&amp;#39;&lt;/span&gt;;
    defined(&lt;span style="color: #a31515"&gt;&amp;#39;YII_DEBUG&amp;#39;&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; define(&lt;span style="color: #a31515"&gt;&amp;#39;YII_DEBUG&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);
    defined(&lt;span style="color: #a31515"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; define(&lt;span style="color: #a31515"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;, 3);
}
$config = dirname(__FILE__) . &lt;span style="color: #a31515"&gt;&amp;#39;/protected/configs/&amp;#39;&lt;/span&gt; . APP_ENV . &lt;span style="color: #a31515"&gt;&amp;#39;.php&amp;#39;&lt;/span&gt;;

&lt;span style="color: #0000ff"&gt;require_once&lt;/span&gt;($yii);
$YiiApp = Yii::createWebApplication($config);
$YiiApp-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据应用所处的环境（开发环境或生产环境）配置不同的环境变量，加载不同的配置文件，然后根据配置信息创建一个Web应用对象（这个对象类似一个容器），并处理请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Yii::createWebApplication($config)&lt;/code&gt;中类Yii直接继承自类YiiBase，并且没有自定义属性和方法，即调用的静态方法createWebApplication来自类YiiBase，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public static function createWebApplication($config=null)
{
    return self::createApplication(&amp;#39;CWebApplication&amp;#39;, $config);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之所以这么实现，是因为Yii还支持控制台/命令行类型的应用实现，比如cron脚本。&lt;/p&gt;
&lt;p&gt;静态方法createApplication实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public static function createApplication($class, $config=null)
{
    return new $class($config);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;真正实例化的类CWebApplication见文件&lt;code&gt;yii/framework/web/CWebApplication.php&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类CWebApplication自己也没有实现构造方法，直接继承自抽象类CApplication（见文件&lt;code&gt;yii/framework/base/CApplication.php&lt;/code&gt;），其构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __construct($config=null)
{
    Yii::setApplication($this);

    // set basePath at early as possible to avoid trouble
    if(is_string($config))
        $config=require($config);
    if(isset($config[&amp;#39;basePath&amp;#39;]))
    {
        $this-&amp;gt;setBasePath($config[&amp;#39;basePath&amp;#39;]);
        unset($config[&amp;#39;basePath&amp;#39;]);
    }
    else
        $this-&amp;gt;setBasePath(&amp;#39;protected&amp;#39;);
    Yii::setPathOfAlias(&amp;#39;application&amp;#39;,$this-&amp;gt;getBasePath());
    Yii::setPathOfAlias(&amp;#39;webroot&amp;#39;,dirname($_SERVER[&amp;#39;SCRIPT_FILENAME&amp;#39;]));
    if(isset($config[&amp;#39;extensionPath&amp;#39;]))
    {
        $this-&amp;gt;setExtensionPath($config[&amp;#39;extensionPath&amp;#39;]);
        unset($config[&amp;#39;extensionPath&amp;#39;]);
    }
    else
        Yii::setPathOfAlias(&amp;#39;ext&amp;#39;,$this-&amp;gt;getBasePath().DIRECTORY_SEPARATOR.&amp;#39;extensions&amp;#39;);
    if(isset($config[&amp;#39;aliases&amp;#39;]))
    {
        $this-&amp;gt;setAliases($config[&amp;#39;aliases&amp;#39;]);
        unset($config[&amp;#39;aliases&amp;#39;]);
    }

    $this-&amp;gt;preinit();

    $this-&amp;gt;initSystemHandlers();
    $this-&amp;gt;registerCoreComponents();

    $this-&amp;gt;configure($config);
    $this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors);
    $this-&amp;gt;preloadComponents();

    $this-&amp;gt;init();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Yii::setApplication($this)&lt;/code&gt;将当前类CWebApplication的实例化对象赋值给类YiiBase的私有属性&lt;code&gt;$_app&lt;/code&gt;，之后通过&lt;code&gt;Yii::app()&lt;/code&gt;就能取到这个对象（app方法其实是类YiiBase中定义的）。&lt;/p&gt;
&lt;p&gt;构造方法根据配置信息初始化一些路径和别名相关的属性。以路径别名&lt;code&gt;application&lt;/code&gt;为例，如果想将日志目录配置为&lt;code&gt;protected/runtime&lt;/code&gt;，则可以指定路径为&lt;code&gt;application.runtime&lt;/code&gt;，这样的好处是你可以配置&lt;code&gt;basePath&lt;/code&gt;来指定动态脚本所在的目录，不一定必须是&lt;code&gt;protected&lt;/code&gt;，即使你的修改了basePath，其余相对basePath的路径配置都不需要变动。&lt;/p&gt;
&lt;p&gt;类CApplication又直接继承自类CModule（见文件&lt;code&gt;yii/framework/base/CModule.php&lt;/code&gt;），上述构造方法中调用的方法&lt;code&gt;preinit&lt;/code&gt;、&lt;code&gt;configure&lt;/code&gt;、&lt;code&gt;preloadComponents&lt;/code&gt;定义在类CModule中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;preinit&lt;/code&gt;的方法体为空。这个方法调用之后主要是加载核心组件、及将配置信息存到&lt;code&gt;Yii::app()&lt;/code&gt;这个容器对象中。如果需要在这些操作之前做一些初始化准备工作，则可以自定义一个类继承自类&lt;code&gt;CWebApplication&lt;/code&gt;，然后实现&lt;code&gt;preinit&lt;/code&gt;方法。但这样的话，index.php中创建web应用对象的方式就有所不同的了，假设自定义的类为&lt;code&gt;MyWebApplication&lt;/code&gt;，index.php中在引入该类文件后：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$yiiApp = Yii::createApplication(&amp;#39;MyWebApplication&amp;#39;, $config);
$yiiApp-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法&lt;code&gt;initSystemHandler&lt;/code&gt;则是根据条件设置框架的异常和错误处理方法。&lt;/p&gt;
&lt;p&gt;方法&lt;code&gt;registerCoreComponents&lt;/code&gt;则是加载框架的核心组件，当然如果有需要可以配置同名（同名指的是key相同，Yii中每个组件都是通过一个key或者说别名来注册和引用）的自定义组件来覆盖默认的核心组件，如db、urlManager。&lt;/p&gt;
&lt;p&gt;组件的注册加载细节我们会另外写一篇文章来介绍。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;方法&lt;code&gt;configure&lt;/code&gt;定义在类&lt;code&gt;CModule&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function configure($config)
{
    if(is_array($config))
    {
        foreach($config as $key=&amp;gt;$value)
            $this-&amp;gt;$key=$value;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看起来是不是很简单？但其实没你想的那么简单呢... 思考一下如果代码中当前对象&lt;code&gt;$this&lt;/code&gt;不存在属性&lt;code&gt;$key&lt;/code&gt;或者名为&lt;code&gt;$key&lt;/code&gt;的属性是私有的会发生什么事情？这时PHP的魔术方法&lt;code&gt;__set&lt;/code&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;类&lt;code&gt;CModule&lt;/code&gt;直接继承自类&lt;code&gt;CComponent&lt;/code&gt;。在类CComponent中定义了方法&lt;code&gt;__set&lt;/code&gt;，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function __set($name,$value)
{
    $setter=&amp;#39;set&amp;#39;.$name;
    if(method_exists($this,$setter))
        return $this-&amp;gt;$setter($value);
    elseif(strncasecmp($name,&amp;#39;on&amp;#39;,2)===0 &amp;amp;&amp;amp; method_exists($this,$name))
    {
        // duplicating getEventHandlers() here for performance
        $name=strtolower($name);
        if(!isset($this-&amp;gt;_e[$name]))
            $this-&amp;gt;_e[$name]=new CList;
        return $this-&amp;gt;_e[$name]-&amp;gt;add($value);
    }
    elseif(is_array($this-&amp;gt;_m))
    {
        foreach($this-&amp;gt;_m as $object)
        {
            if($object-&amp;gt;getEnabled() &amp;amp;&amp;amp; (property_exists($object,$name) || $object-&amp;gt;canSetProperty($name)))
                return $object-&amp;gt;$name=$value;
        }
    }
    if(method_exists($this,&amp;#39;get&amp;#39;.$name))
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is read only.&amp;#39;,
            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));
    else
        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is not defined.&amp;#39;,
            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;PHP中对一个对象的属性进行赋值的规则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果该对象有public的该属性，则直接赋值&lt;/li&gt;
&lt;li&gt;否则看该对象所在继承树上是否有定义魔术方法&lt;code&gt;__set&lt;/code&gt;，如果有则调用&lt;code&gt;__set&lt;/code&gt;来处理赋值过程&lt;/li&gt;
&lt;li&gt;如果连&lt;code&gt;__set&lt;/code&gt;也没有，则为该对象生成一个public的属性，然后赋值给它&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类CComponent中定义的魔术方法&lt;code&gt;__set&lt;/code&gt;其逻辑是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看当前对象是否有名为&lt;code&gt;'set'.$key&lt;/code&gt;的方法，如果有，则以该方法来处理赋值过程&lt;/li&gt;
&lt;li&gt;否则，检查$key是否以字符串&lt;code&gt;on&lt;/code&gt;开头，如果是且当前对象具有名为$key的方法，则认为这是一个事件的赋值过程，将赋值到事件列表中&lt;/li&gt;
&lt;li&gt;否则，则认为这是一个行为(behavior)赋值，尝试为属性&lt;code&gt;_m&lt;/code&gt;对象列表中对象的属性赋值。（貌似是这样，我也还懂&lt;code&gt;_m&lt;/code&gt;的作用）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上述规则逻辑，所以类CModule中定义了很多方法名以字符串&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;get&lt;/code&gt;开头的方法，如setComponents、getComponents、setParams、getParams等。说到这里，你是不是领会到什么了？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;$this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors)&lt;/code&gt;一句中当前对象的属性behaviors的访问权限为public，默认值为空数组，可以在配置文件中配置如下一项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;behaviors&amp;#39; =&amp;gt; array(
    &amp;#39;behaviorName&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;path.to.BehaviorClass&amp;#39;,
        &amp;#39;property1&amp;#39;=&amp;gt;&amp;#39;value1&amp;#39;,
        &amp;#39;property2&amp;#39;=&amp;gt;&amp;#39;value2&amp;#39;,
    )
),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照上述对象属性的赋值规则，该配置项会赋值给属性behaviors。&lt;/p&gt;
&lt;p&gt;方法attachBehaviors对这些配置项逐个初始化然后存入属性&lt;code&gt;_m&lt;/code&gt;中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;方法&lt;code&gt;preloadComponents&lt;/code&gt;定义在类CModule中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Loads static application components.
 */
protected function preloadComponents()
{
    foreach($this-&amp;gt;preload as $id)
        $this-&amp;gt;getComponent($id);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中属性preload访问权限为public，默认也是空数组，可以在其中配置需要预加载的组件的ID。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;$this-&amp;gt;init()&lt;/code&gt;一行中方法&lt;code&gt;init&lt;/code&gt;定义在类CWebApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;protected function init()
{
    parent::init();
    // preload &amp;#39;request&amp;#39; so that it has chance to respond to onBeginRequest event.
    $this-&amp;gt;getRequest();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法&lt;code&gt;getRequest&lt;/code&gt;就是预加载request组件。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;index.php中得到Web应用对象后继而调用其方法run，该run方法定义于类CApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Runs the application.
 * This method loads static application components. Derived classes usually overrides this
 * method to do more application-specific tasks.
 * Remember to call the parent implementation so that static application components are loaded.
 */
public function run()
{
    if($this-&amp;gt;hasEventHandler(&amp;#39;onBeginRequest&amp;#39;))
        $this-&amp;gt;onBeginRequest(new CEvent($this));
    // 这里为了处理程序主动调用exit()或者抛出异常时的情况
    register_shutdown_function(array($this,&amp;#39;end&amp;#39;),0,false);
    // 请求处理
    $this-&amp;gt;processRequest();
    if($this-&amp;gt;hasEventHandler(&amp;#39;onEndRequest&amp;#39;))
        $this-&amp;gt;onEndRequest(new CEvent($this));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法processRequest定义于类CWebApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function processRequest()
{
    // 可以在配置文件里配置request组件时，提供catchAllRequest参数
    // catchAllRequest是一个数组，第一个元素指定一个controller及一个action，其余元素是这个action的参数
    // 如果配置了catchAllRequest，就可以用这个controller/action来处理所有的请求，当网站进入维护状态时，有其用处。
    if(is_array($this-&amp;gt;catchAllRequest) &amp;amp;&amp;amp; isset($this-&amp;gt;catchAllRequest[0]))
    {
        $route=$this-&amp;gt;catchAllRequest[0];
        foreach(array_splice($this-&amp;gt;catchAllRequest,1) as $name=&amp;gt;$value)
            $_GET[$name]=$value;
    }
    else
        // 正常的路由解析
        // 组件urlManager -&amp;gt;parseUrl 组件request
        $route=$this-&amp;gt;getUrlManager()-&amp;gt;parseUrl($this-&amp;gt;getRequest());
    // 根据路由执行控制器处理函数
    $this-&amp;gt;runController($route);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中路由解析的过程我们也会以单独的一篇文章来分析，暂不细说。&lt;/p&gt;
&lt;p&gt;方法runController的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/**
 * Creates the controller and performs the specified action.
 * @param string $route the route of the current request. See {@link createController} for more details.
 * @throws CHttpException if the controller could not be created.
 */
public function runController($route)
{
    if(($ca=$this-&amp;gt;createController($route))!==null)
    {
        list($controller,$actionID)=$ca;
        $oldController=$this-&amp;gt;_controller;
        $this-&amp;gt;_controller=$controller;
        $controller-&amp;gt;init();
        $controller-&amp;gt;run($actionID);
        $this-&amp;gt;_controller=$oldController;
    }
    else
        throw new CHttpException(404,Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Unable to resolve the request &amp;quot;{route}&amp;quot;.&amp;#39;,
            array(&amp;#39;{route}&amp;#39;=&amp;gt;$route===&amp;#39;&amp;#39;?$this-&amp;gt;defaultController:$route)));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中方法createController根据$route按照一定的规则找到对应的controller类，之后调用controller的init方法和run方法。但这个调用之前和之后还恢复老的controller，这应该是因为在一个controller中可以forward到另一个controller中去，也即controller可以递归执行，所以需要保存和恢复上下文。&lt;/p&gt;
&lt;p&gt;Yii中所有Controller类都必须直接或间接继承自类CController，该类的init方法实现为空，如有需要可以在子类中重写。而其run方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function run($actionID)
{
    if(($action=$this-&amp;gt;createAction($actionID))!==null)
    {
        if(($parent=$this-&amp;gt;getModule())===null)
            $parent=Yii::app();
        if($parent-&amp;gt;beforeControllerAction($this,$action))
        {
            $this-&amp;gt;runActionWithFilters($action,$this-&amp;gt;filters());
            $parent-&amp;gt;afterControllerAction($this,$action);
        }
    }
    else
        $this-&amp;gt;missingAction($actionID);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;$this-&amp;gt;runActionWithFilters($action,$this-&amp;gt;filters())&lt;/code&gt;一行中，方法filters的实现仅是返回一个空数组，如果想要使用过滤器就需要在自定义的Controller类中重写该方法，过滤器的配置方法见源码中注释：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;* For a method-based filter (called inline filter), it is specified as &amp;#39;FilterName[ +|- Action1, Action2, ...]&amp;#39;,
 * where the &amp;#39;+&amp;#39; (&amp;#39;-&amp;#39;) operators describe which actions should be (should not be) applied with the filter.
 *
 * For a class-based filter, it is specified as an array like the following:
 * &amp;lt;pre&amp;gt;
 * array(
 *     &amp;#39;FilterClass[ +|- Action1, Action2, ...]&amp;#39;,
 *     &amp;#39;name1&amp;#39;=&amp;gt;&amp;#39;value1&amp;#39;,
 *     &amp;#39;name2&amp;#39;=&amp;gt;&amp;#39;value2&amp;#39;,
 *     ...
 * )
 * &amp;lt;/pre&amp;gt;
 * where the name-value pairs will be used to initialize the properties of the filter.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法runActionWithFilters实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function runActionWithFilters($action,$filters)
{
    if(empty($filters))
        $this-&amp;gt;runAction($action);
    else
    {
        $priorAction=$this-&amp;gt;_action;
        $this-&amp;gt;_action=$action;
        CFilterChain::create($this,$action,$filters)-&amp;gt;run();
        $this-&amp;gt;_action=$priorAction;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果没有设置过滤器，则直接执行目标action，方法runAction的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function runAction($action)
{
    $priorAction=$this-&amp;gt;_action;
    $this-&amp;gt;_action=$action;
    if($this-&amp;gt;beforeAction($action))
    {
        if($action-&amp;gt;runWithParams($this-&amp;gt;getActionParams())===false)
            $this-&amp;gt;invalidActionParams($action);
        else
            $this-&amp;gt;afterAction($action);
    }
    $this-&amp;gt;_action=$priorAction;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;类CController中定义的beforeAction直接返回true，如果需要在目标action执行之前做一些检查过滤操作则需要在自定义的Controller类中重写beforeAction方法，该方法最后必须返回true或false。beforeAction的作用类似于简化版的过滤器。&lt;/p&gt;
&lt;p&gt;beforeAction通过后，则执行目标action。由于路由配置是类正则的，URL解析出来的一些片段值（算是放在url中的请求参数）应该传入目标action，方法getActionParams即是取到这些参数值。Yii在路由解析时将这些参数值也存放到全局变量&lt;code&gt;$_GET&lt;/code&gt;中，所以getActionParams直接返回了&lt;code&gt;$_GET&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果设置了过滤器，则需要根据controller、action、filters创建一个CFilterChain对象（过程中当然会对过滤器配置进行解析），类CFilterChain的run方法实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function run()
{
    if($this-&amp;gt;offsetExists($this-&amp;gt;filterIndex))
    {
        $filter=$this-&amp;gt;itemAt($this-&amp;gt;filterIndex++);
        Yii::trace(&amp;#39;Running filter &amp;#39;.($filter instanceof CInlineFilter ? get_class($this-&amp;gt;controller).&amp;#39;.filter&amp;#39;.$filter-&amp;gt;name.&amp;#39;()&amp;#39;:get_class($filter).&amp;#39;.filter()&amp;#39;),&amp;#39;system.web.filters.CFilterChain&amp;#39;);
        $filter-&amp;gt;filter($this);
    }
    else
        $this-&amp;gt;controller-&amp;gt;runAction($this-&amp;gt;action);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code&gt;$this-&amp;gt;filterIndex&lt;/code&gt;的初始值为0，方法offsetExits定义于类CList中，逻辑就是检测是否遍历执行完所有的过滤器，如果还有，则取出一个过滤器对象，执行其filter方法，该方法的实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public function filter($filterChain)
{
    $method=&amp;#39;filter&amp;#39;.$this-&amp;gt;name;
    $filterChain-&amp;gt;controller-&amp;gt;$method($filterChain);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时候你应该感到疑惑 - 既然是一个过滤器链，那么循环在哪？事实上，Yii的这个地方并没有提供循环来让过滤器逐个执行，这就意味着在自定义的过滤器中，如果过滤条件通过，则需要尾递归地显式调用过滤器链的run方法，这样直到所有的过滤器都通过，才执行目标action&lt;code&gt;$this-&amp;gt;controller-&amp;gt;runAction($this-&amp;gt;action)&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;2014-12-18 补充：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类YiiBase的方法createApplication：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;public static function createApplication($class, $config=null)
{
    return new $class($config);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;是如何找到&lt;code&gt;$class&lt;/code&gt;代表的类（CWebApplication或CConsoleApplication类）的呢？类文件&lt;code&gt;yii/framework/YiiBase.php&lt;/code&gt;的倒数第二行代码为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spl_autoload_register(array('YiiBase','autoload'));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当类文件&lt;code&gt;yii/framework/yii.php&lt;/code&gt;中 &lt;strong&gt;require&lt;/strong&gt; YiiBase类文件时就执行了这句代码。&lt;/p&gt;</content><category term="其他"></category><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>QCon上海2014大会见闻录</title><link href="http://youngsterxyf.github.io/2014/10/21/qcon-sh-2014-seen-heard/" rel="alternate"></link><published>2014-10-21T00:00:00+08:00</published><updated>2014-10-21T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-10-21:/2014/10/21/qcon-sh-2014-seen-heard/</id><summary type="html">&lt;h2&gt;技术&lt;/h2&gt;
&lt;h4&gt;主题演讲&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;软件项目变更的管理和生存之道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人对这个演讲的印象比较深。演讲者即是最近比较火的《Java程序员修炼之道》一书的作者 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;技术&lt;/h2&gt;
&lt;h4&gt;主题演讲&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;软件项目变更的管理和生存之道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人对这个演讲的印象比较深。演讲者即是最近比较火的《Java程序员修炼之道》一书的作者。&lt;/p&gt;
&lt;p&gt;演讲大致以“提出问题 -&amp;gt; 分析问题 -&amp;gt; 解决问题”的思路陈述。&lt;/p&gt;
&lt;p&gt;问题是：在软件演化的整个过程中，变化是始终存在的。如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础架构层面的变化：迁移到新的服务提供商、系统升级&lt;/li&gt;
&lt;li&gt;用户数的变化：突然的增长、持续稳定地增长&lt;/li&gt;
&lt;li&gt;代码的变更：发布新版本、依赖库升级、新的子系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些变化可能会导致两个问题的发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务中断：完全无法为用户提供服务，特别是生产环境变更导致的，发布后的服务中断&lt;/li&gt;
&lt;li&gt;性能问题：性能退化/降级，但可能也不是完全不可用，在预览版(pre-release)和正式发布后(post-release)都可能发生，经常是因为不完全的性能测试造成的。(性能测试是指&lt;strong&gt;基于测量的方法&lt;/strong&gt;来理解一定负载下应用的行为)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“变化”导致的问题，说到底是人为造成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No matter what they tell you, it's always a people problem.    --- Gerald Weinberg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应对“变化”所带来的问题，需要实现以下几个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低变化的风险&lt;/li&gt;
&lt;li&gt;提升可靠性：减小服务中断的损失&lt;/li&gt;
&lt;li&gt;提高可维护性：减小整个平台的耗费&lt;/li&gt;
&lt;li&gt;可量化的影响：最好可以以节省了多少钱来衡量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“服务中断”、“性能问题”发生的原因通常有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;误解了生产环境&lt;ul&gt;
&lt;li&gt;UAT is My Desktop：“User Acceptance Test”的简写，也就是用户验收测试&lt;/li&gt;
&lt;li&gt;PROD-like Data is Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置问题&lt;/li&gt;
&lt;li&gt;不恰当的焦点&lt;ul&gt;
&lt;li&gt;Blame Donkey (all the blame and problems of a situation are being placed upon a single person)&lt;/li&gt;
&lt;li&gt;微观分析 (Micro-analysis)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;孤岛思维 (Silo Mentality)：即团队成员通常仅仅关注各自的职能部门或业务单元。如此有限的关注，阻碍了组织的个别部门对整体运营卓越性的促进作用。&lt;ul&gt;
&lt;li&gt;Throw It Over The Wall&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对“不恰当的焦点”，需理解，性能调优不是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小提示和技巧的集合&lt;/li&gt;
&lt;li&gt;秘密武器&lt;/li&gt;
&lt;li&gt;在项目的末期你洒下的魔法粉尘&lt;/li&gt;
&lt;li&gt;“英雄豪杰”才能干的事情&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要把问题的原因始终归于某些组件。如果轻易就Blame Donkey只能说明对问题的分析不够充分。&lt;strong&gt;应顶住压力不忙于下结论，分析分析再分析，并与相关人沟通分析的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要把精力聚焦在系统非常低的层面(very low-level aspects)上，微观变化(micro-changes)的整体影响是不可知的，实际上可能还会降低系统的性能。
不要做微观分析，除非你的项目是一个已知对此微观分析有效的案例(a known use case for it)，如构建一个通用的库或框架，理解其中的权衡；使用已有的工具来做分析，不要构建你自己的分析工具，使用广泛地与他人讨论你的分析结果。&lt;/p&gt;
&lt;p&gt;总而言之，就是测量啊测量，profiling啊profiling。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The first principle is that you must not fool yourself, and you are the easiest person to fool. -- Richard Feynman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧，上边这些只是在解释问题是什么，然后分析了一下问题，那么如何有效地解决问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解架构！！！&lt;ul&gt;
&lt;li&gt;能凭记忆画出整个应用的架构吗？ 组件关系图、时序图、数据流图 ...&lt;/li&gt;
&lt;li&gt;部署：知道应用是如何跨机器/虚拟机分布的吗？&lt;/li&gt;
&lt;li&gt;如果架构都没理解，服务中断了还搞个屁啊&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以数据说话&lt;ul&gt;
&lt;li&gt;收集监控数据：应该作为一个正式的流程存在，而不是得到出问题才去临时收集。监控数据也应该集中化收集保存&lt;/li&gt;
&lt;li&gt;分析数据：这一环节经常缺失；数据分析解释的技能非常罕见；如果可能就用工具来自动生成报表&lt;/li&gt;
&lt;li&gt;确保所有团队都能看到分析报表：团队之间的沟通是必不可少的&lt;/li&gt;
&lt;li&gt;理解正常的系统功能是啥样的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测量与分析&lt;ul&gt;
&lt;li&gt;对抗认知偏见最好的工具就是数据&lt;/li&gt;
&lt;li&gt;打日志、以及监控：但更需要分析，数据量可能非常大，问题的模式并非总能肉眼就能识别&lt;/li&gt;
&lt;li&gt;常规的/适当的收集过程是必要的，临时抱佛脚肯定不行&lt;/li&gt;
&lt;li&gt;确保日志充分：啥叫充分？能够追溯导致服务中断的所有步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于性能，还想说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有完美的性能，只有可接受的性能（尼玛就不要没完没了地优化了）&lt;/li&gt;
&lt;li&gt;是最终用户决定性能需求&lt;/li&gt;
&lt;li&gt;性能不是功能性的需求：但必须有可观测的量化目标，也需要和系统相关人共同来设定&lt;/li&gt;
&lt;li&gt;性能测试一个迭代的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，实际操作的过程也得讲究科学的方法啊...&lt;/p&gt;
&lt;p&gt;演讲的PPT：&lt;a href="/assets/uploads/files/Managing-and-Surviving-Change.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Building a strong engineering culture&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：Kevin Goldsmith，Spotify公司的技术主管(Director of Engineering)&lt;/p&gt;
&lt;p&gt;1 . 什么是文化？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A pattern of &lt;strong&gt;shared basic assumptions&lt;/strong&gt; that a group has learned as it solved its problems of external adaptation and internal integration, that has worked well enough to be considered valid and therefore, to be taught to new members as the correct way to perceive, think, and feel in relation to those problems.   -- Edgar Schein &lt;a href="http://baike.baidu.com/view/1177302.htm"&gt;百度百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;演讲者提出的理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Culture is &lt;strong&gt;the manifestation of the shared values&lt;/strong&gt; of the organization as &lt;strong&gt;represented by the actions&lt;/strong&gt; of its members.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Values -&amp;gt; Culture -&amp;gt; Processes(流程) + Artifacts(人工制品，如Logo、T恤等) + Rituals(仪式，礼仪) + Beliefs(信仰、新年)&lt;/p&gt;
&lt;p&gt;Spotify公司的一些价值观(Values)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Learn from failure&lt;/li&gt;
&lt;li&gt;Innovation at every level&lt;/li&gt;
&lt;li&gt;Iterative development&lt;/li&gt;
&lt;li&gt;Agile-ﬁrst&lt;/li&gt;
&lt;li&gt;Data-driven&lt;/li&gt;
&lt;li&gt;Autonomous Teams&lt;/li&gt;
&lt;li&gt;Continuous improvement&lt;/li&gt;
&lt;li&gt;Shared Responsibility&lt;/li&gt;
&lt;li&gt;Transparency&lt;/li&gt;
&lt;li&gt;Trust&lt;/li&gt;
&lt;li&gt;Servant Leadership&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2 . 为什么文化很重要？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Apply the same level of deep thinking about building a culture as you would about building a product. -- Tim O'Reilly, O’Reilly Media&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3 . 优秀工程[师]文化(engineering culture)的构成是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stuﬀ gets done&lt;/li&gt;
&lt;li&gt;It gets done well&lt;/li&gt;
&lt;li&gt;People are happy&lt;/li&gt;
&lt;li&gt;Leaders provide direction and guidance and GET OUT OF THE WAY&lt;/li&gt;
&lt;li&gt;Success is celebrated&lt;/li&gt;
&lt;li&gt;Failure is used as a way to learn&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 . 保护文化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Walk the talk&lt;/li&gt;
&lt;li&gt;Hiring is crucial&lt;/li&gt;
&lt;li&gt;Firing is also crucial&lt;/li&gt;
&lt;li&gt;Communicate your values&lt;/li&gt;
&lt;li&gt;Measure against your values&lt;/li&gt;
&lt;li&gt;Your organization reﬂects your values&lt;/li&gt;
&lt;li&gt;Watch out for warning signs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5 . 修复破败的文化&lt;/p&gt;
&lt;p&gt;如何知道文化在破败？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;People don’t care&lt;/li&gt;
&lt;li&gt;(Good) People are leaving&lt;/li&gt;
&lt;li&gt;You spend time on the wrong things instead of building your product&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何修复？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start with yourself&lt;/li&gt;
&lt;li&gt;Then your team&lt;/li&gt;
&lt;li&gt;Build on successes&lt;/li&gt;
&lt;li&gt;Recruit others&lt;/li&gt;
&lt;li&gt;Grow bottom up&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6 . 总结&lt;/p&gt;
&lt;p&gt;You have a culture, Whether you think you do or not&lt;/p&gt;
&lt;p&gt;Work on your culture, It will determine how things get (or don’t get) done&lt;/p&gt;
&lt;p&gt;If you have a good culture, protect it, Make sure everyone understands what you value as a team. Make sure everyone you hire will be happy in your culture.&lt;/p&gt;
&lt;p&gt;If you have a bad culture, transform it, A long process, start small and grow. Don’t try to rush it.&lt;/p&gt;
&lt;p&gt;You are the culture, The culture is the intersection (average) of the values of the people in it. Want to improve your culture? LIVE THE VALUES&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;还有另外两个主题演讲“The Containerised Cloud”（集装箱式/容器化的云，看题目也能猜出是介绍Docker的）和“SDN控制器集群中的分布式技术实践”貌似也不错，可惜鄙人对于Docker和SDN都没什么实践经验，不甚了解，也就不多写了。&lt;/p&gt;
&lt;h4&gt;移动与Web&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Blend - 完美地融合WebApp与Native app&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人是来自百度的雷志兴(berg)&lt;/p&gt;
&lt;p&gt;对于做Web开发，觉得原生移动App学与做都比较有难度的人来说，这种主题是比较有吸引力的。&lt;/p&gt;
&lt;p&gt;当然，难度不是主要原因，原因在于混合式开发移动应用的优点，同时具备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web的灵活性，如：应用可随时发布更新，无需用户下载更新新版本&lt;/li&gt;
&lt;li&gt;原生移动应用(Native App)良好的体验，包括：交互与性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从而达到Web应用和原生移动应用的优势互补。&lt;/p&gt;
&lt;p&gt;&lt;img alt="native-vs-web" src="/assets/uploads/pics/native-vs-web.png"&gt;&lt;/p&gt;
&lt;p&gt;那么如何完美融合，以Web技术开发类原生移动应用呢？百度的同学提出Blend技术方案。&lt;/p&gt;
&lt;p&gt;Blend是一套灵活、低耦的组件库、API及运行环境。Blend将常用或核心组件Native化， 转场、动画、重点组件由Native完成，Native代码针对关键问题，代码规模小，可控；提出“Every element can be a webview”，单个webview变⼩小，局部性能可控。&lt;/p&gt;
&lt;p&gt;具体技术细节见如下PPT截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blend-technique-overview-1" src="/assets/uploads/pics/blend-technique-overview-1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blend-technique-overview-2" src="/assets/uploads/pics/blend-technique-overview-2.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blend-technique-overview-3" src="/assets/uploads/pics/blend-technique-overview-3.png"&gt;&lt;/p&gt;
&lt;p&gt;进一步的信息可访问Blend官网：&lt;a href="http://clouda.com/"&gt;Clouda.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好吧，其实我没有移动开发的经验，所以对这一块的技术也不太懂，待学习。&lt;/p&gt;
&lt;p&gt;演讲的PPT：&lt;a href="/assets/uploads/files/Blend-hybrid-app.pdf"&gt;见这里&lt;/a&gt; （嗯，PPT很漂亮！）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;手机 QQ Hybrid App 优化新思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人是来自腾讯 AlloyTeam 的陈桂鸿&lt;/p&gt;
&lt;p&gt;这个演讲的内容和上面百度同学的类似，同一个技术方向。&lt;/p&gt;
&lt;p&gt;AK (AlloyKit) - 高性能 Hybrid Web 开发框架&lt;/p&gt;
&lt;p&gt;AK 架构体系&lt;/p&gt;
&lt;p&gt;&lt;img alt="ak-arch" src="/assets/uploads/pics/ak-arch.png"&gt;&lt;/p&gt;
&lt;p&gt;演讲的PPT：&lt;a href="/assets/uploads/files/AK-hybrid-app.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;貌似AK还没开源？&lt;/p&gt;
&lt;p&gt;AlloyTeam博客：&lt;a href="http://www.alloyteam.com/"&gt;见这里&lt;/a&gt;，Github：&lt;a href="https://github.com/AlloyTeam"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;前后端分离实践&lt;/strong&gt; 与 &lt;strong&gt;另一个角度看前后端分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这两个演讲的内容基本一致，题目更具体点就是“基于Node.js的前后端分离”。演讲人都来自阿里，一个淘宝，一个天猫。&lt;/p&gt;
&lt;p&gt;涉及的技术问题用一张图大致就能说明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nodejs-split-frontend-backend" src="/assets/uploads/pics/split-frontend-backend.png"&gt;&lt;/p&gt;
&lt;p&gt;这种分离方案所要解决的问题是什么呢？&lt;/p&gt;
&lt;p&gt;我们通常将“编写运行在浏览器中的代码”的工程师称为Web前端工程师，“编写运行在服务器上的代码”的工程师称为Web后端工程师，这是一种“物理的”区分方法。&lt;/p&gt;
&lt;p&gt;在这种区分方法下，目前的Web后端开发基本都是采用MVC框架，那么前后端工程师的工作在View层就有耦合 - 前端工程师编写HTML页面模板，后端工程师负责往模板中注入数据进行渲染展示。这种耦合一方面导致需要更多的时间用于协调沟通，另一方面前端也无法尽可能灵活地优化。&lt;/p&gt;
&lt;p&gt;这种耦合在前端也引入MVC框架（如AngularJS、Backbone、EmberJS）后得到解决，但也引入了新的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;SEO问题&lt;/li&gt;
&lt;li&gt;代码重用问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后就有了上图的方案。前端工程师们振臂呐喊 - 我们不要局限于浏览器！后端工程师们，后端MVC的View、Controller、以及部分Model层的开发都由前端工程师来完成吧，你们就负责部分Model层、负责提供数据就行啦！我们有NodeJS神器！我们不再是前端工程师，我们是全栈工程师！&lt;/p&gt;
&lt;p&gt;但这种方案就没问题了么？个人认为至少存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种工程方案的推广的难度有多大？有多少前端工程师熟悉后端开发中的问题？后端开发并不是简单地换个地方写JS代码。&lt;/li&gt;
&lt;li&gt;这种工程方案必须依赖于NodeJS。任何技术都不是银弹，也不会恒久长存。个人认为如果一种工程解决方案必须依赖于某种具体的技术、甚至一门语言，那就不值得推广。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合权衡来看，这种工程方案仅在一定的条件（不缺牛逼的全栈工程师、确实需要将前端性能做到极致）下才有采用的必要。&lt;/p&gt;
&lt;p&gt;相比这种前后端分离方案，我更赞同演讲中提出的“基于JSON + HTTP接口的版本化管理”，让接口的一切变更都可追溯，这个想法是值得思考和实践的。&lt;/p&gt;
&lt;p&gt;演讲PPT：&lt;a href="/assets/uploads/files/刘磊-前后端分离实践.pdf"&gt;前后端分离实践&lt;/a&gt;，&lt;a href="/assets/uploads/files/另一个角度看前后端分离.pdf"&gt;另一个角度看前后端分离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/lifesinger/lifesinger.github.com/issues/184"&gt;Web 研发模式演变&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html"&gt;BigPipe学习研究&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;乐逗游戏发行平台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：余中强&lt;/p&gt;
&lt;p&gt;这个演讲的干货很多，值得一看。&lt;/p&gt;
&lt;p&gt;其中提到的“定位问题-建设云监控系统”和“API监控系统”是我在做或想做的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-cloud-monitor" src="/assets/uploads/pics/ledou-cloud-monitor.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-api-monitor" src="/assets/uploads/pics/ledou-api-monitor.png"&gt;&lt;/p&gt;
&lt;p&gt;整个系统的演化经历了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;萌芽期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage1" src="/assets/uploads/pics/ledou-arch-stage1.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发展期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发展期的第1阶段只是添加缓存、负载均衡集群化：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage2" src="/assets/uploads/pics/ledou-arch-stage2.png"&gt;&lt;/p&gt;
&lt;p&gt;发展期的第2阶段则是根据业务垂直化切分系统、水平拆分数据表等：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage2-ext" src="/assets/uploads/pics/ledou-arch-stage2-ext.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;壮大期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage3" src="/assets/uploads/pics/ledou-arch-stage3.png"&gt;&lt;/p&gt;
&lt;p&gt;在系统演化过程中也得到了如下经验：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-optimize-lessons" src="/assets/uploads/pics/ledou-optimize-lessons.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-design-lessons" src="/assets/uploads/pics/ledou-design-lessons.png"&gt;&lt;/p&gt;
&lt;p&gt;演讲PPT：&lt;a href="/assets/uploads/files/余中强-乐逗手游发行技术平台.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;跨平台移动应用的自动化验收测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：平安科技 柴锋、高云&lt;/p&gt;
&lt;p&gt;内容主要是基于Cucumber实现的一个自动化测试工具&lt;/p&gt;
&lt;p&gt;Cucumber官网：&lt;a href="http://cukes.info/"&gt;http://cukes.info&lt;/a&gt;，推广“行为驱动的开发”（behaviour driven development - BDD），貌似挺有意思。&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;大数据&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;eBay用户行为数据流实时处理系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：eBay 汪兴朗&lt;/p&gt;
&lt;p&gt;用户行为数据流是指用户在系统/网站的操作，以及操作之间的前后关系。这些数据经过过滤噪音抽取后可以用于用户行为分析、个性化推荐等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ebay-jetstream-arch" src="/assets/uploads/pics/ebay-jetstream-arch.png"&gt;&lt;/p&gt;
&lt;p&gt;图中Jetstream是eBay自研的一个系统，貌似年内会开源，可以关注一下。&lt;/p&gt;
&lt;p&gt;系统处理好的metrics数据存储在TSDB（OpenTSDB？）中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ebay-jetstream-key-tech" src="/assets/uploads/pics/ebay-jetstream-key-tech.png"&gt;&lt;/p&gt;
&lt;p&gt;演讲PPT：&lt;a href="/assets/uploads/files/汪兴郎-eBay用户行为数据流实时处理系统.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;互联网常用场景下的大数据架构解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：MediaV 聚效CTO 胡宁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一切不以具体应用为前提谈大数据都是耍流氓！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;精准的网络广告和个人化推荐（如网购）的原理是一样的。通过这页PPT看看“精准”“个性化”需要考虑的哪些问题：&lt;/p&gt;
&lt;p&gt;&lt;img alt="for-precise-advertisement" src="/assets/uploads/pics/for-precise-advertisement.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;京东基于大数据技术的个性化电商搜索引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人： 京东 刘尚堃&lt;/p&gt;
&lt;p&gt;1 . 为什么需要个性化搜索&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助用户从海量商品中快速找到商品&lt;/li&gt;
&lt;li&gt;满足不同用户的检索诉求&lt;/li&gt;
&lt;li&gt;提升搜索的惊喜性&lt;/li&gt;
&lt;li&gt;帮助京东提升长尾商品的曝光&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2 . 京东个性化搜索考虑的因素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为&lt;/li&gt;
&lt;li&gt;偏好&lt;ul&gt;
&lt;li&gt;用户画像：兴趣、类目、产品、品牌、修饰（主客观）、购买力、性别、敏感度&lt;/li&gt;
&lt;li&gt;偏好三要素：长期偏好、实时偏好、偏好跨平台能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;地域&lt;ul&gt;
&lt;li&gt;身边的陌生人对什么感兴趣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间&lt;/li&gt;
&lt;li&gt;好友&lt;ul&gt;
&lt;li&gt;身边的熟人对什么感兴趣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4&gt;云计算&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;云服务-精益创业者的工具箱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：英语流利说 胡哲人&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算资源 + 数据的存储：阿里云, AWS中国, 青云, UCloud&lt;/li&gt;
&lt;li&gt;用户行为的分析：Talking Data, 友盟&lt;/li&gt;
&lt;li&gt;多媒体资源的存储和分发：七牛, 又拍云&lt;/li&gt;
&lt;li&gt;消息推送：个推，极光推送&lt;/li&gt;
&lt;li&gt;系统监控：监控宝，OneAPM&lt;/li&gt;
&lt;li&gt;邮件发送：SendCloud&lt;/li&gt;
&lt;li&gt;其他：&lt;ul&gt;
&lt;li&gt;IM服务：环信/LeanCloud&lt;/li&gt;
&lt;li&gt;社交分享：ShareSDK/友盟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精益创业：创业团队专注自己的产品，快速迭代&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;环信支持千万并发即时通讯的技术要点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：环信联合创始人 刘少壮&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-1" src="/assets/uploads/pics/huanxin-1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-2" src="/assets/uploads/pics/huanxin-2.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-3" src="/assets/uploads/pics/huanxin-3.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-4" src="/assets/uploads/pics/huanxin-4.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;自动化运维&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;实时运维数据分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：医树网 曾勇&lt;/p&gt;
&lt;p&gt;基于 ElasticSearch + Logstash + Kibana 实现日志的集中收集分析展示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="yishu-elk-usage" src="/assets/uploads/pics/yishu-elk-usage.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;织云自动化运维技术介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：腾讯 梁定安&lt;/p&gt;
&lt;p&gt;1 . 运营规范&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境标准化&lt;/li&gt;
&lt;li&gt;操作工具化&lt;/li&gt;
&lt;li&gt;对象抽象化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一切均可配置，从而达到低维护成本。&lt;/p&gt;
&lt;p&gt;2 . 资源设计&lt;/p&gt;
&lt;p&gt;&lt;img alt="tencent-resource-design" src="/assets/uploads/pics/tencent-resource-design.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;海量在线交易背后的运维监控体系建设&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ctrip-monitor-set" src="/assets/uploads/pics/ctrip-monitor-set.png"&gt;&lt;/p&gt;
&lt;p&gt;其中 CATS 用于监控告警追踪管理，包含以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理报警统一入口&lt;/li&gt;
&lt;li&gt;报警信息补充&lt;/li&gt;
&lt;li&gt;重复报警去除&lt;/li&gt;
&lt;li&gt;报警优先级区分&lt;/li&gt;
&lt;li&gt;报警抑制&lt;/li&gt;
&lt;li&gt;报警聚合&lt;/li&gt;
&lt;li&gt;与工作流系统联动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ctrip-monitor-future" src="/assets/uploads/pics/ctrip-monitor-future.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ctrip-monitor-future-arch" src="/assets/uploads/pics/ctrip-monitor-future-arch.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;互联网金融&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;火币网比特币交易所构建实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：巨建华&lt;/p&gt;
&lt;p&gt;&lt;img alt="huobi-arch-timeline" src="/assets/uploads/pics/huobi-arch-timeline.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;浅谈互联网金融的资金安全和对账体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：爱投资CTO 谷云&lt;/p&gt;
&lt;p&gt;&lt;img alt="aitouzi-definition" src="/assets/uploads/pics/aitouzi-definition.png"&gt;&lt;/p&gt;
&lt;p&gt;互联网金融的价值之一在于发挥平台的专业性，给用户提供更多的投资产品选择。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;互联网金融浅析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：聚爱财 任衡&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-simple-analysis-1" src="/assets/uploads/pics/juaicai-simple-analysis-1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;金融的本质是实现资产最优配置，要求平等、高效，而这，恰好与互联网的精髓不谋而合&lt;/em&gt;
&lt;em&gt;互联网金融的三大基石：货币、支付交易、信用体系&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-people-credit" src="/assets/uploads/pics/juaicai-people-credit.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-2014-trend" src="/assets/uploads/pics/juaicai-2014-trend.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Lending Club 会对贷款项目进行评级&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-p2b" src="/assets/uploads/pics/juaicai-p2b.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;隐私与安全&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;程序员与黑客&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;架构思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑客思维需要贯穿「...-&amp;gt;架构-&amp;gt;研发-&amp;gt;运维-&amp;gt;...」&lt;/li&gt;
&lt;li&gt;优美的架构一定是健壮的&lt;/li&gt;
&lt;li&gt;优美的架构一定是处处优美的：文档、代码、逻辑、人-&amp;gt;团队&lt;/li&gt;
&lt;li&gt;安全的本质是信任&lt;ul&gt;
&lt;li&gt;「紧内聚、松耦合」设计思想：紧内聚 -&amp;gt; 最小单元 -&amp;gt; 到一段逻辑代码，松耦合 -&amp;gt; 分离 -&amp;gt; 不信任任何输入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;漏洞产生的本质：黑客通过输入提交「特殊数据」，特殊数据在数据流的每个单元里处理，如果某个单元没处理好，在单元输出的时候，就会出现相应单元的安全问题。&lt;/p&gt;
&lt;p&gt;分离的艺术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人员职权分离：人是万恶之源；每个角色应该职权清晰，在保证这个「生态系统」可以稳定运行的基础上，尽可能限制目标角色的职权&lt;/li&gt;
&lt;li&gt;服务器分离：&lt;ul&gt;
&lt;li&gt;研发与线上服务器分离：杜绝在线上调试，杜绝把不成熟的代码发布到线上&lt;/li&gt;
&lt;li&gt;线上服务器各司其职：按业务分离（主站、子站等业务不一样）、按服务器类型分离（Web、数据库、缓存、X、Y、Z、...）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;账号权限分离：账号权限和认证授权模型有关&lt;/li&gt;
&lt;li&gt;文件目录分离：&lt;ul&gt;
&lt;li&gt;文件目录设计的关键：命名风格要优美，目录各司其职 &amp;amp; RWX权限要做好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码分离：&lt;ul&gt;
&lt;li&gt;代码设计的关键：命名风格要优美；代码紧内聚、松耦合（系统、包、文件、类、函数、一段逻辑代码……）；  挫代码 -&amp;gt; 一堆bugs -&amp;gt; 必然包含一堆漏洞&lt;/li&gt;
&lt;li&gt;线上不应该出现SVN/Git权限&lt;/li&gt;
&lt;li&gt;线上如果能提交编译后的文件就编译后的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cookie分离&lt;/li&gt;
&lt;li&gt;子域分离：&lt;ul&gt;
&lt;li&gt;子域设计的关键：不同的业务放到不同的子域下；松耦合的公共模块可以考虑放到其他域名下&lt;/li&gt;
&lt;li&gt;域分离对于XSS攻击来说是一只「拦路虎」&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术选型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何组件都有漏洞：&lt;ul&gt;
&lt;li&gt;一般规律：越流行的开源组件越靠谱；越靠谱的团队打造的组件越靠谱&lt;/li&gt;
&lt;li&gt;时刻做好被黑个透的准备：优美的架构多重要；分离设计能大大提高入侵门槛；快速应急 -&amp;gt; 快速自愈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;千里之堤溃于蚁穴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序员使用不靠谱的组件、工具：&lt;ul&gt;
&lt;li&gt;有些模块/代码直接COPY自不靠谱的地方&lt;/li&gt;
&lt;li&gt;研发、运维工具下载自不靠谱的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;升级中心的相关程序被植入后门&lt;ul&gt;
&lt;li&gt;建议用靠谱的源、官方源&lt;/li&gt;
&lt;li&gt;做正确的MD5校验&lt;/li&gt;
&lt;li&gt;但绝大多数情况下会非常无奈，所以有些高保密机构就不会轻易允许升级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GitHub Hack：&lt;ul&gt;
&lt;li&gt;GitHub的搜索语法：&lt;ul&gt;
&lt;li&gt;smtp @163.com&lt;/li&gt;
&lt;li&gt;insert password extension:sql size:&amp;gt;1000&lt;/li&gt;
&lt;li&gt;svn co username password&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;邮箱Hack&lt;/li&gt;
&lt;li&gt;组件严重漏洞爆发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑客思维需要贯穿「...-&amp;gt;架构-&amp;gt;研发-&amp;gt;运维-&amp;gt;...」&lt;ul&gt;
&lt;li&gt;安全意识优先，安全经验逐渐培养&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一定要有个优美的架构&lt;ul&gt;
&lt;li&gt;更少Bugs意味着更少漏洞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透彻理解：安全的本质是信任&lt;ul&gt;
&lt;li&gt;明白单元与分离的重要性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全策略的部署一定要全面&lt;/li&gt;
&lt;li&gt;定期备份机制一定要有&lt;ul&gt;
&lt;li&gt;出问题能快速diff排查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Code Review值得提倡：&lt;ul&gt;
&lt;li&gt;万一代码被植入了后门，还有机会发现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应急响应要争分夺秒&lt;/li&gt;
&lt;li&gt;可以请专业的安全团队把把脉&lt;ul&gt;
&lt;li&gt;四个维度：培训、防御、审计、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;善用安全辅助工具&lt;ul&gt;
&lt;li&gt;日志分析：splunk, logcheck, logwatch&lt;/li&gt;
&lt;li&gt;入侵检测/防御：snort, iptables, ipfw, fail2ban, portsentry, tripwire, ossec&lt;/li&gt;
&lt;li&gt;后门检测：rkhunter, chkrootkit, lynis&lt;/li&gt;
&lt;li&gt;流量监控：Nagios, Cacti, Zabbix&lt;/li&gt;
&lt;li&gt;环境隔离：chroot&lt;/li&gt;
&lt;li&gt;Web抗D/CC：推荐自家产品 jiasule&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4&gt;扩展性、可用性、高性能&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;基于PXC的MySQL高可用架构探索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：去哪儿网 周彦伟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MMM：http://mysql-mmm.org&lt;/li&gt;
&lt;li&gt;Galera&lt;/li&gt;
&lt;li&gt;Percona Xtradb Cluster（PXC）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;构建高可用和弹性伸缩的KV系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：Ucloud 吴斌炜&lt;/p&gt;
&lt;p&gt;Redis&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用场景：&lt;ul&gt;
&lt;li&gt;取最新N个数据的操作&lt;/li&gt;
&lt;li&gt;排行榜应用，取TOP N操作&lt;/li&gt;
&lt;li&gt;需要精准设定过期时间的应用&lt;/li&gt;
&lt;li&gt;计数器应用&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4&gt;创业&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;我们在豌豆荚如何做产品研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：丁吉昌&lt;/p&gt;
&lt;p&gt;豌豆文化：开放、透明、公平&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;董事会议、报告和文档全员可阅&lt;/li&gt;
&lt;li&gt;你可以问创始人任何问题并得到答复&lt;/li&gt;
&lt;li&gt;个人成就及评级全公司可阅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;研发五步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立项（定方向）&lt;ul&gt;
&lt;li&gt;电梯时间（一句话愿景）&lt;/li&gt;
&lt;li&gt;目标用户的特征和核心需求&lt;/li&gt;
&lt;li&gt;现存的解决方案和各自的优劣势&lt;/li&gt;
&lt;li&gt;依赖、相关技术驱动和限制&lt;/li&gt;
&lt;li&gt;人力需求、发布策略和核心衡量指标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定目标（目标管理）：团队朝一个方向努力&lt;ul&gt;
&lt;li&gt;Objectives &amp;amp; Key Results&lt;ul&gt;
&lt;li&gt;首先是个沟通工具&lt;/li&gt;
&lt;li&gt;努力的方向和目标，非 Roadmap&lt;/li&gt;
&lt;li&gt;必须可量化&lt;/li&gt;
&lt;li&gt;制定和执行者一致，团队和个人目标一致&lt;/li&gt;
&lt;li&gt;和个人绩效考核无关，不是 KPI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;季度 OKR &amp;amp; Review&lt;ul&gt;
&lt;li&gt;最佳实践：目标不变，调整主要成果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;月度会议 Month Review：&lt;ul&gt;
&lt;li&gt;是否需要资源和方向调整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控进度（项目管理）&lt;ul&gt;
&lt;li&gt;状态同步透明&lt;/li&gt;
&lt;li&gt;用最合适的方式多方位沟通&lt;/li&gt;
&lt;li&gt;周会/总结&lt;/li&gt;
&lt;li&gt;数据验证 (MUCE)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;带团队（人员管理）&lt;ul&gt;
&lt;li&gt;找最优秀的人&lt;/li&gt;
&lt;li&gt;Re-Org &amp;amp; 换组：绩效合格，每季度可申请换组/工作内容&lt;/li&gt;
&lt;li&gt;One on One：&lt;ul&gt;
&lt;li&gt;经理还是教练？&lt;/li&gt;
&lt;li&gt;排忧解难助成长&lt;/li&gt;
&lt;li&gt;分享职业规划&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;个人绩效：&lt;ul&gt;
&lt;li&gt;绩效不与 OKR 挂钩&lt;/li&gt;
&lt;li&gt;鼓励挑战难度&lt;/li&gt;
&lt;li&gt;鼓励超越优秀&lt;/li&gt;
&lt;li&gt;低 Level 的事情做不到优秀会惩罚&lt;/li&gt;
&lt;li&gt;做事不及格会惩罚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排干扰（兴趣管理）&lt;ul&gt;
&lt;li&gt;Hack Day 发现好玩意&lt;/li&gt;
&lt;li&gt;Polish Week 查漏补缺&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;创业期技术团队杂谈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：岳旭强&lt;/p&gt;
&lt;p&gt;创业实践&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速试错&lt;/li&gt;
&lt;li&gt;活下去是第一诉求&lt;/li&gt;
&lt;li&gt;极致结果：&lt;ul&gt;
&lt;li&gt;简化沟通：下乡、突击队、扁平化&lt;/li&gt;
&lt;li&gt;兴趣激发：自由选择权、黑暗骑士&lt;ul&gt;
&lt;li&gt;技术工作的三个特性：产品性、工程性、技术(艺术)性。对于这三个特性，工程师有不同的偏向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成就感驱动&lt;ul&gt;
&lt;li&gt;明意义&lt;/li&gt;
&lt;li&gt;重参与&lt;/li&gt;
&lt;li&gt;追结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;极致环境&lt;ul&gt;
&lt;li&gt;氛围：自由、简单、开放&lt;/li&gt;
&lt;li&gt;极致要求：凡事必有解，且必有最优解&lt;/li&gt;
&lt;li&gt;攻城师支持：工具平台、一日三餐、全员Mac、1:1 （实际上应该是有条件了才会有这些福利）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文化养成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选拔人才&lt;ul&gt;
&lt;li&gt;技术热情&lt;/li&gt;
&lt;li&gt;逻辑思维&lt;/li&gt;
&lt;li&gt;拿到结果&lt;/li&gt;
&lt;li&gt;工程 vs 产品 vs 技术&lt;/li&gt;
&lt;li&gt;计划 vs 随机应变&lt;/li&gt;
&lt;li&gt;严谨 vs 脱缰野⻢马&lt;/li&gt;
&lt;li&gt;重细节 vs 重宏观&lt;/li&gt;
&lt;li&gt;深度 vs 广度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Building Lean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：Kevin Goldsmith&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The one thing you can’t recycle is wasted time. -- Taiichi Ohno&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Key Lean Concepts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Anything that doesn’t produce value for customers is waste and a candidate for elimination&lt;/li&gt;
&lt;li&gt;Get value to customers as quickly as possible&lt;/li&gt;
&lt;li&gt;Validate product/market fit in the shortest amount of time necessary&lt;/li&gt;
&lt;li&gt;Scientific, data-driven, approach&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Key Lean Ideas：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minimum Viable(可行的) Product&lt;/li&gt;
&lt;li&gt;Create hypotheses, validate with experiments and DATA （大胆假设、小心验证？）&lt;/li&gt;
&lt;li&gt;Learn fast, fail fast&lt;/li&gt;
&lt;li&gt;The speed of iteration is more important than the quality of iteration  -- John Boyd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overcoming doubt：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruthlessly cut features to make the launch&lt;/li&gt;
&lt;li&gt;Commit to consistent, quick, iterations to make up the features we cut&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;吐槽&lt;/h2&gt;
&lt;p&gt;梁漱溟晚年口述一书《这个世界会好吗》，我的回答是：会！只不过需要不断地吐槽！！！&lt;/p&gt;
&lt;h4&gt;演讲即招聘&lt;/h4&gt;
&lt;p&gt;这一点本来是没什么好吐槽的。各种大大小小技术会议几乎每个演讲都会在最后附带一句“我们在招人！”，为了增大吸引力，还在演讲中有意无意地说明公司的待遇如何如何、美女如何如何。不过，我倒怀疑这种招聘形式到底能成功招到几个牛人呢？牛人都是主动规划自己的人生的，想去你们公司的，即使你不说招人，他们也会主动联系你，不想去的，说了也等于没说。特别是那些演讲内容或演讲效果一坨屎的，你还想啥呢。所以，对于技术会议，如果要演讲，就好好准备点干货，好好分享，这样才能给招聘增加吸引力。&lt;/p&gt;
&lt;h4&gt;演讲即产品推销&lt;/h4&gt;
&lt;p&gt;这种演讲，我真想将它吐槽至死！一点节操都不要！厚着脸皮浪费大家的时间。作为技术人应该是最讨厌这种，产品推销反而适得其反。（好吧，也许这只是我的想法）&lt;/p&gt;
&lt;h4&gt;演讲即不知所云&lt;/h4&gt;
&lt;p&gt;这种演讲，怎么说呢... 特别是如果演讲人是个高级工程师之类的，就真心对不起公司、对不起人民了。如果哆哆嗦嗦、词不达意、连个完整的话都说不清、不知所云，通常并不是你水平不行，只能说明你没有好好准备。作为高级工程师，或者有个title的人，紧张、心理素质不好，不应该成为一个糟糕演讲的理由。你的一个糟糕演讲对公司带来的负面影响是很大的，更别想在演讲的最后说“我们招人！”。&lt;/p&gt;
&lt;p&gt;该如何准备一次演讲？我的想法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只分享自己有心得的：如做过的事情或者认真研究过的技术，不是真正懂的东西就不要提，不要给自己挖坑&lt;/li&gt;
&lt;li&gt;制作幻灯片&lt;ul&gt;
&lt;li&gt;先写大纲，划一个演讲内容的范围&lt;/li&gt;
&lt;li&gt;根据大纲，逐个部分充实内容&lt;/li&gt;
&lt;li&gt;最后根据叙述逻辑（一个比较通用的叙述逻辑是：提出问题-&amp;gt;分析问题-&amp;gt;解决问题的方案）调整内容的位置，目的是方便听众快速理解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在正式演讲前对着幻灯片演练几遍，组织一下表述的语言，特别是幻灯片切换时的语言表述，在大脑中大致记住整个幻灯片的起承转合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好吧，虽然我说得貌似挺有道理，但也多少经验，有时间准备读读《演说之禅：职场必知的幻灯片秘技》一书。&lt;/p&gt;
&lt;h2&gt;感想&lt;/h2&gt;
&lt;p&gt;技术这东西，基本上都是围着业务转（不管是技术选型，还是深入实践），各家的业务不同，所以有各自的技术方案，但道道也就那些，没多少神奇之处。对于技术人来说，应该紧抓业务深研技术，才能出好成果，涨牛逼经验。&lt;/p&gt;
&lt;p&gt;故此，技术会议也没必要那么积极参加，个人觉得大型技术会议对于各中小公司的业务交流及宣传比较有用，对于技术交流的作用其实比较有限。非技术细节的东西要么没必要知道，要么已知道；技术细节也是如此。&lt;/p&gt;
&lt;p&gt;不过对于年轻的技术人来说，可以以讲师的身份多参加技术会议，可能对自己的帮助更大。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="http://2014.qconshanghai.com/slides.html"&gt;QCon上海2014大会 幻灯片下载&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>中心化日志记录架构（译）</title><link href="http://youngsterxyf.github.io/2014/10/14/centralized-logging-architecture/" rel="alternate"></link><published>2014-10-14T00:00:00+08:00</published><updated>2014-10-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-10-14:/2014/10/14/centralized-logging-architecture/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://jasonwilder.com/blog/2013/07/16/centralized-logging-architecture/"&gt;Centralized Logging Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://jasonwilder.com/blog/2012/01/03/centralized-logging/"&gt;中心化日志记录&lt;/a&gt;一文中，我介绍了几个工具，用于解决中心化日志记录的问题。但这些工具一般仅能 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://jasonwilder.com/blog/2013/07/16/centralized-logging-architecture/"&gt;Centralized Logging Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://jasonwilder.com/blog/2012/01/03/centralized-logging/"&gt;中心化日志记录&lt;/a&gt;一文中，我介绍了几个工具，用于解决中心化日志记录的问题。但这些工具一般仅能解决这个问题的一部分，
这意味着需要综合使用几个工具来构建一个健壮的解决方案。&lt;/p&gt;
&lt;p&gt;你需要解决问题的这几个主要方面：&lt;em&gt;收集&lt;/em&gt;、&lt;em&gt;传输&lt;/em&gt;、&lt;em&gt;存储&lt;/em&gt;、以及&lt;em&gt;分析&lt;/em&gt;。某些特殊的应用场景下，也许还希望具备&lt;em&gt;告警&lt;/em&gt;的能力。&lt;/p&gt;
&lt;h4&gt;收集&lt;/h4&gt;
&lt;p&gt;应用程序以不同的方式产生日志，一些是通过syslog，其他一些是直接写到文件。考虑一个运行在linux主机上的典型web应用，在&lt;code&gt;/var/log&lt;/code&gt;目录会有十几个甚至更多的日志文件，
如果一些应用指定日志存放在HOME目录或者其他位置，则这些目录下也是如此。&lt;/p&gt;
&lt;p&gt;如果你正在运营一个基于web的应用，开发人员或者运维同事需要快速地访问日志数据以便对线上问题进行排错，那么就需要一个能够近乎实时监控日志文件变化的方案。
如果使用基于日志拷贝的方式 --- 文件以固定的时间间隔拷贝到一台中心服务器上，那么仅能检查与复制操作频率相同的新增日志数据。当站点已经挂掉，而你正在等待相关日志数据的复制，
那么一分钟一次的 rsync cron 任务也许还不够快。&lt;/p&gt;
&lt;p&gt;从另外一个角度来看，如果需要分析线下日志数据，计算各种度量指标，或者其他批量的工作，文件复制的策略也许正合适。&lt;/p&gt;
&lt;h4&gt;传输&lt;/h4&gt;
&lt;p&gt;日志数据会在多个主机上快速地累积起来。为了高效传输日志数据到中心位置，并保证数据不丢失，可能需要额外的工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/facebookarchive/scribe"&gt;Scribe&lt;/a&gt;、&lt;a href="http://flume.apache.org/"&gt;Flume&lt;/a&gt;、&lt;a href="https://github.com/mozilla-services/heka"&gt;Heka&lt;/a&gt;、&lt;a href="http://logstash.net/"&gt;Logstash&lt;/a&gt;、
&lt;a href="http://chukwa.apache.org/"&gt;Chukwa&lt;/a&gt;、&lt;a href="http://www.fluentd.org/"&gt;fluentd&lt;/a&gt;、&lt;a href="https://github.com/bitly/nsq"&gt;nsq&lt;/a&gt;、&lt;a href="http://kafka.apache.org/"&gt;Kafka&lt;/a&gt; 这些框架正是被设计用于
从一个主机到另一个主机可靠地传输大量数据。虽然它们都是用于解决数据传输问题，但做法却不相同。&lt;/p&gt;
&lt;p&gt;例如，&lt;a href="https://github.com/facebookarchive/scribe"&gt;Scribe&lt;/a&gt;、&lt;a href="https://github.com/bitly/nsq"&gt;nsq&lt;/a&gt; 以及 &lt;a href="http://kafka.apache.org/"&gt;Kafka&lt;/a&gt;，要求客户端通过它们的API记录日志数据，
通常，应用程序代码会编写成直接将日志写到这些工具中，这样能够减小延迟，提高可靠性。如果你需要的是中心化的日志文件数据，那么就需要跟踪(tail)日志文件变更，
然后将日志数据通过这些工具各自的API流式写入。如果产生需要收集的日志数据的应用由你控制着，一切会高效得多。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://logstash.net/"&gt;Logstash&lt;/a&gt;、&lt;a href="https://github.com/mozilla-services/heka"&gt;Heka&lt;/a&gt;、&lt;a href="http://www.fluentd.org/"&gt;fluentd&lt;/a&gt; 以及 &lt;a href="http://flume.apache.org/"&gt;Flume&lt;/a&gt; 则提供许多输入源方式，
支持本机跟踪(tailing)文件变化并可靠地传输数据。对于更广泛的日志收集来说，是个更合适的选择。&lt;/p&gt;
&lt;p&gt;虽然 &lt;a href="http://rsyslog.com/"&gt;rsyslog&lt;/a&gt;和&lt;a href="http://www.balabit.com/network-security/syslog-ng"&gt;Syslog-ng&lt;/a&gt; 通常被认为是事实上的日志收集器，但并不是所有应用程序都使用 syslog。&lt;/p&gt;
&lt;h4&gt;存储&lt;/h4&gt;
&lt;p&gt;现在可以传输日志数据了，但数据存放在哪呢？中心化的存储系统需要能够处理数据随着时间的增长。每天都会增加一定量的数据存储，数据量和产生日志数据的主机和进程数量相关。&lt;/p&gt;
&lt;p&gt;如何存储依赖于以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;需要存储多长时间&lt;/em&gt; --- 如果日志是用于长期归档的目的，并且不需要即时分析，那么 &lt;a href="http://aws.amazon.com/cn/s3/"&gt;S3&lt;/a&gt;、&lt;a href="http://aws.amazon.com/cn/glacier/"&gt;AWS Glacier&lt;/a&gt; 或磁带备份
    也许是合适的选择，因为它们对于大量数据的存储相对比较廉价。如果仅需要几天或者几个月的日志，将数据存储到某种分布式存储系统，
    如：&lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt;、&lt;a href="http://cassandra.apache.org/"&gt;Cassandara&lt;/a&gt;、
    &lt;a href="http://www.mongodb.org/"&gt;MongoDB&lt;/a&gt; 或 &lt;a href="http://elasticsearch.org/"&gt;ElasticSearch&lt;/a&gt;也是不错的。如果仅需要保留几个小时的数据用于实时分析，使用&lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;也可以。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;应用场景的数据量&lt;/em&gt; --- Google一天的日志数据量肯定远大于ACME运输物资公司（译注：原文是ACME Fishing Supplies，正确的应该是ACME Shipping Supplies）一天的日志。
    你选择的存储系统当数据量增大时应该允许水平扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;需要如何访问日志&lt;/em&gt; --- 某些存储系统是适于实时甚至批量分析的。AWS Glacier 或磁盘备份加载一个文件就需要花费若干小时，如果需要访问日志进行产品排错，这就不好使了。
    如果计划进行更多的交互式数据分析，将日志数据存储到 &lt;a href="http://elasticsearch.org/"&gt;ElasticSearch&lt;/a&gt; 或 &lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt;
    让你能够更加有效地使用原始数据。某些日志数据非常庞大，就只能使用面向批量处理的框架进行分析了。这种情况下事实上的标准方案是 &lt;a href="http://hadoop.apache.org/"&gt;Apache Hadoop&lt;/a&gt; 
    配合 &lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;分析&lt;/h4&gt;
&lt;p&gt;一旦日志已经存到一个中心化存储平台，就需要一种方式来分析日志。最常见的方式是定期执行一个面向批量处理的进程。如果日志是存储在 &lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt; 中，
那么 &lt;a href="http://hive.apache.org/"&gt;Hive&lt;/a&gt; 或 &lt;a href="http://pig.apache.org/"&gt;Pig&lt;/a&gt; 相比编写原生MapReduce任务，更易于帮助分析数据。&lt;/p&gt;
&lt;p&gt;如果需要一个用于分析的用户界面，可以将解析过的日志数据存到 &lt;a href="http://elasticsearch.org/"&gt;ElasticSearch&lt;/a&gt;，然后使用一个前端方案，如 &lt;a href="http://kibana.org/"&gt;Kibana&lt;/a&gt; 或
&lt;a href="http://www.graylog2.org/"&gt;Graylog2&lt;/a&gt;来查询检查数据。日志解析可以通过 &lt;a href="http://logstash.net/"&gt;Logstash&lt;/a&gt; 或 &lt;a href="https://github.com/mozilla-services/heka"&gt;Heka&lt;/a&gt;来处理，
应用程序也可以直接以JSON格式记录日志。这种方式允许更加实时、交互式的数据获取，但不适于大批量的处理。&lt;/p&gt;
&lt;h4&gt;告警&lt;/h4&gt;
&lt;p&gt;最后一个组件，有时是可以锦上添花的 --- 针对日志模式或基于日志数据计算出来的度量指标进行告警。两种常见用法是：错误报告和监控。&lt;/p&gt;
&lt;p&gt;多数日志数据是无关紧要的，但错误日志则通常说明存在问题。让日志系统在问题发生时给相关人员发送邮件或通知，相比让某个人重复地监视事件，要高效得多。
有几种服务组件可单独提供应用错误日志记录的功能，如 &lt;a href="https://www.getsentry.com/"&gt;Sentry&lt;/a&gt; 或 &lt;a href="https://www.honeybadger.io/"&gt;HoneyBadger&lt;/a&gt; 。这些服务也可以聚合重复的异常，
方便你获知错误发生的频率是怎样的。&lt;/p&gt;
&lt;p&gt;另一个使用案例是监控。例如，你可能有上百个web服务器，想知道它们是否开始返回500响应状态码。如果可以解析web日志文件，根据状态码记录一个度量指标，
当度量指标超过了一个特定的阈值就可以触发告警。 &lt;a href="http://riemann.io/"&gt;Riemann&lt;/a&gt; 就是被设计用于检测这种场景的。&lt;/p&gt;
&lt;p&gt;希望本文能提供一个基本模型帮助你针对你的应用环境设计一个中心化日志记录方案。&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="日志"></category><category term="架构"></category></entry><entry><title>流行PHP项目的phpmetrics分析（译）</title><link href="http://youngsterxyf.github.io/2014/09/22/phpmetrics-of-popular-php-projects/" rel="alternate"></link><published>2014-09-22T00:00:00+08:00</published><updated>2014-09-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-09-22:/2014/09/22/phpmetrics-of-popular-php-projects/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://peteraba.com/blog/phpmetrics-of-popular-projects/"&gt;phpmetrics of popular php projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前我偶然发现一个名为&lt;a href="http://www.phpmetrics.org/"&gt;phpmetrics&lt;/a&gt;的新工具，可用于计算及展示php的度量指标。我当时立马喜欢上了这个工具，并决 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://peteraba.com/blog/phpmetrics-of-popular-projects/"&gt;phpmetrics of popular php projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前我偶然发现一个名为&lt;a href="http://www.phpmetrics.org/"&gt;phpmetrics&lt;/a&gt;的新工具，可用于计算及展示php的度量指标。我当时立马喜欢上了这个工具，并决定用它分析我认为重要的一些php项目。
我知道这个项目列表还远远不够完善，但应该仍然值得一看。我特别喜欢其中的“可维护性”报告，我发现视觉上那些红色的斑点就和丑陋的代码一样令人厌恶。&lt;/p&gt;
&lt;p&gt;这个工具貌似还有点小bug，我会尽力尽快修复这个工具项目的这些小问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些重要的说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前我还无法得到Cakephp和Typo3的分析报告，之后我会尽快调查一下这个问题。&lt;/li&gt;
&lt;li&gt;我是在完整的代码库或下载的源码包上执行这个工具的，这意味着某些情况下还分析了项目的外部依赖库。之后我可能会调整，但目前不在计划之内。&lt;/li&gt;
&lt;li&gt;有些项目包含很多代码库，所以我无法确保测试的都是正确的那个代码库。&lt;em&gt;Joomla&lt;/em&gt;尤其可能这样。&lt;/li&gt;
&lt;li&gt;某些项目并非非常知名，但在github上呈现关注度上升趋势。&lt;/li&gt;
&lt;li&gt;dm-mailer这个项目无足轻重，只是我最新的个人兴趣项目。我将它与phpmetrics一起归到Backfire一节。&lt;/li&gt;
&lt;li&gt;注意：php-yaf和phalcon都是非常有意思的php框架，但多数代码是C实现的，因此没有包含进来。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;说明：阅读该报告的一点小提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多的斑点只是意味着更多的类&lt;/li&gt;
&lt;li&gt;红色意味着不可维护，黄色表示可接受，绿色则表明良好、可维护的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;分析结果&lt;/h3&gt;
&lt;h4&gt;框架&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://www.agavi.org/"&gt;agavi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="agavi-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/agavi-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/agavi/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/agavi/agavi"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交（均指master分支上的）：&lt;em&gt;4个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://auraphp.com/"&gt;aura&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="aura-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/aura-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/aura/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/auraphp/Aura.Framework_Project"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://cakephp.org/"&gt;cakephp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="cakephp-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/na.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;s&gt;戳这里&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/cakephp/cakephp"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="https://ellislab.com/codeigniter"&gt;codeigniter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="codeigniter-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/codeigniter-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/codeigniter/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/EllisLab/CodeIgniter"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="https://github.com/colindean/deano"&gt;deano&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="deano-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/deano-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/deano/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/colindean/deano"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;10个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://fatfreeframework.com/home"&gt;fatfree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="fatfree-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/fatfree-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/fatfree/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/bcosca/fatfree"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1个月内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://flightphp.com/"&gt;flight&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="flight-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/flight-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/flight/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/mikecao/flight"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://fuelphp.com/"&gt;fuelphp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="fuelphp-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/fuelphp-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/fuelphp/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/fuel/fuel"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2个月内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://laravel.com/"&gt;laravel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="laravel-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/laravel-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/laravel/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/laravel/laravel"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://limonade-php.github.io/"&gt;limonade&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="limonade-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/limonade-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/limonade/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/sofadesign/limonade/"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2个月内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://nette.org/en/"&gt;nette&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="nette-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/nette-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/nette/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/nette/nette"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://phavour-project.com/"&gt;phavour&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phavour-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phavour-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phavour/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/phavour/phavour"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;6个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.php-mvc.net/"&gt;php-mvc(advanced)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="php-mvc-advanced-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/php-mvc-advanced-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/php-mvc-advanced/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/panique/php-mvc-advanced"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://phpixie.com/"&gt;phpixie&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phpixie-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phpixie-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phpixie/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/dracony/PHPixie"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;5个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.popphp.org/"&gt;popphp2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="popphp2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/popphp2-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/popphp2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/popphp/popphp2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：3周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://silex.sensiolabs.org/"&gt;silex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="silex-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/silex-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/silex/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/silexphp/Silex"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://slimframework.com/"&gt;slim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="slim-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/slim-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/slim/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/codeguy/Slim"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：5个月内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://symfony.com/legacy"&gt;symfony1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="symfony1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/symfony1-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/symfony1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/symfony/symfony1"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;2年内&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://symfony.com/"&gt;symfony2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="symfony2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/symfony2-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/symfony2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/symfony/symfony"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://typo3.org/"&gt;typo3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="typo3-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/na.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;s&gt;戳这里&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://git.typo3.org/Packages/TYPO3.CMS.git"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.yiiframework.com/"&gt;yii1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="yii1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/yii1-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/yii1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/yiisoft/yii"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.yiiframework.com/"&gt;yii2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="yii2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/yii2-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/yii2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/yiisoft/yii2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://framework.zend.com/"&gt;zf1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="zf1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/zf1-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/zf1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/zendframework/zf1"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://framework.zend.com/"&gt;zf2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="zf2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/zf2-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/zf2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/zendframework/zf2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;CMS&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="https://www.drupal.org/"&gt;drupal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="drupal-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/drupal-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/drupal/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/drupal/drupal"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.joomla.org/"&gt;joomla&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="joomla-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/joomla-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/joomla/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/joomla/joomla-framework"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：5个月内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://getgrav.org/"&gt;grav&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="grav-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/grav-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/grav/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/getgrav/grav"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://pagekit.com/"&gt;pagekit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="pagekit-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/pagekit-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/pagekit/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/pagekit/pagekit"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.webasyst.com/"&gt;os webasyst projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="os-webasyst-projects-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/os-webasyst-projects-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/webasyst/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：N/A&lt;/p&gt;
&lt;p&gt;最近提交：N/A&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://wordpress.org/"&gt;wordpress&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="wordpress-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/wordpress-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/wordpress/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/WordPress/WordPress"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;电子商务&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://magento.com/"&gt;magento1(1.8 copy)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="magento1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/magento1-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/magento1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://bitbucket.org/ecgkodokux/magento1.8.git"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：N/A&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://magento.com/"&gt;magento2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="magento2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/magento2-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/magento2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/magento/magento2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.opencart.com/"&gt;opencart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="opencart-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/opencart-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/opencart/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/opencart/opencart"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.oscommerce.com/"&gt;oscommerce&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="oscommerce-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/oscommerce-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/oscommerce/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/osCommerce/oscommerce"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2年内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.prestashop.com/"&gt;prestashop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="prestashop-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/prestashop-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/prestashop/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/PrestaShop/PrestaShop"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://sylius.org/"&gt;sylius&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="sylius-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/sylius-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/sylius/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/Sylius/Sylius"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;10个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://virtuemart.net/"&gt;virtuemart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="virtuemart-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/virtuemart-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/virtuemart/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="http://dev.virtuemart.net/projects/virtuemart/repository"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：N/A&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.zen-cart.com/"&gt;zencart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="zencart-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/zencart-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/zencart/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/zencart/zc-v1-series"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;开发工具&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://codeception.com/"&gt;codeception&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="codeception-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/codeception-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/codeception/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/Codeception/Codeception"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://phpunit.de/"&gt;phpunit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phpunit-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phpunit-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phpunit/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/sebastianbergmann/phpunit"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;其他&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://piwik.org/"&gt;piwik&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="piwik-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/piwik-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/piwik/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/piwik/piwik"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;Backfire&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="https://github.com/peteraba/zf2-mailer"&gt;dm-mailer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="dm-mailer-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/dm-mailer-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/dm-mailer/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/peteraba/zf2-mailer"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;7个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;项目：&lt;a href="http://www.phpmetrics.org/"&gt;phpmetrics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phpmetrics-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phpmetrics-phpmetric-maintenability.png"&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phpmetrics/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/Halleck45/PhpMetrics"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;问题(Issues)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Cakephp&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;594/666 [========================&amp;gt;---]  89%

[Exception]                         
Closure detected instead of method
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Deano&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;2/9 [======&amp;gt;---------------------]  22%file /home/peter/dev/php/opensource/deano/views/layout/layout.php is not valid and has been skipped
9/9 [============================] 100%file /home/peter/dev/php/opensource/deano/deano.php is not valid and has been skipped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Limonade&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; 9/16 [===============&amp;gt;------------]  56%file /home/peter/dev/php/opensource/limonade/examples/example02/index.php is not valid and has been skipped
16/16 [============================] 100%file /home/peter/dev/php/opensource/limonade/examples/example06/index.php is not valid and has been skipped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Magento&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;3361/9868 [=========&amp;gt;------------------]  34%file ../../opensource/magento2/lib/internal/Zend/Mail/Protocol/Pop3.php is not valid and has been skipped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pagekit&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;102/215 [=============&amp;gt;--------------]  47%file /home/peter/dev/php/opensource/pagekit/extensions/system/src/System/Console/skeleton/extension/src/Controller/SiteController.php is not valid and has been skipped
103/215 [=============&amp;gt;--------------]  47%file /home/peter/dev/php/opensource/pagekit/extensions/system/src/System/Console/skeleton/extension/src/DefaultExtension.php is not valid and has been skipped
105/215 [=============&amp;gt;--------------]  48%file /home/peter/dev/php/opensource/pagekit/extensions/system/src/System/Console/skeleton/theme/src/DefaultTheme.php is not valid and has been skipped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Symfony1&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;199/1320 [====&amp;gt;-----------------------]  15%file /home/peter/dev/php/opensource/symfony1/lib/task/generator/skeleton/module/module/actions/actions.class.php is not valid and has been skipped
205/1320 [====&amp;gt;-----------------------]  15%file /home/peter/dev/php/opensource/symfony1/lib/task/generator/skeleton/app/web/index.php is not valid and has been skipped
206/1320 [====&amp;gt;-----------------------]  15%file /home/peter/dev/php/opensource/symfony1/lib/task/generator/skeleton/app/app/config/ApplicationConfiguration.class.php is not valid and has been skipped
397/1320 [========&amp;gt;-------------------]  30%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/admin/skeleton/lib/helper.php is not valid and has been skipped
398/1320 [========&amp;gt;-------------------]  30%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/admin/skeleton/lib/configuration.php is not valid and has been skipped
399/1320 [========&amp;gt;-------------------]  30%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/admin/skeleton/actions/actions.class.php is not valid and has been skipped
445/1320 [=========&amp;gt;------------------]  33%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/default/skeleton/actions/actions.class.php is not valid and has been skipped
652/1320 [=============&amp;gt;--------------]  49%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/admin/skeleton/lib/helper.php is not valid and has been skipped
653/1320 [=============&amp;gt;--------------]  49%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/admin/skeleton/lib/configuration.php is not valid and has been skipped
654/1320 [=============&amp;gt;--------------]  49%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/admin/skeleton/actions/actions.class.php is not valid and has been skipped
700/1320 [==============&amp;gt;-------------]  53%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/default/skeleton/actions/actions.class.php is not valid and has been skipped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Typo3&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;76/2583 [&amp;gt;---------------------------]   2%

[Exception]                         
Closure detected instead of method
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="PHP"></category></entry><entry><title>RESTful API设计的一点经验</title><link href="http://youngsterxyf.github.io/2014/09/06/experience-about-restful-api/" rel="alternate"></link><published>2014-09-06T00:00:00+08:00</published><updated>2014-09-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-09-06:/2014/09/06/experience-about-restful-api/</id><summary type="html">&lt;p&gt;前段时间的工作涉及产品开放API的设计与实现，整个过程大致可分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据需求、原有数据库设计等，花了半天左右的工夫 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;前段时间的工作涉及产品开放API的设计与实现，整个过程大致可分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据需求、原有数据库设计等，花了半天左右的工夫完成初稿；&lt;/li&gt;
&lt;li&gt;就初稿与相关同事进行讨论，确定一些细节问题，逐步完善；&lt;/li&gt;
&lt;li&gt;根据设计稿，基于Yii框架，配置路由，实现用户身份认证模块；&lt;/li&gt;
&lt;li&gt;基于步骤3，逐个实现业务相关API；&lt;/li&gt;
&lt;li&gt;对部分代码进行重构，减少不必要的代码重复。主要使用Yii控制器的beforeAction方法来实现多层过滤器。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;设计&lt;/h3&gt;
&lt;p&gt;考虑到RESTful API简洁明了的接口表现形式，一开始我们就一致确定使用RESTful风格的API。参考以前自己使用多个开放平台API的经验，
及&lt;a href="https://developer.github.com/v3/"&gt;Github的开放API文档&lt;/a&gt;，大致完成设计初稿。&lt;/p&gt;
&lt;h5&gt;资源&lt;/h5&gt;
&lt;p&gt;RESTful API主要有两个核心：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP协议的4个谓词 - GET、POST、PUT、DELETE，分别对应“查询”、“新增”、“更新”、“删除”4种操作&lt;/li&gt;
&lt;li&gt;资源（resource）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RESTful风格API的设计，最难之处，我认为就是“资源”。&lt;/p&gt;
&lt;p&gt;“资源”是什么？“资源”并不是对应数据库中一个一个数据表，“资源”是一个抽象的概念，
你需要思考你的产品服务要通过API为用户提供什么？一个API提供的数据可能涉及多张数据表，所以“资源”与具体的数据库设计是独立的。&lt;/p&gt;
&lt;p&gt;“资源”的抽象会遇到一个“粒度”的问题，比如一个API返回的数据不应该太多太复杂。&lt;/p&gt;
&lt;p&gt;另外，不同“资源”之间可能存在归属关系，那么是否需要在HTTP API的URL中体现这种归属关系？如果要体现，那么当归属关系的层次较多时，URL的长度可能过长。&lt;/p&gt;
&lt;p&gt;举个简单的例子来进一步解释上述问题：&lt;/p&gt;
&lt;p&gt;假设我们要通过API提供“全国县一级的天气预报数据”。从这句话的表述可以很明显地知道（因为这句话本身是一个明确的需求）这里的“资源”是“全国县一级的天气预报数据”。&lt;/p&gt;
&lt;p&gt;这个“全国县一级的天气预报数据”其实仍是抽象的，天气预报数据可能包含天气、气温、湿度、空气质量等指标，这些指标又是分别存储在不同的数据表中的，那么这个API
的代码逻辑就需要读取几张数据表，然后做合并处理。又或者数据库中存储的数据是区域范围更小更准备的天气预报数据，那么也需要对这些数据按照一定的算法进行处理
得出县一级的天气预报数据。&lt;/p&gt;
&lt;p&gt;如果仅通过一个API来提供全国所有县一级的天气数据，那么可以想象，这个API返回的数据有多大多复杂。并且用户可能需要更灵活的数据查询方式，如仅查询某个省份
所有县一级的天气预报数据。那么可以将这个API拆分成以下几个API：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;GET /province/
GET /province/{province_name_or_id}/county/
GET /province/{province_name_or_id}/county/{county_id_or_name}/weather/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;拆分之后，可能需要多次调用API才能获取到需要的数据，但每个API的定义都简单而明确。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;GET /province/{province_name_or_id}/county/{county_id_or_name}/weather/&lt;/code&gt;这个URL，可能有人觉得它过长了，可以缩短设计为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;GET /county/{county_id_or_name}/weather/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;甚至&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;GET /{county_id_or_name}/weather/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但我更倾向于归属关系明确的长URL，主要原因是，API服务器端可以验证province_name_or_id与county_id_or_name之间的归属关系，以避免用户错误地调用API，
特别是当涉及增删改操作时。&lt;/p&gt;
&lt;p&gt;所以RESTful API设计时有许多细节之处需要权衡。&lt;/p&gt;
&lt;h5&gt;响应码&lt;/h5&gt;
&lt;p&gt;RESTful API请求的响应码通常有两种表现形式，一种是直接使用HTTP协议的HTTP code，另一种是HTTP协议的响应码始终为200，但在响应体中加入类似名为code的字段，
来表达当前API请求的响应状态，这个code字段值的含义就是HTTP code含义，除了code字段外可能还会附加一个类似名为message的字段来进一步解释响应状态。&lt;/p&gt;
&lt;p&gt;我倾向使用第二种形式，理由是：HTTP协议的HTTP code，在为404、500等错误码时，表现的应该是API服务器端程序的健壮性等问题，是未预期的错误，而响应体中的code字段，
在返回404或500等错误码时，表达是API服务器端已预期到这些可能存在的错误，是主动返回这样的错误码的。这样API的调用者也能更容易判断某些问题的原因；&lt;/p&gt;
&lt;h5&gt;请求的唯一标识&lt;/h5&gt;
&lt;p&gt;为了方便快速定位用户反馈的问题，我们在每个API的响应内容中加入一个request_id字段作为API请求的唯一性标识，这个请求处理过程中产生的所有日志都是和这个
request_id关联的，这样可以根据request_id聚合处理关联的log。在用户反馈问题时，仅需提供request_id，我们很容易地就能找到这个请求的所有日志。&lt;/p&gt;
&lt;p&gt;但这个request_id是应该作为HTTP相应头的一个字段，还是作为响应体的一个字段返回？我倾向于第二种，理由是：我们希望API调用方能够在日志或数据库中记录
所有请求的request_id，便于以后发现问题时进行问题追踪。对于这种调用方应该处理的响应数据项，明确地放在响应体中会更好。&lt;/p&gt;
&lt;p&gt;另外，我们也会每个request_id记录对应请求的监控数据，如响应码、请求处理耗费的时间、请求的调用方、请求处理的路由等。这样在对监控数据进行数据可视化后，
可以主动发现某些隐藏的问题。&lt;/p&gt;
&lt;h5&gt;兼容&lt;/h5&gt;
&lt;p&gt;在某些情况下，客户端库或工具可能并不支持HTTP协议谓词PUT和DELETE，那么基于这两个谓词的RESTful
API就需要提供兼容方案。我们的兼容方案是：以POST谓词来替代PUT和DELETE，同时在API请求URL的查询字符串中添加_method一项，指明POST替代的是PUT还是DELETE。如以&lt;code&gt;POST
/xxx/yyy/?_method=DELETE&lt;/code&gt;作为&lt;code&gt;DELETE /xxx/yyy/&lt;/code&gt;的兼容方案。&lt;/p&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;我们的开放API是基于Yii框架实现。&lt;/p&gt;
&lt;h5&gt;路由&lt;/h5&gt;
&lt;p&gt;Yii框架默认的路由形式为：查询字符串r=xxx/yyy，其中xxx为控制器(controller)的名称，yyy为动作方法(action)的名称，这种路由形式对应Yii内部的get路由类型，
因为是默认形式，所以无需额外配置。
Yii另外提供一种名为path的路由形式，即使用URL的路径(path)部分来表达路由。要这种形式的路由需要额外配置Yii框架，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;components&amp;#39; =&amp;gt; array(
    &amp;#39;urlManager&amp;#39; =&amp;gt; array(
        &amp;#39;urlFormat&amp;#39; =&amp;gt; &amp;#39;path&amp;#39;,
        &amp;#39;rules&amp;#39; =&amp;gt; array(
            array(&amp;#39;aaa/bbb&amp;#39;, &amp;#39;pattern&amp;#39; =&amp;gt; &amp;#39;/xxx/yyy&amp;#39;, &amp;#39;verb&amp;#39; =&amp;gt; &amp;#39;POST&amp;#39;),
            ...
        ),
    ),
    ...
),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;urlManager是Yii使用的路由管理组件，其中的urlFormat指明使用path形式的路由，rules中的每一数组项即一个路由配置，路由配置数组的第一个元素（如aaa/bbb），
其中aaa为实际控制器类的名称(不包含Controller后缀)，bbb为控制器类aaa中实际动作方法的名称(不包含action前缀)，pattern元素指明当前路由配置项会处理的URL，
xxx为控制器名称，yyy为动作方法名称，这里可以看出HTTP API URL中的控制器名称、动作方法名称可以和实际的控制器类名称、动作方法名称不一样。verb元素指明
当前路由配置项会处理哪个或哪些HTTP谓词对URL“/xxx/yyy”的请求，多个谓词时以逗号分隔。&lt;/p&gt;
&lt;h5&gt;兼容方案&lt;/h5&gt;
&lt;p&gt;对于兼容方案，POST谓词原本是用来“新增”资源，那么对于相同的URL，POST谓词可能已经被占用，也即意味着谓词“DELETE”或“PUT”的“POST”兼容方案的API请求，也会被Yii框架路由到“新增”资源的处理逻辑，那么需要在“新增”资源的控制器类的beforeAction方法中，通过检查查询字符串参数_method，重新将请求路由到正确的
动作方法上，代码如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;protected function beforeAction($action)
{
    $this-&amp;gt;requestMethod = Yii::app()-&amp;gt;request-&amp;gt;getRequestType();
    // 兼容方案
    // 带参数_method=DELETE的POST请求来代替DELETE请求
    // 带参数_method=PUT的POST请求来代替PUT请求
    if ($this-&amp;gt;requestMethod === &amp;#39;POST&amp;#39; &amp;amp;&amp;amp; isset($_POST[&amp;#39;_method&amp;#39;])) {
        if ($_POST[&amp;#39;_method&amp;#39;] === &amp;#39;DELETE&amp;#39;) {
            // 避免死循环
            unset($_POST[&amp;#39;_method&amp;#39;]);
            $this-&amp;gt;forward($this-&amp;gt;getUniqueId() . &amp;#39;/delete&amp;#39;);
        } elseif ($_POST[&amp;#39;_method&amp;#39;] === &amp;#39;PUT&amp;#39;) {
            unset($_POST[&amp;#39;_method&amp;#39;]);
            $this-&amp;gt;forward($this-&amp;gt;getUniqueId() . &amp;#39;/update&amp;#39;);
        } else {
            $this-&amp;gt;echoJson(CodeStatus::WRONG_PARAM);
            return false;
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;响应码&lt;/h5&gt;
&lt;p&gt;对于API可能用到的所有响应码及其说明，我们使用一个单独的类来集中管理，以避免API中硬编码响应码，以及避免代码重复。如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;CodeStatus&lt;/span&gt; {
        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; OK = 200; &lt;span style="color: #008000"&gt;// 成功&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; CREATED = 201; &lt;span style="color: #008000"&gt;// 创建成功&lt;/span&gt;

        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; REQUEST_WRONG = 400;
        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; TOKEN_WRONG = 403; &lt;span style="color: #008000"&gt;// token已过期或不存在&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; NOT_FOUND = 404; &lt;span style="color: #008000"&gt;// 资源不存在&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; LACK_PARAM = 423; &lt;span style="color: #008000"&gt;// 缺少必要的请求参数&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; WRONG_PARAM = 425; &lt;span style="color: #008000"&gt;// 请求参数不正确&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; DUPLICATE_RESOURCE = 426; &lt;span style="color: #008000"&gt;// 已经存在相同的资源&lt;/span&gt;

        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; SYSTEM_ERROR = 500; &lt;span style="color: #008000"&gt;// 系统异常&lt;/span&gt;

        ...

        &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; $status_code = &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(
            self::OK =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;成功&amp;#39;&lt;/span&gt;,
            self::CREATED =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;创建成功&amp;#39;&lt;/span&gt;,
            self::TOKEN_WRONG =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;token已过期或不存在&amp;#39;&lt;/span&gt;,
            self::LACK_PARAM =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;缺少必要的请求参数&amp;#39;&lt;/span&gt;,
            self::SYSTEM_ERROR =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;系统异常&amp;#39;&lt;/span&gt;,
            self::WRONG_PARAM =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;请求参数不正确&amp;#39;&lt;/span&gt;,
            self::DUPLICATE_RESOURCE =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;已经存在相同的资源&amp;#39;&lt;/span&gt;,
            self::NOT_FOUND =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;资源不存在&amp;#39;&lt;/span&gt;,
            ...
        );
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;API中仅需使用CodeStatus类定义的常量成员即可（如CodeStatus::OK）。&lt;/p&gt;
&lt;h3&gt;推荐阅读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.github.com/v3/"&gt;Github API v3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/interagent/http-api-design"&gt;Heroku HTTP API Design Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="笔记"></category><category term="RESTful"></category></entry><entry><title>基于socket.io的实时消息推送</title><link href="http://youngsterxyf.github.io/2014/09/06/socket.io-push-server/" rel="alternate"></link><published>2014-09-06T00:00:00+08:00</published><updated>2014-09-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-09-06:/2014/09/06/socket.io-push-server/</id><summary type="html">&lt;p&gt;用户访问Web站点的过程是基于HTTP协议的，而HTTP协议的工作模式是：请求-响应，客户端发出访问请求，服务器端以资源数据响应请求。
也就是说，服务器端始终是被动的，即使服 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;用户访问Web站点的过程是基于HTTP协议的，而HTTP协议的工作模式是：请求-响应，客户端发出访问请求，服务器端以资源数据响应请求。
也就是说，服务器端始终是被动的，即使服务器端的资源数据发生变化，如果没有来自客户端的请求，用户就不会看到这些变化。
这种模式是不适合某些应用场景的，比如在社交网络用户需要近乎实时地知道其他用户最新的信息。对于普通站点来说，
请求-响应模式可以满足绝大多数的功能需求，但总有某些功能我们希望能够为用户提供实时消息的体验。&lt;/p&gt;
&lt;p&gt;为解决这个问题，有两种方案可以选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仍旧使用请求-响应模式，只是增大请求的频率或者使用长连接，来达到尽可能接近实时的效果，如使用polling/long-polling，但可能会极大地增加服务器的负载压力或降低服务器的吞吐量&lt;/li&gt;
&lt;li&gt;使用新的协议，在服务器端有资源数据更新时，主动推送给客户端，如WebSocket，虽然这种思路也是使用了长连接，但效率更高，且是客户端服务器端之间的全双工通信。
问题在于目前各大浏览器并不都支持WebSocket。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么目前最好的方式就是结合以上两种方案，在不同的浏览器中，尽可能使用浏览器支持的最好的方案，即浏览器支持第二种方案时，优先使用第二种方案，否则使用第一种方案。socket.io就是这么做的，并且在服务器端和客户端对于不同的方案提供统一的接口。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在我们产品的站内信功能中，希望能够给在线用户实时推送公共消息或私有消息。考虑到以后可能还有其他功能需要实现实时消息推送，所以将实时消息推送实现为一个单独的服务。这种针对不同特性的功能进行解耦也为之后针对性的优化做了铺垫。&lt;/p&gt;
&lt;p&gt;解耦之后的系统结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="socket.io-push-server" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/socket.io-push-server.png"&gt;&lt;/p&gt;
&lt;p&gt;当站点服务器(A)监测到资源数据更新事件发生时，先将数据推送到消息推送服务器(B)，B根据消息的类型以及消息的目标接收人来决定是否推送，如何推送。&lt;/p&gt;
&lt;p&gt;由于我们的Web后端是基于Yii框架实现，那么该如何实现A与B的socket.io服务通信呢？socket.io有自己的一套协议，如果自己实现PHP库来与socket.io服务交互，还有一些工作量。最终我们选择&lt;a href="https://github.com/oncesk/elephant.io"&gt;elephant.io这个PHP库&lt;/a&gt;，并将elephant.io封装为Yii框架的一个组件，实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;

$basePath = Yii::getPathOfAlias(&lt;span style="color: #a31515"&gt;&amp;#39;application.vendor.elephantio.lib.ElephantIO&amp;#39;&lt;/span&gt;);

&lt;span style="color: #0000ff"&gt;require_once&lt;/span&gt;($basePath . DIRECTORY_SEPARATOR . &lt;span style="color: #a31515"&gt;&amp;#39;Client.php&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;require_once&lt;/span&gt;($basePath . DIRECTORY_SEPARATOR . &lt;span style="color: #a31515"&gt;&amp;#39;Payload.php&amp;#39;&lt;/span&gt;);

&lt;span style="color: #0000ff"&gt;use&lt;/span&gt; ElephantIO\Client &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; Elephant;

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;extElephantIO&lt;/span&gt; &lt;span style="color: #0000ff"&gt;extends&lt;/span&gt; CApplicationComponent
{
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; $host = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; $port = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; $namespace = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;

    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; $elephant = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;
    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; $ioNameSpace = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; init()
    {
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($this-&amp;gt;host === &lt;span style="color: #0000ff"&gt;null&lt;/span&gt; || $this-&amp;gt;port === &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;) {
            &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Exception(&lt;span style="color: #a31515"&gt;&amp;#39;%s: %s: %s, Please give me parameters host and port&amp;#39;&lt;/span&gt;, basename(
                __FILE__
            ), __FUNCTION__, __LINE__);
        }

    }

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; setNameSpace($nameSpace)
    {
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($this-&amp;gt;elephant === &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;) {
            $this-&amp;gt;elephant = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Elephant(&lt;span style="color: #a31515"&gt;&amp;#39;http://&amp;#39;&lt;/span&gt; . $this-&amp;gt;host . &lt;span style="color: #a31515"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;
                . $this-&amp;gt;port, &lt;span style="color: #a31515"&gt;&amp;#39;socket.io&amp;#39;&lt;/span&gt;, 1, &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);
            $this-&amp;gt;elephant-&amp;gt;init();
        }
        $this-&amp;gt;ioNameSpace = $this-&amp;gt;elephant-&amp;gt;createFrame(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, $nameSpace);
    }

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; sendMsg($event, $msg)
    {
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($this-&amp;gt;ioNameSpace === &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;) {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($this-&amp;gt;namespace !== &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;) {
                $this-&amp;gt;ioNameSpace = $this-&amp;gt;elephant-&amp;gt;createFrame(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, $this-&amp;gt;namespace);
            } &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; {
                &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Exception(&lt;span style="color: #a31515"&gt;&amp;#39;%s: %s: %s, Please setNameSpace before sendMsg&amp;#39;&lt;/span&gt;, basename(
                    __FILE__
                ), __FUNCTION__, __LINE__);
            }
        }
        $this-&amp;gt;ioNameSpace-&amp;gt;emit($event, $msg);
    }

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; close()
    {
        $this-&amp;gt;elephant-&amp;gt;close();
        $this-&amp;gt;elephant = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将该代码文件放在应用目录extensions下，然后为Yii添加如下配置项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;#39;components&amp;#39; =&amp;gt; array(
    &amp;#39;ElephantIO&amp;#39; =&amp;gt; array(
        &amp;#39;class&amp;#39; =&amp;gt; &amp;#39;application.extensions.extElephantIO&amp;#39;,
        &amp;#39;host&amp;#39; =&amp;gt; &amp;#39;xxx&amp;#39;,
        &amp;#39;port&amp;#39; =&amp;gt; xxx,
    ),
    ...
),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当有资源数据变更事件产生时，如下调用向消息推送服务器发送消息：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$elephant = Yii::app()-&amp;gt;ElephantIO;
$elephant-&amp;gt;setNameSpace(&amp;#39;/message_namespace&amp;#39;);
$elephant-&amp;gt;sendMsg(
    &amp;#39;message_event_type&amp;#39;,
    $messageContent
);       
$elephant-&amp;gt;close();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;对于私有消息推送，如何判断用户当前是否在线？如何验证用户的身份？&lt;/p&gt;
&lt;p&gt;可以基于cookie来实现，socket.io提供的浏览器端JS库，在每次连接时，和普通HTTP请求一样，会携带站点域名下的cookie（我们的消息推送服务的域名为站点服务器域名的子域，所以能拿到站点域名下的所有cookie），消息推送服务器在接收到连接(connection事件)请求时，从连接中取出所有cookie，然后向站点Web后端的某个API转发这些cookie，这个API根据cookie验证用户身份，并将用户信息返回给消息推送服务器，消息推送服务器根据用户信息存储当前连接对象，之后当站点服务器向消息推送服务器发送该用户的消息时，就通过该连接对象给用户推送消息。&lt;/p&gt;
&lt;p&gt;对于公有消息，即广播消息，实现则比较简单，直接向当前所有连接推送消息即可。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;也许有人会问，既然在某些浏览器中socket.io会退化为使用polling/long-polling来传输消息，那么相比直接向站点服务器进行polling/long-polling，有什么优势吗？&lt;/p&gt;
&lt;p&gt;我认为优势有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NodeJS的异步事件回调的方式，适合大并发长连接的应用场景。如果Web后端是使用PHP等实现，则更适合短连接的服务。&lt;/li&gt;
&lt;li&gt;将站点的业务逻辑与消息推送逻辑解耦，那么浏览器通过polling/long-polling来获取消息时，只是涉及消息推送逻辑，不需要执行业务逻辑的代码，而业务逻辑的代码可能很复杂，每次polling，都需要执行一遍的话，会浪费服务器很多资源。&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="socket.io"></category><category term="消息推送"></category><category term="笔记"></category></entry><entry><title>面向分布式系统工程师的分布式系统理论（译）</title><link href="http://youngsterxyf.github.io/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/" rel="alternate"></link><published>2014-08-10T00:00:00+08:00</published><updated>2014-08-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-08-10:/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/"&gt;Distributed systems theory for the distributed systems engineer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gwen Shapira，大腕级的解决方案架构师（SA），如今 Cloudera 的全职工程师，在&lt;a href="https://twitter.com/gwenshap/status/497203248332165121"&gt; Twitter 上提的一个问题&lt;/a&gt;引起了我的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/"&gt;Distributed systems theory for the distributed systems engineer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gwen Shapira，大腕级的解决方案架构师（SA），如今 Cloudera 的全职工程师，在&lt;a href="https://twitter.com/gwenshap/status/497203248332165121"&gt; Twitter 上提的一个问题&lt;/a&gt;引起了我的思考。&lt;/p&gt;
&lt;p&gt;如果是以前，我可能会回答“嗯，这里有篇 FLP 论文，这里有篇 Paxos 论文，这里还有篇拜占庭将军问题的论文...”，我会罗列一箩筐重要的材料，如果你一头扎进去，至少花费 6 个月的时间才能过一遍这些材料。然而我已逐渐明白推荐大量的理论性的论文通常恰恰是着手学习分布式系统理论的错误方式（除非你在做一个 PhD 项目）。论文通常比较深入难懂，需要认真地研习，通常还需要&lt;em&gt;大量的时间投入（significant experience）&lt;/em&gt;来理清这些论文的重要贡献，以及在整个理论体系中的位置。要求工程师具备这样的专业水平又有多大的意义呢？&lt;/p&gt;
&lt;p&gt;但是，很遗憾，对分布式系统理论方面的重大研究成果和思想进行概括、归纳、背景分析的‘导引’性质的优秀材料非常缺乏；特别是没有居高临下态度的材料。对这块空白区域的思考让我想到了另一个有趣的问题：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一个分布式系统工程师应该知道些什么分布式系统理论？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下，一知半解（a little theory）并不会是一件多危险的事情。因此我尝试整理一个列表，罗列出作为一个分布式系统工程师的我认为能够直接应用于我日常工作的一些基本概念；或者让分布式系统工程师完全有能力设计一个新系统的“筹码”。如果你认为我漏掉了一些东西，请联系我。&lt;/p&gt;
&lt;h4&gt;入门第一步&lt;/h4&gt;
&lt;p&gt;以下 4 篇材料出色地解释了构建分布式系统会遇到的一些挑战，共同概述了一系列分布式系统工程师必须要解决的技术上的难题，为之后章节中更深入的研究做好准备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://book.mixu.net/distsys/"&gt;好玩又实在的分布式系统理论&lt;/a&gt;是一本简短的书籍，其内容覆盖了分布式系统领域的一些基本议题，包括时间的作用及不同的复制策略。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/"&gt;为分布式系统领域新人整理的笔记&lt;/a&gt; - 不是理论对理论地讲述，而是做一个非常好非常实用的平衡，让你对其余材料的阅读能够落地。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.7628"&gt;分布式系统研究综述报告&lt;/a&gt; - 一篇经典的论文，解释了为什么不能将所有远程交互都模拟成和本地对象一样。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing"&gt;关于分布式计算的若干谬论&lt;/a&gt; - 分布式计算方面的8点谬论，提醒系统设计者可能会忘记的几类事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;失败和时间&lt;/h4&gt;
&lt;p&gt;分布式系统工程师需要面对的许多困难最终都可以归咎于两个潜在的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程可能会失败&lt;/li&gt;
&lt;li&gt;不存在一种好的方式来周知目前为止进程已经做了些什么&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程之间对于&lt;em&gt;时间&lt;/em&gt;的认知能共享些什么？哪些失败的场景是能够检测到？什么算法和原语可能被正确地实现？这三个问题有着非常深层的联系。多数时候，我们会假设两个不同节点之间对于时间概念或时间以什么样的速度逝去没有任何可共享的认知。&lt;/p&gt;
&lt;p&gt;你应该知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;失败模式的（部分）分层：&lt;a href="http://www.cse.psu.edu/~gcao/teach/513-00/c7.pdf"&gt;崩溃停止-&amp;gt;排除（omission）&lt;/a&gt;-&amp;gt;&lt;a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance"&gt;拜占庭容错&lt;/a&gt;。你应该理解：在高层次上可能发生的问题在低层次上肯定可能发生，在低层次上不可能发生的问题在高层次上也肯定不可能发生。&lt;/li&gt;
&lt;li&gt;在没有任何共享时钟的情况下如何判断在另一个事件之前是否产生了某事件。这意味着你需要理解 &lt;a href="http://web.stanford.edu/class/cs240/readings/lamport.pdf"&gt;Lamport 时钟&lt;/a&gt;及其一般化的&lt;a href="http://en.wikipedia.org/wiki/Vector_clock"&gt;向量时钟&lt;/a&gt;，也需要阅读一下&lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf"&gt;这篇 Dynamo 论文&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;单个失败发生的可能性对于我们实现正确的分布式系统到底会有多大的影响（请阅读下面关于 FLP 结果的笔记）？&lt;/li&gt;
&lt;li&gt;不同的时间模型：同步、部分同步和异步（若我找到好的参考文献会添加链接）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;容错的基本矛盾&lt;/h4&gt;
&lt;p&gt;一个系统，若要不降级而容忍某些错误的发生，就必须能够好像那些错误没有发生一样地运作。这通常意味着系统的这些部分必须能够冗余地工作，但是非绝对必要地做更多的工作通常会在性能和资源耗用方面产生一些消耗。这是为系统添加容错带来的基本矛盾。&lt;/p&gt;
&lt;p&gt;你应该知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保单拷贝可串行化（single-copy serialisability）的仲裁（quorum）技术。可阅读 &lt;a href="https://ecommons.library.cornell.edu/bitstream/1813/6323/1/82-483.pdf"&gt;Skeen 的原始论文&lt;/a&gt;，但可能更建议阅读&lt;a href="http://en.wikipedia.org/wiki/Quorum_(distributed_computing)"&gt;这个 Wikipedia 词条&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;关于&lt;a href="http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/"&gt;两阶段提交&lt;/a&gt;、&lt;a href="http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/"&gt;三阶段提交&lt;/a&gt;和 &lt;a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/"&gt;Paxos&lt;/a&gt; 算法，以及为什么它们有不同的容错性质。&lt;/li&gt;
&lt;li&gt;最终一致性，及其他技术是如何以弱化对系统行为的保证为代价来尝试避免这种矛盾的。这篇 &lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf"&gt;Dynamo 论文&lt;/a&gt;是一个很好的起点，同时 Pat Helland 的经典之作 &lt;a href="http://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf"&gt;Life Beyond Transactions&lt;/a&gt; 也是必读的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基本的原语&lt;/h4&gt;
&lt;p&gt;分布式系统中很少有大家一致认同的基本构建块，但越来越多地在出现。你应该以下的问题是什么，以及在哪可以找到它们的解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;群首选举（leader election）（例如 &lt;a href="http://en.wikipedia.org/wiki/Bully_algorithm"&gt;Bully 算法&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;一致的快照（例如 Chandy 和 Lamport 所写的&lt;a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf"&gt;经典论文&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;共识（阅读上文提到的关于 2PC 和 Paxos 的博文）&lt;/li&gt;
&lt;li&gt;分布式状态机复制（看看 &lt;a href="http://en.wikipedia.org/wiki/State_machine_replication"&gt;Wikipedia&lt;/a&gt; 就可以，但 &lt;a href="http://research.microsoft.com/en-us/um/people/blampson/58-Consensus/Acrobat.pdf"&gt;Lampson 的论文&lt;/a&gt;更权威，只是枯燥了点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基础结论&lt;/h4&gt;
&lt;p&gt;某些客观事实是需要内化于心的，以下是几个关键点（a flavour）（当然还有更多）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果进程之间可能丢失某些消息，那么不可能在实现一致性存储的同时能响应所有的请求。这就是 &lt;a href="http://lpd.epfl.ch/sgilbert/pubs/BrewersConjecture-SigAct.pdf"&gt;CAP 定理&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;以这样一种方式（a.始终是正确的、b.始终能终止-若在一个可能因失败崩溃停止（crash-* stop failures）的异步系统中有（甚至仅）一台机器失效时（FLP 的结果））。我希望在&lt;a href="http://www.slideshare.net/HenryRobinson/pwl-nonotes"&gt;洛杉矶题为 Papers We Love 报告&lt;/a&gt;的第一部分幻灯片-进行证明之前-已经合理地解释了这个结论。&lt;em&gt;建议：没有实际的必要理解这个证明。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;一般而言，消息交互少于两轮是不可能达成共识（Consensus）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;真实系统&lt;/h4&gt;
&lt;p&gt;最重要的练习是重复地阅读新兴的、真实系统的描述，并尝试评价它们的设计决策。一遍又一遍地这样去做。一些建议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/gfs-sosp2003.pdf"&gt;GFS&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/spanner-osdi2012.pdf"&gt;Spanner&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41344.pdf"&gt;F1&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/chubby-osdi06.pdf"&gt;Chubby&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/bigtable-osdi06.pdf"&gt;BigTable&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41378.pdf"&gt;MillWheel&lt;/a&gt;、&lt;a href="http://eurosys2013.tudos.org/wp-content/uploads/2013/paper/Schwarzkopf.pdf"&gt;Omega&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf"&gt;Dapper&lt;/a&gt;、&lt;a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf"&gt;Paxos Made Live&lt;/a&gt;、&lt;a href="http://cacm.acm.org/magazines/2013/2/160173-the-tail-at-scale/abstract"&gt;The Tail At Scale&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Not Google:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://research.microsoft.com/en-us/projects/dryad/eurosys07.pdf"&gt;Dryad&lt;/a&gt;, &lt;a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf"&gt;Cassandra&lt;/a&gt;, &lt;a href="http://ceph.com/papers/weil-ceph-osdi06.pdf"&gt;Ceph&lt;/a&gt;, &lt;a href="https://ramcloud.stanford.edu/wiki/display/ramcloud/RAMCloud+Papers"&gt;RAMCloud&lt;/a&gt;, &lt;a href="http://hyperdex.org/papers/"&gt;HyperDex&lt;/a&gt;, &lt;a href="http://www.mpi-sws.org/~druschel/courses/ds/papers/cooper-pnuts.pdf"&gt;PNUTS&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="分布式系统"></category><category term="翻译"></category></entry><entry><title>技术问题一问一答</title><link href="http://youngsterxyf.github.io/2014/06/26/recently-technology-tips/" rel="alternate"></link><published>2014-06-26T00:00:00+08:00</published><updated>2014-06-26T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-06-26:/2014/06/26/recently-technology-tips/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何方便地删除某目录下所有空文件？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;find . -size 0 -exec rm {} \;&lt;/code&gt; 或 &lt;code&gt;find . -size 0 | xargs rm -f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;find默认会递归遍历所有子目录，如果想只在当前目录查找，可以添加参数&lt;code&gt;-prune&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何查 …&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何方便地删除某目录下所有空文件？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;find . -size 0 -exec rm {} \;&lt;/code&gt; 或 &lt;code&gt;find . -size 0 | xargs rm -f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;find默认会递归遍历所有子目录，如果想只在当前目录查找，可以添加参数&lt;code&gt;-prune&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何查看某进程打开了哪些文件？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先通过&lt;code&gt;ps aux | grep [进程名]&lt;/code&gt;找到该进程的进程号，然后&lt;code&gt;ls -la /proc/[进程号]/fd&lt;/code&gt;，输出不仅包含打开的普通文件。&lt;/p&gt;
&lt;p&gt;另一种不太直观的方法是使用lsof，&lt;code&gt;lsof -c [进程名]&lt;/code&gt;，但这个命令的输出包含进程打开的各种类型的文件，可以简单过滤一下&lt;code&gt;lsof -c [进程名] | grep REG&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何重启php-fpm？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;php5.3.3以上版本的php-fpm不再支持php-fpm以前具有的&lt;code&gt;php-fpm (start|stop|reload)&lt;/code&gt;等命令，需要使用信号控制。
master进程可以理解以下信号：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;INT, TERM 立刻终止&lt;/li&gt;
&lt;li&gt;QUIT 平滑终止&lt;/li&gt;
&lt;li&gt;USR1 重新打开日志文件&lt;/li&gt;
&lt;li&gt;USR2 平滑重载所有worker进程并重新载入配置和二进制模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么应该这样重启php-fpm：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kill -USR2 $(cat php-fpm.pid)&lt;/code&gt; 或 先&lt;code&gt;ps aux | grep php-fpm&lt;/code&gt;找到php-fpm主进程的进程号，然后&lt;code&gt;kill -USR2 [进程号]&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于Nginx、php-fpm等的日志文件使用shell脚本进行切分备份时，发现Nginx、php-fpm还是往备份的老文件中，而不是往新的access.log或error.log文件中写日志，如何解决？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;shell脚本中通常使用mv + touch 或 cp + touch的方式对日志文件进行备份。由于Nginx或php-fpm进程其实只知道日志文件打开后的文件描述符，而不知道打开的是哪个文件。使用mv或cp备份文件后，应该是修改了内核中文件描述符对应的文件路径（我猜的！），但Nginx或php-fpm并不知道现在该文件描述符指向的不再是原来的日志文件。所以解决方法就是通知Nginx或php-fpm根据配置重新打开日志文件。根据前一个问题，可知可以通过kill命令给进程发送USR1信号来实现。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;kill -USR1 &lt;span style="color: #a31515"&gt;`&lt;/span&gt;cat php-fpm.pid&lt;span style="color: #a31515"&gt;`&lt;/span&gt;
kill -USR1 &lt;span style="color: #a31515"&gt;`&lt;/span&gt;cat nginx.pid&lt;span style="color: #a31515"&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作中使用git的分支模式进行协作开发，需要在测试服务器（HTTP Server使用Nginx，应用程序基于PHP的Yii框架实现）上为每个分支开一个测试环境，为了标识使用方便，希望使用同一个HTTP端口，不同的URL前缀标识不同的分支，如master分支的URL为/master/，其他分支的URL为/test/[分支名]/。该如何配置Nginx的虚拟主机？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们的应用使用Yii框架默认的URL风格(/?r=controller/action)，意味着所有非静态内容(非js、css、图片等)请求指向的服务器资源都是相同的（如&lt;code&gt;/&lt;/code&gt;或&lt;code&gt;/xxx/&lt;/code&gt;），而Yii框架的请求处理入口统一为一个index.php文件。Nginx有一个配置变量&lt;code&gt;$uri&lt;/code&gt;，保存着请求的URL（不带请求参数）。那么可以让所有分支的测试环境共用一个root，再将所有非静态内容请求重定向到&lt;code&gt;$uri/index.php&lt;/code&gt;就可以了。对于静态文件请求让其根据路径直接获取文件内容即可。但还有一个问题，怎么让分支代码中所有静态文件超链接都带上分支对应的URL前缀？可以通过为Yii配置一个名为url_prefix的参数，指定该分支所使用的URL前缀，然后在HTML模板（我们使用smarty来渲染）中让所有静态文件超链接都带上这个URL前缀参数。&lt;/p&gt;
&lt;p&gt;根据&lt;a href="http://www.yiiframework.com/doc/guide/1.1/en/quickstart.apache-nginx-config#nginx"&gt;Yii官方文档给出的Nginx虚拟主机配置&lt;/a&gt;进行修改得到我们需要的配置，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;listen 80;
server_name  localhost;

root html;
set $yii_bootstrap &amp;quot;index.php&amp;quot;;
location / {
    index index.html $yii_bootstrap;
    try_files $uri $uri/ $uri/$yii_bootstrap?$args;
}

location ~ ^/(protected|framework|themes/\w+/views) {
    deny all;
}

location ~ \.(js|css|png|jpg|gif|swf|ico|pdf|mov|fla|zip|rar)$ {
    try_files $uri =404;
}

location ~ \.php {
    fastcgi_split_path_info ^(.+\.php)(.*)$;

    set $fsn /$yii_bootstrap;
    if (-f $document_root$fastcgi_script_name){
        set $fsn $fastcgi_script_name;
    }

    fastcgi_pass 127.0.0.1:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root$fsn;

    fastcgi_param PATH_INFO $fastcgi_path_info;
    fastcgi_param PATH_TRANSLATED $document_root$fsn;
}

location ~ /\. {
    deny all;
    access_log off;
    log_not_found off;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="笔记"></category></entry><entry><title>微信服务号开发笔记</title><link href="http://youngsterxyf.github.io/2014/06/14/wechat-service-account-development/" rel="alternate"></link><published>2014-06-14T00:00:00+08:00</published><updated>2014-06-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-06-14:/2014/06/14/wechat-service-account-development/</id><summary type="html">&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;微信服务号的原理比较简单。从请求响应角度来看，逻辑是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户微信客户端 &amp;lt;---&amp;gt; 微信服务器 &amp;lt;---&amp;gt; 微信服务号后台程序 &amp;lt;---&amp;gt; 数据库 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;微信服务号的原理比较简单。从请求响应角度来看，逻辑是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户微信客户端 &amp;lt;---&amp;gt; 微信服务器 &amp;lt;---&amp;gt; 微信服务号后台程序 &amp;lt;---&amp;gt; 数据库或Web Service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是，用户的各种请求先经过微信的服务器，微信服务器将请求转发给微信服务号后台程序。&lt;/p&gt;
&lt;p&gt;既然是微信服务器把用户请求数据转发给我们开发的微信服务号后台程序，那么在启用服务号的开发模式时就需要提供一个URL。另外为了安全
考虑，还需要提供一个token，用来校验请求是否来自微信服务器。校验的方法见&lt;a href="http://mp.weixin.qq.com/wiki/index.php?title=%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF%E7%9C%9F%E5%AE%9E%E6%80%A7"&gt;微信开发者文档&lt;/a&gt;。校验又分两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在开发者首次提交验证申请时，微信服务器将发送GET请求到填写的URL上，并且带上四个参数（signature、timestamp、nonce、echostr），开发者通过对签名（即signature）的效验，来判断此条消息的真实性。&lt;/p&gt;
&lt;p&gt;此后，每次开发者接收用户消息的时候，微信也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微信服务器转发到微信服务号后台程序的消息以及服务号后台程序返回给微信服务器的响应，都是XML格式，消息中都会指明发送者和接收者。
请求消息中的发送者为微信用户的openid，接收者为服务号开发者微信号，响应消息则相反。&lt;/p&gt;
&lt;p&gt;消息中还有一个关键字段MsgType指明消息类型。微信将请求消息分为：普通消息、事件推送、语音识别结果三大类，其中，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通消息分6种：文本、图片、语音、视频、地理位置、链接。&lt;/li&gt;
&lt;li&gt;事件推送分4种：关注/取消关注事件、扫描带参数二维码事件、上报地理位置事件、自定义菜单事件(点击菜单拉取消息时的事件推送、点击菜单跳转链接时的事件推送)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;响应消息也分6种：文本、图片、语音、视频、音乐、图文。&lt;/p&gt;
&lt;p&gt;工作中为产品开发的微信服务号，目前对于普通消息，服务号后台程序自动响应一段文本消息；对于事件推送中的关注事件，则是响应一段欢迎、
功能简介的文本消息。&lt;/p&gt;
&lt;p&gt;另外我们使用了自定义菜单事件，要想使用该事件，先要为你的微信服务号提供自定义菜单。自定义菜单是通过微信提供的API向其推送的。&lt;/p&gt;
&lt;p&gt;在通过API向微信服务器推送自定义菜单时，微信服务器需要确认是否为可信任请求，确认方法是基于请求参数access_token。
access_token需要通过API向微信服务器获取。成功启用服务号的开发模式后，微信会为服务号分配一个AppId和AppSecret，获取access_token时
需要带上这两个参数，用于微信服务器确认是否为已注册服务号的请求。access_token相关文档见&lt;a href="http://mp.weixin.qq.com/wiki/index.php?title=%E8%8E%B7%E5%8F%96access_token"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当成功获取access_token后就可以通过API创建、删除、查询服务号的自定义菜单了。&lt;/p&gt;
&lt;p&gt;自定义菜单相关文档见&lt;a href="http://mp.weixin.qq.com/wiki/index.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;以下Python代码是对自定义菜单API的简单封装：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;#coding: utf-8&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; requests
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; os
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; json
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; time


&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;WechatAdmin&lt;/span&gt;:
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self):
        self.app_id = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
        self.app_secret = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
        self.session = requests.session()
        self.access_token_file = &lt;span style="color: #a31515"&gt;&amp;#39;access_token.json&amp;#39;&lt;/span&gt;
        self.access_token = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fetch_access_token(self):
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; self.access_token != &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;:
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; self.access_token
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; os.path.exists(self.access_token_file):
            &lt;span style="color: #0000ff"&gt;with&lt;/span&gt; open(self.access_token_file) &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; fh:
                origin_content = json.load(fh)
                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; float(origin_content[&lt;span style="color: #a31515"&gt;&amp;#39;update_time&amp;#39;&lt;/span&gt;]) + float(origin_content[&lt;span style="color: #a31515"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;]) &amp;lt; time.time():
                    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; self._remote_fetch_access_token()
                &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
                    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; origin_content[&lt;span style="color: #a31515"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;]
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; self._remote_fetch_access_token()

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; _remote_fetch_access_token(self):
        target_url = &lt;span style="color: #a31515"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=%s&amp;amp;secret=%s&amp;#39;&lt;/span&gt; \
                     % (self.app_id, self.app_secret)
        r = self.session.get(target_url)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; r.status_code == 200:
            response_data = r.json()
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; response_data.get(&lt;span style="color: #a31515"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;) != &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; response_data.get(&lt;span style="color: #a31515"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;) != &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;:
                new_access_token, expires_in = response_data[&lt;span style="color: #a31515"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;], response_data[&lt;span style="color: #a31515"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;]
                &lt;span style="color: #0000ff"&gt;with&lt;/span&gt; open(self.access_token_file, &lt;span style="color: #a31515"&gt;&amp;#39;w+&amp;#39;&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; fh:
                    json.dump({&lt;span style="color: #a31515"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;: new_access_token, &lt;span style="color: #a31515"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;: str(int(expires_in) - 20),
                               &lt;span style="color: #a31515"&gt;&amp;#39;update_time&amp;#39;&lt;/span&gt;: time.time()}, fh)
                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; new_access_token
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; Exception(&lt;span style="color: #a31515"&gt;u&amp;#39;响应内容不对！&amp;#39;&lt;/span&gt;)
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
            &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; Exception(&lt;span style="color: #a31515"&gt;u&amp;#39;非正常响应，%d&amp;#39;&lt;/span&gt; % (r.status_code,))

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; create_menu(self, content):
        menu_create_api = &lt;span style="color: #a31515"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=%s&amp;#39;&lt;/span&gt;
        target_url = menu_create_api % (self.fetch_access_token(),)
        &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
            r = self.session.post(target_url, data=content)
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; r.status_code == 200:
                print r.json()
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; Exception(&lt;span style="color: #a31515"&gt;u&amp;#39;非正常响应, %d&amp;#39;&lt;/span&gt; % (r.status_code,))
        &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; Exception &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
            print e.message
            self._remote_fetch_access_token()
            self.create_menu(content)

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fetch_menu(self):
        target_url = &lt;span style="color: #a31515"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/menu/get?access_token=%s&amp;#39;&lt;/span&gt; % (self.fetch_access_token(),)
        &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
            r = self.session.get(target_url)
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; r.status_code == 200:
                print r.json()
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; Exception(&lt;span style="color: #a31515"&gt;u&amp;#39;非正常响应，%d, %s&amp;#39;&lt;/span&gt; % (r.status_code, r.text))
        &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; Exception &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
            print e.message
            self._remote_fetch_access_token()
            self.fetch_menu()

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; delete_menu(self):
        target_url = &lt;span style="color: #a31515"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=%s&amp;#39;&lt;/span&gt; % (self.fetch_access_token(),)
        &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
            r = self.session.get(target_url)
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; r.status_code == 200:
                print r.json()
            &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; Exception(&lt;span style="color: #a31515"&gt;u&amp;#39;非正常响应, %d, %s&amp;#39;&lt;/span&gt; % (r.status_code, r.text))
        &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; Exception &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
            print e.message
            self._remote_fetch_access_token()
            self.delete_menu()


&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; main():
    wechat = WechatAdmin()
    &lt;span style="color: #008000"&gt;# print wechat.fetch_access_token()&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;with&lt;/span&gt; open(&lt;span style="color: #a31515"&gt;&amp;#39;menus.json&amp;#39;&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; fh:
        wechat.create_menu(fh.read())

    wechat.fetch_menu()
    &lt;span style="color: #008000"&gt;# wechat.delete_menu()&lt;/span&gt;


&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;开发&lt;/h3&gt;
&lt;p&gt;对于微信服务号后台程序，当然可以参照微信官方文档，从头开始实现。但可用非官方微信公众号SDK也不少。比如我使用的PHP
SDK是&lt;a href="https://github.com/netputer/wechat-php-sdk"&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其他语言的SDK也可以找找看。&lt;/p&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我在启用微信服务号的开发模式之后，就直接使用该服务号进行开发测试，但在开发测试过程中，已经有一些产品的用户关注了该服务号，那么这个过程中用户的体验会很差。正确的过程应该是&lt;strong&gt;先申请测试帐号进行开发测试，等开发测试完成后，再上线服务号&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义菜单在变更之后并不是实时更新的，官方文档的说明是：&lt;em&gt;创建自定义菜单后，由于微信客户端缓存，需要24小时微信客户端才会展现出来。建议测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微信客户端应该是基于浏览器内核技术的，所以能解释渲染网页元素。图文消息中图片其实是一个img元素，所以需要你自己提供图床。微信官方的公众平台提供的消息发送功能，对于图文消息要求必须带图片，但服务号后台程序响应的图文消息中其实可以留空图片链接，这样用户收到图文消息看到的效果也许就是你需要的。另外，文本消息也是可以带超链接a元素的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="微信"></category><category term="PHP"></category><category term="笔记"></category></entry><entry><title>高流量站点NGINX与PHP-fpm配置优化（译）</title><link href="http://youngsterxyf.github.io/2014/05/03/optimizing-nginx-and-php-fpm-for-high-traffic-sites/" rel="alternate"></link><published>2014-05-03T00:00:00+08:00</published><updated>2014-05-03T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-05-03:/2014/05/03/optimizing-nginx-and-php-fpm-for-high-traffic-sites/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.softwareprojects.com/resources/programming/t-optimizing-nginx-and-php-fpm-for-high-traffic-sites-2081.html"&gt;Optimizing NGINX and PHP-fpm for high traffic sites&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Nginx搭配PHP已有7年的这份经历让我们学会如何为高流量站点优化NGINX和PHP-fpm配置。&lt;/p&gt;
&lt;p&gt;以下正是这方面的一些提示和建议：&lt;/p&gt;
&lt;h4&gt;1. 将TCP切换为UNIX域套接字&lt;/h4&gt;
&lt;p&gt;UNIX域套接字相比TCP套接字在loopback接口上能提供更好的性能（更少的数据拷贝和上下文切换）。&lt;/p&gt;
&lt;p&gt;但有 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://www.softwareprojects.com/resources/programming/t-optimizing-nginx-and-php-fpm-for-high-traffic-sites-2081.html"&gt;Optimizing NGINX and PHP-fpm for high traffic sites&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Nginx搭配PHP已有7年的这份经历让我们学会如何为高流量站点优化NGINX和PHP-fpm配置。&lt;/p&gt;
&lt;p&gt;以下正是这方面的一些提示和建议：&lt;/p&gt;
&lt;h4&gt;1. 将TCP切换为UNIX域套接字&lt;/h4&gt;
&lt;p&gt;UNIX域套接字相比TCP套接字在loopback接口上能提供更好的性能（更少的数据拷贝和上下文切换）。&lt;/p&gt;
&lt;p&gt;但有一点需要牢记：仅运行在同一台服务器上的程序可以访问UNIX域套接字（显然没有网络支持）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;upstream backend
{
    # UNIX domain sockets
    server unix:/var/run/fastcgi.sock;

    # TCP sockets
    # server 127.0.0.1:8080;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2. 调整工作进程数&lt;/h4&gt;
&lt;p&gt;现代计算机硬件是多处理器的，NGINX可以利用多物理或虚拟处理器。&lt;/p&gt;
&lt;p&gt;多数情况下，你的Web服务器都不会配置为处理多种任务（比如作为Web服务器提供服务的同时也是一个打印服务器），你可以配置NGINX使用所有可用的处理器，NGINX工作进程并不是多线程的。&lt;/p&gt;
&lt;p&gt;运行以下命令可以获知你的机器有多少个处理器：&lt;/p&gt;
&lt;p&gt;Linux上 -&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat /proc/cpuinfo | grep processor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;FreeBSD上 -&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sysctl dev .cpu | grep location
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将nginx.conf文件中work_processes的值设置为机器的处理器核数。&lt;/p&gt;
&lt;p&gt;同时，增大worker_connections（每个处理器核心可以处理多少个连接）的值，以及将"multi_accept"设置为ON，如果你使用的是Linux，则也使用"epoll"：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# We have 16 cores
worker_processes 16;

# connections per worker
events
{
    worker_connections 4096;
    multi_accept on;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3. 设置upstream负载均衡&lt;/h4&gt;
&lt;p&gt;以我们的经验来看，同一台机器上多个upstream后端相比单个upstream后端能够带来更高的吞吐量。&lt;/p&gt;
&lt;p&gt;例如，如果你想支持最大1000个PHP-fpm子进程（children），可以将该数字平均分配到两个upstream后端，各自处理500个PHP-fpm子进程：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;upstream backend {
    server unix:/var/run/php5-fpm.sock1 weight=100 max_fails=5 fail_timeout=5;
    server unix:/var/run/php5-fpm.sock2 weight=100 max_fails=5 fail_timeout=5;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下是两个来自php-fpm.conf的进程池：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;section name=&amp;quot;pool&amp;quot;&amp;gt;

    &amp;lt;value name=&amp;quot;name&amp;quot;&amp;gt;www1&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;listen_address&amp;quot;&amp;gt;/var/run/php5-fpm.sock1&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;listen_options&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;backlog&amp;quot;&amp;gt;-1&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;owner&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;mode&amp;quot;&amp;gt;0666&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;user&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;pm&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;style&amp;quot;&amp;gt;static&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;max_children&amp;quot;&amp;gt;500&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;rlimit_files&amp;quot;&amp;gt;50000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;rlimit_core&amp;quot;&amp;gt;0&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;request_slowlog_timeout&amp;quot;&amp;gt;20s&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;slowlog&amp;quot;&amp;gt;/var/log/php-slow.log&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chroot&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chdir&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;catch_workers_output&amp;quot;&amp;gt;no&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;max_requests&amp;quot;&amp;gt;5000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;allowed_clients&amp;quot;&amp;gt;127.0.0.1&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;environment&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;HOSTNAME&amp;quot;&amp;gt;$HOSTNAME&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;PATH&amp;quot;&amp;gt;/usr/local/bin:/usr/bin:/bin&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMPDIR&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TEMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;OSTYPE&amp;quot;&amp;gt;$OSTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MACHTYPE&amp;quot;&amp;gt;$MACHTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MALLOC_CHECK_&amp;quot;&amp;gt;2&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

&amp;lt;/section&amp;gt;

&amp;lt;section name=&amp;quot;pool&amp;quot;&amp;gt;

    &amp;lt;value name=&amp;quot;name&amp;quot;&amp;gt;www2&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;listen_address&amp;quot;&amp;gt;/var/run/php5-fpm.sock2&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;listen_options&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;backlog&amp;quot;&amp;gt;-1&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;owner&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;mode&amp;quot;&amp;gt;0666&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;user&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;pm&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;style&amp;quot;&amp;gt;static&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;max_children&amp;quot;&amp;gt;500&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;rlimit_files&amp;quot;&amp;gt;50000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;rlimit_core&amp;quot;&amp;gt;0&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;request_slowlog_timeout&amp;quot;&amp;gt;20s&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;slowlog&amp;quot;&amp;gt;/var/log/php-slow.log&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chroot&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chdir&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;catch_workers_output&amp;quot;&amp;gt;no&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;max_requests&amp;quot;&amp;gt;5000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;allowed_clients&amp;quot;&amp;gt;127.0.0.1&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;environment&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;HOSTNAME&amp;quot;&amp;gt;$HOSTNAME&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;PATH&amp;quot;&amp;gt;/usr/local/bin:/usr/bin:/bin&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMPDIR&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TEMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;OSTYPE&amp;quot;&amp;gt;$OSTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MACHTYPE&amp;quot;&amp;gt;$MACHTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MALLOC_CHECK_&amp;quot;&amp;gt;2&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4. 禁用访问日志文件&lt;/h4&gt;
&lt;p&gt;这一点影响较大，因为高流量站点上的日志文件涉及大量必须在所有线程之间同步的IO操作。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;access_log off;
log_not_found off;
error_log /var/log/nginx-error.log warn;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;若你不能关闭访问日志文件，至少应该使用缓冲：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;access_log /var/log/nginx/access.log main buffer=16k;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;5. 启用GZip&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;gzip on;
gzip_disable &amp;quot;msie6&amp;quot;;
gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_min_length 1100;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;6. 缓存被频繁访问的文件相关的信息&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;open_file_cache max=200000 inactive=20s;
open_file_cache_valid 30s;
open_file_cache_min_uses 2;
open_file_cache_errors on;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;7. 调整客户端超时时间&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;client_max_body_size 500M;
client_body_buffer_size 1m;
client_body_timeout 15;
client_header_timeout 15;
keepalive_timeout 2 2;
send_timeout 15;
sendfile on;
tcp_nopush on;
tcp_nodelay on;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;8. 调整输出缓冲区大小&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fastcgi_buffers 256 16k;
fastcgi_buffer_size 128k;
fastcgi_connect_timeout 3s;
fastcgi_send_timeout 120s;
fastcgi_read_timeout 120s;
reset_timedout_connection on;
server_names_hash_bucket_size 100;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;9. /etc/sysctl.conf调优&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Recycle Zombie connections
net.inet.tcp.fast_finwait2_recycle=1
net.inet.tcp.maxtcptw=200000

# Increase number of files
kern.maxfiles=65535
kern.maxfilesperproc=16384

# Increase page share factor per process
vm.pmap.pv_entry_max=54272521
vm.pmap.shpgperproc=20000

# Increase number of connections
vfs.vmiodirenable=1
kern.ipc.somaxconn=3240000
net.inet.tcp.rfc1323=1
net.inet.tcp.delayed_ack=0
net.inet.tcp.restrict_rst=1
kern.ipc.maxsockbuf=2097152
kern.ipc.shmmax=268435456

# Host cache
net.inet.tcp.hostcache.hashsize=4096
net.inet.tcp.hostcache.cachelimit=131072
net.inet.tcp.hostcache.bucketlimit=120

# Increase number of ports
net.inet.ip.portrange.first=2000
net.inet.ip.portrange.last=100000
net.inet.ip.portrange.hifirst=2000
net.inet.ip.portrange.hilast=100000
kern.ipc.semvmx=131068

# Disable Ping-flood attacks
net.inet.tcp.msl=2000
net.inet.icmp.bmcastecho=1
net.inet.icmp.icmplim=1
net.inet.tcp.blackhole=2
net.inet.udp.blackhole=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;10. 监控&lt;/h4&gt;
&lt;p&gt;持续监控打开连接的数目，空闲内存以及等待状态线程的数目。&lt;/p&gt;
&lt;p&gt;设置警报在超出阈值时通知你。你可以自己构建这些警报，或者使用类似&lt;a href="http://serverdensity.io"&gt;ServerDensity&lt;/a&gt;的东西。&lt;/p&gt;
&lt;p&gt;确认安装了NGINX的&lt;a href="http://wiki.nginx.org/HttpStubStatusModule"&gt;stub_status&lt;/a&gt;模块。该模块默认并不会编译进NGINX，所以可能你需要重新编译NGINX -&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;./configure --with-http_ssl_module --with-http_stub_status_module --without-mail_pop3_module
--without-mail_imap_module --without-mail_smtp_module
make install BATCH=yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Nginx"></category><category term="PHP"></category><category term="服务器"></category></entry><entry><title>Firefox中“max-width:100%”不兼容问题</title><link href="http://youngsterxyf.github.io/2014/04/28/max-width-in-firefox/" rel="alternate"></link><published>2014-04-28T00:00:00+08:00</published><updated>2014-04-28T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-04-28:/2014/04/28/max-width-in-firefox/</id><summary type="html">&lt;p&gt;这个博客是基于“&lt;a href="http://docs.getpelican.com/en/3.3.0/"&gt;Pelican&lt;/a&gt; + &lt;a href="http://wowubuntu.com/markdown/"&gt;Markdown&lt;/a&gt; +
&lt;a href="https://github.com/youngsterxyf/my-pelican-themes/tree/master/my-gum"&gt;定制的my-gum主题&lt;/a&gt;”的。定制的主题将博文正文页面的
右边栏去掉，这导致在Firefox等浏览器中，正文中大的图片会突破正文块 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这个博客是基于“&lt;a href="http://docs.getpelican.com/en/3.3.0/"&gt;Pelican&lt;/a&gt; + &lt;a href="http://wowubuntu.com/markdown/"&gt;Markdown&lt;/a&gt; +
&lt;a href="https://github.com/youngsterxyf/my-pelican-themes/tree/master/my-gum"&gt;定制的my-gum主题&lt;/a&gt;”的。定制的主题将博文正文页面的
右边栏去掉，这导致在Firefox等浏览器中，正文中大的图片会突破正文块的宽度，高度也得不到限制，显示效果非常差。&lt;/p&gt;
&lt;p&gt;其原因是：Markdown的&lt;a href="http://wowubuntu.com/markdown/#img"&gt;图片区块元素&lt;/a&gt;&lt;code&gt;![Alt
text](/path/to/img.jpg)&lt;/code&gt;渲染成HTML元素的结果为 -&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    &amp;lt;img src=&lt;span style="color: #a31515"&gt;&amp;quot;/path/to/img.jpg&amp;quot;&lt;/span&gt; alt=&lt;span style="color: #a31515"&gt;&amp;quot;Alt text&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/img&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素内的元素是行内(inline)元素。主题my-gum使用的CSS框架&lt;a href="http://gumbyframework.com/"&gt;gumby&lt;/a&gt;对img元素是使用&lt;code&gt;max-width:
100%&lt;/code&gt;将图片的最大宽度限制为父元素的宽度。但&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/max-width"&gt;在Firefox中max-width对于行内元素并不会生效(all elements but non-replaced 
inline elements, table rows, and row
groups)&lt;/a&gt;，所以造成了显示问题。&lt;/p&gt;
&lt;p&gt;网络上有人说可以用&lt;code&gt;width: 100%&lt;/code&gt;替代之，但&lt;code&gt;width: 100%&lt;/code&gt;和&lt;code&gt;max-width: 100%&lt;/code&gt;的区别是：&lt;code&gt;width: 100%&lt;/code&gt;是将所有指定元素的宽度
拉伸或收缩到和父元素的宽度一致，而&lt;code&gt;max-width:
100%&lt;/code&gt;则是如果指定元素的宽度不超过父元素的宽度，则大小不变，如果超过了父元素的宽度，则将宽度收缩为父元素的宽度。如果使用&lt;code&gt;width:
100%&lt;/code&gt;，那么我博文中的图片，即使再小，都会被拉伸为正文的宽度，自然是不会好看的。&lt;/p&gt;
&lt;p&gt;我的想法是：既然使用CSS不能解决这个问题，那就尝试使用Javascript。当图片加载完毕后，将图片宽度与正文宽度做比较，如果
图片宽度大于正文宽度，则为该图片设置&lt;code&gt;width: 100%&lt;/code&gt;。唯一不完美的地方是某些大图片加载完毕之前的宽度很大，比较难看。&lt;/p&gt;
&lt;p&gt;代码如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$(&lt;span style="color: #0000ff"&gt;function&lt;/span&gt;() {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; entryContentWidth = $(&lt;span style="color: #a31515"&gt;&amp;#39;.row&amp;#39;&lt;/span&gt;).width();

    $(&lt;span style="color: #a31515"&gt;&amp;#39;.entry-content img&amp;#39;&lt;/span&gt;).on(&lt;span style="color: #a31515"&gt;&amp;#39;load&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;function&lt;/span&gt;(){
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($(&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;).width() &amp;gt; entryContentWidth) {
            $(&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;).width(&lt;span style="color: #a31515"&gt;&amp;#39;100%&amp;#39;&lt;/span&gt;);
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/14550356/image-mysteriously-ignoring-max-width-in-firefox-ie"&gt;Image mysteriously ignoring max-width in Firefox &amp;amp; IE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2789727/is-p-a-block-level-or-inline-level-element"&gt;is &amp;lt;p&amp;gt; a block-level or inline-level element?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/max-width"&gt;MDN - max-width&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://api.jquery.com/load-event/"&gt;JQuery - load event&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="CSS"></category><category term="浏览器兼容"></category><category term="JavaScript"></category></entry><entry><title>Windows命令提示符中统计行数（译）</title><link href="http://youngsterxyf.github.io/2014/03/05/counting-lines-in-cmd/" rel="alternate"></link><published>2014-03-05T00:00:00+08:00</published><updated>2014-03-05T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-03-05:/2014/03/05/counting-lines-in-cmd/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://rickardnobel.se/counting-lines-in-windows-command-prompt/"&gt;Counting lines in Windows command prompt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用内置工具FIND统计cmd.exe输出的行数非常方便！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在命令行环境中工作时，能够统计不同工具的输出结果的行数有时会非常 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://rickardnobel.se/counting-lines-in-windows-command-prompt/"&gt;Counting lines in Windows command prompt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用内置工具FIND统计cmd.exe输出的行数非常方便！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在命令行环境中工作时，能够统计不同工具的输出结果的行数有时会非常有用。许多Unix/Linux操作系统都包含带有许多功能选项的&lt;strong&gt;wc&lt;/strong&gt;
工具，Windows则没有内置一样的替代品，但是Windows命令提示符(cmd.exe)原生支持了部分相同功能。&lt;/p&gt;
&lt;p&gt;本文将讲述在cmd.exe中我们可以如何使用&lt;strong&gt;FIND&lt;/strong&gt;工具来统计行数。工具find，有些类似于Unix上的grep，自MS-DOS以来就一直存在，
使用简单。&lt;/p&gt;
&lt;p&gt;假设我们有一台Windows服务器，想看看当前有多少个活跃的TCP会话。这可以使用netstat命令，并且通过管道连接FIND来查找已建立的会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;netstat -ano | find /i "estab"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="established-TCP-2.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/established-TCP-2.png"&gt;&lt;/p&gt;
&lt;p&gt;这行命令的输出可能会有几百行以至于占满整个命令提示符窗口，而我们可能仅仅关心会话的数目。通过在这行命令之后增加一个&lt;strong&gt;/c&lt;/strong&gt;开关选项，
我们就能得到打开的TCP会话的数目。&lt;/p&gt;
&lt;p&gt;我们仍然使用上一个命令的过滤规则（通过查找字符串“estab”来找到包含ESTABLISHED状态的行）但带有/c，这样就会仅显现匹配行的数目。&lt;/p&gt;
&lt;p&gt;&lt;img alt="established-TCP.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/established-TCP.png"&gt;&lt;/p&gt;
&lt;p&gt;如下另一个示例则是查看本地缓存的DNS记录的数目。&lt;/p&gt;
&lt;p&gt;&lt;img alt="displaydns.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/displaydns.png"&gt;&lt;/p&gt;
&lt;p&gt;选项/c也可以用于统计一个命令输出的所有行。例如，我们想知道目录服务(Active Directory)中分组的数目。通过一个管道连接到&lt;strong&gt;FIND /v "" /c&lt;/strong&gt;，
我们能统计所有不匹配(&lt;strong&gt;/v&lt;/strong&gt;)空字符串（""）的行（即非空白行）。如果你使用过Unix工具wc，这就相当于&lt;strong&gt;wc -l&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="find-group-2.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/find-group-2.png"&gt;&lt;/p&gt;
&lt;p&gt;另一个示例是：事件查看器命令行工具&lt;strong&gt;wevtutil&lt;/strong&gt;会输出大量日志数据行。如果仅仅想知道现代Windows系统中不同日志的数目，我们可以将几百个日志文件的文件名
通过管道传输给&lt;code&gt;FIND /v "" /c&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="wevutil.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/wevutil.png"&gt;&lt;/p&gt;
&lt;p&gt;最后一个示例是：假设有一个日志文件或者类似文件，总共有上千行内容。我们想快速知道包含特定短语的数据行的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TYPE C:\Windows\Schedlgu.txt | FIND /i "task failure" /c&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;相关阅读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc725655.aspx"&gt;Technet - Find&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.robvanderwoude.com/type.php"&gt;The TYPE command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc732507.aspx"&gt;Technet - Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc732848.aspx"&gt;Technet - Wevtutil&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc732952.aspx"&gt;Technet - Dsquery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Windows"></category><category term="翻译"></category></entry><entry><title>读书笔记：Web容量规划的艺术</title><link href="http://youngsterxyf.github.io/2014/02/25/read-the-art-of-capacity-planning/" rel="alternate"></link><published>2014-02-25T00:00:00+08:00</published><updated>2014-02-25T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-02-25:/2014/02/25/read-the-art-of-capacity-planning/</id><summary type="html">&lt;h3&gt;第1章 容量规划的目标、问题和过程&lt;/h3&gt;
&lt;p&gt;了解你的基础设施中每一部分何时会失败（最好不发生）对容量规划至关重要。&lt;/p&gt;
&lt;p&gt;假设你有 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;第1章 容量规划的目标、问题和过程&lt;/h3&gt;
&lt;p&gt;了解你的基础设施中每一部分何时会失败（最好不发生）对容量规划至关重要。&lt;/p&gt;
&lt;p&gt;假设你有一台数据库服务器用于响应从前端Web服务器提交过来的查询。容量规划意味着你应该知道下述问题的答案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑到特定的硬件配置，数据库服务器每秒可管理多少个查询？&lt;/li&gt;
&lt;li&gt;在性能降低到影响终端用户体验之前，它每秒可应答多少次查询？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;性能与容量：两种不同的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能调优是优化已经存在的性能。容量规划通过使用当前性能做为基线决定你的系统需要什么以及什么时候需要。&lt;/p&gt;
&lt;p&gt;当面对容量问题的时候，试着少花精力使已存在的设备运行更快，而是关注当下要解决的重点：找出你到底需要什么，什么时候需要。&lt;/p&gt;
&lt;p&gt;权衡对已有系统进行调优所花的人力时间，可能简简单单的买更多的硬件是正确的。在最优化和容量扩展方面的权衡是一个挑战，并且因环境而异。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网站的架构和架构对容量方面的影响&lt;/p&gt;
&lt;p&gt;你的驾车风格会影响到你的车的里程，类似的原理能够应用于网站的架构上。在本书中一个反复出现的主题是你的网站架构对于如何使用、消耗
和管理容量产生重大影响。在有效使用容量上，相比于调整和改变你的服务器和网络，设计能带来更大的影响。同时，随着需求的出现如何方便和灵活
地进行增加或者减少容量，也是设计能带来的重要作用。&lt;/p&gt;
&lt;p&gt;调整架构以便更容易容量管理。保持你的架构易于分割和分段，可以帮助你处理大量的负载特性问题---即在你创建了一个需要增长什么和何时增长的准确规划之前，
你需要解决的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过开放API所提供的Web服务引入了另一个逐渐扩大的问题，因为你的应用程序数据会被更多的应用程序访问，它们也都有自己的使用和增长模式。
这也意味着用户可以方便地滥用系统，从而将更多不确定因素放入容量公式中。API的使用情况需要监控，以观察新出现的模式。&lt;/p&gt;
&lt;p&gt;容量规划可以变得非常重要，但是并不困难，你所需要做的只是稍微关注一下正确因素。容量规划的过程可分解为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设定你的目标&lt;/li&gt;
&lt;li&gt;收集对应的指标并找出你所面临的限制&lt;/li&gt;
&lt;li&gt;绘制趋势并根据那些指标和限制做出预测&lt;/li&gt;
&lt;li&gt;容量部署和管理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第2章 设定容量目标&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;服务等级协议(SLA)&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;服务等级协议百分比和可接受的宕机时间&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;正常运行服务等级协议      每年的宕机时间&lt;/p&gt;
&lt;p&gt;90.0%                       36天12小时&lt;/p&gt;
&lt;p&gt;95.0%                       18天6小时&lt;/p&gt;
&lt;p&gt;99.0%                       87小时36分钟&lt;/p&gt;
&lt;p&gt;99.50%                      43小时48分钟&lt;/p&gt;
&lt;p&gt;99.90%                      8小时45分钟36秒&lt;/p&gt;
&lt;p&gt;99.99%                      52分钟33秒&lt;/p&gt;
&lt;p&gt;99.999%                     5分钟15秒&lt;/p&gt;
&lt;p&gt;99.9999%                    32秒&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;业务容量需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在当今Web 2.0这样的网络现象中，由于大多数Web服务为个人应用程序开发者提供开放的API接口，以建立基于他们的B2B关系。因此，很多企业
通常把收入流寄托于方便的使用API。这也意味着企业关系依赖于一定程度的API的可用性或者性能，以可用性百分比来测量或者经过协商的API请求的频率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构决策&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的架构是关于你所有的后端组件（包括硬件和软件）是怎样结合的基本的设计。架构的设计对于规划和管理容量起到至关重要的作用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;推荐书籍：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Building Scalable Web Sites (《构建可扩展网站》)&lt;/li&gt;
&lt;li&gt;Scalable Internet Architectures (《可扩展的网络架构》)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;提供测量点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是为了测量的目的，还是对变化的环境快速响应，你都希望你的架构设计完美，以便你能将它分割成不同的部分来执行离散的任务。
在一个理想的情况下，后端的每个组件都有一个单独的工作要做，但如果需要，它也可以很好地执行多个工作。同时，它对每个工作的影响也可以很容易的被测量。&lt;/p&gt;
&lt;p&gt;你会发现，简单的架构改变可以帮助你理解你的容量被使用的用途是什么。当你在考虑架构设计时，一定要记住：分工以及“分块、松耦合”原理，
可以一直在你的站点是如何被使用的方面给你一些线索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬件决策(垂直缩放比例、水平缩放比例、对角缩放比例)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为你架构中的每一个部件选择正确的硬件可以对成本产生很大影响。&lt;/p&gt;
&lt;p&gt;能够横向扩展意味着该架构能简单地通过在现有的基础设施上添加相同功能的网络节点从而达到增加容量的目的。&lt;/p&gt;
&lt;p&gt;能够纵向扩展则是指一种通过在服务器内部添加硬件资源从而达到扩充容量目的。这些硬件资源包括CPU、内存、硬盘和网络。&lt;/p&gt;
&lt;p&gt;对角扩展是指对基础设施中已有的横向扩展节点进行纵向扩展的过程。&lt;/p&gt;
&lt;h3&gt;第3章 测量：容量的单位&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;认可测量本身带来的影响&lt;/p&gt;
&lt;p&gt;为了采集和传输度量指标，一些系统资源就会被消耗。好的监测工具努力做得很轻量，不妨碍系统的主要工作，但是总会有一些额外开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;监测可作为识别紧急问题的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们的站点出现错误的时候，如果能够迅速地获取状态信息是非常重要的。可能你想能够得到如下这些问题的快速回答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是什么错误？&lt;/li&gt;
&lt;li&gt;错误是何时发生的？&lt;/li&gt;
&lt;li&gt;是什么引发了错误？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡器基于一个相对简短的算法列表来建立负载分发，使得你能指定协议来达到跨越所有可用的服务器均衡地处理流量。&lt;/p&gt;
&lt;p&gt;就我们的目的而言，负载均衡器为容量管理提供了一个非常理想的框架，因为通过它可以在生产环境中方便地进行容量的伸缩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序监测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器统计数据只是描绘了容量图的一部分。你还应该特别针对你的应用程序，测量并记录高级别的度量指标---不是针对一个服务器，而是对整个系统。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;数据库容量&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;基本的服务器统计数据之外，还有一些数据库特定的指标你需要跟踪：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每秒的查询（SELECT, INSERT, UPDATE, 和DELETE）&lt;/li&gt;
&lt;li&gt;当前打开的连接数&lt;/li&gt;
&lt;li&gt;复制时主从数据库之间的滞后时间&lt;/li&gt;
&lt;li&gt;高速缓存命中率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规划数据库（特别是集群的数据库）的容量需求是一件棘手的事情。确定你数据库的性能上限非常困难，因为可能有些隐藏的极端问题仅在一些边缘情况下才会暴露出来。&lt;/p&gt;
&lt;p&gt;但对于数据库而言，性能调优是非常重要的。数据库的性能通常更多依赖于你的方案和查询而不是硬件的速度。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;缓存系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在Web架构中，缓存最经常被用于存储数据库结果（比如用Memcached）或实际文件（比如用Squid和Varnish）。&lt;/p&gt;
&lt;p&gt;影响缓存容量的两个主要因素是你的工作集的大小，以及你的数据动态变化的程度。缓存有一个固定的大小。可缓存对象的工作集是指在给定时期内请求的独特对象的数目---不管数据库结果还是文件。
理想的情况是，你将拥有足够的缓存容量来处理整个工作集。这意味着绝大多数的缓存请求会命中。&lt;/p&gt;
&lt;p&gt;在Flickr，我们使用Squid作为反向代理来缓存照片。我们使用更慢、更便宜、更大容量的磁盘来存储照片，但是利用缓存系统来提供照片，这些缓存系统使用的是更小但更快的磁盘。
随着照片请求率增长，我们横向扩展缓存服务器的数量。随着照片数量的增长，我们还横向扩展后台存储的数量。&lt;/p&gt;
&lt;p&gt;跟踪任何缓存软件最重要的度量指标是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存命中率&lt;/li&gt;
&lt;li&gt;总请求率&lt;/li&gt;
&lt;li&gt;对象平均时间&lt;/li&gt;
&lt;li&gt;LRU参考时间(当使用LRU方法时)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;API的使用率及其对容量的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一些方法来测量并记录每个用户或者每个请求方法对开放的API的使用量，这对于那些提供API接口的网站进行容量跟踪，应被视为必须的。
通常通过独特的API key，或者是其他独特的凭据来进行。每次调用API，通过key就能识别出应用程序和负责构建应用程序的开发者。&lt;/p&gt;
&lt;p&gt;因为产生大量的API调用比使用常规的客户端浏览器要容易得多，你应该跟踪哪个应用程序正在以何种速率调用什么API。&lt;/p&gt;
&lt;p&gt;在Flickr，我们根据在服务条款中列出的规定，使那些看起来滥用API的key自动失效。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;基础架构的每一部分都将花费系统资源来为网站服务，你应该确保对这些资源进行适当的测量。然而，记录正确的测量并不足够。
你还需要知道何时那些资源将耗尽，这也是为什么你需要定期地探测并建立这些上限。&lt;/p&gt;
&lt;p&gt;通过寻找基础架构上限的实践过程，可暴露出你甚至不知道的瓶颈。基于此，你可能需要改变应用程序、硬件、网络或造成问题的其他部分。
每次你对基础架构做一次修改，都需要再次检查上限，因为它们也很有可能改变。这不应该令人惊奇，因为现在你知道容量规划是一个过程，而不是一次性的事件。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;没有测量系统、应用层度量指标的历史数据，则容量规划无法存在。不知道系统的最高性能上限从而避免接近它们，则规划也是没有效果的。
要找到基础架构每部分的上限，需要下面这些步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测量和记录服务器的主要功能。&lt;em&gt;例如：Apache命中，数据库查询&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;测量和记录服务器的基础硬件资源。&lt;em&gt;例如：CPU、内存、硬盘、网络使用量&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;判断服务器的主要功能如何与其硬件资源相关联。&lt;em&gt;例如：N个数据库查询占用M%的CPU使用量&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;通过以下方法之一，基于服务器的主要功能和硬件资源，找到可接受的最大资源使用量（或上限）：&lt;ul&gt;
&lt;li&gt;通过使用负载均衡或应用程序技术，人工（而小心）增加真实的生产负载到服务器。&lt;/li&gt;
&lt;li&gt;尽可能确切地模拟一个真实的生产负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第4章 趋势预测&lt;/h3&gt;
&lt;p&gt;预测容量需求部分靠直觉，部分靠数学。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;曲线拟合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容量预测的整体过程非常简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定、测量和绘制对每个资源定义的度量指标 &lt;em&gt;例如：磁盘消耗&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;对你拥有的资源应用约束限制 &lt;em&gt;例如：总可用磁盘空间&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;使用趋势分析（曲线拟合）说明何时你的使用量会超出限制 &lt;em&gt;例如：找出磁盘空间耗尽的日期&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第5章 部署&lt;/h3&gt;
&lt;p&gt;&lt;img alt="racp-5.1" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/tacp-fig-5.1.png"&gt;&lt;/p&gt;
&lt;h3&gt;附录A 虚拟化和云计算&lt;/h3&gt;
&lt;p&gt;容量规划的两个目标：一是以最有效的方式来利用你手头上所拥有的资源，二是根据目前的使用模式来预测未来需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟化指的是一台计算机的不同层面的计算资源的抽象。实际中，虚拟化通常用于描述OS（操作系统）的抽象。&lt;/p&gt;
&lt;h3&gt;附录B 对瞬时增长的处理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;减轻失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下的方法是针对那些最坏情况的场景，当所有其他增加容量的选择都不起作用，并且从根本上改变基础设施本身是不可能的时候。
应该说这种救火似的场景是容量规划所应该极力避免的；但是有些时候它确实是不可避免的。&lt;/p&gt;
&lt;p&gt;以下列出的方法并非万能的，当暴发的访问流量来临并且你的服务器在负载下正要挂掉时，能对你有所帮忙。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;禁用重量级的功能&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种可能的方法就是禁用站点的一些重量级功能。将打开或者关闭一些功能的能力内建到系统中将帮助你对容量问题做出更加有效的响应，
即使是在那些重大的流量问题事件中。拥有一个快捷的，只有一行简单的打开或者关闭的配置参数在你的应用程序中是有巨大价值的，
特别是当该功能就是问题的起因或者是造成不可接受性能的时候。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;烘烤过的静态页面&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那些遭遇非常严重流量问题的网站经常采用的另一种技术就是将动态页面转变为静态页面。这可能会很简单也可能会很难，这取决于页面到底有多动态，
但你可以保守的只将那些最常被访问的页面或者动态性最少的页面转换为静态页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;缓存&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;附录C 容量工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Ganglia, http://ganglia.sourceforge.net/&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nagios, http://www.nagios.org/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dstat，系统统计工具模块化，http://dag.wiee.rs/home-made/dstat/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fabric, http://docs.fabfile.org/, https://github.com/fabric/fabric&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="笔记"></category><category term="容量规划"></category></entry><entry><title>如何实现Golang的http请求处理中间件（译）</title><link href="http://youngsterxyf.github.io/2014/01/17/golang-http-handlers-as-middleware/" rel="alternate"></link><published>2014-01-17T00:00:00+08:00</published><updated>2014-01-17T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-17:/2014/01/17/golang-http-handlers-as-middleware/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://capotej.com/blog/2013/10/07/golang-http-handlers-as-middleware/"&gt;Golang Http Handlers as Middleware&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数现代Web组件栈允许通过栈式/组件式中间件“过滤”请求，这样就能干净地从web应用中分离出横切关注点（译注：面向方面程序设计中的概念？）。
本 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://capotej.com/blog/2013/10/07/golang-http-handlers-as-middleware/"&gt;Golang Http Handlers as Middleware&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数现代Web组件栈允许通过栈式/组件式中间件“过滤”请求，这样就能干净地从web应用中分离出横切关注点（译注：面向方面程序设计中的概念？）。
本周我尝试在Go语言的&lt;code&gt;http.FileServer&lt;/code&gt;中植入钩子，发现实现起来十分简便，让我非常惊讶。&lt;/p&gt;
&lt;p&gt;让我们从一个基本的文件服务器开始说起：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    http.ListenAndServe(&lt;span style="color: #a31515"&gt;&amp;quot;:8080&amp;quot;&lt;/span&gt;, http.FileServer(http.Dir(&lt;span style="color: #a31515"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;)))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段程序会在端口8080上开启一个本地文件服务器。那么我们该如何在这其中植入钩子从而能够在文件请求处理之前执行一些代码？来看一下&lt;code&gt;http.ListenAndServe&lt;/code&gt;的方法签名：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; ListenAndServe(addr &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, handler Handler) &lt;span style="color: #2b91af"&gt;error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看起来&lt;code&gt;http.FileServer&lt;/code&gt;返回了一个&lt;code&gt;Handler&lt;/code&gt;---给定一个根目录就能知道如何处理文件请求。那我们来看看&lt;code&gt;Handler&lt;/code&gt;接口：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;type&lt;/span&gt; Handler &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt; {
    ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据Go语言的接口原理，任何对象只要实现了&lt;code&gt;ServeHTTP&lt;/code&gt;就是一个&lt;code&gt;Handler&lt;/code&gt;。那么似乎我们需要做的事情就是构造一个自己的&lt;code&gt;Handler&lt;/code&gt;---封装&lt;code&gt;http.FileServer&lt;/code&gt;的处理流程。
Go语言的net/http标准库模块内置了一个帮助函数&lt;code&gt;http.HandlerFunc&lt;/code&gt;，用于将普通函数转变为请求处理函数（handler）：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;type&lt;/span&gt; HandlerFunc &lt;span style="color: #0000ff"&gt;func&lt;/span&gt;(ResponseWriter, *Request)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么我们这样封装&lt;code&gt;http.FileServer&lt;/code&gt;就可以了：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; OurLoggingHandler(h http.Handler) http.Handler {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; http.HandlerFunc(&lt;span style="color: #0000ff"&gt;func&lt;/span&gt;(w http.ResponseWriter, r *http.Request)) {
        fmt.Println(*r.URL)
        h.ServeHTTP(w ,r)
    })
}

&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    fileHandler := http.FileServer(http.Dir(&lt;span style="color: #a31515"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;))
    wrappedHandler := OurLoggingHandler(fileHandler)
    http.ListenAndServe(&lt;span style="color: #a31515"&gt;&amp;quot;:8080&amp;quot;&lt;/span&gt;, wrappedHandler)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Go语言的net/http标准库模块有很多内置的&lt;a href="http://golang.org/pkg/net/http/#Handler"&gt;处理函数&lt;/a&gt;，如&lt;a href="http://golang.org/pkg/net/http/#TimeoutHandler"&gt;TimeoutHandler&lt;/a&gt;和&lt;a href="http://golang.org/pkg/net/http/#RedirectHandler"&gt;RedirectHandler&lt;/a&gt;，
可以相同的方式混合匹配使用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;译者推荐阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/yjf512/archive/2012/08/22/2650873.html"&gt;Golang Http Server源码阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Golang"></category><category term="翻译"></category><category term="中间件"></category></entry><entry><title>为何Goroutine的栈空间可以无限大？（译）</title><link href="http://youngsterxyf.github.io/2014/01/17/goroutine-stack-infinite/" rel="alternate"></link><published>2014-01-17T00:00:00+08:00</published><updated>2014-01-17T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-17:/2014/01/17/goroutine-stack-infinite/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite"&gt;Why is a Goroutine's stack infinite?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go编程新手可能会偶然发现&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;---与一个Goroutine可用栈空间大小相关---的一个古怪特性。这通常是由于程序员
无意间构造了一个无限递归函数调用而产生的。为了阐明 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite"&gt;Why is a Goroutine's stack infinite?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go编程新手可能会偶然发现&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;---与一个Goroutine可用栈空间大小相关---的一个古怪特性。这通常是由于程序员
无意间构造了一个无限递归函数调用而产生的。为了阐明这个特性，以如下代码（有点刻意设计的）为例。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;package&lt;/span&gt; main

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;type&lt;/span&gt; S &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; {
    a, b &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;
}

&lt;span style="color: #008000"&gt;// String implements the fmt.Stringer interface&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; (s *S) String() &lt;span style="color: #2b91af"&gt;string&lt;/span&gt; {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span style="color: #a31515"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;, s)     &lt;span style="color: #008000"&gt;// Sprintf will call s.String()&lt;/span&gt;
}

&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    s := &amp;amp;S{a: 1, b: 2}
    fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你运行这个程序（我不建议你这样做），你会发现你的机器开始频繁地swap（译注：不了解swap的，可以简单理解为“内存与硬盘之间数据的导出导入”），
并且可能不再响应操作事件，除非你在一切无法挽回之前及时地按下^C。我知道所有人都会先在Go官网的playground中尝试运行这个程序，
&lt;a href="http://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite"&gt;所以我已经为你准备好了&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大多数程序员应该都遇到过无限递归导致的问题，但这都只是对于他们的程序来说是致命的，对于他们的机器通常来说并不是。那么，为何Go程序会不同呢？&lt;/p&gt;
&lt;p&gt;Goroutine的主要特征之一是其开销---在内存占用初始化方面，创建一个Goroutine的开销非常小（相比于一个传统POSIX线程的1-8M字节），并且
Goroutine的栈空间是按需扩大和缩小的。这就允许一个Goroutine以单个4096字节的栈空间开始，然后按需扩容缩容，也不用担心栈空间耗尽的风险。&lt;/p&gt;
&lt;p&gt;为了实现这一特性，链接器（5l，6l，8l）在每个函数的开头都插入一小段前导代码$ ^1 $，这段代码会检测该函数需要的栈空间大小是否小于当前可用的栈空间。
若大于，则调用&lt;code&gt;runtime.morestack&lt;/code&gt;分配一个新的栈页（stack page）$ ^2 $，拷贝函数调用方传递来的参数，然后将控制权返回给原来要调用的函数，
这样这个函数就可以安全运行了。当这个函数退出时，再撤销操作，将函数返回值拷贝回函数调用方的栈帧（stack frame），不再需要的栈空间也被释放。&lt;/p&gt;
&lt;p&gt;通过这个过程，栈空间就好像无限大一样，若假设不会持续地跨越两个栈的大小边界-通常称为&lt;em&gt;栈切分（stack splitting）&lt;/em&gt;（译注：不太理解这句话，应该是指：&lt;strong&gt;程序执行
到函数调用方，正好将近耗尽预分配的栈空间，而函数调用方中又不断地调用其他函数，这样每次函数调用就需要分配新的栈空间，函数调用结束后又需要
释放新分配的栈空间，所以开销积累起来就比较大&lt;/strong&gt;），这种栈空间分配方式的开销也会很小。&lt;/p&gt;
&lt;p&gt;然而，直到现在我都还未披露一个细节---粗心地使用递归函数导致内存耗尽的话，当需要新的栈页时，就会&lt;em&gt;从堆上分配&lt;/em&gt;（译注：这句话可能有点问题。应该是Goroutine耗尽操作系统为Go程序分配的栈大小的话，
就从堆上分配）。&lt;/p&gt;
&lt;p&gt;由于无限递归函数持续地调用自己，新的栈页最后就需要从堆上分配。堆的大小很快就会超过机器的可用物理内存空间，到那时，swapping会很快导致你的机器不可用。&lt;/p&gt;
&lt;p&gt;Go程序可用的堆大小依赖于很多东西，包括机器的CPU架构和操作系统，但这通常是一个超出机器物理内存的值，因此机器很可能在程序耗尽它的堆空间之前就会频繁地swap。&lt;/p&gt;
&lt;p&gt;对于Go 1.1，曾有强烈要求增大32位、64位平台上堆的最大值，但这在某种程度上恶化了这一问题，比如，你的机器不太可能有128GB$ ^3 $的物理内存。&lt;/p&gt;
&lt;p&gt;最后提一下，关于这个问题有几个未解决的issue（&lt;a href="https://code.google.com/p/go/issues/detail?id=4692"&gt;链接&lt;/a&gt;，&lt;a href="https://code.google.com/p/go/issues/detail?id=2556"&gt;链接&lt;/a&gt;）,
目前还没找到一个解决方案能够不影响按常规编写的程序的性能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;也适用于方法（method），虽然方法是作为第一个参数为方法接受者（the method receiver）的函数来实现的，但在讨论Go语言中分段的（segmented）栈如何工作之时，并没有实际的区别。&lt;/li&gt;
&lt;li&gt;使用单词page并不意味着仅按固定的4096字节来分配，如果需要，runtime.morestack会分配一个更大的，倍数于一个页大小的空间。&lt;/li&gt;
&lt;li&gt;由于Go 1.1发布周期中一个后来的改变，64位的Windows平台仅允许32Gb大小的堆。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;译者补充相关文章&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.nella.org/a-trip-down-the-split-rabbithole/"&gt;A trip down the (split) rabbithole&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://runtime.diandian.com/post/2011-12-24/11488238"&gt;go语言中split stack(上)&lt;/a&gt;，&lt;a href="http://runtime.diandian.com/post/2011-12-26/10119542"&gt;go语言中split stack(下)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mikespook.com/2011/03/go%E5%9C%A8stack%E4%B8%8A%E5%B9%B2%E4%BA%86%E7%A5%9E%E9%A9%AC%EF%BC%9F/"&gt;go在stack上干了神马？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Golang"></category><category term="翻译"></category></entry><entry><title>Go - 以任意类型的slices作为输入参数（译）</title><link href="http://youngsterxyf.github.io/2014/01/16/go-input-slices-any-type/" rel="alternate"></link><published>2014-01-16T00:00:00+08:00</published><updated>2014-01-16T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-16:/2014/01/16/go-input-slices-any-type/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://ahmetalpbalkan.com/blog/golang-take-slices-of-any-type-as-input-parameter/"&gt;Go – taking slices of any type as input parameters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近参与的一个业余项目，&lt;a href="https://github.com/ahmetalpbalkan/go-linq"&gt;go-linq&lt;/a&gt;，让我了解到Go语言的类型系统并不是为任何类面向
对象编程而设计的。没有泛型，没有类型继承 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://ahmetalpbalkan.com/blog/golang-take-slices-of-any-type-as-input-parameter/"&gt;Go – taking slices of any type as input parameters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近参与的一个业余项目，&lt;a href="https://github.com/ahmetalpbalkan/go-linq"&gt;go-linq&lt;/a&gt;，让我了解到Go语言的类型系统并不是为任何类面向
对象编程而设计的。没有泛型，没有类型继承，也没有提供任何对这些特性有用的东西。&lt;/p&gt;
&lt;p&gt;但是，提供了一个名为&lt;code&gt;interface{}&lt;/code&gt;的类型，你可以向其赋予几乎任意类型的值，不会抛出编译错误，就像.NET的&lt;code&gt;Object&lt;/code&gt;或Java的&lt;code&gt;Object&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}
o := 3.14
o := Student{Name: &lt;span style="color: #a31515"&gt;&amp;quot;Ahmet&amp;quot;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们假设你需要一个可以接收任意类型slices的函数，如果考虑如下这样实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Method(in []&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}){...}
...
slice := []&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;{1, 2, 3}
Method(slice)   &lt;span style="color: #008000"&gt;// 抛出错误&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的代码会抛出编译错误，因为&lt;code&gt;[]int&lt;/code&gt;不是&lt;code&gt;[]interface{}&lt;/code&gt;。那么该如何解决这个问题呢？你可以要求&lt;code&gt;Method&lt;/code&gt;的使用者先把slices
转换为&lt;code&gt;[]interface{}&lt;/code&gt;类型。也就是说他们必须借助于如下类似函数将他们的&lt;code&gt;[]AnyType&lt;/code&gt;类型参数转换为&lt;code&gt;[]interface{}&lt;/code&gt;类型：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; conv(in []AnyType) (out []&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}) {
    out = make([]&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}, len(in))
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i, v := &lt;span style="color: #0000ff"&gt;range&lt;/span&gt; in {
        out[i] = v
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但这种实现的扩展性并不好。如果&lt;code&gt;Method&lt;/code&gt;的使用者（可以是一个常用函数如&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Filter&lt;/code&gt;等）想向&lt;code&gt;Method&lt;/code&gt;传递N种不同类型的参数，
那么他们就必须编写N个&lt;code&gt;conv&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;对此，我们该怎么办呢？使用&lt;strong&gt;reflection&lt;/strong&gt;（反射）呀！实现一个函数以&lt;code&gt;interface{}&lt;/code&gt;（可以赋任意类型的值）为输入参数类型，在函数内部
将这个输入参数转换为一个slice，然后用于我们&lt;code&gt;Method&lt;/code&gt;函数。如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; takeSliceArg(arg &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}) (out []&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}, ok &lt;span style="color: #2b91af"&gt;bool&lt;/span&gt;) {
    slice, success := takeArg(arg, reflect.Slice)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; !success {
        ok = &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
    }
    c := slice.Len()
    out = make([]&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}, c)
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i := 0; i &amp;lt; c; i++ {
        out[i] = slice.Index(i).Interface()
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; out, &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;
}

&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; takeArg(arg &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}, kind reflect.Kind) (val reflect.Value, ok &lt;span style="color: #2b91af"&gt;bool&lt;/span&gt;) {
    val = reflect.ValueOf(arg)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; val.Kind() == kind {
        ok = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数&lt;code&gt;takeArg()&lt;/code&gt;尝试将传入的参数值转换为指定的&lt;a href="http://golang.org/pkg/reflect/#Kind"&gt;reflect.Kind&lt;/a&gt;类型，然后函数&lt;code&gt;takeSliceArg()&lt;/code&gt;
尝试将传递给它的值（经&lt;code&gt;takeArg()&lt;/code&gt;转换后）转换为一个&lt;code&gt;interface{}&lt;/code&gt;的slice。虽然，这样会因为反射而影响到一点性能，但影响并不大。&lt;/p&gt;
&lt;p&gt;就是这样了。这种方案启发于Tobia Confronto的&lt;a href="https://github.com/tobia/fn"&gt;fn项目&lt;/a&gt;，并&lt;a href="https://github.com/ahmetalpbalkan/go-linq/commit/fa1548dc4ad8126e62c1848df6e6d961753d976e#diff-3"&gt;应用到go-linq中&lt;/a&gt;。&lt;/p&gt;</content><category term="其他"></category><category term="Golang"></category><category term="翻译"></category></entry><entry><title>回顾2013，展望2014</title><link href="http://youngsterxyf.github.io/2014/01/06/review13-lookin14/" rel="alternate"></link><published>2014-01-06T00:00:00+08:00</published><updated>2014-01-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-06:/2014/01/06/review13-lookin14/</id><summary type="html">&lt;p&gt;2013已经过去了。&lt;/p&gt;
&lt;p&gt;时间消逝得太快，以至于很多事情在记忆上相互重叠，无法明确区分事情发生的时间点。那么该如何回顾这过去的一年 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;2013已经过去了。&lt;/p&gt;
&lt;p&gt;时间消逝得太快，以至于很多事情在记忆上相互重叠，无法明确区分事情发生的时间点。那么该如何回顾这过去的一年？&lt;/p&gt;
&lt;h2&gt;工作&lt;/h2&gt;
&lt;p&gt;2013，参加工作的第一年，我几乎全身心地扑在工作上，自认为做了一些事情，也有很多收获，愉快而充实。技术工作于我而言，更多的
是一种兴趣、乐趣。&lt;/p&gt;
&lt;p&gt;非常感谢领导、导师以及伙伴。领导、导师给了我很大的空间，导师始终耐心地给于业务和技术的指导，和伙伴的合作非常愉快。&lt;/p&gt;
&lt;p&gt;这一年，如果说我有了些许成长进步，很大程度上归功于他们。&lt;/p&gt;
&lt;p&gt;这些话说得也许有些像获奖感言，却是发自我的真心。&lt;/p&gt;
&lt;h2&gt;生活&lt;/h2&gt;
&lt;p&gt;2013，我和老婆，订婚、领证，终于结束了长达5年的异地恋，从此以后会有个人始终和我“相依为命”，面对或许琐碎的每一天，在城市飘荡的
日子也不会再孤单，我很安心，很踏实。&lt;/p&gt;
&lt;p&gt;现在，我没车、没房，每个月的工资也不算高，但我始终在努力，除了为自己，还因为有个人值得你去努力把生活过得更好。&lt;/p&gt;
&lt;p&gt;为了记录我们以前和以后人生中的重要时刻，我特意创建了一个&lt;a href="http://youngsterxyf.github.io/love"&gt;大事年表网页&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;读书&lt;/h2&gt;
&lt;p&gt;2013，我读过的书非常少，如果非得为此找个理由，我想应该是：很大部分精力都放在了工作和技术上。&lt;/p&gt;
&lt;p&gt;我非常庆幸自己高中、大学、读研的时候阅读了大量的杂书，虽然在一定程度上影响了我的学业，但我更加看重我如今的心态、思想，气质。&lt;/p&gt;
&lt;p&gt;这里简单罗列一下2013年读过的书：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明朝那些事儿（1-7全）（强烈推荐）&lt;/li&gt;
&lt;li&gt;读者（梁文道著）&lt;/li&gt;
&lt;li&gt;Go Web编程&lt;/li&gt;
&lt;li&gt;Learning Raphael - JS Vector Graphic（对Web数据可视化感兴趣的话，非常推荐）-&amp;gt; &lt;a href="https://github.com/youngsterxyf/Coder-s-code/blob/master/JavaScript/learning_raphael_js_vector_graphic.js"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Just For Fun - The Story of an Accidental Revolutionary （Linus Torvalds自传，推荐）-&amp;gt; &lt;a href="http://youngsterxyf.github.io/2013/11/07/read-just_for_fun/"&gt;读书笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Beginning jQuery [读书笔记）-&amp;gt; &lt;a href="https://github.com/youngsterxyf/Coder-s-code/blob/master/JavaScript/beginning-jquery.js"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Learning from jQuery（推荐给jQuery学习者）-&amp;gt; &lt;a href="https://github.com/youngsterxyf/Coder-s-code/blob/master/JavaScript/learning-from-jQuery.js"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaScript语言精粹 -&amp;gt; &lt;a href="http://youngsterxyf.github.io/2013/03/14/read-js-thegoodparts/"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/zh"&gt;Pro Git&lt;/a&gt; （未读完）&lt;/li&gt;
&lt;li&gt;精通CSS-高级Web标准解决方案 （未读完）&lt;/li&gt;
&lt;li&gt;UNIX环境高级编程 （未读完）&lt;/li&gt;
&lt;li&gt;当我谈跑步时，我谈些什么（村上春树著，未读完）&lt;/li&gt;
&lt;li&gt;研究之美 （是13年读的么？）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;书单中几乎都是技术书，而技术书又是因工作需要而阅读的，所以好几本都未读完。&lt;/p&gt;
&lt;p&gt;仍然希望2014年多花些时间阅读，增强“内功”，目前列入计划的书籍有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;历史研究（汤因比著）&lt;/li&gt;
&lt;li&gt;UNIX环境高级编程&lt;/li&gt;
&lt;li&gt;TCP/IP详解 卷1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;求精而不求多，努力达成目标。&lt;/p&gt;
&lt;h2&gt;博客&lt;/h2&gt;
&lt;p&gt;坚持写博客，也是13年的一大收获，一共写了&lt;a href="http://youngsterxyf.github.io/archives.html"&gt;45篇文章&lt;/a&gt;，主要分为技术译文和工作技术总结两部分。&lt;/p&gt;
&lt;p&gt;深感写博客对于技术、知识积累是非常有帮助的，现在我就经常翻阅以前写的文章。&lt;/p&gt;
&lt;p&gt;勤写博客、总结工作心得，对于工作的帮助也很大，不说别的，就说：有时也许领导突然让你就近期的工作写个总结，如果你已经写了博客，那就可以直接拿过来改改就可以O了，哈哈。&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;13年，我并没有怎么运动锻炼。&lt;a href="http://youngsterxyf.github.io/2013/01/18/review12-lookinto13/"&gt;回顾2012，展望2013&lt;/a&gt;中的“信誓旦旦”让如今的我感到很羞愧。但，住处离公司近，这一优点让我养成了
走路上下班的习惯，从4月份入职到现在，9个月，除了一次睡过头了打车到公司，每天上下班走路各半个小时左右，对于我的身体健康不能说没有积极的影响。&lt;/p&gt;
&lt;h2&gt;未来一年&lt;/h2&gt;
&lt;p&gt;2014年，相比2013年，也许并不会有太多的区别，但我仍非常期望自己---2013年做得好的继续保持，没有达到自己期望的地方则加油努力！&lt;/p&gt;
&lt;p&gt;“活着是一种修行！”&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category></entry><entry><title>微博"收藏/赞/转发"技术资料汇总</title><link href="http://youngsterxyf.github.io/2013/12/28/weibo_tech_resources_summary/" rel="alternate"></link><published>2013-12-28T00:00:00+08:00</published><updated>2013-12-28T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-28:/2013/12/28/weibo_tech_resources_summary/</id><summary type="html">&lt;p&gt;使用新浪微博，我很少发状态，主要是跟踪技术圈的一些动态，技术牛人们都在搞些什么东东，因而收藏和转发了一些优秀 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;使用新浪微博，我很少发状态，主要是跟踪技术圈的一些动态，技术牛人们都在搞些什么东东，因而收藏和转发了一些优秀的技术资源，
但有些资源当时并没有来得及阅读消化，也没必要马上就阅读学习的，所以这里整理汇总一下，以免湮没在浩瀚的网络信息海洋中。&lt;/p&gt;
&lt;h3&gt;书籍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP权威指南 &amp;lt;- &lt;a href="http://weibo.com/fenng"&gt;@Fenng&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nlp.stanford.edu/IR-book/"&gt;Introduction to Information Retrieval&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/lirenchen"&gt;@陈利人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.codingnow.com/temp/readinglua.pdf"&gt;Lua 源码欣赏&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/deepcold"&gt;@简悦云风&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://aosabook.org/en/index.html"&gt;The Architecture of Open Source Applications&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/2169336083"&gt;@CloudFoundry &lt;/a&gt; (已陆续读了部分章节，赞！图灵社区有章节翻译)&lt;/li&gt;
&lt;li&gt;程序设计实践 &amp;lt;- &lt;a href="http://weibo.com/wintercn"&gt;@寒冬winter&lt;/a&gt; &lt;em&gt;推荐语：薄薄200页，就能让一个掌握一门编程语言基础的人成为一个合格的程序员，其中“算法和数据结构”一章不到30页，我认为细细读过足以应付大多数面试和工作需要。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;七周七语言 &amp;lt;- &lt;a href="http://weibo.com/tchuba"&gt;@淘宝褚霸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C语言接口与实现 &amp;lt;- &lt;a href="http://weibo.com/huangz1990"&gt;@huangz1990&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Linux Programming Interface &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt; &lt;em&gt;推荐语：既《Unix网络编程》一二册、《Unix环境高级编程》这三本书之后的最全面最好的一本介绍linux方面的书籍，非常推荐大家读一读&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;代码阅读方法与实践 &amp;lt;- &lt;a href="http://weibo.com/tchuba"&gt;@淘宝褚霸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/"&gt;JavaScript 设计模式&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/oschina2010"&gt;@开源中国&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://learnvimscriptthehardway.stevelosh.com/"&gt;Learn Vimscript the Hard Way&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C++ 的设计与演化 &amp;lt;- &lt;a href="http://weibo.com/marchliu"&gt;@刘鑫Mars&lt;/a&gt; &lt;em&gt;推荐语：无论你对CPP是爱还是恨，只要对它有强烈的感情，就值得读一读&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nmon.sourceforge.net/pmwiki.php"&gt;nmon for Linux&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/tchuba"&gt;@淘宝褚霸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bitbucket.org/kardianos/rsync"&gt;rsync(Go语言实现)&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://plan9.bell-labs.com/plan9/"&gt;plan9&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/codebox"&gt;@CodeBox-腾讯&lt;/a&gt; &lt;em&gt;推荐语：推荐有技术品味的同学都看看plan9的源码，真正世界级大师的作品。plan9的部分代码后来直接用来实现go语言了。&lt;/em&gt; (前年关注过这个项目，哈哈，我的Github头像就是用的plan9的图标)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/square/maximum-awesome"&gt;maximum-awesome&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://influxdb.org/"&gt;InFluxDB&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/soddyque"&gt;@有点儿欢乐&lt;/a&gt;(目前，我们使用InfluxDB来实现一种时间序列数据后备存储方案。官方的文档还不太完善，也还没生产应用案例)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bitly.github.io/nsq/"&gt;NSQ&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1855563263"&gt;@夏永锋_SJTU&lt;/a&gt; (哈哈，我自己。目前我们使用NSQ来接收服务器上报的各项性能数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://voorloopnul.com/blog/a-python-proxy-in-less-than-100-lines-of-code/"&gt;A python proxy in less than 100 lines of code&lt;/a&gt; &amp;lt;- &lt;a href="http://e.weibo.com/u/2093492691?ref=http%3A%2F%2Fweibo.com%2Ffav%3Fpage%3D5"&gt;@程序员的那些事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pymotw.com/2/"&gt;Python Module of the Week&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/royshan"&gt;@骆逸&lt;/a&gt; (我翻译过其中&lt;a href="http://youngsterxyf.github.io/2013/03/30/argparse/"&gt;argparse&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/"&gt;What really happens when you navigate to a URL&lt;/a&gt;，&lt;a href="http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html"&gt;译文&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/lirenchen"&gt;@陈利人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rxin.github.io/db-readings/"&gt;Readings in Databases&lt;/a&gt; &amp;lt;- &lt;a href="http://e.weibo.com/u/2093492691"&gt;@程序员的那些事&lt;/a&gt; (数据库相关论文列表，赞！)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/"&gt;How Browsers Work: Behind the scenes of modern web browsers&lt;/a&gt;，&lt;a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/"&gt;译文&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/ftqq"&gt;@方糖气球&lt;/a&gt; (大致读过一遍)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.allthingsdistributed.com/2012/12/paper-readings-2012.html"&gt;The Back-to-Basics Readings of 2012&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt; (2014年，我打算跟踪阅读这一系列)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://coderwall.com/p/rklk_a"&gt;Go: Share Memory By Communicating&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.valleytalk.org/2011/06/18/%E5%AF%B9%E5%A4%A7%E9%80%81%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E4%B8%83%E4%B8%AA%E6%9C%9F%E6%9C%9B/"&gt;对大宋下一代系统软件架构师的七个期望&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/baoyungang"&gt;@包云岗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf"&gt;Scaling Memcache at Facebook&lt;/a&gt;，&lt;a href="http://www.oschina.net/translate/scaling-memcache-facebook"&gt;译文&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/emclabschina"&gt;@EMC中国研究院&lt;/a&gt;, &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.bigendian123.com/go/2013/11/29/golang-schedule/"&gt;goroutine与调度器&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/marckywu"&gt;@高端小混混&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.golang.org/go-slices-usage-and-internals"&gt;Go Slices: usage and internals&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/"&gt;Baby's First Garbage Collector&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/forhapy"&gt;@傅海平ICT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/2216172320"&gt;@何_登成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tiewei.github.io/cloud/Docker-Getting-Start/"&gt;Docker介绍: 相关技术&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/ferest"&gt;@fe-rest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/yzsind/article/details/6059209"&gt;面向程序员的数据库访问性能优化法则&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/2216172320"&gt;@何_登成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bash.cumulonim.biz/BashPitfalls.html"&gt;Bash Pitfalls&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/huoding"&gt;@火丁笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.rational.so/blog/2013/11/09/sosp-2013-analysis/"&gt;SOSP 2013 Analysis&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1657470871"&gt;@王威廉&lt;/a&gt; (挺有意思的一篇学术八卦文)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rogueleaderr.com/post/65157477648/the-idiomatic-guide-to-deploying-django-in-production"&gt;The Idiomatic Guide to Deploying Django in Production&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zh.learnlayout.com/"&gt;学习CSS布局&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/royshan"&gt;@骆逸&lt;/a&gt; (读过，不错)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.manong.io/technologies-we-use/"&gt;《码农周刊》用到的一些技术&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt; (不错，赞！)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chenzhenianqing.cn/articles/943.html"&gt;Redis主从同步源码浅析-Master端&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/chenzhenianqing"&gt;@趁着年轻-海文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.disqus.com/post/62187806135/scaling-django-to-8-billion-page-views"&gt;Scaling Django to 8 Billion Page Views&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://devo.ps/blog/2013/09/11/zookeeper-vs-doozer-vs-etcd.html"&gt;ZooKeeper vs. Doozer vs. Etcd&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.engineyard.com/2012/linux-scalability"&gt;Linux TCP/IP Tuning for Scalability&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.gopheracademy.com/day-22-a-journey-into-nsq"&gt;A Journey Into NSQ&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt; (我们已经在项目中使用NSQ了，哈哈)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://highscalability.com/blog/2013/8/26/reddit-lessons-learned-from-mistakes-made-scaling-to-1-billi.html"&gt;Reddit: Lessons Learned From Mistakes Made Scaling To 1 Billion Pageviews A Month&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/i-m-h-o/231d7499a75"&gt;Programmer’s dilemma&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.soimort.org/posts/160/"&gt;程序语言简史&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/deepcold"&gt;@简悦云风&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://queue.acm.org/detail.cfm?id=1854041"&gt;Thinking Clearly about Performance&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html"&gt;Scaling Pinterest - From 0 To 10s Of Billions Of Page Views A Month In Two Years&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;图片/Slide/其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://photo.weibo.com/2636918231/wbphotos/large/mid/3527795659267872/pid/9d2c2dd7gw1e082ueq8qpj"&gt;图解llinux启动流程图&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/cnhackers"&gt;@中国黑客联盟V&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/chriscoyier/lets-do-a-bunch-of-simple-stuff-to-make-websites-faster"&gt;Let's Do A Bunch of Simple Stuff to Make Websites Faster&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1855563263"&gt;@夏永锋_SJTU&lt;/a&gt; (哈哈，我自己)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rivierarb.fr/presentations/messaging-systems/#1"&gt;Messaging Systems - How to make the right choice?&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hewgill.com/~greg/stackoverflow/ebooks/"&gt;Stack Overflow 上的顶级问答电子书汇总&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/idreamland"&gt;@池建强&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://denvergophers.com/2013-09/tips-and-tricks.slide#1"&gt;Tips and Tricks with Go&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.igvita.com/slides/2013/fluent-perfcourse.pdf"&gt;Building Faster Websites&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/springside/springside4/wiki/Redis"&gt;Redis Wiki&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/huangz1990"&gt;@huangz1990&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/11VTTGHVNmiiw6GY0WBdX9laBUtLOhmrdgltuth3_pug/edit#slide=id.p"&gt;Golang Server Design Pattern&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://v.163.com/movie/2013/5/N/R/M8TBJIK7D_M8TBLIINR.html"&gt;乔布斯：遗失的访谈(1995)&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/wensong8"&gt;@淘宝正明&lt;/a&gt; (推荐，非常赞！)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://vdisk.weibo.com/s/s55H8"&gt;分布式基础理论系列论文翻译集&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/phylipsbmy"&gt;@我在地上数星星&lt;/a&gt; (赞！要花点时间认真读一下)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://research.microsoft.com/en-us/um/people/gray/papers/ieee_HA_Swieorick.pdf"&gt;High Available computer systems&lt;/a&gt;, &lt;a href="http://research.microsoft.com/en-us/um/people/gray/papers/TandemTR85.7_WhyDoComputersStop.pdf"&gt;Why do Computers stop&lt;/a&gt;, &lt;a href="http://roc.cs.berkeley.edu/papers/usits03.pdf"&gt;Why do Internet Services Fail&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="微博"></category><category term="技术"></category></entry><entry><title>IE下JavaScript Date对象的不同之处</title><link href="http://youngsterxyf.github.io/2013/12/03/date_difference_in_ie/" rel="alternate"></link><published>2013-12-03T00:00:00+08:00</published><updated>2013-12-03T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-03:/2013/12/03/date_difference_in_ie/</id><summary type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/29/inner_warehouse_monitor_system/"&gt;仓库作业机器监控系统&lt;/a&gt;项目中使用&lt;a href="http://www.highcharts.com/demo/line-time-series"&gt;HighCharts的时间序列数据图&lt;/a&gt;来绘制机器CPU使用率、内存使用量、网络流量趋势变化图等，这些图在IE下却没有正常显示，IE也没有报错，按理说HighCharts的IE兼容性是较好的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/29/inner_warehouse_monitor_system/"&gt;仓库作业机器监控系统&lt;/a&gt;项目中使用&lt;a href="http://www.highcharts.com/demo/line-time-series"&gt;HighCharts的时间序列数据图&lt;/a&gt;来绘制机器CPU使用率、内存使用量、网络流量趋势变化图等，这些图在IE下却没有正常显示，IE也没有报错，按理说HighCharts的IE兼容性是较好的，不会出现这种问题，
最后查明原因---确实不是HighCharts的问题，而是由于IE下JavaScript的Date对象缺少一种构造函数导致的。&lt;/p&gt;
&lt;p&gt;IE中JavaScript的Date对象有如下&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/cd9w2te4.aspx"&gt;三种构造函数&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dateObj = new Date()
dateObj = new Date(dateVal)
dateObj = new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其他浏览器中除了这三种之外，&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"&gt;还有一种&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dateObj = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date(dateString);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果在IE下使用了这种构造函数，IE不会提示错误，但在调用dateObj的getMonth、getDate等等方法时返回的是&lt;strong&gt;NaN&lt;/strong&gt;，从而导致了其他问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：感谢@yiyun指出，IE中的Date构造函数只是不支持"xxxx-xx-xx"这种格式的时间字符串&lt;/em&gt;。&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/cd9w2te4.aspx"&gt;文档&lt;/a&gt;也有说明，是我阅读不仔细：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dateVal
    必需。如果是数值，dateVal表示指定日期与1970年1月1日午夜之间相差的协调世界时的毫秒数。   
    如果是字符串，则根据日期和时间字符串(JavaScript)中的规则分析dateVal。dateVal参数也可以是从一些ActiveX对象返回的 VT_DATE值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中日期和时间字符串的规则见：&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/ff743760.aspx"&gt;http://msdn.microsoft.com/zh-cn/library/ie/ff743760.aspx&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在我的案例中，是需要将时间字符串“xxxx-xx-xx”（如“2013-12-03”）转换成一个Date对象，为了兼容IE，我如下实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; newIEDate(dateStr) {
    &lt;span style="color: #008000"&gt;// dateStr的格式：xxxx-xx-xx&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; dateParts = dateStr.split(&lt;span style="color: #a31515"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;);
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date(parseInt(dateParts[0]), parseInt(dateParts[1])-1, parseInt(dateParts[2]));
}
...
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; objDate;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($.browser.msie) {
    objDate = newIEDate(queryDate);
} &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; {
    objDate = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date(queryDate);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码中，&lt;code&gt;$.browser.msie&lt;/code&gt;来自jQuery。另外，构造函数&lt;code&gt;new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]])&lt;/code&gt;中的&lt;strong&gt;year&lt;/strong&gt;必须是年份全称（如1998，而不应是98），&lt;strong&gt;month&lt;/strong&gt;参数则应在0-11（代表1月至12月）之间取值。&lt;/p&gt;
&lt;h4&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/cd9w2te4.aspx"&gt;MSDN - Date 对象 (JavaScript)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"&gt;MDN - Date&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="JavaScript"></category><category term="笔记"></category></entry><entry><title>某运营平台架构调整</title><link href="http://youngsterxyf.github.io/2013/12/02/operation_platform_arch_change/" rel="alternate"></link><published>2013-12-02T00:00:00+08:00</published><updated>2013-12-02T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-02:/2013/12/02/operation_platform_arch_change/</id><summary type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/10/15/standardization-operation-development/"&gt;运营开发规范化&lt;/a&gt;一文中提过工作中涉及一个&lt;strong&gt;运营平台&lt;/strong&gt;。曾有段时间我一直吐槽该平台的代码实现有多烂，各种功 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/10/15/standardization-operation-development/"&gt;运营开发规范化&lt;/a&gt;一文中提过工作中涉及一个&lt;strong&gt;运营平台&lt;/strong&gt;。曾有段时间我一直吐槽该平台的代码实现有多烂，各种功能的逻辑有多“野蛮”，应尽快改造，但也许“worse is better”，我的吐槽只能仅仅是吐槽而已了。&lt;/p&gt;
&lt;p&gt;最近该平台终于频繁出问题了。原因是上线了一个新功能---生产系统的模块之间每发生一次模块调用，就会调用该运营平台的API上报一次数据，该API的逻辑是将上报的数据存入Redis中。API由PHP实现，服务器以Nginx + PHP-FPM的方式处理API调用请求。当生产系统的业务量增大，模块直接的调用次数频率增大直接导致API调用的频率增大，
加上该平台所在服务器各种cron任务等的影响，导致在某些时候，PHP-FPM子进程数量飙升，跑满CPU，并且PHP-FPM子进程的数目持续不降（原因不明）。这样导致一方面用户无法访问该平台---服务器响应502（Nginx接受请求，但PHP-FPM无法处理该请求），另一方面更多的数据上报API调用无法完成，造成大量数据丢失和误告警。
用户怨声载道，领导也很头疼，要求尽快搞定该问题，但迟迟没人挑起这个活。&lt;/p&gt;
&lt;p&gt;为了开个头，上上个周末的一天我绘制了两张对比图（如下所示），尝试给出建议方案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="operation_platform_old_arch" src="/assets/uploads/pics/operation_platform_old_arch.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="operation_platform_new_arch" src="/assets/uploads/pics/operation_platform_new_arch.png"&gt;&lt;/p&gt;
&lt;p&gt;这种方案的时间成本较低，无需改动对外API，也无需大量修改代码。&lt;/p&gt;</content><category term="其他"></category><category term="架构"></category><category term="笔记"></category></entry><entry><title>HAProxyConsole简介</title><link href="http://youngsterxyf.github.io/2013/12/02/re_introduce_haproxyconsole/" rel="alternate"></link><published>2013-12-02T00:00:00+08:00</published><updated>2013-12-02T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-02:/2013/12/02/re_introduce_haproxyconsole/</id><summary type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/01/unescape-html-in-golang-html_template/"&gt;Golang中如何让html/template不转义html标签&lt;/a&gt;、&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;两篇文章中都提到为了方便使用HAProxy，我实现了一个简单的HAProxy负载均衡任务管理系统。前些天我把 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/01/unescape-html-in-golang-html_template/"&gt;Golang中如何让html/template不转义html标签&lt;/a&gt;、&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;两篇文章中都提到为了方便使用HAProxy，我实现了一个简单的HAProxy负载均衡任务管理系统。前些天我把&lt;a href="http://youngsterxyf.github.io/haproxyconsole/"&gt;代码放在Github上&lt;/a&gt;，算是开源吧。&lt;/p&gt;
&lt;p&gt;同事使用该管理系统，遇到问题时，由于不清楚其实现，也就无法分析问题出在哪，同时也会有些恐慌，生怕搞挂了HAProxy，毕竟上面承载了一些关键的业务，所以我绘制一张图用于说明HAProxyConsole的应用场景和工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="HAProxyConsole-arch" src="/assets/uploads/pics/HAProxyConsole-arch.png"&gt;&lt;/p&gt;
&lt;p&gt;图中蓝色标识的部分都属于HAProxyConsole。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户通过Web页面增/删/改/查负载均衡任务，但这4个操作直接修改的都仅是数据库（DB.json或MySQL数据库）。另外，HAProxyConsole的Web页面中还嵌入了主从HAProxy自带的数据统计页面。&lt;/li&gt;
&lt;li&gt;只有当用户点击按钮“应用到主HAProxy”或“应用到从HAProxy”后，HAProxyConsole才会根据DB.json或MySQL中存储的数据和配置文件haproxy_conf_comm.json生成最新的HAProxy配置文件，然后拷贝一份为主HAProxy的配置文件或远程拷贝一份为从HAProxy的配置文件，最后重启HAProxy进程（/path/to/haproxy/sbin/haproxy -f /path/to/haproxy/conf/haproxy.conf -st `cat /path/to/haproxy/haproxy.pid`），使最新的配置生效。重启的过程中HAProxy会先检测最新配置文件的正确性，如果不正确，则不会重启。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在部署HAProxyConsole，应按实际情况修改配置文件&lt;code&gt;app_conf.ini&lt;/code&gt;中的参数值。另外，由于HAProxyConsole在为HAProxy应用最新配置时，是直接覆盖HAProxy原来的配置文件，所以&lt;code&gt;haproxy_conf_comm.json&lt;/code&gt;中指定的HAProxy数据统计页面所使用的端口应与你原来为HAProxy指定的数据统计页面的端口一致。&lt;/p&gt;</content><category term="其他"></category><category term="HAProxy"></category><category term="Keepalived"></category><category term="负载均衡"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>仓库作业机器监控系统设计与实现</title><link href="http://youngsterxyf.github.io/2013/11/29/inner_warehouse_monitor_system/" rel="alternate"></link><published>2013-11-29T00:00:00+08:00</published><updated>2013-11-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-29:/2013/11/29/inner_warehouse_monitor_system/</id><summary type="html">&lt;p&gt;近期在参与一个仓库作业机器监控项目。该项目的需求背景是：公司的电商业务在全国各地有多处或大或小的仓库，仓库 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;近期在参与一个仓库作业机器监控项目。该项目的需求背景是：公司的电商业务在全国各地有多处或大或小的仓库，仓库的作业人员（没有IT技术背景）经常反馈/投诉作业机器断网、断电、连不了服务等问题。实际情况经常与反馈的不一致，但运维侧并没有数据可以证明，所以才有了这个项目的需求。&lt;/p&gt;
&lt;p&gt;该项目第一期的目标仅是&lt;em&gt;收集、展示作业机器某些监控指标数据，以便在快速定位解决问题，或至少有数据可查&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;为了避免大量监控数据上报影响到生产系统的网络服务，系统采用如下结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt="inner_warehouse_monitor" src="/assets/uploads/pics/inner_warehouse_monitor.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现一个agent用于在仓库作业PC或作业PDA上获取机器的监控数据；&lt;/li&gt;
&lt;li&gt;在仓库本地服务器上实现一个数据收集处理服务，提供API给agent上传监控数据；数据收集处理服务会将接收到的数据持久化到数据库，提供给仓库本地服务器上的webApp进行数据展示等；&lt;/li&gt;
&lt;li&gt;中心服务器可以调用各个仓库本地服务器上的webApp提供的数据查询接口（数据用于定位、发现问题）；定期按需对各个仓库本地服务器上的数据进行归档。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，主要的工作都集中在&lt;strong&gt;作业机器上的agent&lt;/strong&gt;和&lt;strong&gt;数据收集处理服务、webApp&lt;/strong&gt;。这其中最关键的又是&lt;strong&gt;数据收集处理服务&lt;/strong&gt;。考虑到需要多地部署运维仓库本地服务器，而且某些大仓库作业机器的数目目前已多达800-1000，我们做了如下技术选型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Golang实现agent、数据收集处理服务、webApp；&lt;/li&gt;
&lt;li&gt;以SQLite作为数据库来存储agent上报的所有数据；&lt;/li&gt;
&lt;li&gt;以&lt;a href="http://bitly.github.io/nsq/"&gt;NSQ&lt;/a&gt;作为异步消息队列中间件；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选用Golang的理由是：可以静态编译，部署简单，只需将编译好的可执行二进制程序丢到服务器上跑起来就可以了。&lt;/p&gt;
&lt;p&gt;选用SQLite的理由是：不必像MySQL那样安装server程序，无需额外部署维护。当然SQLite的文件锁会大大影响数据库读写性能，我们通过尽可能拆分数据库，将不同的指标数据存储在不同的SQLite DB文件中，甚至将每台作业机器每个指标的每天的数据分别存储在不同的DB文件中，来尽可能减小文件锁的性能影响，目前看来效果还不错。&lt;/p&gt;
&lt;p&gt;选择NSQ的理由是：Golang实现、分布式、伸缩性好、性能高、支持HTTP/TCP协议、自带web管理界面等。&lt;/p&gt;
&lt;p&gt;详细的系统结构图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="inner_warehouse_monitor-arch" src="/assets/uploads/pics/inner_warehouse_monitor-arch.png"&gt;&lt;/p&gt;
&lt;p&gt;NSQ支持多topic（不同topic的数据不同），topic又可以有多个channel（同一个topic的所有channel中的数据相同，以多播的方式实现，每个channel在client中有一个对应的处理流程来处理channel中的数据）。我们将作业机器不同的监控指标数据作为不同topic传入NSQ，多数指标数据只需持久化到数据库以备后用，所以这些topic仅需一个channel。&lt;/p&gt;
&lt;p&gt;webApp基于Beego框架实现，避免重复造轮子、工作量小。webApp中的数据展示采用HighCharts、Raphael实现，兼容性好。&lt;/p&gt;
&lt;p&gt;对于机器指标数据，其实不应该使用关系型数据库来存储，因为这种数据的特点是：写入之后只读不改、时间序列的、几乎没有关系型的读取操作、连续批量数据读取，所以开源监控系统如Cacti、Ganglia等均使用RRDtool来读写指标数据。所以如上所述，我们将指标数据的存储尽可能地拆分成多个文件以提高读写性能而不会造成其他问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;系统的工作流程如下所述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作业机器上的agent启动后会先向NSQ的register topic发送一个注册消息，NSQ Client根据该注册消息在register数据表中将该作业机器的状态改为“正常运行中”；&lt;/li&gt;
&lt;li&gt;然后，agent定期上报监控数据到NSQ，NSQ Client中各种数据的处理流程将数据持久化到SQLite数据库文件；&lt;/li&gt;
&lt;li&gt;用户访问/中心服务器调用API时，webApp读取SQLite数据库；&lt;/li&gt;
&lt;li&gt;有一个Goroutine针对注册过的作业机器定期检测3分钟以内是否收到过其上报的心跳数据，若未收到，则将机器状态从“正常运行中”改成“运行异常”，若收到，则将“运行异常”改为“正常运行中”；&lt;/li&gt;
&lt;li&gt;作业机器在正常关机时会向NSQ的register topic发送一个正常关机的消息，Client读取到该消息后，会将该机器在register数据表中的状态改为“已正常关机”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前，系统工作良好。之后会对系统做压测，如果出现瓶颈，估计可能还是数据存储，这样的话我们可能会尝试RRDtool或&lt;a href="http://influxdb.org/"&gt;InfluxDB&lt;/a&gt;。&lt;/p&gt;</content><category term="其他"></category><category term="技术"></category><category term="总结"></category><category term="笔记"></category><category term="Golang"></category></entry><entry><title>读书笔记：Just For Fun - The Story of an Accidental Revolutionary</title><link href="http://youngsterxyf.github.io/2013/11/07/read-just_for_fun/" rel="alternate"></link><published>2013-11-07T00:00:00+08:00</published><updated>2013-11-07T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-07:/2013/11/07/read-just_for_fun/</id><summary type="html">&lt;p&gt;前些天偶然在图灵社区上看到&lt;a href="http://www.ituring.com.cn/book/1115?q=%E8%B6%8A%E7%8E%A9%E8%B6%8A%E5%A4%A7"&gt;这本书的出版计划&lt;/a&gt;，才猛然想起之前看过一两个章节，遂再次找到该书的&lt;a href="http://ishare.iask.sina.com.cn/f/14439267.html"&gt;中文电子版&lt;/a&gt;（&lt;em&gt;原谅 …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;前些天偶然在图灵社区上看到&lt;a href="http://www.ituring.com.cn/book/1115?q=%E8%B6%8A%E7%8E%A9%E8%B6%8A%E5%A4%A7"&gt;这本书的出版计划&lt;/a&gt;，才猛然想起之前看过一两个章节，遂再次找到该书的&lt;a href="http://ishare.iask.sina.com.cn/f/14439267.html"&gt;中文电子版&lt;/a&gt;（&lt;em&gt;原谅我&lt;/em&gt;）（关于该电子版，我不清楚其来源。中国青年出版社出过该书的中文版，译名为《乐者为王》，不知该电子版即为该中文版，还是开源爱好者自己翻译。不过翻译质量不高，应该不是正式出版的），花了一天左右时间看完。&lt;/p&gt;
&lt;p&gt;本书由Linus Torvalds和David Diamond合著，书写方式是Linus自述，穿插David Diamond的一些采访旁白，主要讲述Linus如何偶然地成为信息时代的一个革命者（The Story of an Accidental Revolutionary）。Linus在书中表达了对Linux这一伟大的开源项目的看法、对于人生意义、事物发展规律等问题的个人理解。以下是书中让我印象比较深刻的几处内容：&lt;/p&gt;
&lt;h3&gt;生活的意义&lt;/h3&gt;
&lt;p&gt;对于这一哲学性的问题，估计现在很多人见到都会发笑。本书以这个问题的讨论开始，并以这个问题结尾。Linus并没有直接地回答，而是举例说明人类社会的事物发展都必然经过三个阶段---生存、社会秩序、娱乐，那么生活的意义就是促成这一发展过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;李纳斯：这个答案基本上简单而漂亮。 它不会给你的生活以任何意义，但可以告诉你将发生什么。
有三件事具有生命的意义。它们是你生活当中所有事情的动机，包括你所做的任何事情和一个生命体该做的所有事情。
第一是生存，第二是社会秩序，第三是娱乐。生活中所有的事情都是按这个顺序发展的。娱乐之后便一无所的。
因此从某种意义上说，这意味着生活的意义就是要达到第三个阶段。你一旦达到了第三个阶段，就算成功了。但首先要越过前两个阶段。
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这一理解是非常漂亮的。对于该问题（我为什么而活？），以前我也思考了很多，但最后的答案竟然是---活着本来就是没有意义的，一切意义都是人为地赋予。答案很悲观，Linus的答案本质上也是如此，只不过避免了直接面对该问题，以顺从事物发展规律作为生活的意义，对我有所启发，也让我多了些生活的“正能量”。&lt;/p&gt;
&lt;p&gt;对于未来的预言，特别是计算机行业的发展，Linus同样并没有直接回答问题，同样地以此作为回答：人们并不是真的需要计算机（包含网络等等），而是需要基于计算机实现生存、社会秩序、娱乐三个目标，那么未来的一切、计算机行业的发展必然是更好地帮助人们实现这三个目标。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于娱乐，有本书《娱乐至死》表达了对人类社会发展泛娱乐化、特别是教育趋向娱乐化的担忧。从另一角度佐证了Linus的看法，只不过一消极悲观，一积极乐观。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;与Andrew S. Tanenbaum的争论&lt;/h3&gt;
&lt;p&gt;这一事件在Wikipedia上还有专门的词条-&lt;a href="http://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate"&gt;Tanenbaum-Torvalds debate&lt;/a&gt;。以前也关注过该事件，但把问题的重心放在了“微内核（Micro kernel）”和“宏内核（Monolithic kernel）”的优缺点上，看了该书之后才真正理解Linus的选择，并赞同他的看法。&lt;/p&gt;
&lt;p&gt;这一争论的原文见&lt;a href="https://groups.google.com/forum/#!topic/comp.os.minix/wlhw16QWltI%5B1-25-false%5D"&gt;邮件列表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于Tanenbaum提出的问题，Linus做了如下回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;安德鲁塔南鲍姆写道： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我在美国待了几个星期，所以没来得及对Linux做多少评论(不是说如果我在，我就会说什么)。但是，Linux确实值得一评。我现在就有话要说。&lt;/p&gt;
&lt;p&gt;正如你们所知，MINIX只是我的爱好，每当晚上我写烦了书，如果当时没有什么战争、 革命、 直播的参议院听政会，我就会摆弄MINIX。我的真正职业是大学教授和操作系统领域中的研究人员。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用这个作为MINIX局限性的借口？对不起，但是你输了。我的借口比你的还多，而Linux在很多领域还是胜MINIX一筹。更别说MINIX的大部分似乎是由布鲁斯?伊文斯编写的了。 &lt;/p&gt;
&lt;p&gt;反驳一：你说你把 MINIX当作爱好来玩――那么，请问是谁在拿MINIX挣钱呢？又是谁在免费发送Linux呢？再来谈谈爱好。让MINIX能免费获得，我对MINIX的最大抱怨就会消失。Linux在很大程度上对我是一个爱好(但是一个很严肃的爱好，最棒的一种爱好)。我没有从我的爱好中赚一分钱，它也不是我在大学要修的课程之一。我是纯粹用我自己的时间，在自己的机器上做出来的。 &lt;/p&gt;
&lt;p&gt;反驳二：你是教授和研究人员。这真是一个 MINIX出现核心缺陷的好借口。我只能希望 Amoeba不会像MINIX那样垮掉。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.微内核对Monolithic system &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，Linux是Monolithic的，我同意微内核是好一点儿。 如果不是你的话题有争议性，我可能会同意你的大部分意见。从理论角度(及审美角度)而言，Linux输了。如果GNU的kernel在去年春天就已完善的话，我可能就不会开始这个工程。而事实是，GNU还没有完善，也远非如此。如果现在就已实现的这一点而论，Linux才大获全胜。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MINIX是一个基于微内核的系统。Linux是Monolithic的系统。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这是判断一个kernel好坏的唯一标准，你的观点就对了。但你没提到的是，MINIX在微内核方面的表现并不出色，而且对核内真正的多任务操作仍存在着问题。 如果我做的是一个在多线程文件系统上有问题的OS的话，我就不会这么快来责备别人。而事实上，我竭尽所能来使人们忘记软件设计者在此问题上的惨败。(是的，我知道MINIX拥有众多黑客支持者，但他们只是黑客。而布鲁斯?伊文斯告诉我有很多可以竞争的机会。) &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.可移植性 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“可移植性是给那些写不出新程序的人们准备的。” &lt;/p&gt;
&lt;p&gt;――我，现在刚说的，口出狂言 &lt;/p&gt;
&lt;p&gt;事实上，Linux比MINIX更具有可移植性。 “你说什么？”我听见你说。 是真的――但却不是在你所说的意义上。我使Linux尽量符合标准(我当时手边并没有POSIX标准)。 把程序移植到Linux上比到MINIX上要容易得多。 &lt;/p&gt;
&lt;p&gt;我同意，可移植性是个好东西，但是只有在它确实有意义的地方才是个令人向往的特性。没有必要专门使一个操作系统太具有可移植性：能粘到可移植的API上就行了。操作系统的实质就是利用硬件的特点，并将其隐藏在一层高级的系统调用后面。而Linux就是如此，它比任何kernel都更多地利用了386的特性。当然这使得kernel确实不可移植，但是这也使设计大为简化，是一个可以接受的权宜之计，因为这首先保证了Linux的诞生。我也同意，Linux又太不具有可移植性了。去年一月我拥有了自己的386，而Linux系统的创建在一定程度上成为了一个让我认识386的项目。如果要成为一个真正的项目，必须能够在可移植性方面做一些事情。 但是，我最初的设计思想就是没有考虑到可移植性，如果我这样说并不是太过分地为自己辩护。去年四月我开始这个项目时，认为不会有什么人会真的使用它。我很高兴我的这个想法错了。 随着我对源代码的发布，每个人都可以免费来装截Linux，哪怕还不是很方便。 &lt;/p&gt;
&lt;p&gt;李纳斯 &lt;/p&gt;
&lt;p&gt;附：很抱歉我有时言辞过激。如果你没有其他的操作系统可供选择的话，MINIX已经挺好的了。如果你有五到十个386机器闲着没用，那么Amoeba也会不错，只是我确定无疑是没有的。我一般不会勃然大怒，但是在涉及到Linux的问题时，我是有点容易感情用事。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一反驳非常精彩，并且有说服力！特别是对于“可移植性”问题的说明，值得每个程序员阅读。&lt;/p&gt;
&lt;h3&gt;知识产权&lt;/h3&gt;
&lt;p&gt;关于知识产权，通常有两种截然不同的观点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有些人认为，专利和劳动保险形式的知识产权法规是自由世界的祸害，信息提供者(IP)法规并不仅仅是训导，实际上简直就是罪恶，应该尽快地加以铲除。 另一些人认为整个世界经济实际上是由知识产权所驱动的。这些人想通过他们的努力来加强IP法规的法律地位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而Linus是这么认为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于许多人，包括对我自己而言，知识产权是有关人类的创造活动的规则，是关于那些使我们成为人类――而不是动物(当然，这本身是一件好事)的活动的规则。正是在这个意义上，“知识产权”这一名称本身就是一种侮辱。 它并不是如有形财产那样可以出售，它是创造性活动本身，这是人类所能够做到的最伟大的事情。&lt;/p&gt;
&lt;p&gt;那种创造――不管它是以绘画、 音乐、 雕塑、 菱或是程序的方式出现，都应当受到尊重：创造者和他所创造的事物之间有着你所无法切断的密切联系。这就像母亲与孩子之间的联系，或者如同中国菜与味精之间的联系。 但是与此同时，它却又是世界上每一个人都应当分享的事物，因为它是属于人类共同的。&lt;/p&gt;
&lt;p&gt;你拥有你所创造的东西就意味着你可以控制它的使用。 例如，你有权将这一艺术成果出售给其他人，而且在这个问题上，除了美国国税局以外，任何人都不会说什么。 但是，它其实并不仅仅是钱的问题，而是其他人在同样的问题上陷于困惑时帮他们解决了问题，省却了时间与精力。 &lt;/p&gt;
&lt;p&gt;许多要求加强知识产权立法的讨论是基于这样一种观点，即：给创造者和艺术家以更多的“保护”。而人们似乎不曾、或者说是从未意识到，这样一种强有力的权利导致一些人剥夺了另一些人的权利。&lt;/p&gt;
&lt;p&gt;我热爱版权。我只是认为没必要将版权所有者的权利无限扩大。不要扩大到将消费者的权利都被剥夺殆尽。&lt;/p&gt;
&lt;p&gt;很显然，只有极少的个人获得了专利。 另一方面，公司却获得了大量的专利。这些专利是他们用来对付其他公司的有力武器，可以威胁别人因专利侵权而要面临起诉。现今的专利系统基本上可以说是信息提供者这间的冷战，而不是他们之前的核战争。目前这种情况也不见得比过去的冷战好。&lt;/p&gt;
&lt;p&gt;如果你想避免专利申请过程中的麻烦，你可以采用更为厉害的手段：商业秘密。商业秘密的优点在于，你不必担心什么商业秘密办公室或者类似的机构：你只需要将其封存起来，然后就不必顾虑那么多了。
过去人们一直是这样做的，实际上这也就是法规之所以被引入的原因所在。为了鼓励个人和公司公开其秘密，专利法允许在一定期限内保护市场――如果你公开你所拥有的秘密的话。一个针锋相对的基本形式是：你告诉大家你是如何做成某事的，那么我们就允许你拥有一定年限的特殊权利。&lt;/p&gt;
&lt;p&gt;在专利产生之前，人们会充满猜忌地保守他们自己的技术优势，一直到将它们带入坟墓。很显然，那是不利于技术进步的，因为有前途的技术从来没有向其他人公开过。对于专利特权的承诺使得专利成为将秘密告诉大家的一种强有力的刺激，因为你再也不用担心你的竞争对手会发现你在做什么了。&lt;/p&gt;
&lt;p&gt;然而，那是过去，现在情形不同了。 如今，即使是商业秘密也有了法律保护，尽管它们的理由世人无法理解。&lt;/p&gt;
&lt;p&gt;很大程度上，在这场知识产权战争中寻求和平的解决之道正是公开源代码所努力的目标。&lt;/p&gt;
&lt;p&gt;同一事物的另一面在于，的确，知识产权可能是不公平的，的确，知识产权法规在很大程度上将其目标定位于大公司而不是消费者权利，甚至也不是个人著作者或创新者。 然而其主体是积极有利的。知识产权集中于强有力的权利之上，与之相对应的事实是这一强有力的武器在市场上是如此的有效。 核武器是冷战时代的终极力量，同样的原因使得知识产权在技术战争时代里大受欢迎。&lt;/p&gt;
&lt;p&gt;虽然大量的新措施使非法使用他人的知识产权变得更加困难，但同时也使得合法使用他人的知识产权变得更加困难。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;原谅我喋喋不休地摘录了这么多内容，但其实书中这部分的内容还有很多精彩之处。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;知识产权本来的目的是保护创造者的基本权利，以促进创新和分享，但知识产权如果走过了头（例如如今的专利战争）就会导致创新难以普及，他人无法合法合理地使用这些创新。开源运动则鼓励充分地开放分享创新，同时通过各种形式许可证来保护创造者的基本权利，这也就意味着开源运动的理念不仅只是影响计算机行业，也会对所有行业产生巨大的正面影响。&lt;/p&gt;
&lt;p&gt;人类社会的发展是一个积累的过程，创新知识的分享越充分，积累也就越快，人类社会的发展也就越快。这也是我欣赏支持黑客精神和开源运动的缘由。&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;关于书名的翻译&lt;/h4&gt;
&lt;p&gt;这本书的书名，中国青年出版社的版本是译为《乐者为王》，而将要出版的人民邮电出版社的版本貌似要译为《越玩越大-我和Linux的故事》（正式出版前的暂译名？）。对于这两个译名我都不满意。原书取名《Just For Fun --- The Story of an Accidental Revolutionary》，我想应该是考虑了两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linus非常看重尊重自己的兴趣。其实Linux就是始于它的个人兴趣，也因此Linux到如今的发展及其造成的广泛影响也是当初Linus没有料想也不可能料想到的，人生往往如此，很多事情都是Accidental的；&lt;/li&gt;
&lt;li&gt;Linus认为任何人类社会事物发展的终极阶段就是---娱乐，那么生活的意义就是不断努力为达到这一终极阶段而贡献自己的一份力量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第二点，该书的最后一节中作者做了明确的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对了，就是这三件事：生存、你在社会中的位置、还有快乐。&lt;/p&gt;
&lt;p&gt;这三件事就是我们正在做着的事情。 任何其他的事物，都是社会学家可能会称之为“突发行为”的东西，它们源于那些规则更为简单的行为模式。&lt;/p&gt;
&lt;p&gt;然而事情不仅仅是“这就是激励人生活的事物”。如果情形是这样的话，那它们也就不会成为关于生命的理论了。令人感兴趣的，这三种激励因素有着内在的次序，而这一次序表明了生命的所在。事情并不仅仅是，我们人类被这三种事物所驱使――对于人类以外的其他生命行为也是如此。 &lt;/p&gt;
&lt;p&gt;这一次序是：生存；社会交往；寻找乐趣。 &lt;/p&gt;
&lt;p&gt;它也是进化的次序。这就是我们选择了“Just for Fun”作为本书名称的原因。
因为我们曾经所做的一切事情，似乎最终都是为了我们自己的乐趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译名《乐者为王》虽然简练，却不能明确地表达这两层意思。《越玩越大-我和Linux的故事》则跟闹着玩似的。&lt;/p&gt;
&lt;p&gt;为什么不直译为《只为乐趣》呢？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;关于本书，阮一峰也写过一篇阅读笔记，见&lt;a href="http://www.ruanyifeng.com/blog/2012/09/linus_torvalds.html"&gt;《Linus Torvalds自传》摘录&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;</content><category term="其他"></category><category term="阅读"></category><category term="笔记"></category></entry><entry><title>修改PyPI源</title><link href="http://youngsterxyf.github.io/2013/11/01/change-pypi-mirror/" rel="alternate"></link><published>2013-11-01T00:00:00+08:00</published><updated>2013-11-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-01:/2013/11/01/change-pypi-mirror/</id><summary type="html">&lt;p&gt;使用easy_install或pip安装Python第三方库，默认的源地址是：https://pypi.python.org/simple/ 。使用该源有两个问题:&lt;/p&gt;
&lt;p&gt;1.
国内访问速度较慢&lt;/p&gt;
&lt;p&gt;2.
由于该源使用https协议，若机器上没有安装openssl或ssl配置不对 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;使用easy_install或pip安装Python第三方库，默认的源地址是：https://pypi.python.org/simple/ 。使用该源有两个问题:&lt;/p&gt;
&lt;p&gt;1.
国内访问速度较慢&lt;/p&gt;
&lt;p&gt;2.
由于该源使用https协议，若机器上没有安装openssl或ssl配置不对，将导致easy_install或pip访问该源失败&lt;/p&gt;
&lt;p&gt;若想解决这两个问题，可以使用国内的PyPI镜像源。&lt;/p&gt;
&lt;p&gt;从 &lt;a href="http://www.pypi-mirrors.org/"&gt;http://www.pypi-mirrors.org/&lt;/a&gt; 可以看到国内的PyPI镜像源主要有三个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.pypi.python.org&lt;/li&gt;
&lt;li&gt;pypi.douban.com&lt;/li&gt;
&lt;li&gt;pypi.hustunique.com&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;修改easy_install和pip使用的源有两种方式（以Linux上从镜像源e.pypi.python.org下载安装requests为例）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令方式：针对一次使用，临时修改&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;easy_install&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;easy_install -i http://e.pypi.python.org/simple requests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pip install requests -i http://e.pypi.python.org/simple
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：&lt;em&gt;1. 源路径要包含/simple部分；2. 使用pip时-i参数应放在install xxx的后面&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改（若没有，则创建）easy_install/pip的配置文件&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;easy_install：在&lt;code&gt;~/.pydistutils.cfg&lt;/code&gt;配置文件中写入如下内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[easy_install]
index_url = http://e.pypi.python.org/simple
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip：在&lt;code&gt;~/.pip/pip.conf&lt;/code&gt;配置文件中写入：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[global]
index-url = http://e.pypi.python.org/simple
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.lidaren.com/archives/886"&gt;修改easy_install和pip的镜像地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonhosted.org/setuptools/easy_install.html"&gt;easy_install&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pip-installer.org/en/latest/configuration.html"&gt;pip configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Python"></category><category term="PyPI"></category><category term="pip"></category><category term="easy_install"></category><category term="ssl"></category></entry><entry><title>Golang中如何让html/template不转义html标签</title><link href="http://youngsterxyf.github.io/2013/11/01/unescape-html-in-golang-html_template/" rel="alternate"></link><published>2013-11-01T00:00:00+08:00</published><updated>2013-11-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-01:/2013/11/01/unescape-html-in-golang-html_template/</id><summary type="html">&lt;p&gt;近期在使用Golang的&lt;a href="http://golang.org/pkg/net/http/"&gt;net/http&lt;/a&gt;和&lt;a href="http://golang.org/pkg/html/template/"&gt;html/template&lt;/a&gt;开发一个简单的HAProxy负载均衡任务管理系统（见&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;一文说明）。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/pkg/html/template/"&gt;htmp/template&lt;/a&gt;在渲染页面模板的时 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;近期在使用Golang的&lt;a href="http://golang.org/pkg/net/http/"&gt;net/http&lt;/a&gt;和&lt;a href="http://golang.org/pkg/html/template/"&gt;html/template&lt;/a&gt;开发一个简单的HAProxy负载均衡任务管理系统（见&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;一文说明）。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/pkg/html/template/"&gt;htmp/template&lt;/a&gt;在渲染页面模板的时候默认会转义字符串中的html标签，但有时我们并不想转义html标签，以下图所示为例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="add_haproxy_balance_task" src="/assets/uploads/pics/haproxy_task_add.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="list_haproxy_balance_task" src="/assets/uploads/pics/haproxy_task_list.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1中“ip:port列表(一行一个)”和“说明”两个输入框的内容行与行是以&lt;code&gt;\n&lt;/code&gt;分隔的；图2中，这两部分内容分别在表格的“后端机器列表”和“说明”两列中展示，但行与行其实是以&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;分隔的；那么在将数据存入数据库之前或从数据库中取出数据后，会将字符串中的&lt;code&gt;\n&lt;/code&gt;替换为&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;。如果将替换后的数据以字符串类型传入模板，&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;标签渲染后的效果就是&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;文本而不是换行。&lt;/p&gt;
&lt;p&gt;有两种方式避免&lt;code&gt;html/template&lt;/code&gt;转义html标签：&lt;/p&gt;
&lt;p&gt;1.
把字符串类型数据转换成&lt;code&gt;template.HTML&lt;/code&gt;类型再传入模板进行渲染：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lti := listenTaskInfo{
    Seq:      seq,
    Id:       row.Id,
    Servers:  template.HTML(strings.Join(strings.Split(row.Servers, &lt;span style="color: #a31515"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;), &lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;&lt;/span&gt;)),
    Vip:      appConf.Vip,
    Vport:    row.VPort,
    Comment:  template.HTML(strings.Join(strings.Split(row.Comment, &lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;), &lt;span style="color: #a31515"&gt;&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;&lt;/span&gt;)),
    LogOrNot: row.LogOrNot,
    DateTime: row.DateTime,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
&lt;code&gt;html/template&lt;/code&gt;允许根据需要为模板变量添加一个处理函数，在模板解析的时候该函数就能对模板变量做进一步的处理，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;/search?q={{. | urlquery}}&amp;quot;&amp;gt;{{. | html}}&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;html/template&lt;/code&gt;貌似并没有内置这样的函数让其不转义html标签，但提供了接口让我们按需自定义这类函数。那么我们可以自定义一个函数-在模板解析的时候将模板变量转换成&lt;code&gt;template.HTML&lt;/code&gt;类型，如（该例子来自&lt;a href="http://coderdave.com/view/how-to-unescape-text-in-a-golang-html-template"&gt;How To Unescape Text In A Golang Html Template&lt;/a&gt;）：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; unescaped (x &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{} { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; template.HTML(x) }

&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; renderTemplate(w http.ResponseWriter, tmpl &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, view *Page) {
    t := template.New(&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&lt;/span&gt;)  
    t = t.Funcs(template.FuncMap{&lt;span style="color: #a31515"&gt;&amp;quot;unescaped&amp;quot;&lt;/span&gt;: unescaped})
    t, err := t.ParseFiles(&lt;span style="color: #a31515"&gt;&amp;quot;view.html&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;edit.html&amp;quot;&lt;/span&gt;)
    err = t.ExecuteTemplate(w, tmpl + &lt;span style="color: #a31515"&gt;&amp;quot;.html&amp;quot;&lt;/span&gt;, view)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; err != &lt;span style="color: #0000ff"&gt;nil&lt;/span&gt; {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码使得模板解析的时候可以使用unescaped函数将模板变量x转换成&lt;code&gt;template.HTML&lt;/code&gt;类型，关键是如下两句：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 定义函数unescaped&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; unescaped (x &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{} { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; template.HTML(x) }
&lt;span style="color: #008000"&gt;// 在模板对象t中注册unescaped&lt;/span&gt;
t = t.Funcs(template.FuncMap{&lt;span style="color: #a31515"&gt;&amp;quot;unescaped&amp;quot;&lt;/span&gt;: unescaped})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样，在模板中就可以使用unescaped函数了，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{{printf &lt;span style="color: #a31515"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt; .Body | unescaped}} &lt;span style="color: #008000"&gt;//[]byte&lt;/span&gt;
{{.Body | unescaped}} &lt;span style="color: #008000"&gt;//string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实现不转义HTML标签，本质上，这两种方法是一样的，只不过一种是在字符串传入模板之前将其转换成&lt;code&gt;template.HTML&lt;/code&gt;类型，另一种是在字符串传入模板之后解析之时转换。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;template.HTML&lt;/code&gt;类型，&lt;code&gt;text/template&lt;/code&gt;还定义了&lt;code&gt;template.JS&lt;/code&gt;、&lt;code&gt;template.CSS&lt;/code&gt;等数据类型。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://golang.org/pkg/html/template/"&gt;html/template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://coderdave.com/view/how-to-unescape-text-in-a-golang-html-template"&gt;How To Unescape Text In A Golang Html Template&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Golang"></category><category term="template"></category></entry><entry><title>学在腾讯：简而美的微信后台架构</title><link href="http://youngsterxyf.github.io/2013/10/23/learning-in-tencent-backend-arch-of-weixin/" rel="alternate"></link><published>2013-10-23T00:00:00+08:00</published><updated>2013-10-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-23:/2013/10/23/learning-in-tencent-backend-arch-of-weixin/</id><summary type="html">&lt;p&gt;注：&lt;em&gt;公司分享讲座的一点笔记，不保证准确性。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;h4&gt;极致的业务特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;流畅的消息收发&lt;/li&gt;
&lt;li&gt;及时的通知&lt;/li&gt;
&lt;li&gt;省电&lt;/li&gt;
&lt;li&gt;省流量&lt;/li&gt;
&lt;li&gt;瘦客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;困难 …&lt;/h4&gt;</summary><content type="html">&lt;p&gt;注：&lt;em&gt;公司分享讲座的一点笔记，不保证准确性。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;h4&gt;极致的业务特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;流畅的消息收发&lt;/li&gt;
&lt;li&gt;及时的通知&lt;/li&gt;
&lt;li&gt;省电&lt;/li&gt;
&lt;li&gt;省流量&lt;/li&gt;
&lt;li&gt;瘦客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;困难的后台-终端同步&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同步多样数据：账户信息、通讯录、消息、朋友圈等&lt;/li&gt;
&lt;li&gt;及时通知与同步&lt;/li&gt;
&lt;li&gt;移动网络下的可靠同步&lt;/li&gt;
&lt;li&gt;省流量与电量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方案&lt;/h2&gt;
&lt;h4&gt;极简的同步协议&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;后台与终端只需要沟通一个数字，后台即可知道终端缺失的所有数据。&lt;/li&gt;
&lt;li&gt;变更序列号/版本号：&lt;ul&gt;
&lt;li&gt;后台对用户数据的每项变更，都赋予一个单调递增的序列号，即用户的每项数据都有一个全局递增序列号。&lt;/li&gt;
&lt;li&gt;后台每次给终端发送数据都会带上所发送的所有数据的最大序列号。&lt;/li&gt;
&lt;li&gt;终端每次请求数据时都会带上已经接受到的最大序列号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;高效的通知机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ios Apple Push Network Service&lt;/li&gt;
&lt;li&gt;Android等-长连接&lt;/li&gt;
&lt;li&gt;GPRS/EDGE信令风暴优化&lt;/li&gt;
&lt;li&gt;自适应心跳间隔调节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;三层后台架构&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Arch of weixin backend" src="/assets/uploads/pics/arch-of-weixin-backend.png"&gt;&lt;/p&gt;
&lt;h4&gt;统一的RPC框架&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据ProtocolBuffer定义生成服务器框架和客户端&lt;ul&gt;
&lt;li&gt;服务器：开发人员填充接口实现&lt;/li&gt;
&lt;li&gt;客户端： 应用方本地调用客户端提供的接口函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;屏蔽网络细节&lt;ul&gt;
&lt;li&gt;支持基于TCP/UDP的网络调用&lt;/li&gt;
&lt;li&gt;支持长短连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;丰富的功能&lt;ul&gt;
&lt;li&gt;基于sharding的SET分布&lt;/li&gt;
&lt;li&gt;基于一致性哈希的无状态存储&lt;/li&gt;
&lt;li&gt;服务透明重定向&lt;/li&gt;
&lt;li&gt;丰富的自动化监控：(1)QPS；(2)响应时间；(3)排队时间；(4)各个接口的调用频率与返回状态码分布；(5)各个服务之间的调用拓扑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;高并发的协程RPC&lt;/h4&gt;
&lt;p&gt;服务器同步的调用模型相较异步模型更容易学习、使用和调错。但一台服务器支撑的进程数和线程数是非常有限的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于用户态线程（协程）的RPC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机可以支撑数万甚至十万的用户态线程，仅受CPU和内存约束&lt;/li&gt;
&lt;li&gt;提高并发性和性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;用户态线程RPC的实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于makecontext/getcontext/swapcontext&lt;/li&gt;
&lt;li&gt;Hook Network: read/write/epoll&lt;/li&gt;
&lt;li&gt;用户态线程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;就近访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;就近访问IDC&lt;/li&gt;
&lt;li&gt;就近网络接入：覆盖各大运营商&lt;/li&gt;
&lt;li&gt;CDN：上传下载图片&lt;ul&gt;
&lt;li&gt;腾讯自建CDN&lt;/li&gt;
&lt;li&gt;AKAMAI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;多IDC分布提升用户体验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;国内复杂的网络环境&lt;/li&gt;
&lt;li&gt;超过1亿的海外用户&lt;ul&gt;
&lt;li&gt;分布在全球&lt;/li&gt;
&lt;li&gt;更为多样化的网络环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个IDC都提供完整的功能和所需访问的所有数据&lt;/li&gt;
&lt;li&gt;每个IDC有共同的数据和独立数据&lt;ul&gt;
&lt;li&gt;账户信息全球一致&lt;/li&gt;
&lt;li&gt;用户数据各自独立：(1)一个用户只属于某个IDC；(2)用户属性、关系链、消息；(3)按需共享的SNS数据-照片、评论、红心，减少网络同步带宽消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;IDC分布数据的高可靠最终一致性保证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;账户数据和SNS数据主备访问模型&lt;ul&gt;
&lt;li&gt;用户所在的IDC是主IDC&lt;/li&gt;
&lt;li&gt;其他IDC相对这个用户所在IDC都是备IDC&lt;/li&gt;
&lt;li&gt;更新由主扩散到备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;弱实时性跨IDC更新采用基于Zookeeper仲裁的主备任务队列&lt;ul&gt;
&lt;li&gt;收拢跨IDC访问接口&lt;/li&gt;
&lt;li&gt;重做保证跨IDC更新的可靠性&lt;/li&gt;
&lt;li&gt;数据序列号在重做时保证达到最终一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关系链跨IDC更新&lt;ul&gt;
&lt;li&gt;隐私控制要求实时性&lt;/li&gt;
&lt;li&gt;直接跨IDC网络调用&lt;/li&gt;
&lt;li&gt;后台批处理重试失败请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;容错和容灾机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单IDC&lt;ul&gt;
&lt;li&gt;用户按SET分布，各个SET之间独立&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高可用的异地容灾&lt;ul&gt;
&lt;li&gt;每个服务的主IDC都有一个灾备IDC&lt;/li&gt;
&lt;li&gt;挑战：终端在主备IDC切换时的无缝连接；主备间的数据一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="腾讯"></category><category term="微信"></category><category term="架构"></category></entry><entry><title>搭建高可用负载均衡组件及缓存DNS</title><link href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/" rel="alternate"></link><published>2013-10-16T00:00:00+08:00</published><updated>2013-10-16T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-16:/2013/10/16/high-availability-load-balancer-and-dns/</id><summary type="html">&lt;p&gt;该项工作，如题所示，主要分为两部分：高可用负载均衡组件、缓存DNS。&lt;/p&gt;
&lt;h3&gt;高可用负载均衡组件&lt;/h3&gt;
&lt;p&gt;需求：优化业务系统架构中某些关 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;该项工作，如题所示，主要分为两部分：高可用负载均衡组件、缓存DNS。&lt;/p&gt;
&lt;h3&gt;高可用负载均衡组件&lt;/h3&gt;
&lt;p&gt;需求：优化业务系统架构中某些关键环节，针对TCP层数据流量进行负载均衡，并保证服务的高可用。&lt;/p&gt;
&lt;p&gt;技术选型：HAProxy + Keepalived，这对组合比较常见成熟。&lt;/p&gt;
&lt;p&gt;另外，由于HAProxy的负载均衡任务可能比较多，靠人工修改配置来增删改任务不方便可靠，所以实现了一个简单的HAProxy管理系统，
以后经实际使用验证和完善会开放源码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="high availability load balancer" src="/assets/uploads/pics/high-availability-load-balancer.png"&gt;&lt;/p&gt;
&lt;h3&gt;缓存DNS&lt;/h3&gt;
&lt;p&gt;先以www.qq.com为例，解释一下域名解析过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="resolve qq.com" src="/assets/uploads/pics/resolve-qq-com.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1.
用户向Local DNS发起www.qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;2.
Local DNS向根服务器发起com.查询请求；&lt;/p&gt;
&lt;p&gt;3.
根服务器向Local DNS返回com.解析记录；&lt;/p&gt;
&lt;p&gt;4.
Local DNS向com.权威服务器发起qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;5.
com.权威服务器向Local DNS返回qq.com.解析记录；&lt;/p&gt;
&lt;p&gt;6.
Local DNS向qq.com.权威服务器发起www.qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;7.
qq.com.权威服务器向Local DNS返回www.qq.com.解析记录；&lt;/p&gt;
&lt;p&gt;8.
Local DNS向用户返回www.qq.com解析记录。&lt;/p&gt;
&lt;p&gt;Local DNS一般由网络运营商（如电信、网通等）提供。&lt;/p&gt;
&lt;p&gt;缓存DNS处于用户端（这是一个相对的概念）与local DNS之间，利用DNS服务器软件的缓存功能以及缓存DNS与用户端的近距离特点来加速域名解析。&lt;/p&gt;
&lt;p&gt;也可以在缓存DNS上按需求进行域名劫持。运营商为了牟利，也会在local DNS上进行域名劫持，这对于各大互联网公司对外提供的服务来说是个很大的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在完成该工作后，我编写了一份安装配置文档，方便其他同事参考。文档见：
&lt;a href="/assets/uploads/files/high-availability-load-balancer-and-dns.pdf"&gt;HAProxy+HAProxyConsole+Keepalived+BIND安装配置文档.pdf&lt;/a&gt;。&lt;/p&gt;</content><category term="其他"></category><category term="高可用"></category><category term="负载均衡"></category><category term="HAProxy"></category><category term="Keepalived"></category><category term="HAProxyConsole"></category><category term="DNS"></category><category term="BIND"></category></entry><entry><title>运营开发规范化</title><link href="http://youngsterxyf.github.io/2013/10/15/standardization-operation-development/" rel="alternate"></link><published>2013-10-15T00:00:00+08:00</published><updated>2013-10-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-15:/2013/10/15/standardization-operation-development/</id><summary type="html">&lt;p&gt;今年3月底毕业，入职腾讯做运营开发，至今6个月有余。入职之时组内仅有1个运营开发的同事，到目前已扩充到5人，加3个实习生。&lt;/p&gt;
&lt;p&gt;入职之时的运营开发过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;今年3月底毕业，入职腾讯做运营开发，至今6个月有余。入职之时组内仅有1个运营开发的同事，到目前已扩充到5人，加3个实习生。&lt;/p&gt;
&lt;p&gt;入职之时的运营开发过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在办公机器（Windows）上编写代码，功能测试通过后，&lt;/li&gt;
&lt;li&gt;ssh远程连接到生产服务器（Linux），vim打开一个新文件，复制办公机器上的代码，粘贴到vim中，保存，&lt;/li&gt;
&lt;li&gt;打开浏览器测试上线的功能/效果是否正确，若不正确，&lt;/li&gt;
&lt;li&gt;直接在生产服务器上编辑代码文件，直到达到需要的功能效果，&lt;/li&gt;
&lt;li&gt;再从生产服务器上将修改后的代码复制粘贴到办公机器（也许不会有这一步，之后所有的修改都直接在生产服务器上操作）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程存在如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码没有版本控制&lt;/li&gt;
&lt;li&gt;没有与生产服务器一致的测试环境&lt;/li&gt;
&lt;li&gt;代码部署过程繁琐&lt;/li&gt;
&lt;li&gt;办公开发机器上代码很可能比生产服务器上代码还旧&lt;/li&gt;
&lt;li&gt;上面4点都会导致混乱&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外，当团队从1人扩充到多人后，不可避免地会遇到协作的问题，解决代码开发协作问题一般涉及如下几方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用代码版本控制&lt;/li&gt;
&lt;li&gt;规定版本控制的工作流&lt;/li&gt;
&lt;li&gt;编码规范&lt;/li&gt;
&lt;li&gt;项目/代码文档&lt;/li&gt;
&lt;li&gt;定期code review&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决上述问题，我陆续地做了如下工作：&lt;/p&gt;
&lt;h3&gt;搭建Gitlab服务器、测试服务器&lt;/h3&gt;
&lt;p&gt;个人认为开发工作规范化的第一点就是版本控制，基于版本控制可以完成很多自动化的任务。&lt;/p&gt;
&lt;p&gt;平时个人的代码、文档都通过Git版本控制存放在Github上，所以选择Gitlab来自建类Github平台，服务器的搭建过程见： &lt;a href="http://youngsterxyf.github.io/2013/06/18/setup-testing-server/"&gt;搭建测试服务器(源码编译方式)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;测试服务器和Gitlab服务器是同一台机器，在Git服务器端某个版本库的hooks目录下添加post-receive hook脚本，当有代码提交时，触发执行该脚本，脚本会将该版本库各个分支的代码更新到特定目录中，
然后以每个目录为root添加Nginx虚拟主机配置。这样每次代码提交后，就可以直接打开浏览器查看效果了。hook脚本代码见：&lt;a href="https://gist.github.com/youngsterxyf/6988132"&gt;post-receive.py&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;该hook脚本的实现比较暴力---任何代码提交都会检查签出所有分支代码。&lt;/p&gt;
&lt;p&gt;目前为止，Gitlab平台已得到较好的使用，但由于所要开发的运营平台涉及到一些监控数据API问题，很难有效地使用测试服务器，所以测试服务器一直没有正式使用起来。&lt;/p&gt;
&lt;h3&gt;选择一种Git工作流&lt;/h3&gt;
&lt;p&gt;若是单个使用Git，那么Git的工作流基本上就是：&lt;code&gt;git status&lt;/code&gt;，&lt;code&gt;git add xxx&lt;/code&gt;， &lt;code&gt;git commit -m "xxx"&lt;/code&gt;，&lt;code&gt;git pull&lt;/code&gt;，&lt;code&gt;git push origin master&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当涉及多人协作时，为了减少手动合并代码的工作量以及尽可能避免污染Git远程服务器版本信息，Git工作流就要复杂一些。&lt;/p&gt;
&lt;p&gt;我们的Git工作流如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="our-git-workflow" src="/assets/uploads/pics/git-workflow.png"&gt;&lt;/p&gt;
&lt;p&gt;Git远程服务器端和办公机端版本库都保持两个共享分支：master和develop。master分支是稳定分支，其最新代码与生产服务器上的代码一致。develop是测试分支。&lt;/p&gt;
&lt;p&gt;开发人员开发新功能或fix bug时，先在本地机器从master分支创建一个非共享分支xxx，在xxx分支中编写代码；需要在测试服务器测试代码时，将xxx分支合并入develop分支，将develop分支push到远程服务器；
经测试后，确定需要上线生产服务器，则将xxx分支合并入master分支，并push远程服务器，生产服务器从master分支pull代码进行部署。&lt;/p&gt;
&lt;p&gt;这种工作流能避免“先提交的代码后上线”而导致的版本回滚问题。&lt;/p&gt;
&lt;h3&gt;生产服务器上的代码迁入版本控制&lt;/h3&gt;
&lt;p&gt;这项工作虽然工作量不大，却值得一提。因为不能影响正常的服务，也不能导致任何文件的丢失损坏，所以应该慎之又慎。&lt;/p&gt;
&lt;p&gt;我选择周末在公司完成该工作，过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Gitlab上新建一个版本库，如&lt;em&gt;xxx&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;将生产服务器上的代码打包备份一下；&lt;/li&gt;
&lt;li&gt;进入代码根目录，执行&lt;code&gt;git init&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建编写.gitignore文件，因为一些非代码文件，如图片、视频等，是不需要进入版本控制的，应告诉git忽略。注意：已进入版本控制的文件，即使在.gitignore里列出，git也不会忽略的。
由于文件比较多，目录结构比较复杂，所以可能很难一次性找到所有需要过滤的文件，可以先&lt;code&gt;git add *&lt;/code&gt;，然后通过&lt;code&gt;git status&lt;/code&gt;来查看哪些文件已被加入暂存区，如果有需要过滤的文件被加入了暂存区，则执行&lt;code&gt;git reset&lt;/code&gt;取消
暂存区内容，再次编辑.gitignore；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确认需要过滤的文件都能被.gitignore中的内容匹配后执行&lt;code&gt;git add * &amp;amp;&amp;amp; git commit -m "init"&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将本地的git版本库与Gitlab服务器端的git版本库关联起来。假设Gitlab服务器端版本库的http链接为&lt;em&gt;http://gitlab.server.com/xxx.git&lt;/em&gt;，执行&lt;code&gt;git remote add origin http://gitlab.server.com/xxx.git&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将本地版本库代码推送到远程Gitlab服务器端。执行&lt;code&gt;git push origin master&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，生产服务器上的代码就迁入版本控制了，之后代码部署，只需从Git远程服务器拉取（pull）一下就可以了。&lt;/p&gt;
&lt;p&gt;代码部署过程，原本也想通过hook方式---在代码提交进入master分支时，触发hook脚本，将master分支最新的代码拉取到生产服务器上，但一方面由于网络设定---测试服务器不能主动连接生产服务器，
另一方面谨慎起见，没有采用这种自动方式。在代码提交到Gitlab服务器端后，需要登录到生产服务器执行&lt;code&gt;git pull&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;项目/代码文档&lt;/h3&gt;
&lt;p&gt;入职一段时间后，虽然为运营平台写了几个功能模块，但对于与这几个模块关联的其他模块的实现逻辑并不清楚。对于非我实现的模块具体要解决的问题、以及各个模块的数据来源等也不清楚，也没有文档可查阅，所以着手写一份代码文档---&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;说明各个功能模块解决的问题、实现逻辑、API、相关cron脚本、数据表；&lt;/li&gt;
&lt;li&gt;说明运营平台的请求处理过程、用户身份认证方式；&lt;/li&gt;
&lt;li&gt;前端页面的构成（因为该运营平台所有页面统一使用一种iframe组合的结构）；&lt;/li&gt;
&lt;li&gt;指出代码中一些隐藏的bug、代码中的“坏味道”，并针对代码存在的问题，提出一些编程建议；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于前端页面HTML、CSS、JS，我没有过多纠结。我们前端方面的技能不咋地，前端实现依赖于BootStrap、jQuery等开源代码库。&lt;/p&gt;
&lt;p&gt;这项工作花费的较多时间，导致到后来有点赶工作，文档也写得比较粗糙。现在来看，这份文档写得很不好，只有文字叙述，没有图表，比较枯燥，当然部分原因也是该运营平台没有采用一个完整的框架，各个模块通过前端页面拼凑起来。&lt;/p&gt;
&lt;p&gt;该文档中提出的一些编程建议却有一些可取之处：&lt;/p&gt;
&lt;p&gt;1.
&lt;strong&gt;代码上线之前，务必先删除调试语句&lt;/strong&gt;，比如&lt;code&gt;common.php&lt;/code&gt;中的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;file_put_contents(&amp;#39;/tmp/cron_test_ip.txt&amp;#39;, print_r($ip, true));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调试语句对于正式上线的代码来说是多余的，会影响应用的性能，也可能带来安全问题。&lt;/p&gt;
&lt;p&gt;2.
&lt;strong&gt;清楚地理解你写下的每行代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于非函数式语言来说，每行代码都可能有一些“副作用”，如果你没有理解好你写的代码，就可能带来你无法预料的后果，也会花费你大量调试时间，所以不要轻易使用你还不是很理解的函数、类以及语言特性。&lt;/p&gt;
&lt;p&gt;3.
&lt;strong&gt;一份代码“写三遍”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编程是一个将大脑中的想法转化为可执行程序的过程，如果想法还不清楚，也就不可能写出正确的程序，即使写出的程序可执行，也可能会存在逻辑上的漏洞，成为隐藏的bug。写程序也并不是一气呵成的，而是一个反复编写调试的过程，这个过程非常关注细节，可能导致你无法从整体上把握程序的结构、性能等问题，所以在写完一个程序，程序也能执行了，你还得重新阅读思考一遍你写的程序。&lt;/p&gt;
&lt;p&gt;第一遍：仔细思考要用程序来实现的任务逻辑，避免逻辑错误、漏洞；&lt;/p&gt;
&lt;p&gt;第二遍：编写程序，旨在实现一个可执行的程序；&lt;/p&gt;
&lt;p&gt;第三遍：重新完整地阅读一遍程序，去除不必要的语句，优化代码结构，提高程序性能。&lt;/p&gt;
&lt;p&gt;4.
&lt;strong&gt;恰当处理cron脚本/API文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应将cron脚本/API文件放在恰当的目录下，在cron脚本/API文件数目较多时，应使用较为细分的目录结构对cron脚本/API文件进行归类。另外，应及时清除弃用的代码文件。&lt;/p&gt;
&lt;p&gt;5.
&lt;strong&gt;前端页面代码尽可能分离HTML、CSS、JS。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;务必不要内联引用CSS，即不要通过使用HTML标签的style属性来为标签添加CSS效果，因为这会造成大量的冗余代码，并且影响了HTML代码的简洁。&lt;/p&gt;
&lt;p&gt;最好是将HTML、CSS、JS代码分离成不同的文件，即使用外部引用JS、CSS。优点有3：1)提高HTML、JS、CSS代码各自的简洁易读性；2)能够在多个页面（甚至整个网站）之间共享JS、CSS，提高代码复用，减轻代码更新的工作量，提高网站风格的一致性；3)方便网站内容动静分离，分别对JS、CSS代码进行压缩处理，也能使用CDN来加速请求响应。&lt;/p&gt;
&lt;p&gt;退一步，也可以在HTML的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中编写CSS、JS代码。&lt;/p&gt;
&lt;p&gt;6.
&lt;strong&gt;DRY（Don't Repeat Yourself）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要复制粘贴代码。在发现相同代码在不同地方出现两次以上时，就应使用函数、类、公共文件等方式来避免重复代码的出现，提高代码的复用性，也为未来更新代码减少工作量。&lt;/p&gt;
&lt;p&gt;7.
&lt;strong&gt;尽可能避免使用依赖特定操作系统、文件系统的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;（1）尽可能避免通过绝对路径引入文件，因为当代码中出现大量绝对路径时，代码迁移或变更的工作量就会大得多，而且可能会遗漏更改，从而导致bug。可以通过在一个公共文件中为项目根目录定义常量，在需要时基于该常量来引入文件，代码迁移或变更时只需更改该变量的值就可以了。另外，如果可行，则尽可能使用相对路径。&lt;/p&gt;
&lt;p&gt;（2）尽可能避免直接调用操作系统提供的shell命令来完成任务。一方面某些特殊符号对于shell来说是有特殊意义的，如果参数中带有这些特殊符号就需要特别注意；另一方面对于代码的可移植性来说，直接调用shell命令是很大的问题。一般来说，编程语言都有一些库来支持对文件系统等对象的操作，应尽可能使用这些库来完成任务。&lt;/p&gt;
&lt;h3&gt;规范宣导&lt;/h3&gt;
&lt;p&gt;为了推行规范，需要和组内运营开发同事说明&lt;strong&gt;规范的必要性&lt;/strong&gt;、&lt;strong&gt;如何执行规范（如Git的使用、Git工作流）&lt;/strong&gt;、&lt;strong&gt;哪些东西可以从代码文档中查询&lt;/strong&gt;等，所以简单了做了个分享，ppt见：&lt;a href="/assets/uploads/files/s-o-p.pdf"&gt;规范化运营开发&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;如何推行“定期code review”&lt;/h3&gt;
&lt;p&gt;You know, i am a newcomer，在工作中很难让同事们定期花点时间坐下来review代码，so，我只好实现一个自动化工具---一个cron脚本，每周执行一次，获取一周以来的commit，为其中每个committer随机分配另一个committer一周以来的所有commit作为review任务，将任务中的commit在gitlab上的超链接发送到各自的邮箱。&lt;/p&gt;
&lt;p&gt;代码见：&lt;a href="https://gist.github.com/youngsterxyf/7002279"&gt;pack_git_commit.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码中导入的TofApi是我对公司提供的统一消息发送接口的Python封装。&lt;/p&gt;
&lt;h3&gt;如何推行“编码规范”&lt;/h3&gt;
&lt;p&gt;与“如何推行‘定期code review’”一样，我也是编写了一个自动化小工具来帮助推行编码规范---一个cron脚本，先定制git log命令参数，脚本中调用该git log命令，解析出需要的数据，对不同类型的代码文件使用不同的静态分析程序来分析每行代码不符合编码风格之处，然后将结果提交到gitlab的一个特定代码库中，并将结果的超链接发送到每个代码文件相关人员（对该文件做过增删的人）的邮箱，以提供编码风格改进参考。&lt;/p&gt;
&lt;p&gt;该工具目前支持js、php、python文件代码的分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;js代码的分析是以Google JavaScript Style Guide为标准，借助Google的closure_linter工具进行分析（我对该工具的代码进行了hack，以支持过滤正则表达式文件名表示的文件）&lt;/li&gt;
&lt;li&gt;php代码的分析是以Zend  Coding Standards（http://framework.zend.com/wiki/display/ZFDEV2/Coding+Standards） 为标准，借助phpcs进行分析&lt;/li&gt;
&lt;li&gt;python代码的分析是以PEP 8为标准，借助flake8进行分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主代码见：&lt;a href="https://gist.github.com/youngsterxyf/7002350"&gt;codelintset.go&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于最近对golang比较感兴趣，所以主程序使用golang实现。&lt;/p&gt;
&lt;p&gt;代码中涉及的send_mail.py也是使用上面提到的TofApi的一个邮件发送脚本，template.tmpl是一个golang模板，用于生成静态分析结果，包括源码、分析结果、相关人员三个部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;这个程序还有点问题 --- git在每个commit中会记录两个时间：author date（文件增删改的时间）和committer date（commit的时间），但很有可能某个变更在commit到本地版本库后，过了很长时间才push到远程服务器。
该程序是在gitlab服务器上每天执行一次，其中git log的参数&lt;code&gt;--since&lt;/code&gt;是对committer date起作用。即使一天之内有新commit push到gitlab服务器，该程序执行定制的git log命令，结果也很可能为空，因为是commit一天之后才push的。
查了一下gitlab的API，好像也没找到commit push的时间的API，估计得自己去分析gitlab的数据库，然后读取commit push的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2013-10-22 更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;codelintset.go&lt;/em&gt;已更新为&lt;a href="https://gist.github.com/youngsterxyf/7093991"&gt;第二版&lt;/a&gt;，通过读取gitlab数据库中的相关数据来解决上述问题，并将原来需要配置的常量全部放到json文件，程序运行时会解析该json文件。这样，修改配置不需要重新编译源码。&lt;/p&gt;</content><category term="其他"></category><category term="服务器"></category><category term="Linux"></category><category term="Git"></category><category term="Golang"></category><category term="Python"></category></entry><entry><title>一项工作中涉及的几个命令</title><link href="http://youngsterxyf.github.io/2013/10/14/several-command-in-one-task/" rel="alternate"></link><published>2013-10-14T00:00:00+08:00</published><updated>2013-10-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-14:/2013/10/14/several-command-in-one-task/</id><summary type="html">&lt;p&gt;今天写了点shell脚本，在一些CentOS服务器上进行了一些操作，涉及如下命令：&lt;/p&gt;
&lt;h3&gt;统计特定进程个数&lt;/h3&gt;
&lt;p&gt;如统计haproxy进程的个数&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -e | grep haproxy | wc -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;获取特定进程的pid&lt;/h3&gt;
&lt;p&gt;如获取haproxy进程的pid&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -e | grep haproxy …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;今天写了点shell脚本，在一些CentOS服务器上进行了一些操作，涉及如下命令：&lt;/p&gt;
&lt;h3&gt;统计特定进程个数&lt;/h3&gt;
&lt;p&gt;如统计haproxy进程的个数&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -e | grep haproxy | wc -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;获取特定进程的pid&lt;/h3&gt;
&lt;p&gt;如获取haproxy进程的pid&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -e | grep haproxy | awk &lt;span style="color: #a31515"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;一对多添加ssh信任关系&lt;/h3&gt;
&lt;p&gt;如192.168.2.1用户usernameA到192.168.2.x用户usernameB的信任关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在192.168.2.1创建自己的公钥私钥：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh-keygen -t rsa   &lt;span style="color: #008000"&gt;# 提示输入时，全部留空回车。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝192.168.2.1的公钥到192.168.2.x机器上：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh-copy-id &lt;span style="color: #a31515"&gt;&amp;quot;-p 22 usernameB@192.168.2.x&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里192.168.2.x的sshd服务是开放22端口。&lt;/p&gt;
&lt;p&gt;根据提示输入usernameB的密钥后，就会将192.168.2.1上/home/usernameA/.ssh/id_rsa.pub的内容拷贝192.168.2.x的/home/usernameB/.ssh/authorized_keys文件中。&lt;/p&gt;
&lt;p&gt;以后通过&lt;code&gt;ssh -p 22 usernameB@192.168.2.x&lt;/code&gt;访问192.168.2.x时都不在需要输入usernameB的密码。&lt;/p&gt;
&lt;h3&gt;修改网卡ip&lt;/h3&gt;
&lt;p&gt;如修改网卡eth0的ip。&lt;/p&gt;
&lt;p&gt;文件/etc/sysconfig/network-scripts/ifcfg-eth0大致有如下所示内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;DEVICE=&amp;#39;eth0&amp;#39;
HWADDR=&amp;#39;&amp;#39;
NM_CONTROLLED=&amp;#39;yes&amp;#39;
ONBOOT=&amp;#39;yes&amp;#39;
IPADDR=&amp;#39;192.168.2.193&amp;#39;
NETMASK=&amp;#39;255.255.255.0&amp;#39;
GATEWAY=&amp;#39;192.168.2.1&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将IPADDR的值修改为需指定的ip，保存后，执行如下命令：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;service network restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/init.d/network restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;修改系统时间&lt;/h3&gt;
&lt;p&gt;通过命令&lt;code&gt;date&lt;/code&gt;可以查看Linux服务器当前的时间，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ date
Mon Oct 14 17:44:31 CST 2013
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令加&lt;code&gt;-s&lt;/code&gt;参数，即可修改系统的时间，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ date -s &amp;quot;Mon Oct 14 20:44:31 CST 2013&amp;quot;
Mon Oct 14 20:44:31 CST 2013
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在系统启动时，Linux系统将时间从CMOS中读到系统时间变量中，以后修改时间通过修改系统时间实现。为了保持系统时间与CMOS时间的一致性， Linux每隔一段时间会将系统时间写入CMOS。
由于该同步是每隔一段时间（大概是几分钟）进行的，在执行&lt;code&gt;date -s "xxx"&lt;/code&gt;后，如果马上重启机器，修改时间就有可能没有被写入CMOS,这就是问题的原因。如果要确保修改生效可以执行如下命令：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;clock -w
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考：http://www.blogjava.net/itvincent/archive/2007/08/03/134242.html&lt;/p&gt;
&lt;h3&gt;开机自启动程序设置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如为haproxy编写开机自启动shell脚本-haproxy.sh，内容如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;#!/bin/bash&lt;/span&gt;
&lt;span style="color: #008000"&gt;#&lt;/span&gt;
&lt;span style="color: #008000"&gt;# chkconfig: 2345 25 9&lt;/span&gt;
&lt;span style="color: #008000"&gt;# description: haproxy is a level 4 LB&lt;/span&gt;

. /etc/rc.d/init.d/functions

PID=/usr/local/haproxy/haproxy.pid
SBIN=/usr/local/haproxy/sbin/haproxy
CONF=/usr/local/haproxy/conf/haproxy.conf
logfile=/root/app.log

restart () {
    $SBIN -f $CONF -st &lt;span style="color: #a31515"&gt;`&lt;/span&gt;cat $PID&lt;span style="color: #a31515"&gt;`&lt;/span&gt;
    echo &lt;span style="color: #a31515"&gt;&amp;quot;Restart haproxy At `date`&amp;quot;&lt;/span&gt;&amp;gt;&amp;gt;$logfile
}

start () {
    &lt;span style="color: #008000"&gt;#if [ -f $PID ]; then&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#        echo &amp;quot;started already&amp;quot;&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#        exit 0;&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#fi&lt;/span&gt;
    $SBIN -c -f $CONF
    $SBIN -f $CONF
    echo &lt;span style="color: #a31515"&gt;&amp;quot;Start haproxy Process pid:`cat &lt;/span&gt;$PID&lt;span style="color: #a31515"&gt;`&amp;quot;&lt;/span&gt;
    echo &lt;span style="color: #a31515"&gt;&amp;quot;Start haproxy At `date`&amp;quot;&lt;/span&gt;&amp;gt;&amp;gt;$logfile
}

stop () {
        echo &lt;span style="color: #a31515"&gt;&amp;quot;Kill haproxy Process pid:`cat &lt;/span&gt;$PID&lt;span style="color: #a31515"&gt;`&amp;quot;&lt;/span&gt;
        kill -SIGINT &lt;span style="color: #a31515"&gt;`&lt;/span&gt;cat $PID&lt;span style="color: #a31515"&gt;`&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;Stop haproxy At `date`&amp;quot;&lt;/span&gt;&amp;gt;&amp;gt;$logfile
}

pid () {
        ps -ef|grep master|grep &lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;$SBIN&lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;haproxy Pid Is:`cat &lt;/span&gt;$PID&lt;span style="color: #a31515"&gt;`&amp;quot;&lt;/span&gt;
}

&lt;span style="color: #0000ff"&gt;case&lt;/span&gt; $1 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; 
reload|restart)
        pid
        restart
        pid
        ;;
start)
        start
        ;;
stop)
        stop
        ;;
check|-t)
        $SBIN -c -f $CONF
        ;;
pid|p|-p)
        pid
        ;;
*)
        echo &lt;span style="color: #a31515"&gt;&amp;quot;Please Use ( restart|start|stop|check|pid ) as argument&amp;quot;&lt;/span&gt;
        ;;
&lt;span style="color: #0000ff"&gt;esac&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制haproxy.sh到/etc/init.d/目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将haproxy加入开机启动，即设置在开机时自动执行haproxy.sh脚本：&lt;code&gt;chkconfig --add haproxy.sh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭开机启动：&lt;code&gt;chkconfig haproxy.sh off&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启开机启动：&lt;code&gt;chkconfig haproxy.sh on&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：http://blog.csdn.net/jiedushi/article/details/6767445&lt;/p&gt;</content><category term="其他"></category><category term="Linux"></category><category term="命令行"></category></entry><entry><title>从URL监控问题谈网站Web架构</title><link href="http://youngsterxyf.github.io/2013/10/12/url-monitoring-and-web-arch/" rel="alternate"></link><published>2013-10-12T00:00:00+08:00</published><updated>2013-10-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-12:/2013/10/12/url-monitoring-and-web-arch/</id><summary type="html">&lt;p&gt;之前工作中实现了一个对站点进行URL监控的功能。原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cron脚本定时从一台Nginx服务器上获得Nginx配置文件（包括upstream配置），在解析配置得到：&lt;code&gt;域名-&amp;gt;upstream名&lt;/code&gt;（可能有多个）、&lt;code&gt;upstream名-&amp;gt;属于该upstream的服务器ip列表&lt;/code&gt;，存入数据库；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户 …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;之前工作中实现了一个对站点进行URL监控的功能。原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cron脚本定时从一台Nginx服务器上获得Nginx配置文件（包括upstream配置），在解析配置得到：&lt;code&gt;域名-&amp;gt;upstream名&lt;/code&gt;（可能有多个）、&lt;code&gt;upstream名-&amp;gt;属于该upstream的服务器ip列表&lt;/code&gt;，存入数据库；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户通过Web界面配置URL监控项，配置过程为：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入要监控的URL，如http://www.sample.com/test.php ，前端JS解析出域名部分www.sample.com，向后端发送AJAX请求，得到该域名相关的upstream；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;用户选择正确的那个upstream（Nginx可以将对不同URL的请求转发到不同的upstream后端机器）；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后填写监控告警信息接收人等其他配置信息，提交即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个cron脚本定时地:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从数据库中读取URL监控项数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;根据监控项中的upstream名，从数据库中读取属于该upstream的ip列表；&lt;/li&gt;
&lt;li&gt;逐个使用ip列表中的ip替换URL的域名部分，将域名部分作为HTTP请求头的HOST字段的值；&lt;/li&gt;
&lt;li&gt;使用libcurl库或curl命令发出请求（如使用curl命令：&lt;code&gt;curl -H "www.sample.com" http://192.168.1.1/test.php&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;如果响应码非200或非3xx等，则发送告警信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方式的好处是&lt;strong&gt;不仅能够检测URL指代的web页面或服务是否正常，还能检测提供该web页面或服务的每台服务器是否服务正常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;该URL监控功能基于的网站Web架构也是上了一定流量的网站通常采用的架构，大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx-frontend-forward" src="/assets/uploads/pics/nginx_frontend_forward.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/assets/uploads/pics/nginx_frontend_forward.png"&gt;高清无码大图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该Web架构中，使用一台Nginx服务器作为统一入口来接收所有请求，对请求进行规则匹配和负载均衡后转发到某台后端实际提供服务的服务器上。&lt;strong&gt;在转发请求之前，该Nginx服务器可能会因为某些原因对请求的某些参数（如请求的头部字段）进行修改&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从上图也可以看出，该URL监控方式还有一个好处：监控的请求不需要经过Nginx前端转发机。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;近几天，该URL监控功能出现了误报的问题，原因为：对于某些域名或URL的请求，在经过Nginx前端转发机时被Nginx修改了请求头HOST字段，然后才转发到后端机器，而&lt;strong&gt;后端机器Nginx虚拟主机配置的server_name字段的值是与前端转发机修改后的请求头HOST字段一致的&lt;/strong&gt;，而该URL监控功能的请求是绕过前端转发机直接向后端服务器发送请求，请求头HOST字段为URL中的域名部分，与后端服务器Nginx虚拟主机配置的server_name字段的值不一致，所以后端服务器不会接受该请求。&lt;/p&gt;
&lt;p&gt;那么怎样在保持该URL监控方式的三大好处的前提下解决该问题呢？&lt;/p&gt;
&lt;p&gt;目前我能想到的就是&lt;strong&gt;编写程序从Nginx配置文件中解析得什么样的请求被修改了头部HOST字段&lt;/strong&gt;，但这个难度又实在太大，不可行，了解Nginx的人应该知道Nginx配置可以有多灵活多复杂。&lt;/p&gt;
&lt;p&gt;换个思路想想，URL监控的目的是什么？&lt;strong&gt;是监控服务于特定URL的所有服务器都正常，还是仅监控特定URL服务是否正常？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人认为，URL监控的目的应该是&lt;strong&gt;监控特定URL服务是否正常&lt;/strong&gt;，而&lt;strong&gt;实际提供该URL服务的每台后端服务器是否工作正常，应该通过心跳检测、服务器上的进程监控程序、Nginx前端转发机负载均衡状态等来监控&lt;/strong&gt;。这样，也就绕过了上述的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上述问题的存在一方面也是因为网站的Web架构中有一个前端转发机，那么为什么要有这个前端转发机呢？好处是什么？弊处又是什么？若有弊处，如何解决？&lt;/p&gt;
&lt;p&gt;个人理解，好处主要有如下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;网络安全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nginx提供的负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将系统作为一个整体来看，其提供的服务可以通过GSLB基于用户ip地理信息和运营商，尽可能加速访问速度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;网络安全&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前端转发机通过防火墙、Nginx白名单等方式为所有后端服务器提供统一的安全策略；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端转发机将实际提供服务的机器与互联网隔离，后端服务器上代码和数据不会直接受到攻击和窃取。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Nginx提供的负载均衡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对于某些服务，单台后端服务器可能无法支撑负载，基于Nginx的负载均衡功能可以使用多台机器来分流请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;通过GSLB加速整个系统提供的服务&lt;/h3&gt;
&lt;p&gt;要想利用GSLB进行加速，需要为系统在每个（大）运营商的网络中都部署一台前端转发机，各个前端转发机以专线或者其他有效方式与后端服务器连接。&lt;/p&gt;
&lt;p&gt;假设所有前端转发机共享域名x.xxx.com，在记录有该域名信息的DNS服务器上对应该域名就有多个ip。该系统对外提供www.example.com、www.a.example.com、www.b.example.com等站点的服务。用户在访问这几个站点时，域名www.example.com、www.a.example.com、www.b.example.com的DNS解析过程是先将这些域名都CNAME为x.xxx.com，然后查找到x.xxx.com对应的ip返回给用户端。记录x.xxx.com的授权DNS服务器在接收到域名x.xxx.com的DNS请求后，通过与该DNS服务器关联的GSLB控制设备根据请求来自的运营商（以及地理信息等其他信息）得到访问最快的前端转发机ip返回给用户端。&lt;/p&gt;
&lt;p&gt;各个前端转发服务器通过Nginx虚拟主机配置的server_name参数和HTTP请求的头部HOST字段来区分对不同站点的请求。&lt;/p&gt;
&lt;p&gt;上述环节中，记录x.xxx.com的授权服务器如果放在某个运营商网络里，对于其他运营商网络里的用户，DNS解析过程就会比较慢，从而大大影响了访问速度。一个有效的解决方案是：该DNS服务器同时接入多个运营商网络。&lt;/p&gt;
&lt;p&gt;如果网站代码进行动静分离，静态内容通常会采用CDN方式来加速，我想CDN技术也是基于GSLB来实现的吧？&lt;/p&gt;
&lt;p&gt;对于有钱的大厂来说，按区域部署IDC后，GSLB更能显示其优势吧？！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上图中所示的网站Web架构当然也有其弊处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx前端转发机会成为系统单点&lt;/li&gt;
&lt;li&gt;Nginx前端转发机可能会成为系统的性能瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系统单点&lt;/h3&gt;
&lt;p&gt;对于该问题，可以使用keepalived来实现双机热备。&lt;/p&gt;
&lt;h3&gt;性能瓶颈&lt;/h3&gt;
&lt;p&gt;如果真的成了性能瓶颈，可以对前端转发机Nginx的功能进行拆分，即尽可能简化前端转发机Nginx的配置，如每个虚拟主机配置为仅转发请求。在前端转发机与后端服务器之间增加一层负载均衡服务器，负载均衡、访问控制、rewrite等功能放在该层完成。演变后的系统结构图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="add_load_balance_level" src="/assets/uploads/pics/add_load_balance_level.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/assets/uploads/pics/add_load_balance_level.png"&gt;高清无码大图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外，我想只能加强服务器硬件或者将系统拆分成多个小系统了吧。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;欢迎拍砖！&lt;/p&gt;</content><category term="其他"></category><category term="监控"></category><category term="架构"></category><category term="Web"></category><category term="工作笔记"></category></entry><entry><title>通过示例学习Git内部构造（译）</title><link href="http://youngsterxyf.github.io/2013/09/28/learning-git-internals-by-example/" rel="alternate"></link><published>2013-09-28T00:00:00+08:00</published><updated>2013-09-28T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-09-28:/2013/09/28/learning-git-internals-by-example/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://teohm.github.io/blog/2011/05/30/learning-git-internals-by-example/"&gt;Learning Git Internals by Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;状态：草稿&lt;/p&gt;
&lt;p&gt;计划修订本文，未来可能会简化一些...&lt;/p&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;p&gt;从Subversion和Mercurial切换到Git之后的几个月，我始终觉得Git在本质上是不同于Subversion和Mercurial的，但没法确切地说出区别。
我 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://teohm.github.io/blog/2011/05/30/learning-git-internals-by-example/"&gt;Learning Git Internals by Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;状态：草稿&lt;/p&gt;
&lt;p&gt;计划修订本文，未来可能会简化一些...&lt;/p&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;p&gt;从Subversion和Mercurial切换到Git之后的几个月，我始终觉得Git在本质上是不同于Subversion和Mercurial的，但没法确切地说出区别。
我经常在Github上看到tree、parent等术语，也搞不清楚它们确切的含义。&lt;/p&gt;
&lt;p&gt;因此我决定花些时间学学Git。&lt;/p&gt;
&lt;p&gt;我会尝试概述，并阐述一路走来学到的关于Git的关键信息...但这仅是有助于我回答Git与其他源码控制工具区别的Git内部构造基本知识。&lt;/p&gt;
&lt;h2&gt;实体、引用、索引（Objects，References，The Index）&lt;/h2&gt;
&lt;p&gt;要理解Git内部构造的核心，我们应理解三个东西： &lt;strong&gt;实体&lt;/strong&gt;、&lt;strong&gt;引用&lt;/strong&gt;、 &lt;strong&gt;索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我发现这个模型非常优雅。用一个小小的图表就能完全展现，也易于理解记忆。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Big Picture" src="/assets/uploads/pics/git-internals/big-picture.png"&gt;&lt;/p&gt;
&lt;h3&gt;实体&lt;/h3&gt;
&lt;p&gt;你提交到一个Git代码仓库中的所有文件，包括每个提交的说明信息（the commit info）都在目录 &lt;code&gt;.git/objects/&lt;/code&gt;中存储为&lt;strong&gt;实体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个实体以一个40字符长度的字符串（该实体内容的SHA1哈希值）来标识。&lt;/p&gt;
&lt;p&gt;实体有&lt;strong&gt;4类&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;blob&lt;/em&gt; - 存储文件内容。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tree&lt;/em&gt; - 存储目录结构和文件名。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;commit&lt;/em&gt; - 存储提交的说明，组成Git的提交图谱。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tag&lt;/em&gt; - 存储带注释的标签（tag）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下文的示例会阐明这些实体是如何相互关联的。&lt;/p&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;Git中，一个&lt;em&gt;分支（branch）&lt;/em&gt;、&lt;em&gt;远程分支（remote branch）&lt;/em&gt;或一个&lt;em&gt;标签（tag）&lt;/em&gt;（也称为轻量标签）仅是&lt;strong&gt;指向一个实体的一个指针&lt;/strong&gt;，这里的实体通常是一个commit实体。&lt;/p&gt;
&lt;p&gt;这些引用以文本文件的形式存储在目录&lt;code&gt;.git/refs/&lt;/code&gt;中。&lt;/p&gt;
&lt;h4&gt;符号引用（Symbolic References）&lt;/h4&gt;
&lt;p&gt;Git有一种特殊的引用，称为&lt;em&gt;符号引用&lt;/em&gt;。它并不直接指向一个实体，而是&lt;strong&gt;指向另一个引用&lt;/strong&gt;。举例来说，&lt;code&gt;.git/HEAD&lt;/code&gt;就是一个符号引用。它指向你正在工作的当前分支。&lt;/p&gt;
&lt;h3&gt;索引&lt;/h3&gt;
&lt;p&gt;索引是一个暂存区，以二进制文件的形式存储为文件&lt;code&gt;.git/index&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;git add&lt;/code&gt;一个文件，Git将该文件的信息添加到索引中。当&lt;code&gt;git commit&lt;/code&gt;，Git仅提交索引文件中列出的文件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;我们来演练一个简单的示例，创建一个Git代码仓库，提交一些文件，看看幕后&lt;code&gt;.git&lt;/code&gt;目录中都发生了些什么。&lt;/p&gt;
&lt;h3&gt;初始化新的代码仓库&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git init canai
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="初始化代码仓库后" src="/assets/uploads/pics/git-internals/init.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建了空目录&lt;code&gt;.git/objects/&lt;/code&gt;和&lt;code&gt;.git/refs/&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;还没有索引（Index）文件。&lt;/li&gt;
&lt;li&gt;创建了符号索引文件&lt;code&gt;HEAD&lt;/code&gt;。&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat .git/HEAD
ref: refs/heads/master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加新文件&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ echo &amp;quot;A roti canai project.&amp;quot; &amp;gt;&amp;gt; README
$ git add README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="添加新文件后" src="/assets/uploads/pics/git-internals/new-file.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建了索引（Index）文件。它有一个SHA1哈希值指向一个blob实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git ls-files --stage
100644 5f89c6f016cad2d419e865df380595e39b1256db 0 README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个blob实体。README文件的内容存储在该blob中。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# .git/objects/5f/89c6f016cad2d419e865df380595e39b1256db
$ git cat-file blob 5f89c6
A roti canai project.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;首次提交&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git commit -m&amp;#39;first commit&amp;#39;
[master (root-commit) d9976cf] first commit
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="首次提交后" src="/assets/uploads/pics/git-internals/first-commit.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建了分支‘master’引用，指向‘master’分支中最新的commit实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat .git/refs/heads/master 
d9976cfe0430557885d162927dd70186d0f521e8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了第一个commit实体，指向代码仓库根目录tree实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# .git/objects/d9/976cfe0430557885d162927dd70186d0f521e8
$ git cat-file commit d9976cf
tree 0ff699bbafc5d17d0637bf058c924ab405b5dcfe
author Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306739524 +0800
committer Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306739524 +0800

first commit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了tree实体。该tree代表目录“canai”。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# .git/objects/0f/f699bbafc5d17d0637bf058c924ab405b5dcfe
$ git ls-tree 0ff699
100644 blob 5f89c6f016cad2d419e865df380595e39b1256db  README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加一个修改过的文件&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ echo &amp;quot;Welcome everyone.&amp;quot; &amp;gt;&amp;gt; README
$ git add README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="添加一个修改过的文件后" src="/assets/uploads/pics/git-internals/modified-file.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更新了索引（Index）文件。注意到了吗？它记录了一个新blob。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git ls-files --stage
100644 1192db4c15e019da7fc053225d09dea14bc3ac07 0 README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的blob实体。README的整个内容被存入一个新的blob。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# .git/objects/11/92db4c15e019da7fc053225d09dea14bc3ac07
$ git cat-file blob 1192db
A roti canai project.
Welcome everyone.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;向子目录中添加文件&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ mkdir doc
$ echo &amp;quot;[[TBD]] manual toc&amp;quot; &amp;gt;&amp;gt; doc/manual.txt
$ git add doc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="向子目录添加文件后" src="/assets/uploads/pics/git-internals/subdir.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更新了索引（Index）文件。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git ls-files --stage
100644 1192db4c15e019da7fc053225d09dea14bc3ac07 0 README
100644 ea283e4fb22719fad512405d41dffa050cd16f9a 0 doc/manual.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的blob实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# .git/objects/ea/283e4fb22719fad512405d41dffa050cd16f9a
$ git cat-file blob ea283
[[TBD]] manual toc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第二次提交&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git commit -m&amp;#39;second commit&amp;#39;
[master 556eaf3] second commit
 2 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 doc/manual.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="第二次提交后" src="/assets/uploads/pics/git-internals/second-commit.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更新了分支“master”引用，指向该分支中最新的commit实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat .git/refs/heads/master 
556eaf374886d4c07a1906b9fdcaba195292b96
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了第二个commit实体。注意它的“parent”是指向首个commit实体。这样形成了一个提交图谱。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git cat-file commit 556e
tree 7729a8b15b747bce541a9752a8f10d57daf221b6
parent d9976cfe0430557885d162927dd70186d0f521e8
author Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306743598 +0800
committer Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306743598 +0800

second commit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的代码仓库根目录tree实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git ls-tree 7729
100644 blob 1192db4c15e019da7fc053225d09dea14bc3ac07  README
040000 tree 6ff17d485bf857514f299f0bde0e2a5c932bd055  doc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的子目录tree实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git ls-tree 6ff1
100644 blob ea283e4fb22719fad512405d41dffa050cd16f9a  manual.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加一个注释标签（annotated tag）&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git tag -a -m&amp;#39;this is annotated tag&amp;#39; v0.1 d9976
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="添加一个注释标签后" src="/assets/uploads/pics/git-internals/annotated-tag.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建了一个标签引用，指向一个tag实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat .git/refs/tags/v0.1 
c758f4820f02acf20bb3f6d7f6098f25ee6ed730
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个tag实体。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git cat-file tag c758
object d9976cfe0430557885d162927dd70186d0f521e8
type commit
tag v0.1
tagger Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306744918 +0800

this is annotated tag
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加一个新的（轻量的）标签&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ git tag root-commit d9976
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="添加一个新的轻量标签后" src="/assets/uploads/pics/git-internals/new-tag.png"&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建了一个标签引用，指向一个commit实体。&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cat .git/refs/tags/root-commit 
d9976cfe0430557885d162927dd70186d0f521e8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;补充阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://book.git-scm.com/index.html"&gt;Git社区书&lt;/a&gt;“第7章：内部构造探究”&lt;/li&gt;
&lt;li&gt;&lt;a href="http://progit.org/book/ch9-0.html"&gt;Pro Git&lt;/a&gt;“第9章：Git内部构造”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;接下来做什么呢？&lt;/h2&gt;
&lt;p&gt;寻找适合分布式团队、长期项目的一个最小化git工作流。&lt;/p&gt;</content><category term="其他"></category><category term="Git"></category><category term="翻译"></category></entry><entry><title>时间的心</title><link href="http://youngsterxyf.github.io/2013/08/22/heart-of-time/" rel="alternate"></link><published>2013-08-22T00:00:00+08:00</published><updated>2013-08-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-08-22:/2013/08/22/heart-of-time/</id><summary type="html">&lt;p&gt;近期工作生活的一点心得：&lt;/p&gt;
&lt;h3&gt;珍惜自己的时间&lt;/h3&gt;
&lt;p&gt;乐于助人是好事，但，是需要耗费时间的，那么在助人之前就得确认帮助别人所 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;近期工作生活的一点心得：&lt;/p&gt;
&lt;h3&gt;珍惜自己的时间&lt;/h3&gt;
&lt;p&gt;乐于助人是好事，但，是需要耗费时间的，那么在助人之前就得确认帮助别人所做的事情有多大意义，是否对得起所耗费的时间精力。每个人的时间都很珍贵，应尽可能用来做有价值的事情，不要把自己的时间看得过于廉价。&lt;/p&gt;
&lt;p&gt;所以之后有人请我帮忙时，我会先问两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到什么问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要解决这个问题？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这两个问题来判断是否值得帮忙。&lt;/p&gt;
&lt;h3&gt;平常心&lt;/h3&gt;
&lt;p&gt;一心追求技术，对技术好坏有自己的“正义感”，是好事。但，不能苛求别人，更不能不停评价吐槽，否则于己于人都无益处。对别人、别人的技术水平宽容一点，把苛求留给自己，不断提高自己，努力把事情做得更好，其他的则应保持平常心。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;至于本文的题目，则纯属扯淡，故作矫情，从两个部分的标题中取出最后一词组合而成。&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category><category term="自省"></category></entry><entry><title>Y分钟学会Python（译）</title><link href="http://youngsterxyf.github.io/2013/06/29/learn-python-in-y-minutes/" rel="alternate"></link><published>2013-06-29T00:00:00+08:00</published><updated>2013-06-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-29:/2013/06/29/learn-python-in-y-minutes/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://learnxinyminutes.com/docs/python/"&gt;Learn Python in Y Minutes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python由Guido Van Rossum发明于90年代初期，是目前最流行的编程语言之一，因其语法的清晰简洁我爱上了Python，其代码基本上可以
说是 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://learnxinyminutes.com/docs/python/"&gt;Learn Python in Y Minutes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python由Guido Van Rossum发明于90年代初期，是目前最流行的编程语言之一，因其语法的清晰简洁我爱上了Python，其代码基本上可以
说是可执行的伪代码。&lt;/p&gt;
&lt;p&gt;非常欢迎反馈！你可以通过推特&lt;a href="https://twitter.com/louiedinh"&gt;@louiedinh&lt;/a&gt;或louiedinh AT gmail联系我。&lt;/p&gt;
&lt;p&gt;备注：本文是专门针对Python 2.7的，但应该是适用于Python 2.x的。很快我也会为Python 3写这样的一篇文章！&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 单行注释以井字符开头&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot; 我们可以使用三个双引号（&amp;quot;）或单引号（&amp;#39;）&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    来编写多行注释&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;


&lt;span style="color: #008000"&gt;##########################################################&lt;/span&gt;
&lt;span style="color: #008000"&gt;## 1. 基本数据类型和操作符&lt;/span&gt;
&lt;span style="color: #008000"&gt;##########################################################&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 数字&lt;/span&gt;
3 &lt;span style="color: #008000"&gt;#=&amp;gt; 3&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 你预想的数学运算&lt;/span&gt;
1 + 1 &lt;span style="color: #008000"&gt;#=&amp;gt; 2&lt;/span&gt;
8 - 1 &lt;span style="color: #008000"&gt;#=&amp;gt; 7&lt;/span&gt;
10 * 2 &lt;span style="color: #008000"&gt;#=&amp;gt; 20&lt;/span&gt;
35 / 5 &lt;span style="color: #008000"&gt;#=&amp;gt; 7&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 除法略显诡异。整数相除会自动向下取小于结果的最大整数&lt;/span&gt;
11 / 4 &lt;span style="color: #008000"&gt;#=&amp;gt; 2&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 还有浮点数和浮点数除法（译注：除数和被除数两者至少一个为浮点数，结果才会是浮点数）&lt;/span&gt;
2.0     &lt;span style="color: #008000"&gt;# 这是一个浮点数&lt;/span&gt;
5.0 / 2.0 &lt;span style="color: #008000"&gt;#=&amp;gt; 2.5 额...语法更明确一些&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 使用括号来强制优先级&lt;/span&gt;
(1 + 3) * 2 &lt;span style="color: #008000"&gt;#=&amp;gt; 8&lt;/span&gt;


&lt;span style="color: #008000"&gt;# 布尔值也是基本类型数据&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;True&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 使用not来求反&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;True&lt;/span&gt; &lt;span style="color: #008000"&gt;#=&amp;gt; False&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;False&lt;/span&gt; &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 相等比较使用==&lt;/span&gt;
1 == 1 &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;
2 == 1 &lt;span style="color: #008000"&gt;#=&amp;gt; False&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 不相等比较使用!=&lt;/span&gt;
1 != 1 &lt;span style="color: #008000"&gt;#=&amp;gt; False&lt;/span&gt;
2 != 1 &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 更多的比较方式&lt;/span&gt;
1 &amp;lt; 10 &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;
1 &amp;gt; 10 &lt;span style="color: #008000"&gt;#=&amp;gt; False&lt;/span&gt;
2 &amp;lt;= 2 &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;
2 &amp;gt;= 2 &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 比较操作可以串接！&lt;/span&gt;
1 &amp;lt; 2 &amp;lt; 3 &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;
2 &amp;lt; 3 &amp;lt; 2 &lt;span style="color: #008000"&gt;#=&amp;gt; False&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 可以使用&amp;quot;或&amp;#39;创建字符串&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;This is a string.&amp;quot;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;#39;This is also a string.&amp;#39;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 字符串也可以相加！&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;Hello &amp;quot;&lt;/span&gt; + &lt;span style="color: #a31515"&gt;&amp;quot;world!&amp;quot;&lt;/span&gt; &lt;span style="color: #008000"&gt;#=&amp;gt; &amp;quot;Hello world!&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 字符串可以看作是一个字符列表&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;This is a string&amp;quot;&lt;/span&gt;[0] &lt;span style="color: #008000"&gt;#=&amp;gt; &amp;#39;T&amp;#39;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# None是一个对象&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;None&lt;/span&gt; &lt;span style="color: #008000"&gt;#=&amp;gt; None&lt;/span&gt;


&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;
&lt;span style="color: #008000"&gt;## 2. 变量与数据容器&lt;/span&gt;
&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 打印输出非常简单&lt;/span&gt;
print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m Python. Nice to meet you!&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 赋值之前不需要声明变量&lt;/span&gt;
some_var = 5    &lt;span style="color: #008000"&gt;# 约定使用 小写_字母_和_下划线 的命名方式&lt;/span&gt;
some_var &lt;span style="color: #008000"&gt;#=&amp;gt; 5&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 访问之前未赋值的变量会产生一个异常&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
    some_other_var
&lt;span style="color: #0000ff"&gt;except&lt;/span&gt; NameError:
    print &lt;span style="color: #a31515"&gt;&amp;quot;Raises a name error&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 赋值时可以使用条件表达式&lt;/span&gt;
some_var = a &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; a &amp;gt; b &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; b
&lt;span style="color: #008000"&gt;# 如果a大于b，则将a赋给some_var，&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 否则将b赋给some_var&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 列表用于存储数据序列&lt;/span&gt;
li = []
&lt;span style="color: #008000"&gt;# 你可以一个预先填充的列表开始&lt;/span&gt;
other_li = [4, 5, 6]

&lt;span style="color: #008000"&gt;# 使用append将数据添加到列表的末尾&lt;/span&gt;
li.append(1)    &lt;span style="color: #008000"&gt;#li现在为[1]&lt;/span&gt;
li.append(2)    &lt;span style="color: #008000"&gt;#li现在为[1, 2]&lt;/span&gt;
li.append(4)    &lt;span style="color: #008000"&gt;#li现在为[1, 2, 4]&lt;/span&gt;
li.append(3)    &lt;span style="color: #008000"&gt;#li现在为[1, 2, 4, 3]&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 使用pop从列表末尾删除数据&lt;/span&gt;
li.pop()    &lt;span style="color: #008000"&gt;#=&amp;gt; 3，li现在为[1, 2, 4]&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 把刚刚删除的数据存回来&lt;/span&gt;
li.append(3)    &lt;span style="color: #008000"&gt;# 现在li再一次为[1, 2, 4, 3]&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 像访问数组一样访问列表&lt;/span&gt;
li[0] &lt;span style="color: #008000"&gt;#=&amp;gt; 1&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 看看最后一个元素&lt;/span&gt;
li[-1] &lt;span style="color: #008000"&gt;#=&amp;gt; 3&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 越界访问会产生一个IndexError&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
    li[4] &lt;span style="color: #008000"&gt;# 抛出一个IndexError异常&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;except&lt;/span&gt; IndexError:
    print &lt;span style="color: #a31515"&gt;&amp;quot;Raises an IndexError&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 可以通过分片(slice)语法来查看列表中某个区间的数据&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 以数学角度来说，这是一个闭合/开放区间&lt;/span&gt;
li[1:3] &lt;span style="color: #008000"&gt;#=&amp;gt; [2, 4]&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 省略结束位置&lt;/span&gt;
li[2:] &lt;span style="color: #008000"&gt;#=&amp;gt; [4, 3]&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 省略开始位置&lt;/span&gt;
li[:3] &lt;span style="color: #008000"&gt;#=&amp;gt; [1, 2, 4]&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 使用del从列表中删除任意元素&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;del&lt;/span&gt; li[2] &lt;span style="color: #008000"&gt;#li现在为[1, 2, 3]&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 列表可以相加&lt;/span&gt;
li + other_li &lt;span style="color: #008000"&gt;#=&amp;gt; [1, 3, 3, 4, 5, 6] - 注意：li和other_li并未改变&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以extend来连结列表&lt;/span&gt;
li.extend(other_li) &lt;span style="color: #008000"&gt;# 现在li为[1, 2, 3, 4, 5, 6]&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以in来检测列表中是否存在某元素&lt;/span&gt;
1 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; li &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以len函数来检测列表长度&lt;/span&gt;
len(li) &lt;span style="color: #008000"&gt;#=&amp;gt; 6&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 元组类似列表，但不可变&lt;/span&gt;
tup  = (1, 2, 3)
tup[0] &lt;span style="color: #008000"&gt;#=&amp;gt; 1&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
    tup[0] = 3 &lt;span style="color: #008000"&gt;# 抛出一个TypeError异常&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;except&lt;/span&gt; TypeError:
    print &lt;span style="color: #a31515"&gt;&amp;quot;Tuples cannot be mutated.&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 可以在元组上使用和列表一样的操作&lt;/span&gt;
len(tup) &lt;span style="color: #008000"&gt;#=&amp;gt; 3&lt;/span&gt;
tup + (4, 5, 6) &lt;span style="color: #008000"&gt;#=&amp;gt; (1, 2, 3, 4, 5, 6)&lt;/span&gt;
tup[:2] &lt;span style="color: #008000"&gt;#=&amp;gt; (1, 2)&lt;/span&gt;
2 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; tup &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 可以将元组解包到变量&lt;/span&gt;
a, b, c = (1, 2, 3) &lt;span style="color: #008000"&gt;# 现在a等于1，b等于2，c等于3&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 如果你省略括号，默认也会创建元组&lt;/span&gt;
d, e, f = 4, 5, 6
&lt;span style="color: #008000"&gt;# 看看两个变量互换值有多简单&lt;/span&gt;
e, d = d, e     &lt;span style="color: #008000"&gt;#现在d为5，e为4&lt;/span&gt;


&lt;span style="color: #008000"&gt;# 字典存储映射关系&lt;/span&gt;
empty_dict = {}
&lt;span style="color: #008000"&gt;# 这是一个预先填充的字典&lt;/span&gt;
filled_dict = {&lt;span style="color: #a31515"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;: 1, &lt;span style="color: #a31515"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;: 2, &lt;span style="color: #a31515"&gt;&amp;quot;three&amp;quot;&lt;/span&gt;: 3}

&lt;span style="color: #008000"&gt;# 以[]语法查找值&lt;/span&gt;
filled_dict[&lt;span style="color: #a31515"&gt;&amp;#39;one&amp;#39;&lt;/span&gt;] &lt;span style="color: #008000"&gt;#=&amp;gt; 1&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以列表形式获取所有的键&lt;/span&gt;
filled_dict.keys() &lt;span style="color: #008000"&gt;#=&amp;gt; [&amp;quot;three&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;one&amp;quot;]&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 注意 - 字典键的顺序是不确定的&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 你的结果也许和上面的输出结果并不一致&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以in来检测字典中是否存在某个键&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;one&amp;quot;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; filled_dict &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;
1 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; filled_dict &lt;span style="color: #008000"&gt;#=&amp;gt; False&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 试图使用某个不存在的键会抛出一个KeyError异常&lt;/span&gt;
filled_dict[&lt;span style="color: #a31515"&gt;&amp;#39;four&amp;#39;&lt;/span&gt;] &lt;span style="color: #008000"&gt;#=&amp;gt; 抛出KeyError异常&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 使用get方法来避免KeyError&lt;/span&gt;
filled_dict.get(&lt;span style="color: #a31515"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;) &lt;span style="color: #008000"&gt;#=&amp;gt; 1&lt;/span&gt;
filled_dict.get(&lt;span style="color: #a31515"&gt;&amp;quot;four&amp;quot;&lt;/span&gt;) &lt;span style="color: #008000"&gt;#=&amp;gt; None&lt;/span&gt;

&lt;span style="color: #008000"&gt;# get方法支持一个默认参数，不存在某个键时返回该默认参数值&lt;/span&gt;
filled_dict.get(&lt;span style="color: #a31515"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;, 4) &lt;span style="color: #008000"&gt;#=&amp;gt; 1&lt;/span&gt;
filled_dict.get(&lt;span style="color: #a31515"&gt;&amp;quot;four&amp;quot;&lt;/span&gt;, 4) &lt;span style="color: #008000"&gt;#=&amp;gt; 4&lt;/span&gt;

&lt;span style="color: #008000"&gt;# setdefault方法是一种添加新的键-值对到字典的安全方式&lt;/span&gt;
filled_dict.setdefault(&lt;span style="color: #a31515"&gt;&amp;quot;five&amp;quot;&lt;/span&gt;, 5) &lt;span style="color: #008000"&gt;#filled_dict[&amp;quot;five&amp;quot;]设置为5&lt;/span&gt;
filled_dict.setdefault(&lt;span style="color: #a31515"&gt;&amp;quot;five&amp;quot;&lt;/span&gt;, 6) &lt;span style="color: #008000"&gt;#filled_dict[&amp;quot;five&amp;quot;]仍为5&lt;/span&gt;


&lt;span style="color: #008000"&gt;# 集合&lt;/span&gt;
empty_set = set()
&lt;span style="color: #008000"&gt;# 以几个值初始化一个集合&lt;/span&gt;
filled_set = set([1, 2, 2, 3, 4]) &lt;span style="color: #008000"&gt;# filled_set现为set([1, 2, 3, 4, 5])&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以&amp;amp;执行集合交运算&lt;/span&gt;
other_set = set([3, 4, 5, 6])
filled_set &amp;amp; other_set &lt;span style="color: #008000"&gt;#=&amp;gt; set([3, 4, 5])&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 以|执行集合并运算&lt;/span&gt;
filled_set | other_set &lt;span style="color: #008000"&gt;#=&amp;gt; set([1, 2, 3, 4, 5, 6])&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 以-执行集合差运算&lt;/span&gt;
set([1, 2, 3, 4]) - set([2, 3, 5]) &lt;span style="color: #008000"&gt;#=&amp;gt; set([1, 4])&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以in来检测集合中是否存在某个值&lt;/span&gt;
2 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; filled_set &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;
10 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; filled_set &lt;span style="color: #008000"&gt;#=&amp;gt; False&lt;/span&gt;


&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;
&lt;span style="color: #008000"&gt;## 3. 控制流程&lt;/span&gt;
&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 创建个变量&lt;/span&gt;
some_var = 5

&lt;span style="color: #008000"&gt;# 以下是一个if语句。缩进在Python是有重要意义的。&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 打印 &amp;quot;some_var is smaller than 10&amp;quot;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; some_var &amp;gt; 10:
    print &lt;span style="color: #a31515"&gt;&amp;quot;some_var is totally bigger than 10.&amp;quot;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;elif&lt;/span&gt; some_var &amp;lt; 10:
    print &lt;span style="color: #a31515"&gt;&amp;quot;some_var is smaller than 10.&amp;quot;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
    print &lt;span style="color: #a31515"&gt;&amp;quot;some_var is indeed 10.&amp;quot;&lt;/span&gt;


&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;For循环在列表上迭代&lt;/span&gt;
&lt;span style="color: #a31515"&gt;输出：&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    dog is a mammal&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    cat is a mammal&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    mouse is a mammal&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; animal &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [&lt;span style="color: #a31515"&gt;&amp;quot;dog&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;cat&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;mouse&amp;quot;&lt;/span&gt;]:
    &lt;span style="color: #008000"&gt;# 可以使用%来插补格式化字符串&lt;/span&gt;
    print &lt;span style="color: #a31515"&gt;&amp;quot;%s is a mammal&amp;quot;&lt;/span&gt; % animal

&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;while循环直到未满足某个条件。&lt;/span&gt;
&lt;span style="color: #a31515"&gt;输出：&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    0&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    1&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    2&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    3&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
x = 0
&lt;span style="color: #0000ff"&gt;while&lt;/span&gt; x &amp;lt; 4:
    print x
    x += 1    &lt;span style="color: #008000"&gt;# x = x + 1的一种简写&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 使用try/except块来处理异常&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 对Python 2.6及以上版本有效&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
    &lt;span style="color: #008000"&gt;# 使用raise来抛出一个错误&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; IndexError(&lt;span style="color: #a31515"&gt;&amp;quot;This is an index error&amp;quot;&lt;/span&gt;)
&lt;span style="color: #0000ff"&gt;except&lt;/span&gt; IndexError &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
    &lt;span style="color: #0000ff"&gt;pass&lt;/span&gt;    &lt;span style="color: #008000"&gt;# pass就是什么都不干。通常这里用来做一些恢复工作&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 对于Python 2.7及以下版本有效&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
    &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; IndexError(&lt;span style="color: #a31515"&gt;&amp;quot;This is an index error&amp;quot;&lt;/span&gt;)
&lt;span style="color: #0000ff"&gt;except&lt;/span&gt; IndexError, e:   &lt;span style="color: #008000"&gt;# 没有&amp;quot;as&amp;quot;，以逗号替代&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;pass&lt;/span&gt;


&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;
&lt;span style="color: #008000"&gt;## 4. 函数&lt;/span&gt;
&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 使用def来创建新函数&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; add(x, y):
    print &lt;span style="color: #a31515"&gt;&amp;quot;x is %s and y is %s&amp;quot;&lt;/span&gt; % (x, y)
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; x + y    &lt;span style="color: #008000"&gt;# 以一个return语句来返回值&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 以参数调用函数&lt;/span&gt;
add(5, 6) &lt;span style="color: #008000"&gt;#=&amp;gt; 11 并输出 &amp;quot;x is 5 and y is 6&amp;quot;&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 另一种调用函数的方式是关键字参数&lt;/span&gt;
add(x=5, y=6)   &lt;span style="color: #008000"&gt;# 关键字参数可以任意顺序输入&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 可定义接受可变数量的位置参数的函数&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; varargs(*args):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; args

varargs(1, 2, 3) &lt;span style="color: #008000"&gt;#=&amp;gt; (1, 2, 3)&lt;/span&gt;


&lt;span style="color: #008000"&gt;# 也可以定义接受可变数量关键字参数的函数&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; keyword_args(**kwargs):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; kwargs

&lt;span style="color: #008000"&gt;# 调用一下该函数看看会发生什么&lt;/span&gt;
keyword_args(big=&lt;span style="color: #a31515"&gt;&amp;quot;foot&amp;quot;&lt;/span&gt;, loch=&lt;span style="color: #a31515"&gt;&amp;quot;ness&amp;quot;&lt;/span&gt;) &lt;span style="color: #008000"&gt;#=&amp;gt; {&amp;quot;big&amp;quot;: &amp;quot;foo&amp;quot;, &amp;quot;loch&amp;quot;: &amp;quot;ness&amp;quot;}&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 也可以一次性接受两种参数&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; all_the_args(*args, **kwargs):
    print args
    print kwargs
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;all_the_args(1, 2, a=3, b=4)输出：&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    [1, 2]&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    {&amp;quot;a&amp;quot;: 3, &amp;quot;b&amp;quot;: 4}&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 在调用一个函数时也可以使用*和**&lt;/span&gt;
args = (1, 2, 3, 4)
kwargs = {&lt;span style="color: #a31515"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;: 3, &lt;span style="color: #a31515"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;: 4}
foo(*args)  &lt;span style="color: #008000"&gt;#等价于foo(1, 2, 3, 4)&lt;/span&gt;
foo(**kwargs)   &lt;span style="color: #008000"&gt;# 等价于foo(a=3, b=4)&lt;/span&gt;
foo(*args, **kwargs)    &lt;span style="color: #008000"&gt;# 等价于foo(1, 2, 3, 4, a=3, b=4)&lt;/span&gt;

&lt;span style="color: #008000"&gt;# Python的函数是一等函数&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; create_adder(x):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; adder(y):
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; x + y
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; adder

add_10 = create_adder(10)
add_10(3) &lt;span style="color: #008000"&gt;#=&amp;gt; 13&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 也有匿名函数&lt;/span&gt;
(lamda x: x &amp;gt; 2)(3) &lt;span style="color: #008000"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 有一些内置的高阶函数&lt;/span&gt;
map(add_10, [1, 2, 3]) &lt;span style="color: #008000"&gt;#=&amp;gt; [11, 12, 13]&lt;/span&gt;
filter(lamda x: x &amp;gt; 5, [3, 4, 5, 6, 7]) &lt;span style="color: #008000"&gt;#=&amp;gt;[6, 7]&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 可以使用列表推导来实现映射和过滤&lt;/span&gt;
[add_10(i) &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [1, 2, 3]] &lt;span style="color: #008000"&gt;#=&amp;gt; [11, 13, 13]&lt;/span&gt;
[x &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; x &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [3, 4, 5, 6,7 ] &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; x &amp;gt; 5] &lt;span style="color: #008000"&gt;#=&amp;gt; [6, 7]&lt;/span&gt;

&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;
&lt;span style="color: #008000"&gt;## 5. 类&lt;/span&gt;
&lt;span style="color: #008000"&gt;####################################################&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 创建一个子类继承自object来得到一个类&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Human&lt;/span&gt;(object):

    &lt;span style="color: #008000"&gt;# 类属性。在该类的所有示例之间共享&lt;/span&gt;
    species = &lt;span style="color: #a31515"&gt;&amp;quot;H. sapiens&amp;quot;&lt;/span&gt;

    &lt;span style="color: #008000"&gt;# 基本初始化构造方法&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, name):
        &lt;span style="color: #008000"&gt;# 将参数赋值给实例的name属性&lt;/span&gt;
        self.name = name

    &lt;span style="color: #008000"&gt;# 实例方法。所有示例方法都以self为第一个参数&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; say(self, msg):
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;%s: %s&amp;quot;&lt;/span&gt; % (self.name, msg)

    &lt;span style="color: #008000"&gt;# 类方法由所有实例共享&lt;/span&gt;
    &lt;span style="color: #008000"&gt;# 以调用类为第一个参数进行调用&lt;/span&gt;
    @classmethod
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; get_species(cls):
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; cls.species

    &lt;span style="color: #008000"&gt;# 静态方法的调用不需要一个类或实例的引用&lt;/span&gt;
    @staticmethod
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; grunt():
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;*grunt*&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 实例化一个类&lt;/span&gt;
i = Human(name=&lt;span style="color: #a31515"&gt;&amp;quot;Ian&amp;quot;&lt;/span&gt;)
print i.say(&lt;span style="color: #a31515"&gt;&amp;quot;hi&amp;quot;&lt;/span&gt;)       &lt;span style="color: #008000"&gt;# 输出&amp;quot;Ian: hi&amp;quot;&lt;/span&gt;

j = Human(&lt;span style="color: #a31515"&gt;&amp;quot;Joel&amp;quot;&lt;/span&gt;)
print j.say(&lt;span style="color: #a31515"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;)        &lt;span style="color: #008000"&gt;# 输出&amp;quot;Joel: hello&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 调用类方法&lt;/span&gt;
i.get_species() &lt;span style="color: #008000"&gt;#=&amp;gt; &amp;quot;H. sapiens&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 修改共享属性&lt;/span&gt;
Human.species = &lt;span style="color: #a31515"&gt;&amp;quot;H. neanderthalensis&amp;quot;&lt;/span&gt;
i.get_species() &lt;span style="color: #008000"&gt;#=&amp;gt; &amp;quot;H. neanderthalensis&amp;quot;&lt;/span&gt;
j.get_species() &lt;span style="color: #008000"&gt;#=&amp;gt; &amp;quot;H. neanderthalensis&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 调用静态方法&lt;/span&gt;
Human.grunt()   &lt;span style="color: #008000"&gt;#=&amp;gt; &amp;quot;*grunt*&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;进一步阅读&lt;/h3&gt;
&lt;p&gt;想要学习更多？试试&lt;a href="http://learnpythonthehardway.org/book/"&gt;笨方法学习Python&lt;/a&gt;。&lt;/p&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>FTP是90年代的，使用Git取代它来部署代码吧！（译）</title><link href="http://youngsterxyf.github.io/2013/06/24/deploy-via-git/" rel="alternate"></link><published>2013-06-24T00:00:00+08:00</published><updated>2013-06-24T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-24:/2013/06/24/deploy-via-git/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://coderwall.com/p/xczkaq?&amp;amp;p=1&amp;amp;q="&gt;FTP is so 90's. Let's deploy via Git instead!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，在你的服务器上创建一个目录，并在其中初始化一个空的git仓库。我喜欢使用&lt;code&gt;~/www/&lt;/code&gt;目录来 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://coderwall.com/p/xczkaq?&amp;amp;p=1&amp;amp;q="&gt;FTP is so 90's. Let's deploy via Git instead!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，在你的服务器上创建一个目录，并在其中初始化一个空的git仓库。我喜欢使用&lt;code&gt;~/www/&lt;/code&gt;目录来存放网站代码，
因此我会这么做：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mkdir ~/www/example.com &amp;amp;&amp;amp; cd ~/www/example.com
git init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着，设置你服务器上的git仓库以便很好地通过&lt;code&gt;git push&lt;/code&gt;来部署代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git config core.worktree ~/www/example.com
git config receive.denycurrentbranch ignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，为git设置一个post-receive钩子来检出&lt;code&gt;master&lt;/code&gt;分支，这样，你的web服务器就可以为那个分支的代码文件服务了。
（记住，&lt;code&gt;^D&lt;/code&gt;是Control+D，或任何一种你shell的&lt;a href="http://en.wikipedia.org/wiki/End-of-transmission_character"&gt;EOT字符&lt;/a&gt;）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat &amp;gt; .git/hooks/post-receive
&lt;span style="color: #008000"&gt;#!/bin/sh&lt;/span&gt;
git checkout -f
^D
chmod +x .git/hooks/post-receive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;谨记：若需要一个构建过程，你可以在post-receive钩子中添加任何你想要添加的东西。例如，我的sinatra项目其中之一使用了如下的
post-receive钩子：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;#!/bin/sh&lt;/span&gt;
git checkout -f
bundle install
touch ~/www/example.com/tmp/restart.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;回到你的本地机器，为代码部署准备好你的git仓库。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cd ~/www/dev/example.com
git remote add origin &lt;span style="color: #a31515"&gt;\&lt;/span&gt;
ssh://user@example.com/home/user/www/example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于第一次推送代码到服务器，执行如下命令。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在，任何时候你想部署本地的变更，只要简单地执行如下命令！&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Git"></category><category term="翻译"></category></entry><entry><title>搭建测试服务器(源码编译方式)</title><link href="http://youngsterxyf.github.io/2013/06/18/setup-testing-server/" rel="alternate"></link><published>2013-06-18T00:00:00+08:00</published><updated>2013-06-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-18:/2013/06/18/setup-testing-server/</id><summary type="html">&lt;p&gt;目前工作中开发流程还比较初级，甚至连测试服务器都没有，代码的变更都是直接先在开发人员的本地机器上简单测试 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;目前工作中开发流程还比较初级，甚至连测试服务器都没有，代码的变更都是直接先在开发人员的本地机器上简单测试一下，然后直接部署到生产服务器上，这就相当于生产服务器同时充当了测试服务器的角色，虽然开发的是面向公司内部的系统，但作为一个有理想有追求的码农，是不允许这样粗糙混乱的开发流程的，所以申请了台服务器，自己搭建个测试服务器。&lt;/p&gt;
&lt;p&gt;由于公司的服务器统一使用SUSE Linux Server操作系统，并且版本较老。与Ubuntu、Centos等Linux发行版不同，SUSE Linux没有可用的软件源（不知是否与OpenSUSE的软件源兼容？），即没法使用系统的软件包管理工具。这样问题就很多了。&lt;/p&gt;
&lt;p&gt;我选择源码编译的方式来安装所有涉及的软件。也许有人会说，为什么不在网络上查找RPM包然后安装呢？那么先想一下RPM包本质上是个什么东西呢？RPM包（以及DEB包）其实就是将编译好的一些程序以一定的规则打包在一起，然后系统的包管理工具（yum、zypper）按照相同的规则（在依赖满足的情况下）将RPM包里文件复制到指定好的目录里。如果RPM包的依赖没有解决，是无法成功安装的。即使安装好了，若程序依赖的动态链接库等不存在或版本不匹配，也是无法正确运行的，比如libc库的版本过低，但明显你不能轻易替换libc库，因为系统中已安装的很多程序都依赖于libc库。那么相比源码编译方式，RPM包方式的问题更难解决。&lt;/p&gt;
&lt;p&gt;需要安装的软件有Nginx、PHP、MySQL、Memcached、Redis、Mongodb、Python2.7（系统上自带了2.4版本，版本过老）、Git、Gitlab、Ruby（Gitlab基于Ruby on Rails实现），运维工具tmux、htop，以及基础依赖库curl（libcurl）、cmake、libxml2、libxslt、openssl、pcre、readline、zlib、ic4c、libevent等。&lt;/p&gt;
&lt;p&gt;除Gitlab之外（因为Gitlab是个Web应用）的所有软件编译安装流程都类似：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;wget [下载链接]&lt;/code&gt;   # 对于https协议的链接，也许需要添加 &lt;code&gt;--no-check-certificate&lt;/code&gt; 来避免证书验证。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -xvf [软件源码压缩包(*.tar.gz/*.tar)] / unzip [软件源码压缩包(*.zip)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd [源码目录] &amp;amp;&amp;amp; ./configure [--prefix=...] [...]&lt;/code&gt;  # openssl的是./config [...]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中最重要的步骤是&lt;code&gt;./configure&lt;/code&gt;。在这一步中将指定软件的安装目录，以及其他参数（比如依赖的路径）。可以通过&lt;code&gt;./configure --help&lt;/code&gt;来查看configure的选项列表，认真阅读一下，看看自己的编译是否需要带上某些选项。&lt;/p&gt;
&lt;p&gt;软件在编译过程中可能会自动查找借助某些工具，若找不到可能就会编译失败，其查找的规则一般就是环境变量PATH。所以若发现是因为找不到某些工具软件导致编译失败，那得确认一下系统是否安装该工具，若已安装，则配置一下PATH（&lt;code&gt;export PATH=$PATH:/path/to/tool/&lt;/code&gt;或&lt;code&gt;export PATH=/path/to/tool/:$PATH&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;软件也可能依赖一些动态或静态链接库，其查找规则是&lt;code&gt;/etc/ld.so.conf&lt;/code&gt;文件中指定的查找路径。编译过程中经常会因为未找到动态链接库而失败，如果该库已存在，可能需配置一下ld.so.conf，将依赖库的路径添加到ld.so.conf中，然后执行ldconfig。&lt;/p&gt;
&lt;p&gt;很多时候编译失败了，但你并不知道编译过程尝试过去哪些路径中查找某个依赖库。直接阅读Makefile并修改不是个好主意。这时strace神器就派上用场了。&lt;strong&gt;strace is a system call tracer, i.e. a debugging tool which prints out a trace of all the system calls made by a another process/program&lt;/strong&gt;。比如：&lt;code&gt;strace make&lt;/code&gt;，就会输出大量跟踪信息。当编译因未找到依赖而中止后，回溯输出的跟踪信息，看看make过程找过哪些路径，然后将依赖文件软链接到这些路径中某一个，再重新编译。&lt;/p&gt;
&lt;p&gt;从上述4个方面可以解决大多数编译过程中的依赖问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;关于编译安装路径，我个人的看法是，基础依赖库，如openssl、zlib等在configure的时候不使用--prefix选项，即使用默认的安装路径，这样其他依赖于这些基础库的软件编译过程中发生依赖缺失问题的可能性要小一些。若系统原来存在老版本的依赖库，这样的默认安装路径方式一般并不会覆盖老版本文件，所以也不用担心会导致系统中已安装的软件运行存在问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;关于mysql的编译安装过程可参考：&lt;a href="http://www.linuxidc.com/linux/2011-08/40087.htm"&gt;Linux下源码编译MySQL 5.5 与安装过程全记录&lt;/a&gt;，过程较为复杂。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PHP源码编译默认不会产生php-fpm（PHP-FPM (FastCGI Process Manager) is an alternative PHP FastCGI implementation with some additional features useful for sites of any size, especially busier sites.），从&lt;code&gt;./configure --help&lt;/code&gt;的输出中可以看到这样几行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;--enable-fpm              Enable building of the fpm SAPI executable
--with-fpm-user=USER  Set the user for php-fpm to run as. (default: nobody)
--with-fpm-group=GRP  Set the group for php-fpm to run as. For a system user, this
              should usually be set to match the fpm username (default: nobody)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样只要在configure的时候提供这几个选项就可以启用php-fpm了。&lt;/p&gt;
&lt;p&gt;为保证测试服务器上的PHP启用的扩展模块与生产服务器上的PHP一致，可通过phpinfo()函数来获知生产服务器上的PHP在configure编译的时候带了哪些选项。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/php-configure.jpg" alt="php-configure.jpg"&gt;&lt;/p&gt;
&lt;p&gt;但这样你得额外编译安装zlib、libmcrypt、libpng、freetype等库。&lt;/p&gt;
&lt;p&gt;PHP configure的选项特别多。&lt;/p&gt;
&lt;p&gt;最后我的configure命令为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;./configure --prefix=/usr/local/php --enable-fpm --with-mysql=/usr/local/mysql \
        --with-mysqli=/usr/local/mysql/bin/mysql_config --with-gd --enable-sockets \
        --enable-bcmath --enable-mbstring --enable-zip --with-zlib=/usr/local/zlib \
        --with-mcrypt --with-freetype-dir=/usr --with-curl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;PHP安装完成后，可能还需编译安装一些扩展模块，比如：Redis、memcache、APC等。PHP扩展模块的编译安装流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/usr/local/php/bin/phpize&lt;/li&gt;
&lt;li&gt;./configure --with-php-config=/usr/local/php/bin/php-config [...]    # 可通过./configure --help查看该扩展configure可带的选项&lt;/li&gt;
&lt;li&gt;make &amp;amp;&amp;amp; make install&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果扩展模块最后安装的路径并不是你期望的，则可以将所有编译好的扩展模块统一复制到同一个路径之下，然后修改php.ini（如果不存在，则可在/path/to/php/lib目录下新建一个）中extension_dir一项的值为扩展模块的统一路径，并为每个新增的扩展模块添加一行&lt;code&gt;extension=xxx.so&lt;/code&gt;，如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;extension=redis.so
extension=memcache.so
extension=apc.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后可通过phpinfo()函数来确认是否成功安装扩展。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;关于Python源码编译，除了可能存在依赖问题外，默认的配置（Modules/Setup.dist）没有启用一些标准库模块，这些模块在实际中又非常基础常用。所以在configure之前需要编辑Modules/Setup.dist文件，启用某些必要的模块（只需去除某些行前&lt;code&gt;#&lt;/code&gt;符号，稍微阅读一下该文件就知道了），但某些模块又有其他依赖，从而导致Python编译失败，这样的模块可以不启用，所以可能需要多次来回尝试。在make编译结束时的输出信息中会提示哪些必要的模块没有启用，以及哪些模块已启用但编译失败了。你可以忽略这些模块，但之后Python的使用可能会存在一些问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由于Git可以支持HTTP、GIT、HTTPS、SSH协议，会依赖libssl、libcrypto、libcurl、libmcrypt等库，libssl、libcrypto这两个库都由openssl编译产生，libcurl由curl编译产生。如果未能成功编译ssl支持，也能通过编译，只是在之后的使用中遇到HTTPS协议可能会有问题。如果使用Git遇到HTTPS协议不能成功验证证书时，可以设置&lt;code&gt;git config --global http.sslVerify false&lt;/code&gt;来避免证书验证。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Gitlab是基于Ruby on Rails实现的类Github代码托管平台。其官方的安装教程见：&lt;a href="https://github.com/gitlabhq/gitlabhq/blob/5-0-stable/doc/install/installation.md"&gt;https://github.com/gitlabhq/gitlabhq/blob/5-0-stable/doc/install/installation.md&lt;/a&gt;，不同Gitlab版本的安装过程有些不同，链接指向的是5-0-stable版本的安装教程。官方的安装教程是针对Ubuntu/Debian的，其他Linux发行版的安装过程会略有不同。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;由于我对于Ruby以及Ruby on Rails并不了解，以下内容可能有些表述不正确的地方，请注意。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;与Python的pip和easy_install一样，Ruby使用gem来管理第三方库，并通常使用bundle来管理应用的依赖问题（Ruby on Rails就使用bundle来管理依赖），bundle其实又借助了gem。&lt;/p&gt;
&lt;p&gt;与Python的pypi以及Linux发行版的软件源一样，RubyGems在世界各地也有很多镜像。为了加快gem安装第三方库的过程，国内可以选择&lt;a href="http://ruby.taobao.org/"&gt;淘宝的RubyGems镜像&lt;/a&gt;，更改镜像的方法见&lt;a href="http://ruby.taobao.org/"&gt;淘宝RubyGems镜像网站&lt;/a&gt;上的说明。&lt;/p&gt;
&lt;p&gt;对于bundle，要想修改它所使用的RubyGems镜像，可以通过编辑应用根目录中的Gemfile文件的第一行&lt;code&gt;source "http://xxxxx"&lt;/code&gt;来修改。&lt;/p&gt;
&lt;p&gt;安装Gitlab过程使用bundle安装Mysql2 gem等依赖时，可能会遇到这种类似的问题：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Installing mysql2 (0.3.11) with native extensions
Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是由于gem未找到mysql的一些头文件，即include目录中的文件。在Ubuntu/Debian中，可能可以通过&lt;code&gt;sudo apt-get install libmysqlclient-dev&lt;/code&gt;来解决问题（可以通过系统包管理器安装的软件的dev包，其实就是源码编译安装后include目录中的内容）。对于我所处的系统环境，只能想法子让gem能找到include目录。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;bundle install [...]&lt;/code&gt;后，找到mysql2 gem的目录，比如在我的Gitlab中路径为&lt;code&gt;gitlab/vendor/bundle/ruby/1.9.1/gems/mysql2-0.3.11&lt;/code&gt;，再查看从子目录&lt;code&gt;ext/mysql2&lt;/code&gt;中的extconf.rb文件，文件中有这样一段：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dirs = ENV[&amp;#39;PATH&amp;#39;].split(File::PATH_SEPARATOR) + %w[
/opt
/opt/local
/opt/local/mysql
/opt/local/lib/mysql5
/usr
/usr/local
/usr/local/mysql
/usr/local/mysql-*
/usr/local/lib/mysql5
].map{|dir| &amp;quot;#{dir}/bin&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我bundle install的时候之所以失败，是因为我把mysql安装到了/usr/local/mysql56目录，所以gem找不到mysql的include目录。直接在extconf.rb文件中添加mysql安装路径是没用的，因为每次执行bundle install都会重新生成该文件，所以我执行&lt;code&gt;cp -r /usr/local/mysql56 /usr/local/mysql&lt;/code&gt;来创建了mysql目录，应该也可以通过软链接来实现。&lt;/p&gt;
&lt;p&gt;其他某些gem依赖可能也会有这样的问题，可以通过这样类似的方式解决。&lt;/p&gt;
&lt;p&gt;Ubuntu/Debian中安装nginx后，在nginx配置目录/etc/nginx中会自动生成sites-available、sites-enabled这两个目录，这两目录的关系是这样的：在sites-available目录中为每个可能需要nginx服务的应用编写一个虚拟主机配置文件（对于nginx配置即server模块），若某个应用现在需要nginx服务，则将它的配置文件从sites-available软链接到sites-enabled，而nginx的主配置文件nginx.conf的http模块的最后通过&lt;code&gt;include sites-enabled/*&lt;/code&gt;将sites-enabled中所有的软链接配置文件包含进来。这种方式的好处在于模块化配置文件，非常灵活方便。但在SUSE中编译安装后，conf目录下并没有这两个目录，所以只能自己创建，并修改nginx.conf的http模块最后手动添加&lt;code&gt;include sites-enabled/*&lt;/code&gt;一行即可。&lt;/p&gt;
&lt;p&gt;之后在试用Gitlab时，发现无法查看代码文件中的内容，通过浏览器的开发者工具看到是个500 Server Error响应。查看gitlab/log目录中的unicorn.stderr.log日志文件，有如下错误信息：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ActionView::Template::Error (Failed to get header.):
9:   .file_content.code
10:     - unless blob.empty?
11:       %div{class: user_color_scheme_class}
12:         = raw blob.colorize(formatter: :gitlab)
13:     - else
14:       %p.nothing_here_message Empty file
app/models/tree.rb:6:in `colorize&amp;#39;
app/views/tree/blob/_text.html.haml:12:in `_app_views_tree_blob__text_html_haml__128024721089489703_57418280&amp;#39;
app/views/tree/_blob.html.haml:9:in `_app_views_tree__blob_html_haml__1829533197002461340_55995660&amp;#39;
app/views/tree/_tree.html.haml:16:in `_app_views_tree__tree_html_haml___4517474428772753218_46927720&amp;#39;
app/views/tree/show.html.haml:4:in `_app_views_tree_show_html_haml__3020201194833589280_44750920&amp;#39;
app/controllers/tree_controller.rb:17:in `show&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看网络资料可以知道这是由于代码高亮渲染的时候出了问题。Gitlab使用pygments.rb来高亮代码。pygments.rb是&lt;strong&gt;Ruby wrapper for the Python &lt;a href="http://pygments.org/"&gt;pygments syntax highlighter&lt;/a&gt;&lt;/strong&gt;。那么，高亮渲染失败可能有三种可能：(1)未找到合适的Python版本，pygments.rb依赖于Python 2.5+，(2)没有安装Python的pygments第三方库，(3)其他原因。很不幸，我遇到的是第三种可能。官方&lt;a href="https://github.com/gitlabhq/gitlab-public-wiki/wiki/Trouble-Shooting-Guide"&gt;Trouble-Shooting-Guide&lt;/a&gt;对于该问题给出&lt;a href="https://github.com/gitlabhq/gitlabhq/issues/2214#issuecomment-11137058"&gt;解决方案&lt;/a&gt;是针对第一种可能的。&lt;/p&gt;
&lt;p&gt;在pyments.rb gem目录&lt;code&gt;gitlab/vendor/bundle/ruby/1.9.1/gems/pygments.rb-0.4.2&lt;/code&gt;的子目录&lt;code&gt;lib/pygments&lt;/code&gt;中有(且仅有)一个可执行的python源码文件mentos.py，pygments.rb应该就是通过该程序文件调用Python的pygments库来高亮代码的，我尝试执行该文件，执行失败，原因是标准库json的某行代码中对象调用了encode('hex')方法失败，提示不存在hex编码。经分析查找原因，问题出在标准库模块&lt;a href="http://docs.python.org/2/library/binascii.html"&gt;binascii&lt;/a&gt;(The binascii module contains a number of methods to convert between binary and various ASCII-encoded binary representations)未编译安装。该模块需要编辑Modules/Setup.dist文件启用。启用后（可能还有其他相关模块，我是把其他很多模块一起启用了）重新编译Python就可以了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;源码编译安装软件遇到最多的问题是依赖缺失，有时会非常繁琐。经过这次经历，我深感操作系统的软件包管理器是多么的重要，能节省我们很多很多时间和精力！&lt;/p&gt;</content><category term="其他"></category><category term="Linux"></category><category term="PHP"></category><category term="MySQL"></category><category term="Nginx"></category><category term="服务器"></category><category term="Python"></category><category term="Git"></category></entry><entry><title>PHP最佳实践（译）</title><link href="http://youngsterxyf.github.io/2013/06/01/php-best-practices/" rel="alternate"></link><published>2013-06-01T00:00:00+08:00</published><updated>2013-06-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-01:/2013/06/01/php-best-practices/</id><summary type="html">&lt;p&gt;原文： &lt;a href="https://phpbestpractices.org/"&gt;PHP Best Practices-A short, practical guide for common and confusing PHP tasks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;最后修订日期&amp;amp;维护者&lt;/h2&gt;
&lt;p&gt;本文档最后审阅于2013年3月8日。最后修改于2013年5月8日。&lt;/p&gt;
&lt;p&gt;由我，&lt;a href="https://alexcabal.com/"&gt;Alex Cabal&lt;/a&gt;，维护该文档 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文： &lt;a href="https://phpbestpractices.org/"&gt;PHP Best Practices-A short, practical guide for common and confusing PHP tasks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;最后修订日期&amp;amp;维护者&lt;/h2&gt;
&lt;p&gt;本文档最后审阅于2013年3月8日。最后修改于2013年5月8日。&lt;/p&gt;
&lt;p&gt;由我，&lt;a href="https://alexcabal.com/"&gt;Alex Cabal&lt;/a&gt;，维护该文档。我编写PHP程序已有很长一段时间了，当前我
经营着&lt;a href="http://www.scribophile.com/"&gt;Scribophile，由认真作家组成的一个在线写作团体&lt;/a&gt;,
&lt;a href="http://writerfolio.com/"&gt;Writerfolio，为自由职业者提供的一个易用写作工具集&lt;/a&gt;，以及
&lt;a href="https://standardebooks.com"&gt;Standard Ebooks，一个图文并茂、无数字版权管理的公共领域电子书出版商&lt;/a&gt;。
有时我是个为吸引我的项目或客户而工作的自由职业者。&lt;/p&gt;
&lt;p&gt;如果你认为我在某些事情上能够帮到你，或者对本文档有点建议或纠正存在的错误，&lt;a href="https://alexcabal.com/contact/"&gt;请给我写封邮件&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;PHP是一门复杂的语言，经过多年折腾，使其不同版本之间高度不一致，有时还有些bug。
每个版本都有自己独有的特性、多余和怪异之处，也很难跟踪哪个版本有哪些问题。这也就
很好理解为什么有时它会遭到那么多的厌恶。&lt;/p&gt;
&lt;p&gt;尽管如此，如今它还是Web开发方面最流行的语言。因其悠久的历史，对于实现密码哈希和
数据库访问诸如此类的基本任务你能够找到很多教程。但问题在于，5个教程，你就很有可能
找到5种完全不同的完成任务的方式，那么哪种是“正确”的方式呢？其他方式有难以捉摸的bug
或者陷阱？确实很难搞明白，所以你经常要在互联网上反复查找尝试确认正确的答案。&lt;/p&gt;
&lt;p&gt;这也是PHP编程新手频繁地因为丑陋、过时、或不安全的代码而遭到责备的原因之一。如果
Google搜索的第一个结果是一篇4年前的文章，讲述一种5年前的方法，那么PHP新手们也就
很难改变经常遭受责备的现状。&lt;/p&gt;
&lt;p&gt;本文档通过为PHP中常见的令人困惑的问题和任务编辑组织一系列被认为最佳实践的基本做法，
来尝试解决上述问题。若一个低层次的任务在PHP中有多种令人困惑的实现方式，本文也会涵盖。&lt;/p&gt;
&lt;h3&gt;是什么&lt;/h3&gt;
&lt;p&gt;这是一份指南，在PHP程序员遇到一些常见低层次任务但不明确最佳做法（由于PHP可能提供
了多种解决方案）之时，为其建议最佳实践。例如：连接数据库是一个常见任务，PHP中提供了
大量可行的方案，但并不是所有的都是好的做法，因此，本文也会包含该问题。&lt;/p&gt;
&lt;p&gt;本文包含的是一系列简短的、入门性质的方案。涉及的示例在基本设定下就能够运行起来，
你研究一下应该就能把它们变为对你有用的东西。&lt;/p&gt;
&lt;p&gt;本文将指出一些我们认为是PHP中最新最好的东西。然而，这意味如果你在使用老版本的PHP，
一些用来实现这些解决方案的特性对你并不可用。&lt;/p&gt;
&lt;p&gt;这份文档会一直更新，我会尽我最大努力保持该文档与PHP的发展同步。&lt;/p&gt;
&lt;h3&gt;不是什么&lt;/h3&gt;
&lt;p&gt;本文档不是一份PHP教程。你应该在别处学习语言基础和语法。&lt;/p&gt;
&lt;p&gt;它也不是一份针对web应用常见问题，如cookie存储、缓存、编程风格、文档等的指南。&lt;/p&gt;
&lt;p&gt;它也不是一个安全指南。当本文档触碰到一些安全相关的问题时，也是希望你自己做些研究来
确保你的PHP应用的安全问题。你的代码造成的问题应该都是自己的过错。&lt;/p&gt;
&lt;p&gt;该文档也并不是在主张一种特定的编程风格、模式或者框架。&lt;/p&gt;
&lt;p&gt;也不是在主张一种特定的方式来完成高层次任务如用户注册、登录系统等。本文档只限于
PHP的悠久历史所造成的一些易混淆或不明确的低层次任务。&lt;/p&gt;
&lt;p&gt;它不是一个一劳永逸的解决方案，也不是一个唯一的方案。下面要讲述的一些方法对于你的
特定场景来说也许并不是最好的，存在很多不同的方式来达到同样的目的。特别是，高负载web
应用也许能从更加难懂的方案中获益更多。&lt;/p&gt;
&lt;h2&gt;我们在使用哪个版本的PHP？&lt;/h2&gt;
&lt;h3&gt;带Suhosin-Patch的PHP 5.3.10-1ubuntu3.6，安装在Ubuntu 12.04 LTS上。&lt;/h3&gt;
&lt;p&gt;PHP是Web世界里的百年老龟，它的壳上铭刻着一段丰富、复杂、而粗糙的历史。在一个共享
主机的环境里，它的配置可能会限制你能做的事情。&lt;/p&gt;
&lt;p&gt;为了保持清晰地叙述，我们将仅针对一个版本的PHP进行讲述。在2013年4月30日时，该版本
为&lt;strong&gt;PHP 5.3.10-1ubuntu3.6 with Suhosin-Patch&lt;/strong&gt;。若你在&lt;strong&gt;Ubuntu 12.04 LTS&lt;/strong&gt;服务器
上使用apt-get进行安装的就是该版本的PHP。&lt;/p&gt;
&lt;p&gt;你也许发现这些方案中的一些在其他或者更老版本的PHP上也能工作。如果是这样的话，就&lt;em&gt;由
你来研究在这些更老版本上潜在的难以捉摸的bug或安全问题&lt;/em&gt;。&lt;/p&gt;
&lt;h2&gt;存储密码&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://www.openwall.com/phpass/"&gt;phpass&lt;/a&gt;库来哈希和比较密码&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;经phpass 0.3测试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在存入数据库之前进行哈希保护用户密码的标准方式。许多常用的哈希算法如md5,甚至是sha1
对于密码存储都是不安全的，因为&lt;a href="http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/"&gt;骇客能够使用那些算法轻而易举地破解密码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对密码进行哈希最安全的方法是使用bcrypt算法。开源的phpass库以一个易于使用的类来提供
该功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Include the phpass library&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;require_once&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;phpass-03/PasswordHash.php&amp;#39;&lt;/span&gt;)

&lt;span style="color: #008000"&gt;// Initialize the hasher without portable hashes (this is more secure)&lt;/span&gt;
$hasher = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; PasswordHash(8, &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Hash the password. $hashedPassword will be a 60-character string.&lt;/span&gt;
$hashedPassword = $hasher-&amp;gt;HashPassword(&lt;span style="color: #a31515"&gt;&amp;#39;my super cool password&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// You can now safely store the contents of $hashedPassword in your database!&lt;/span&gt;

&lt;span style="color: #008000"&gt;// Check if a user has provided the correct password by comparing what they&lt;/span&gt;
&lt;span style="color: #008000"&gt;// typed with our hash&lt;/span&gt;
$hasher-&amp;gt;CheckPassword(&lt;span style="color: #a31515"&gt;&amp;#39;the wrong password&amp;#39;&lt;/span&gt;, $hashedPassword);  &lt;span style="color: #008000"&gt;// false&lt;/span&gt;

$hasher-&amp;gt;CheckPassword(&lt;span style="color: #a31515"&gt;&amp;#39;my super cool password&amp;#39;&lt;/span&gt;, $hashedPassword);  &lt;span style="color: #008000"&gt;// true&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;许多资源可能推荐你在哈希之前对你的密码“加盐”。想法很好，但phpass在HashPassword()函数中已经对你的密码“加盐”了，这意味着你不需要自己“加盐”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.openwall.com/phpass/"&gt;phpass&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blogs.msdn.com/b/lixiong/archive/2011/12/25/md5-sha1-salt-and-bcrypt.aspx"&gt;为什么使用md5或sha哈希密码是不安全的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codahale.com/how-to-safely-store-a-password/"&gt;怎样安全地存储密码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;连接并查询MySQL数据库&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/book.pdo.php"&gt;PDO&lt;/a&gt;及其预处理语句功能。&lt;/h3&gt;
&lt;p&gt;在PHP中，有很多方式来连接到一个MySQL数据库。PDO（PHP数据对象）是其中最新且最健壮的一种。PDO跨多种不同类型数据库有一个一致的接口，使用面向对象的方式，支持更多的新数据库支持的特性。&lt;/p&gt;
&lt;p&gt;你应该使用PDO的预处理语句函数来帮助防范SQL注入攻击。使用函数&lt;a href="http://php.net/manual/en/pdostatement.bindvalue.php"&gt;bindValue&lt;/a&gt;来确保你的SQL免于一级SQL注入攻击。（虽然并不是100%安全的，查看进一步阅读获取更多细节。）在以前，这必须使用一些“魔术引号(magic
quotes)”函数的组合来实现。PDO使得那堆东西不再需要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;{
    &lt;span style="color: #008000"&gt;// Create a new connection.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// You&amp;#39;ll probably want to replace hostname with localhost in the first parameter.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// The PDO options we pass do the following:&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// \PDO::ATTR_ERRMODE enables exceptions for errors.  This is optional but can be handy.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// \PDO::ATTR_PERSISTENT disables persistent connections, which can cause concurrency issues in certain cases.  See &amp;quot;Gotchas&amp;quot;.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// \PDO::MYSQL_ATTR_INIT_COMMAND alerts the connection that we&amp;#39;ll be passing UTF-8 data.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// This may not be required depending on your configuration, but it&amp;#39;ll save you headaches down the road&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// if you&amp;#39;re trying to store Unicode strings in your database.  See &amp;quot;Gotchas&amp;quot;.&lt;/span&gt;
    $link = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; \PDO( &lt;span style="color: #a31515"&gt;&amp;#39;mysql:host=your-hostname;dbname=your-db&amp;#39;&lt;/span&gt;, 
                        &lt;span style="color: #a31515"&gt;&amp;#39;your-username&amp;#39;&lt;/span&gt;, 
                        &lt;span style="color: #a31515"&gt;&amp;#39;your-password&amp;#39;&lt;/span&gt;, 
                        &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(
                            \PDO::ATTR_ERRMODE =&amp;gt; \PDO::ERRMODE_EXCEPTION, 
                            \PDO::ATTR_PERSISTENT =&amp;gt; &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;, 
                            \PDO::MYSQL_ATTR_INIT_COMMAND =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;set names utf8mb4&amp;#39;&lt;/span&gt;
                        )
                    );

    $handle = $link-&amp;gt;prepare(&lt;span style="color: #a31515"&gt;&amp;#39;select Username from Users where UserId = ? or Username = ? limit ?&amp;#39;&lt;/span&gt;);

    &lt;span style="color: #008000"&gt;// PHP bug: if you don&amp;#39;t specify PDO::PARAM_INT, PDO may enclose the argument in quotes.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// This can mess up some MySQL queries that don&amp;#39;t expect integers to be quoted.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// See: https://bugs.php.net/bug.php?id=44639&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// If you&amp;#39;re not sure whether the value you&amp;#39;re passing is an integer, use the is_int() function.&lt;/span&gt;
    $handle-&amp;gt;bindValue(1, 100, PDO::PARAM_INT);
    $handle-&amp;gt;bindValue(2, &lt;span style="color: #a31515"&gt;&amp;#39;Bilbo Baggins&amp;#39;&lt;/span&gt;);
    $handle-&amp;gt;bindValue(3, 5, PDO::PARAM_INT);

    $handle-&amp;gt;execute();

    &lt;span style="color: #008000"&gt;// Using the fetchAll() method might be too resource-heavy if you&amp;#39;re selecting a truly massive amount of rows.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// If that&amp;#39;s the case, you can use the fetch() method and loop through each result row one by one.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// You can also return arrays and other things instead of objects.  See the PDO documentation for details.&lt;/span&gt;
    $result = $handle-&amp;gt;fetchAll(\PDO::FETCH_OBJ);

    &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($result &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $row){
        &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;($row-&amp;gt;Username);
    }
}
&lt;span style="color: #0000ff"&gt;catch&lt;/span&gt;(\PDOException $ex){
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;($ex-&amp;gt;getMessage());
}
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当绑定整型变量时，如果不传递PDO::PARAM_INT参数有事可能会导致PDO对数据加引号。这会
搞坏特定的MySQL查询。查看&lt;a href="https://bugs.php.net/bug.php?id=44639"&gt;该bug报告&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;未使用 &lt;code&gt;set names utf8mb4&lt;/code&gt; 作为首个查询，可能会导致Unicode数据错误地存储进数据库，这依赖于你的配置。如果你
绝对有把握你的Unicode编码数据不会出问题，那你可以不管这个。&lt;/li&gt;
&lt;li&gt;启用持久连接可能会导致怪异的并发相关的问题。这不是一个PHP的问题，而是一个应用层面
的问题。只要你仔细考虑了后果，持久连接一般会是安全的。查看&lt;a href="http://stackoverflow.com/questions/3332074/what-are-the-disadvantages-of-using-persistent-connection-in-pdo"&gt;Stack
Overfilow这个问题&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使你使用了 &lt;code&gt;set names utf8mb4&lt;/code&gt; ，你也得确认实际的数据库表使用的是utf8mb4字符集！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在单个execute()调用中执行多条SQL语句。只需使用分号分隔语句，但注意&lt;a href="https://bugs.php.net/bug.php?id=61207"&gt;这个bug&lt;/a&gt;，在该文档所针对的PHP版本中还没修复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.pdo.php"&gt;PHP手册：PDO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/"&gt;为什么你应该使用PHP的PDO访问数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1402017/php-pdo-vs-normal-mysql-connect"&gt;Stack Overflow: PHP PDO vs 普通的mysql_connect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection"&gt;Stack Overflow: PDO预处理语句足以防范SQL注入吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2159434/set-names-utf8-in-mysql"&gt;Stack Overflow: 在MySQL中使用SET NAMES utf8？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP标签&lt;/h2&gt;
&lt;h3&gt;使用 &lt;code&gt;&amp;lt;?php ?&amp;gt;&lt;/code&gt; 。&lt;/h3&gt;
&lt;p&gt;有几种不同的方式用来区分PHP程序块：&lt;code&gt;&amp;lt;?php ?&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;?= ?&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;, 以及&lt;code&gt;&amp;lt;%
%&amp;gt;&lt;/code&gt;。对于打字来说，更短的标签更方便些，但唯一一种在所有PHP服务器上都一定能工作的标签
是&lt;code&gt;&amp;lt;?php
?&amp;gt;&lt;/code&gt;。若你计划将你的PHP应用部署到一台上面的PHP配置你无法控制的服务器上，那么你应始终使用
&lt;code&gt;&amp;lt;?php ?&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若你仅仅是为自己编码，也能控制你将使用的PHP配置，你可能觉得短标签更方便些。但记住
&lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;可能会和XML声明冲突，并且&lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;实际上是ASP的风格。&lt;/p&gt;
&lt;p&gt;无论你选择哪一种，确保一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个纯PHP文件（例如，仅包含一个类定义的文件）中包含一个关闭&lt;code&gt;?&amp;gt;&lt;/code&gt;标签时，确保其后
不会跟着任何换行。当PHP解析器安全地吃进跟在关闭标签之后的单个换行符时，任何其他的换行
都可能被输出到浏览器，如果之后要输出某些HTTP头，那么可能会造成混淆。&lt;/li&gt;
&lt;li&gt;编写Web应用时，确保在关闭&lt;code&gt;?&amp;gt;&lt;/code&gt;标签与html的&lt;code&gt;&amp;lt;!doctype&amp;gt;&lt;/code&gt;标签之间不会留下换行。正确的HTML
文件中，&lt;code&gt;&amp;lt;!doctype&amp;gt;&lt;/code&gt;标签必须是文件中的第一样东西---在其之前的任何空格或换行都会使其
无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/200640/are-php-short-tags-acceptable-to-use"&gt;Stack Overflow: 可以使用PHP短标签吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自动加载类&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/function.spl-autoload-register.php"&gt;spl_autoload_register()&lt;/a&gt;来注册你的自动加载函数。&lt;/h3&gt;
&lt;p&gt;PHP提供了若干方式来自动加载包含还未加载的类的文件。老的方法是使用名为&lt;a href="http://php.net/manual/en/function.autoload.php"&gt;&lt;code&gt;__autoload()&lt;/code&gt;&lt;/a&gt;魔术全局函数。然而你一次仅能定义一个&lt;code&gt;__autoload()&lt;/code&gt;函数，因此如果你的程序
包含一个也使用了&lt;code&gt;__autoload()&lt;/code&gt;函数的库，就会发生冲突。&lt;/p&gt;
&lt;p&gt;处理这个问题的正确方法是唯一地命名你的自动加载函数，然后使用&lt;code&gt;spl_autoload_register()&lt;/code&gt;函数
来注册它。该函数允许定义多个&lt;code&gt;__autoload()&lt;/code&gt;这样的函数，因此你不必担心其他代码的&lt;code&gt;__autoload()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// First, define your auto-load function&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; MyAutoload($className){
    &lt;span style="color: #0000ff"&gt;include_once&lt;/span&gt;($className . &lt;span style="color: #a31515"&gt;&amp;#39;.php&amp;#39;&lt;/span&gt;);
}

&lt;span style="color: #008000"&gt;// Next, register it with PHP&lt;/span&gt;
spl_autoload_register(&lt;span style="color: #a31515"&gt;&amp;#39;MyAutoload&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Try it out!&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Since we haven&amp;#39;t included a file defining the MyClass object, our&lt;/span&gt;
&lt;span style="color: #008000"&gt;// auto-loader will kick in and include MyClass.php.&lt;/span&gt;
&lt;span style="color: #008000"&gt;// For this example, assume the MyClass class is defined in the MyClass.php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// file.&lt;/span&gt;
$var = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MyClass();
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/function.spl-autoload-register.php"&gt;PHP手册：spl_autoload_register()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/791899/efficient-php-auto-loading-and-naming-strategies"&gt;Stack Overflow: 高效的PHP自动加载和命名策略&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;从性能角度来看单引号和双引号&lt;/h2&gt;
&lt;h3&gt;其实并不重要。&lt;/h3&gt;
&lt;p&gt;已有很多人花费很多笔墨来讨论是使用单引号（&lt;code&gt;'&lt;/code&gt;）还是双引号（&lt;code&gt;"&lt;/code&gt;）来定义字符串。
单引号字符串不会被解析，因此放入字符串的任何东西都会以原样显示。双引号字符串会被解析，
字符串中的任何PHP变量都会被求值。另外，转义字符如换行符&lt;code&gt;\n&lt;/code&gt;和制表符&lt;code&gt;\t&lt;/code&gt;在单引号字符串中
不会被求值，但在双引号字符串中会被求值。&lt;/p&gt;
&lt;p&gt;由于双引号字符串在程序运行时要求值，从而理论上使用单引号字符串能提高性能，因为PHP
不会对单引号字符串求值。这对于一定规模的应用来说也许确实如此，但对于现实中一般的应用来说，
区别非常小以至于根本不用在意。因此对于普通应用，你选择哪种字符串并不重要。对于负载
极其高的应用来说，是有点作用的。根据你的应用的需要来做选择，但无论你选择什么，请保持一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.types.string.php"&gt;PHP手册：字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://phpbench.com/"&gt;PHP基准&lt;/a&gt;（向下滚动到引号类型(Quote Types)）&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/13620/speed-difference-in-using-inline-strings-vs-concatenation-in-php5"&gt;Stack Overflow: PHP中单引号字符串相比双引号字符串有性能优势么？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;define() vs. const&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://www.php.net/manual/en/function.define.php"&gt;define()&lt;/a&gt;，除非考虑到可读性、类常量、或关注微优化&lt;/h3&gt;
&lt;p&gt;习惯上，在PHP中是使用define()函数来定义常量。但从某个时候开始，PHP中也能够使用&lt;a href="http://php.net/manual/en/language.oop5.constants.php"&gt;const&lt;/a&gt;
关键字来声明常量了。那么当定义常量时，该使用哪种方式呢？&lt;/p&gt;
&lt;p&gt;答案在于这两种方法之间的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;define()在执行期定义常量，而const在编译期定义常量。这样const就有轻微的速度优势，
但不值得考虑这个问题，除非你在构建大规模的软件。&lt;/li&gt;
&lt;li&gt;define()将常量放入全局作用域，虽然你可以在常量名中包含命名空间。这意味着你不能
使用define()定义类常量。&lt;/li&gt;
&lt;li&gt;define()允许你在常量名和常量值中使用表达式，而const则都不允许。这使得define()
更加灵活。&lt;/li&gt;
&lt;li&gt;define()可以在if()代码块中调用，但const不行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Let&amp;#39;s see how the two methods treat namespaces&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;namespace&lt;/span&gt; MiddleEarth\Creatures\Dwarves;
&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GIMLI_ID = 1;
define(&lt;span style="color: #a31515"&gt;&amp;#39;MiddleEarth\Creatures\Elves\LEGOLAS_ID&amp;#39;&lt;/span&gt;, 2);

&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt;(\MiddleEarth\Creatures\Dwarves\GIMLI_ID);  &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt;(\MiddleEarth\Creatures\Elves\LEGOLAS_ID);  &lt;span style="color: #008000"&gt;// 2; note that we used define()&lt;/span&gt;

&lt;span style="color: #008000"&gt;// Now let&amp;#39;s declare some bit-shifted constants representing ways to enter Mordor.&lt;/span&gt;
define(&lt;span style="color: #a31515"&gt;&amp;#39;TRANSPORT_METHOD_SNEAKING&amp;#39;&lt;/span&gt;, 1 &amp;lt;&amp;lt; 0); &lt;span style="color: #008000"&gt;// OK!&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; TRANSPORT_METHOD_WALKING = 1 &amp;lt;&amp;lt; 1; &lt;span style="color: #008000"&gt;//Compile error! const can&amp;#39;t use expressions as values&lt;/span&gt;

&lt;span style="color: #008000"&gt;// Next, conditional constants.&lt;/span&gt;
define(&lt;span style="color: #a31515"&gt;&amp;#39;HOBBITS_FRODO_ID&amp;#39;&lt;/span&gt;, 1);

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($isGoingToMordor){
    define(&lt;span style="color: #a31515"&gt;&amp;#39;TRANSPORT_METHOD&amp;#39;&lt;/span&gt;, TRANSPORT_METHOD_SNEAKING); &lt;span style="color: #008000"&gt;// OK!&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; PARTY_LEADER_ID = HOBBITS_FRODO_ID &lt;span style="color: #008000"&gt;// Compile error: const can&amp;#39;t be used in an if block&lt;/span&gt;
}

&lt;span style="color: #008000"&gt;// Finally, class constants&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;OneRing&lt;/span&gt;{
    &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; MELTING_POINT_DEGREES = 1000000; &lt;span style="color: #008000"&gt;// OK!&lt;/span&gt;
    define(&lt;span style="color: #a31515"&gt;&amp;#39;SHOW_ELVISH_DEGREES&amp;#39;&lt;/span&gt;, 200); &lt;span style="color: #008000"&gt;// Compile error: can&amp;#39;t use define() within a class&lt;/span&gt;
}
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为define()更加灵活，你应该使用它以避免一些令人头疼的事情，除非你明确地需要类
常量。使用const通常会产生更加可读的代码，但是以牺牲灵活性为代价的。&lt;/p&gt;
&lt;p&gt;无论你选择哪一种，请保持一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2447791/define-vs-const"&gt;Stack Overflow: define() vs. const&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.constants.syntax.php"&gt;PHP手册：常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1225082/define-vs-variable-in-php"&gt;Stack Overflow: define() vs. 变量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;缓存PHP opcode&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/book.apc.php"&gt;APC&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在一个标准的PHP环境中，每次访问PHP脚本时，脚本都会被编译然后执行。一次又一次地花费
时间编译相同的脚本对于大型站点会造成性能问题。&lt;/p&gt;
&lt;p&gt;解决方案是采用一个opcode缓存。opcode缓存是一个能够记下每个脚本经过编译的版本，这样
服务器就不需要浪费时间一次又一次地编译了。通常这些opcode缓存系统也能智能地检测到
一个脚本是否发生改变，因此当你升级PHP源码时，并不需要手动清空缓存。&lt;/p&gt;
&lt;p&gt;有几个PHP
opcode缓存可用，其中值得关注的有&lt;a href="http://sourceforge.net/projects/eaccelerator/"&gt;eaccelerator&lt;/a&gt;，
&lt;a href="http://xcache.lighttpd.net/"&gt;xcache&lt;/a&gt;，以及&lt;a href="http://php.net/manual/en/book.apc.php"&gt;APC&lt;/a&gt;。
APC是PHP项目官方支持的，最为活跃，也最容易安装。它也提供一个可选的类&lt;a href="http://memcached.org/"&gt;memcached&lt;/a&gt;
的持久化键-值对存储，因此你应使用它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装APC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Ubuntu 12.04上你可以通过在终端中执行以下命令来安装APC：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;user@localhost: sudo apt-get install php-apc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除此之外，不需要进一步的配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将APC作为一个持久化键-值存储系统来使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;APC也提供了对于你的脚本透明的类似于memcached的功能。与使用memcached相比一个大的优势是
APC是集成到PHP核心的，因此你不需要在服务器上维护另一个运行的部件，并且PHP开发者在APC
上的工作很活跃。但从另一方面来说，APC并不是一个分布式缓存，如果你需要这个特性，你就
必须使用memcached了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Store some values in the APC cache.  We can optionally pass a time-to-live, &lt;/span&gt;
&lt;span style="color: #008000"&gt;// but in this example the values will live forever until they&amp;#39;re garbage-collected by APC.&lt;/span&gt;
apc_store(&lt;span style="color: #a31515"&gt;&amp;#39;username-1532&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;Frodo Baggins&amp;#39;&lt;/span&gt;);
apc_store(&lt;span style="color: #a31515"&gt;&amp;#39;username-958&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;Aragorn&amp;#39;&lt;/span&gt;);
apc_store(&lt;span style="color: #a31515"&gt;&amp;#39;username-6389&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;Gandalf&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// After storing these values, any PHP script can access them, no matter when it&amp;#39;s run!&lt;/span&gt;
$value = apc_fetch(&lt;span style="color: #a31515"&gt;&amp;#39;username-958&amp;#39;&lt;/span&gt;, $success);
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($success === &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;($value); &lt;span style="color: #008000"&gt;// Aragorn&lt;/span&gt;

$value = apc_fetch(&lt;span style="color: #a31515"&gt;&amp;#39;username-1&amp;#39;&lt;/span&gt;, $success); &lt;span style="color: #008000"&gt;// $success will be set to boolean false, because this key doesn&amp;#39;t exist.&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($success !== &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;) &lt;span style="color: #008000"&gt;// Note the !==, this checks for true boolean false, not &amp;quot;falsey&amp;quot; values like 0 or empty string.&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;Key not found&amp;#39;&lt;/span&gt;);

apc_delete(&lt;span style="color: #a31515"&gt;&amp;#39;username-958&amp;#39;&lt;/span&gt;); &lt;span style="color: #008000"&gt;// This key will no longer be available.&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你使用的不是&lt;a href="https://phpbestpractices.org/#serving-php"&gt;PHP-FPM&lt;/a&gt;（例如你在
使用&lt;a href="http://stackoverflow.com/questions/2712825/what-is-mod-php"&gt;mod_php&lt;/a&gt;
或&lt;a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html"&gt;mod_fastcgi&lt;/a&gt;），那么
每个PHP进程都会有自己独有的APC实例，包括键-值存储。若你不注意，这可能会在你的应用
代码中造成同步问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.apc.php"&gt;PHP手册：APC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP与Memcached&lt;/h2&gt;
&lt;h3&gt;若你需要一个分布式缓存，那就使用&lt;a href="http://php.net/manual/en/book.memcached.php"&gt;Memcached&lt;/a&gt;客户端库。否则，使用APC。&lt;/h3&gt;
&lt;p&gt;缓存系统通常能够提升应用的性能。Memcached是一个受欢迎的选择，它能配合许多语言使用，
包括PHP。&lt;/p&gt;
&lt;p&gt;然而，从一个PHP脚本中访问一个Memcached服务器，你有两个不同且命名很愚蠢的客户端库选择项：
&lt;a href="http://php.net/manual/en/book.memcache.php"&gt;Memcache&lt;/a&gt;和&lt;a href="http://php.net/manual/en/book.memcached.php"&gt;Memcached&lt;/a&gt;。
它们是两个名字几乎相同的不同库，两者都可用于访问一个Memcached实例。&lt;/p&gt;
&lt;p&gt;事实证明，Memcached库对于Memcached协议的实现最好，包含了一些Mmecache库没有的有用的特性，
并且看起来Memcached库的开发也最为活跃。&lt;/p&gt;
&lt;p&gt;然而，如果不需要访问来自一组分布式服务器的一个Memcached实例，那就&lt;a href="https://phpbestpractices.org/#opcode-cache"&gt;使用APC&lt;/a&gt;。
APC得到PHP项目的支持，具备很多和Memcached相同的功能，并且能够用作opcode缓存，这能提高PHP脚本的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Memcached客户端库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安装Memcached服务器之后，需要安装Memcached客户端库。没有该库，PHP脚本就没法与
Memcached服务器通信。&lt;/p&gt;
&lt;p&gt;在Ubuntu 12.04上，你可以使用如下命令来安装Memcached客户端库：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;user@localhost: sudo apt-get install php5-memcached
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;使用APC作为替代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;a href="https://phpbestpractices.org/#opcode-cache"&gt;opcode缓存一节&lt;/a&gt;阅读更多与使用APC作为
Memcached替代方案相关的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.memcached.php"&gt;PHP手册：Memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.apc.php"&gt;PHP手册：APC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1442411/using-memcache-vs-memcached-with-php"&gt;Stack Overflow: PHP中使用Memcache vs. Memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/815041/memcached-vs-apc-which-one-should-i-choose"&gt;Stack Overflow: Memcached vs APC，我该选择哪一个？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP与正则表达式&lt;/h2&gt;
&lt;h3&gt;使用 &lt;a href="http://php.net/manual/en/book.pcre.php"&gt;PCRE&lt;/a&gt; ( &lt;code&gt;preg_*&lt;/code&gt; ) 家族函数&lt;/h3&gt;
&lt;p&gt;PHP有两种使用不同的方式来使用正则表达式：PCRE（Perl兼容表示法，&lt;code&gt;preg_*&lt;/code&gt;）函数
和&lt;a href="http://php.net/manual/en/book.regex.php"&gt;POSIX&lt;/a&gt;（POSIX扩展表示法，&lt;code&gt;ereg_*&lt;/code&gt;）
函数。&lt;/p&gt;
&lt;p&gt;每个函数家族各自使用一种风格稍微不同的正则表达式。幸运的是，POSIX家族函数从PHP
5.3.0开始就被弃用了。因此，你绝不应该使用POSIX家族函数编写新的代码。始终使用
PRCE家族函数，即&lt;code&gt;preg_*&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.pcre.php"&gt;PHP手册：PCRE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.noupe.com/php/php-regular-expressions.html"&gt;PHP正则表达式起步&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置Web服务器提供PHP服务&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/install.fpm.php"&gt;PHP-FPM&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有多种方式来配置一个web服务器以提供PHP服务。传统（并且糟糕的）的方式是使用Apache的
&lt;a href="http://stackoverflow.com/questions/2712825/what-is-mod-php"&gt;mod_php&lt;/a&gt;。Mod_php将PHP
绑定到Apache自身，但是Apache对于该模块功能的管理工作非常糟糕。一旦遇到较大的流量，
就会遭受严重的内存问题。&lt;/p&gt;
&lt;p&gt;后来两个新的可选项很快流行起来：&lt;a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html"&gt;mod_fastcgi&lt;/a&gt;
和&lt;a href="http://httpd.apache.org/mod_fcgid/"&gt;mod_fcgid&lt;/a&gt;。两者均保持一定数量的PHP执行进程，
Apache将请求发送到这些端口来处理PHP的执行。由于这些库限制了存活的PHP进程的数量，
从而大大减少了内存使用而没有影响性能。&lt;/p&gt;
&lt;p&gt;一些聪明的人创建一个fastcgi的实现，专门为真正与PHP工作良好而设计，他们称之为
&lt;a href="http://php.net/manual/en/install.fpm.php"&gt;PHP-FPM&lt;/a&gt;。PHP 5.3.0之前，为安装它，
你得跨越许多障碍，但幸运的是，PHP 5.3.3的核心包含了PHP-FPM，因此在Ubuntu 12.04上安装它非常方便。&lt;/p&gt;
&lt;p&gt;如下示例是针对Apache 2.2.22的，但PHP-FPM也能用于其他web服务器如Nginx。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装PHP-FPM和Apache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Ubuntu 12.04上你可以使用如下命令安装PHP-FPM和Apache：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;user@localhost: sudo apt-get install apache2-mpm-worker
libapache2-mod-fastcgi php5-fpm
user@localhost: sudo a2enmod actions alias fastcgi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意我们&lt;em&gt;必须&lt;/em&gt;使用apache2-mpm-worker，而不是apache2-mpm-prefork或apache2-mpm-threaded。&lt;/p&gt;
&lt;p&gt;接下来配置Aapache虚拟主机将PHP请求路由到PHP-FPM进程。将如下配置语句放入Apache
配置文件（在Ubuntu 12.04上默认配置文件是/etc/apache2/sites-available/default）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    AddHandler php5-fcgi .php
    Action php5-fcgi /php5-fcgi
    Alias /php5-fcgi /usr/lib/cgi-bin/php5-fcgi
    FastCgiExternalServer /usr/lib/cgi-bin/php5-fcgi -host 127.0.0.1:9000 -idle-timeout 120 -pass-header Authorization
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，重启Apache和FPM进程：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;user@localhost: sudo service apache2 restart &amp;amp;&amp;amp; sudo service php5-fpm
restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/install.fpm.php"&gt;PHP手册：PHP-FPM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php-fpm.org/"&gt;PHP-FPM主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://alexcabal.com/installing-apache-mod_fastcgi-php-fpm-on-ubuntu-server-maverick/"&gt;在Ubuntu服务器Maverick上安装Apache + mod_fastcgi + PHP-FPM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.joomlaperformance.com/articles/webcasts/why_mod_php_is_bad_for_performance_52_58.html"&gt;为什么mod_php的性能很糟糕&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;发送邮件&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="https://code.google.com/a/apache-extras.org/p/phpmailer/"&gt;PHPMailer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;经PHPMailer 5.1测试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;PHP提供了一个&lt;a href="http://php.net/manual/en/function.mail.php"&gt;mail()&lt;/a&gt;函数，看起来很简单易用。
不幸的是，与PHP中的很多东西一样，它的简单性是个幻象，因其虚假的表面使用它会导致
严重的安全问题。&lt;/p&gt;
&lt;p&gt;Email是一组网络协议，比PHP的历史还曲折。完全可以说发送邮件中的陷阱与PHP的mail()
函数一样多，这个可能会令你有点“不寒而栗”吧。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://code.google.com/a/apache-extras.org/p/phpmailer/"&gt;PHPMailer&lt;/a&gt;是一个流行而
成熟的开源库，为安全地发送邮件提供一个易用的接口。它关注可能陷阱，这样你可以专注
于更重要的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Include the PHPMailer library&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;require_once&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;phpmailer-5.1/class.phpmailer.php&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Passing &amp;#39;true&amp;#39; enables exceptions.  This is optional and defaults to false.&lt;/span&gt;
$mailer = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; PHPMailer(&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Send a mail from Bilbo Baggins to Gandalf the Grey&lt;/span&gt;

&lt;span style="color: #008000"&gt;// Set up to, from, and the message body.  The body doesn&amp;#39;t have to be HTML;&lt;/span&gt;
&lt;span style="color: #008000"&gt;// check the PHPMailer documentation for details.&lt;/span&gt;
$mailer-&amp;gt;Sender = &lt;span style="color: #a31515"&gt;&amp;#39;bbaggins@example.com&amp;#39;&lt;/span&gt;;
$mailer-&amp;gt;AddReplyTo(&lt;span style="color: #a31515"&gt;&amp;#39;bbaggins@example.com&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;Bilbo Baggins&amp;#39;&lt;/span&gt;);
$mailer-&amp;gt;SetFrom(&lt;span style="color: #a31515"&gt;&amp;#39;bbaggins@example.com&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;Bilbo Baggins&amp;#39;&lt;/span&gt;);
$mailer-&amp;gt;AddAddress(&lt;span style="color: #a31515"&gt;&amp;#39;gandalf@example.com&amp;#39;&lt;/span&gt;);
$mailer-&amp;gt;Subject = &lt;span style="color: #a31515"&gt;&amp;#39;The finest weed in the South Farthing&amp;#39;&lt;/span&gt;;
$mailer-&amp;gt;MsgHTML(&lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;p&amp;gt;You really must try it, Gandalf!&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;-Bilbo&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Set up our connection information.&lt;/span&gt;
$mailer-&amp;gt;IsSMTP();
$mailer-&amp;gt;SMTPAuth = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
$mailer-&amp;gt;SMTPSecure = &lt;span style="color: #a31515"&gt;&amp;#39;ssl&amp;#39;&lt;/span&gt;;
$mailer-&amp;gt;Port = 465;
$mailer-&amp;gt;Host = &lt;span style="color: #a31515"&gt;&amp;#39;my smpt host&amp;#39;&lt;/span&gt;;
$mailer-&amp;gt;Username = &lt;span style="color: #a31515"&gt;&amp;#39;my smtp username&amp;#39;&lt;/span&gt;;
$mailer-&amp;gt;Password = &lt;span style="color: #a31515"&gt;&amp;#39;my smtp password&amp;#39;&lt;/span&gt;;

&lt;span style="color: #008000"&gt;// All done!&lt;/span&gt;
$mailer-&amp;gt;Send();
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;验证邮件地址&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/function.filter-var.php"&gt;filter_var()&lt;/a&gt;函数&lt;/h3&gt;
&lt;p&gt;Web应用可能需要做的一件常见任务是检测用户是否输入了一个有效的邮件地址。毫无疑问
你可以在网上找到一些声称可以解决该问题的复杂的正则表达式，但是最简单的方法是使用
PHP的内建&lt;code&gt;filter_var()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
filter_var(&lt;span style="color: #a31515"&gt;&amp;#39;sgamgee@example.com&amp;#39;&lt;/span&gt;, FILTER_VALIDATE_EMAIL);
&lt;span style="color: #008000"&gt;//Returns &amp;quot;sgamgee@example.com&amp;quot;. This is a valid email address.&lt;/span&gt;

filter_var(&lt;span style="color: #a31515"&gt;&amp;#39;sauron@mordor&amp;#39;&lt;/span&gt;, FILTER_VALIDATE_EMAIL);
&lt;span style="color: #008000"&gt;// Returns boolean false! This is *not* a valid email address.&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/function.filter-var.php"&gt;PHP手册：filter_var()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/filter.filters.php"&gt;PHP手册：过滤器的类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;净化HTML输入和输出&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;对于简单的数据净化，使用&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;函数,
复杂的数据净化则使用&lt;a href="http://htmlpurifier.org/"&gt;HTML Purifier&lt;/a&gt;库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;经HTML Purifier 4.4.0测试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在任何web应用中展示用户输出时，首先对其进行“净化”去除任何潜在危险的HTML是非常必要的。
一个恶意的用户可以制作某些HTML，若被你的web应用直接输出，对查看它的人来说会很危险。&lt;/p&gt;
&lt;p&gt;虽然可以尝试使用正则表达式来净化HTML，但不要这样做。HTML是一种复杂的语言，试图
使用正则表达式来净化HTML几乎总是失败的。&lt;/p&gt;
&lt;p&gt;你可能会找到建议你使用&lt;a href="http://php.net/manual/en/function.strip-tags.php"&gt;strip_tags()&lt;/a&gt;
函数的观点。虽然strip_tags()从技术上来说是安全的，但如果输入的不合法的HTML（比如，
没有结束标签），它就成了一个“愚蠢”的函数，可能会去除比你期望的更多的内容。由于非技术用户
在通信中经常使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;字符，&lt;code&gt;strip_tags()&lt;/code&gt;也就不是一个好的选择了。&lt;/p&gt;
&lt;p&gt;如果阅读了&lt;a href="https://phpbestpractices.org/#validating-emails"&gt;验证邮件地址&lt;/a&gt;一节，
你也许也会考虑使用&lt;a href="http://php.net/manual/en/function.filter-var.php"&gt;filter_var()&lt;/a&gt;
函数。然而&lt;a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks"&gt;filter_var()函数在遇到断行时会出现问题&lt;/a&gt;，
并且需要不直观的配置以接近&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;函数的效果，
因此也不是一个好的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于简单需求的净化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的web应用仅需要完全地转义（因此可以无害地呈现，但不是完全去除）HTML，则使用
PHP的内建&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;函数。
这个函数要比HTML Purifier快得多，因此它不对HTML做任何验证---仅转义所有东西。&lt;/p&gt;
&lt;p&gt;htmlentities()不同于类似功能的函数&lt;a href="http://php.net/manual/en/function.htmlspecialchars.php"&gt;htmlspecialchars()&lt;/a&gt;，
它会编码所有适用的HTML实体，而不仅仅是一个小的子集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!&lt;/span&gt;
$evilHtml = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;div onclick=&amp;quot;xss();&amp;quot;&amp;gt;Mua-ha-ha!  Twiddling my evil mustache...&amp;lt;/div&amp;gt;&amp;#39;&lt;/span&gt;;

&lt;span style="color: #008000"&gt;// Use the ENT_QUOTES flag to make sure both single and double quotes are escaped.&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Use the UTF-8 character encoding if you&amp;#39;ve stored the text as UTF-8 (as you should have).&lt;/span&gt;
&lt;span style="color: #008000"&gt;// See the UTF-8 section in this document for more details.&lt;/span&gt;
$safeHtml = htmlentities($evilHtml, ENT_QUOTES, &lt;span style="color: #a31515"&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;);
&lt;span style="color: #008000"&gt;// $safeHtml is now fully escaped HTML.  You can output $safeHtml to your users without fear!&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;对于复杂需求的净化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于很多web应用来说，简单地转义HTML是不够的。你可能想完全去除任何HTML，或者允许
一小部分子集的HTML存在。若是如此，则使用&lt;a href="http://htmlpurifier.org/"&gt;HTML Purifier&lt;/a&gt;
库。&lt;/p&gt;
&lt;p&gt;HTML Purifier是一个经过充分测试但效率比较低的库。这就是为什么如果你的需求并不复杂
就应使用&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;，因为
它的效率要快得多。&lt;/p&gt;
&lt;p&gt;HTML Purifier相比&lt;a href="http://php.net/manual/en/function.strip-tags.php"&gt;strip_tags()&lt;/a&gt;
是有优势的，因为它在净化HTML之前会对其校验。这意味着如果用户输入无效HTML，HTML 
Purifier相比strip_tags()更能保留HTML的原意。HTML
Purifier高度可定制，允许你为HTML的一个子集建立白名单来允许这个HTML子集的实体存在
输出中。&lt;/p&gt;
&lt;p&gt;但其缺点就是相当的慢，它要求一些设置，在一个共享主机的环境里可能是不可行的。其文档
通常也复杂而不易理解。以下示例是一个基本的使用配置。查看&lt;a href="http://htmlpurifier.org/docs"&gt;文档&lt;/a&gt;
阅读HTML Purifier提供的更多更高级的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Include the HTML Purifier library&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;require_once&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;htmlpurifier-4.4.0/HTMLPurifier.auto.php&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!&lt;/span&gt;
$evilHtml = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;div onclick=&amp;quot;xss();&amp;quot;&amp;gt;Mua-ha-ha!  Twiddling my evil mustache...&amp;lt;/div&amp;gt;&amp;#39;&lt;/span&gt;;

&lt;span style="color: #008000"&gt;// Set up the HTML Purifier object with the default configuration.&lt;/span&gt;
$purifier = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; HTMLPurifier(HTMLPurifier_Config::createDefault());

$safeHtml = $purifier-&amp;gt;purify($evilHtml);
&lt;span style="color: #008000"&gt;// $safeHtml is now sanitized.  You can output $safeHtml to your users without fear!&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以错误的字符编码使用htmlentities()会造成意想不到的输出。在调用该函数时始终确认
指定了一种字符编码，并且该编码与将被净化的字符串的编码相匹配。更多细节请查看
&lt;a href="https://phpbestpractices.org/#utf-8"&gt;UTF-8一节&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;使用htmlentities()时，始终包含ENT_QUOTES和字符编码参数。默认情况下，htmlentities()
不会对单引号编码。多愚蠢的默认做法！&lt;/li&gt;
&lt;li&gt;HTML
Purifier对于复杂的HTML效率极其的低。可以考虑设置一个缓存方案如APC来保存经过净化的结果
以备后用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://htmlpurifier.org/comparison"&gt;PHP HTML净化工具对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/3605629/php-prevent-xss-with-strip-tags"&gt;Stack Overflow: 使用strip_tags()来防止XSS？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/129677/whats-the-best-method-for-sanitizing-user-input-with-php"&gt;Stack Overflow: PHP中净化用户输入的最佳方法是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks"&gt;Stack Overflow: 断行时的FILTER_SANITIZE_SPECIAL_CHARS问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP与UTF-8&lt;/h2&gt;
&lt;h3&gt;没有一行式解决方案。小心、注意细节，以及一致性。&lt;/h3&gt;
&lt;p&gt;PHP中的UTF-8糟透了。原谅我的用词。&lt;/p&gt;
&lt;p&gt;目前PHP在低层次上还不支持Unicode。有几种方式可以确保UTF-8字符串能够被正确处理，
但并不容易，需要深入到web应用的所有层面，从HTML，到SQL，到PHP。我们旨在提供一个简洁、
实用的概述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP层面的UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本的&lt;a href="http://php.net/manual/en/language.operators.string.php"&gt;字符串操作&lt;/a&gt;，如串接
两个字符串、将字符串赋给变量，并不需要任何针对UTF-8的特殊东西。然而，多数
&lt;a href="http://php.net/manual/en/ref.strings.php"&gt;字符串函数&lt;/a&gt;，如&lt;a href="http://php.net/manual/en/function.strpos.php"&gt;strpos()&lt;/a&gt;
和&lt;a href="http://php.net/manual/en/function.strlen.php"&gt;strlen&lt;/a&gt;，就需要特殊的考虑。这些
函数都有一个对应的&lt;code&gt;mb_*&lt;/code&gt;函数：例如，&lt;a href="http://php.net/manual/en/function.mb-strpos.php"&gt;mb_strpos()&lt;/a&gt;
和&lt;a href="http://php.net/manual/en/function.mb-strlen.php"&gt;mb_strlen()&lt;/a&gt;。这些对应的函数
统称为&lt;a href="http://php.net/manual/en/ref.mbstring.php"&gt;多字节字符串函数&lt;/a&gt;。这些多字节字符串
函数是专门为操作Unicode字符串而设计的。&lt;/p&gt;
&lt;p&gt;当你操作Unicode字符串时，必须使用&lt;code&gt;mb_*&lt;/code&gt;函数。例如，如果你使用&lt;a href="http://php.net/manual/en/function.substr.php"&gt;substr()&lt;/a&gt;
操作一个UTF-8字符串，其结果就很可能包含一些乱码。正确的函数应该是对应的多字节函数，
&lt;a href="http://php.net/manual/en/function.mb-substr.php"&gt;mb_substr()&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;难的是始终记得使用&lt;code&gt;mb_*&lt;/code&gt;函数。即使你仅一次忘了，你的Unicode字符串在接下来的处理中
就可能产生乱码。&lt;/p&gt;
&lt;p&gt;并不是所有的字符串函数都有一个对应的&lt;code&gt;mb_*&lt;/code&gt;。如果不存在你想要的那一个，那你就只能
自认倒霉了。&lt;/p&gt;
&lt;p&gt;此外，在每个PHP脚本的顶部（或者在全局包含脚本的顶部）你都应使用
&lt;a href="http://php.net/manual/en/function.mb-internal-encoding.php"&gt;mb_internal_encoding&lt;/a&gt;
函数，如果你的脚本会输出到浏览器，那么还得紧跟其后加个&lt;a href="http://php.net/manual/en/function.mb-http-output.php"&gt;mb_http_output()&lt;/a&gt;
函数。在每个脚本中显式地定义字符串的编码在以后能为你减少很多令人头疼的事情。&lt;/p&gt;
&lt;p&gt;最后，许多操作字符串的PHP函数都有一个可选参数让你指定字符编码。若有该选项， 你应
始终显式地指明UTF-8编码。例如，&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;
就有一个字符编码方式选项，在处理这样的字符串时应始终指定UTF-8。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL层面的UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的PHP脚本会访问MySQL，即使你遵从了前述的注意事项，你的字符串也有可能在数据库
中存储为非UTF-8字符串。&lt;/p&gt;
&lt;p&gt;确保从PHP到MySQL的字符串为UTF-8编码的，确保你的数据库以及数据表均设置为utf8mb4字符集，
并且在你的数据库中执行任何其他查询之前先执行MySQL查询`set names
utf8mb4`。这是至关重要的。示例
请查看&lt;a href="https://phpbestpractices.org/#mysql"&gt;连接并查询MySQL数据库&lt;/a&gt;一节内容。&lt;/p&gt;
&lt;p&gt;注意你必须使用`utf8mb4`字符集来获得完整的UTF-8支持，而不是`utf8`字符集！原因
请查看&lt;a href="https://phpbestpractices.org/#utf8-further-reading"&gt;进一步阅读&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器层面的UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;a href="http://php.net/manual/en/function.mb-http-output.php"&gt;mb_http_output()&lt;/a&gt;函数
来确保你的PHP脚本输出UTF-8字符串到浏览器。并且在HTML页面的&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签块中包含
&lt;a href="http://htmlpurifier.org/docs/enduser-utf8.html"&gt;字符集&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签块&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Tell PHP that we&amp;#39;re using UTF-8 strings until the end of the script&lt;/span&gt;
mb_internal_encoding(&lt;span style="color: #a31515"&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Tell PHP that we&amp;#39;ll be outputting UTF-8 to the browser&lt;/span&gt;
mb_http_output(&lt;span style="color: #a31515"&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Our UTF-8 test string&lt;/span&gt;
$string = &lt;span style="color: #a31515"&gt;&amp;#39;Aš galiu valgyti stiklą ir jis manęs nežeidžia&amp;#39;&lt;/span&gt;;

&lt;span style="color: #008000"&gt;// Transform the string in some way with a multibyte function&lt;/span&gt;
$string = mb_substr($string, 0, 10);

&lt;span style="color: #008000"&gt;// Connect to a database to store the transformed string&lt;/span&gt;
&lt;span style="color: #008000"&gt;// See the PDO example in this document for more information&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Note the `set names utf8mb4` commmand!&lt;/span&gt;
$link = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; \PDO(   &lt;span style="color: #a31515"&gt;&amp;#39;mysql:host=your-hostname;dbname=your-db&amp;#39;&lt;/span&gt;,
                    &lt;span style="color: #a31515"&gt;&amp;#39;your-username&amp;#39;&lt;/span&gt;,
                    &lt;span style="color: #a31515"&gt;&amp;#39;your-password&amp;#39;&lt;/span&gt;,
                    &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(
                        \PDO::ATTR_ERRMODE =&amp;gt; \PDO::ERRMODE_EXCEPTION,
                        \PDO::ATTR_PERSISTENT =&amp;gt; &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;,
                        \PDO::MYSQL_ATTR_INIT_COMMAND =&amp;gt; &lt;span style="color: #a31515"&gt;&amp;#39;set names utf8mb4&amp;#39;&lt;/span&gt;
                    )
                );

&lt;span style="color: #008000"&gt;// Store our transformed string as UTF-8 in our database&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Assume our DB and tables are in the utf8mb4 character set and collation&lt;/span&gt;
$handle = $link-&amp;gt;prepare(&lt;span style="color: #a31515"&gt;&amp;#39;insert into Sentences (Id, Body) values (?, ?)&amp;#39;&lt;/span&gt;);
$handle-&amp;gt;bindValue(1, 1, PDO::PARAM_INT);
$handle-&amp;gt;bindValue(2, $string);
$handle-&amp;gt;execute();

&lt;span style="color: #008000"&gt;// Retrieve the string we just stored to prove it was stored correctly&lt;/span&gt;
$handle = $link-&amp;gt;prepare(&lt;span style="color: #a31515"&gt;&amp;#39;select * from Sentences where Id = ?&amp;#39;&lt;/span&gt;);
$handle-&amp;gt;bindValue(1, 1, PDO::PARAM_INT);
$handle-&amp;gt;execute();

&lt;span style="color: #008000"&gt;// Store the result into an object that we&amp;#39;ll output later in our HTML&lt;/span&gt;
$result = $handle-&amp;gt;fetchAll(\PDO::FETCH_OBJ);
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot; /&amp;gt;
        &amp;lt;title&amp;gt;UTF-8 test page&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt;($result &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; $row){
            &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;($row-&amp;gt;Body);  &lt;span style="color: #008000"&gt;// This should correctly output our transformed UTF-8 string to the browser&lt;/span&gt;
        }
        &lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/ref.mbstring.php"&gt;PHP手册：多字节字符串函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.loftdigital.com/blog/php-utf-8-cheatsheet"&gt;PHP UTF-8备忘单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible"&gt;Stack Overflow: 什么因素致使PHP不兼容Unicode？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings"&gt;Stack Overflow: PHP与MySQL之间国际化字符串的最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mathiasbynens.be/notes/mysql-utf8mb4"&gt;怎样在MySQL数据库中完整支持Unicode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;处理日期和时间&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://www.php.net/manual/en/class.datetime.php"&gt;DateTime类&lt;/a&gt;。&lt;/h3&gt;
&lt;p&gt;在PHP糟糕的老时光里，我们必须使用&lt;a href="http://www.php.net/manual/en/function.date.php"&gt;date()&lt;/a&gt;，
&lt;a href="http://www.php.net/manual/en/function.gmdate.php"&gt;gmdate()&lt;/a&gt;，
&lt;a href="http://www.php.net/manual/en/function.date-timezone-set.php"&gt;date_timezone_set()&lt;/a&gt;，
&lt;a href="http://www.php.net/manual/en/function.strtotime.php"&gt;strtotime()&lt;/a&gt;等等令人迷惑的
组合来处理日期和时间。悲哀的是现在你仍旧会找到很多在线教程在讲述这些不易使用的老式函数。&lt;/p&gt;
&lt;p&gt;幸运的是，我们正在讨论的PHP版本包含友好得多的&lt;a href="http://www.php.net/manual/en/class.datetime.php"&gt;DateTime类&lt;/a&gt;。
该类封装了老式日期函数所有功能，甚至更多，在一个易于使用的类中，并且使得时区转换更加容易。
在PHP中始终使用DateTime类来创建，比较，改变以及展示日期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Construct a new UTC date.  Always specify UTC unless you really know what you&amp;#39;re doing!&lt;/span&gt;
$date = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; DateTime(&lt;span style="color: #a31515"&gt;&amp;#39;2011-05-04 05:00:00&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; DateTimeZone(&lt;span style="color: #a31515"&gt;&amp;#39;UTC&amp;#39;&lt;/span&gt;));

&lt;span style="color: #008000"&gt;// Add ten days to our initial date&lt;/span&gt;
$date-&amp;gt;add(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; DateInterval(&lt;span style="color: #a31515"&gt;&amp;#39;P10D&amp;#39;&lt;/span&gt;));

&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt;($date-&amp;gt;format(&lt;span style="color: #a31515"&gt;&amp;#39;Y-m-d h:i:s&amp;#39;&lt;/span&gt;)); &lt;span style="color: #008000"&gt;// 2011-05-14 05:00:00&lt;/span&gt;

&lt;span style="color: #008000"&gt;// Sadly we don&amp;#39;t have a Middle Earth timezone&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Convert our UTC date to the PST (or PDT, depending) time zone&lt;/span&gt;
$date-&amp;gt;setTimezone(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; DateTimeZone(&lt;span style="color: #a31515"&gt;&amp;#39;America/Los_Angeles&amp;#39;&lt;/span&gt;));

&lt;span style="color: #008000"&gt;// Note that if you run this line yourself, it might differ by an hour depending on daylight savings&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt;($date-&amp;gt;format(&lt;span style="color: #a31515"&gt;&amp;#39;Y-m-d h:i:s&amp;#39;&lt;/span&gt;)); &lt;span style="color: #008000"&gt;// 2011-05-13 10:00:00&lt;/span&gt;

$later = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; DateTime(&lt;span style="color: #a31515"&gt;&amp;#39;2012-05-20&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; DateTimeZone(&lt;span style="color: #a31515"&gt;&amp;#39;UTC&amp;#39;&lt;/span&gt;));

&lt;span style="color: #008000"&gt;// Compare two dates&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($date &amp;lt; $later)
    &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;Yup, you can compare dates using these easy operators!&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Find the difference between two dates&lt;/span&gt;
$difference = $date-&amp;gt;diff($later);

&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;The 2nd date is &amp;#39;&lt;/span&gt; . $difference[&lt;span style="color: #a31515"&gt;&amp;#39;days&amp;#39;&lt;/span&gt;] . &lt;span style="color: #a31515"&gt;&amp;#39; later than 1st date.&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你不指定一个时区，&lt;a href="http://www.php.net/manual/en/datetime.construct.php"&gt;DateTime::__construct()&lt;/a&gt;
就会将生成日期的时区设置为正在运行的计算机的时区。之后，这会导致大量令人头疼的事情。
&lt;strong&gt;在创建新日期时始终指定UTC时区，除非你确实清楚自己在做的事情。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果你在DateTime::__construct()中使用Unix时间戳，那么时区将始终设置为UTC而不管
第二个参数你指定了什么。&lt;/li&gt;
&lt;li&gt;向DateTime::__construct()传递零值日期（如：“0000-00-00”，常见MySQL生成该值作为
DateTime类型数据列的默认值）会产生一个无意义的日期，而不是“0000-00-00”。&lt;/li&gt;
&lt;li&gt;在32位系统上使用&lt;a href="http://www.php.net/manual/en/datetime.gettimestamp.php"&gt;DateTime::getTimestamp()&lt;/a&gt;
不会产生代表2038年之后日期的时间戳。64位系统则没有问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/book.datetime.php"&gt;PHP手册：DateTime类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5319710/accessing-dates-in-php-beyond-2038"&gt;Stack Overflow: 访问超出2038的日期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;检测一个值是否为null或false&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;===&lt;/a&gt;操作符来检测null和布尔false值。&lt;/h3&gt;
&lt;p&gt;PHP宽松的类型系统提供了许多不同的方法来检测一个变量的值。然而这也造成了很多问题。
使用&lt;code&gt;==&lt;/code&gt;来检测一个值是否为null或false，如果该值实际上是一个空字符串或0，也会误报
为false。&lt;a href="http://php.net/manual/en/function.isset.php"&gt;isset&lt;/a&gt;是检测一个变量是否有值，
而不是检测该值是否为null或false，因此在这里使用是不恰当的。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/function.is-null.php"&gt;is_null()&lt;/a&gt;函数能准确地检测一个值
是否为null，&lt;a href="http://php.net/manual/en/function.is-bool.php"&gt;is_bool&lt;/a&gt;可以检测一个值
是否是布尔值（比如false），但存在一个更好的选择：&lt;code&gt;===&lt;/code&gt;操作符。&lt;code&gt;===&lt;/code&gt;检测两个值是否同一，
这不同于PHP宽松类型世界里的&lt;em&gt;相等&lt;/em&gt;。它也比is_null()和is_bool()要快一些，并且有些人
认为这比使用函数来做比较更干净些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$x = 0;
$y = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;

&lt;span style="color: #008000"&gt;// Is $x null?&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($x == &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;Oops! $x is 0, not null!&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Is $y null?&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(is_null($y))
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;Great, but could be faster.&amp;#39;&lt;/span&gt;);

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;($y === &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;Perfect!&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// Does the string abc contain the character a?&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(strpos(&lt;span style="color: #a31515"&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;))
    &lt;span style="color: #008000"&gt;// GOTCHA!  strpos returns 0, indicating it wishes to return the position of the first character.&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// But PHP interpretes 0 as false, so we never reach this print statement!&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;Found it!&amp;#39;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;//Solution: use !== (the opposite of ===) to see if strpos() returns 0, or boolean false.   &lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(strpos(&lt;span style="color: #a31515"&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;) !== &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;print&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;Found it for real this time!&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试一个返回0或布尔false的函数的返回值时，如strpos()，始终使用&lt;code&gt;===&lt;/code&gt;和&lt;code&gt;!==&lt;/code&gt;，否则
你就会碰到问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;PHP手册：比较操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/8228837/is-nullx-vs-x-null-in-php"&gt;Stack Overflow: is_null() vs ===&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;建议与指正&lt;/h2&gt;
&lt;p&gt;感谢阅读！如果你有些地方还不太理解，很正常，PHP是复杂的，并且充斥着陷阱。因为我也
只是一个人，所以本文档中难免存在错误。&lt;/p&gt;
&lt;p&gt;如果你想为本文档贡献建议或纠正错误之处，请使用&lt;a href="https://phpbestpractices.org/#maintainers"&gt;最后修订日期&amp;amp;维护者&lt;/a&gt;
一节中的信息联系我。&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="PHP"></category></entry><entry><title>城市的日子</title><link href="http://youngsterxyf.github.io/2013/05/19/life-of-city/" rel="alternate"></link><published>2013-05-19T00:00:00+08:00</published><updated>2013-05-19T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-05-19:/2013/05/19/life-of-city/</id><summary type="html">&lt;p&gt;我仍须一个人&lt;br /&gt;
面对这个城市，&lt;br /&gt;
以及如此雷同的日复日。&lt;br /&gt;
&lt;br /&gt;
电话、网络，&lt;br /&gt;
工作、技术、阅读、爱好，&lt;br /&gt;
朋友，&lt;br /&gt;
还有我的思考，&lt;br /&gt;
都改变不了，&lt;br /&gt;
这城市 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我仍须一个人&lt;br /&gt;
面对这个城市，&lt;br /&gt;
以及如此雷同的日复日。&lt;br /&gt;
&lt;br /&gt;
电话、网络，&lt;br /&gt;
工作、技术、阅读、爱好，&lt;br /&gt;
朋友，&lt;br /&gt;
还有我的思考，&lt;br /&gt;
都改变不了，&lt;br /&gt;
这城市的日子。&lt;br /&gt;
&lt;br /&gt;
所以，&lt;br /&gt;
我想她。&lt;br /&gt;&lt;/p&gt;</content><category term="其他"></category><category term="诗歌"></category><category term="笔记"></category><category term="生活"></category></entry><entry><title>编译安装MemcacheQ</title><link href="http://youngsterxyf.github.io/2013/04/27/compile-and-install-memcacheq/" rel="alternate"></link><published>2013-04-27T00:00:00+08:00</published><updated>2013-04-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-27:/2013/04/27/compile-and-install-memcacheq/</id><summary type="html">&lt;p&gt;MemcacheQ是一个MemcacheDB的变种，用来提供简单的消息队列服务。（注：MemcacheDB并不是一个数据缓存解决方案，而是一个为数据持久化设计的分布式的键-值对数据存储系统，采用memcache协议，以BerkeleyDB作为存储后端，&lt;a href="http://memcachedb.org/"&gt;主页&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;MemcacheQ依赖于BerkeleyDB和libevent …&lt;/p&gt;</summary><content type="html">&lt;p&gt;MemcacheQ是一个MemcacheDB的变种，用来提供简单的消息队列服务。（注：MemcacheDB并不是一个数据缓存解决方案，而是一个为数据持久化设计的分布式的键-值对数据存储系统，采用memcache协议，以BerkeleyDB作为存储后端，&lt;a href="http://memcachedb.org/"&gt;主页&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;MemcacheQ依赖于BerkeleyDB和libevent，所以需先编译安装这两者。&lt;/p&gt;
&lt;p&gt;1.
从&lt;a href="http://www.oracle.com/technetwork/products/berkeleydb/downloads/index.html"&gt;Oracle官网&lt;/a&gt;上下载某一版本的BerkeleyDB（这里以5.0.32版本为例）&lt;/p&gt;
&lt;p&gt;解压缩： &lt;code&gt;tar -xvf db-5.0.32.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入db-5.0.32/build_unix目录后执行： 1) &lt;code&gt;../dist/configure&lt;/code&gt; , 2) &lt;code&gt;make&lt;/code&gt; , 3) &lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，会把BerkeleyDB安装到&lt;code&gt;/usr/local/BerkeleyDB.5.3&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;2.
从&lt;a href="http://libevent.org/"&gt;libevent官网&lt;/a&gt;下载libevent, 这里以2.0.21版本为例：&lt;/p&gt;
&lt;p&gt;同样解压缩，进入libevent-2.0.21-stable/目录，执行 1) &lt;code&gt;./configure&lt;/code&gt; , 2) &lt;code&gt;make&lt;/code&gt; , 3) &lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，这样会把libevent编译好后的一些库文件放到&lt;code&gt;/usr/local/lib&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;3.
从&lt;a href="https://code.google.com/p/memcacheq/downloads/list"&gt;https://code.google.com/p/memcacheq/downloads/list&lt;/a&gt;下载memcacheq，当前版本为0.2.0。由于memcacheq的configure文件第3571行：&lt;code&gt;bdbdir="/usr/local/BerkeleyDB.4.7"&lt;/code&gt;，硬编码了依赖于BerkeleyDB 4.7版本，但在Oracle官网上已经不提供4.7版本的下载，所以需要将该处的版本4.7改为之前所编译的BerkeleyDB版本，如5.0。&lt;/p&gt;
&lt;p&gt;然后执行 1) &lt;code&gt;./configure -prefix=/usr/local/memcacheq -enable-threads&lt;/code&gt;（&lt;code&gt;-prefix&lt;/code&gt;选项指定将memcacheq安装到/usr/local/memcacheq目录下），2) &lt;code&gt;make&lt;/code&gt; , 3) &lt;code&gt;sudo make install&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;4.
在Linux上，memcacheq启动时要想成功动态链接BerkeleyDB和libevent的库文件，得先手动配置动态链接库查找路径：编辑文件&lt;code&gt;/etc/ld.so.conf&lt;/code&gt;，在末尾添加两行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/usr/local/lib
/usr/local/BerkeleyDB.5.0/lib
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;保存后，在命令行执行： &lt;code&gt;ldconfig&lt;/code&gt;即可。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;启动memcacheq: &lt;code&gt;/usr/local/memcacheq/bin/memcacheq -d -r -H /tmp/memcacheq -N -R -v -L 1024 -B 1024 &amp;gt; /tmp/mq_error.log 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;相关选项的含义可以通过&lt;code&gt;memcacheq -h&lt;/code&gt;来查看。&lt;/p&gt;
&lt;p&gt;memcacheq默认打开的网络端口为22201，可通过命令&lt;code&gt;netstat -tlnp&lt;/code&gt;来查看。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;若想编写PHP程序来测试使用memcacheq，需要先安装配置PHP &lt;a href="http://cn2.php.net/memcache"&gt;memcache扩展模块&lt;/a&gt;，可先通过&lt;code&gt;php -m | grep memcache&lt;/code&gt;来查看是否已安装。测试程序如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$memcache_obj = memcache_connect(&lt;span style="color: #a31515"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;, 22201);

&lt;span style="color: #008000"&gt;// push数据进入队列demoqueue1&lt;/span&gt;
$set_rs = memcache_set($memcache_obj, &lt;span style="color: #a31515"&gt;&amp;#39;demoqueue1&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;message body here&amp;#39;&lt;/span&gt;, 0, 0);
var_dump($set_rs);

&lt;span style="color: #008000"&gt;// 从队列demoqueue1中pop出数据&lt;/span&gt;
$get_rs = memcache_get($memcache_obj, &lt;span style="color: #a31515"&gt;&amp;#39;demoqueue1&amp;#39;&lt;/span&gt;);
var_dump($get_rs);

memcache_close($memcache_obj);
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://memcachedb.org/memcacheq/"&gt;http://memcachedb.org/memcacheq/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://memcachedb.org/memcacheq/INSTALL.html"&gt;http://memcachedb.org/memcacheq/INSTALL.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="笔记"></category><category term="工作"></category><category term="服务器"></category><category term="技术"></category></entry><entry><title>工作中的技术人</title><link href="http://youngsterxyf.github.io/2013/04/23/technical-person/" rel="alternate"></link><published>2013-04-23T00:00:00+08:00</published><updated>2013-04-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-23:/2013/04/23/technical-person/</id><summary type="html">&lt;p&gt;工作入职半个月，有些事情不太顺利，还没有正式上手工作，也许大公司的节奏便是如此，但我内心是比较急的，希望能尽快 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;工作入职半个月，有些事情不太顺利，还没有正式上手工作，也许大公司的节奏便是如此，但我内心是比较急的，希望能尽快地上手做实际的工作，而不是学习和等待。&lt;/p&gt;
&lt;p&gt;这半个月里，主要是熟悉工作环境，学习了解工作相关的技术。虽说学习，但其实大部分相关技术以前都了解或使用过，只是经验还不够。&lt;/p&gt;
&lt;p&gt;第一周，除了常规的入职事宜，搭建了开发测试环境，并阅读理解工作中使用的web框架。对于这个框架，有太多的吐槽点，严格地说算不上是个框架，可能是因为写得比较早。对于框架，我认为最重要的是为多人协作完成一件事情提供实现上的规范，其次是代码复用，减少工作量。但这个框架除了一些供复用的代码，就啥都没有了。&lt;/p&gt;
&lt;p&gt;第二周，学习巩固PHP基础，一直没认真地学习过PHP，只是在实习的时候做了一些开发，稍微了解了下Yii框架和Zend框架，觉得太复杂了点。除此之外，初步了解组内的运维工作，特别是整个系统的架构。&lt;/p&gt;
&lt;p&gt;经过一番思考，基于自己的理解，昨天编写了一个玩具性质的MVC web框架原型&lt;a href="https://github.com/youngsterxyf/minibean"&gt;minibean&lt;/a&gt;，该框架以路由转发和控制器为核心，所有非静态文件请求的处理都以Application类对象为入口，按照一定规则对请求URI经路由转发找到对应的控制器类，控制器对象中调用模型与视图的类对象等。以后随着开发经验的增加以及对其他开源成熟框架的学习，会不断地完善该框架。在编写该框架的过程中，深感自己经验的不足，特别是对于Model层，以后可能会刻意阅读某些开源框架的Model层实现。&lt;/p&gt;
&lt;p&gt;目前组内开发工作还很初步，还没有一个正规的开发流程，也没有明确的开发规范。这样虽然没法从已有的工作中学习很多，但也许有机会参与到这些事情创造过程中，收获会更大。&lt;/p&gt;
&lt;p&gt;经过和老同事讨论，以后开发工作涉及的语言和工具包括：Nginx、MySQL、PHP、Redis/Memcached、SVN等，对于这些东西，我都是需要深入学习加强的（当然首先是要解决业务需求）。另外，鉴于原有的那个框架实在不怎么样，以后新的工作可能会选择Zend Framework作为开发框架。&lt;/p&gt;
&lt;p&gt;对于工作环境，我觉得不太满意的地方主要是技术氛围不太浓厚，以后有机会和大家一起建立起好的技术氛围，搞搞技术分享讨论什么的。另外，有点憋屈的是，觉着自己被小看了，老同事老觉得应届毕业生啥的不懂，所以也不急着分配具体的工作给我，老让我学习学习再学习。个人认为最好的学习方式是给个具体的需求，具体的问题让我去解决，有经验的同事只需对结果把把关就可以。当我在这过程中遇到搞不定的问题再向他们请教，以这种方式来上手熟悉工作也许更好。我个人也比较喜欢直接丢个实际的问题让我去解决。&lt;/p&gt;
&lt;p&gt;对于今后的自己，我有两点忠告：&lt;/p&gt;
&lt;p&gt;1.
时刻警惕迷失&lt;/p&gt;
&lt;p&gt;虽然工作很重要，要解决业务需求，工作所涉及的技术也应该扎实掌握，深入理解，但不能把自己局限在此，也不能让自己迷失在过于细节的地方。公司提供了一个完善的平台，但这个平台在我看来自足得有些封闭，所以需警惕，要不断地和同事，和公司外面的人交流学习。要经常自我反思，回顾自己走过的路，要让自己的大脑空闲下来花些时间整体规划即将要做的事情。&lt;/p&gt;
&lt;p&gt;2.
保持锐气&lt;/p&gt;
&lt;p&gt;初步觉着有些同事没什么工作生活技术的激情，可能是长时间工作的缘故，也可能是因为我还太年轻。但目前我还不愿意自己进入那种状态。自己以后应该更加主动积极地对待工作。我喜欢称呼自己为“技术人”，因为“技术人”不仅是搞技术的，更重要的是对技术有热情，有使命感。&lt;/p&gt;</content><category term="其他"></category><category term="工作"></category><category term="感悟"></category></entry><entry><title>Windows上安装PHP开发测试环境</title><link href="http://youngsterxyf.github.io/2013/04/15/install-php-development-environment-on-windows/" rel="alternate"></link><published>2013-04-15T00:00:00+08:00</published><updated>2013-04-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-15:/2013/04/15/install-php-development-environment-on-windows/</id><summary type="html">&lt;p&gt;先从HTTP请求处理流程图来看看我们所需的PHP开发测试环境包含哪些组件。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/php-development-env.jpg" alt="PHP开发测试环境"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出系统包含如下几种组件之间的交互：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx与PHP-CGI(PHP)的交互&lt;/li&gt;
&lt;li&gt;PHP-CGI(PHP)与文件系统、分布式内存对象缓存系统、数据 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;先从HTTP请求处理流程图来看看我们所需的PHP开发测试环境包含哪些组件。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/php-development-env.jpg" alt="PHP开发测试环境"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出系统包含如下几种组件之间的交互：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx与PHP-CGI(PHP)的交互&lt;/li&gt;
&lt;li&gt;PHP-CGI(PHP)与文件系统、分布式内存对象缓存系统、数据库之间的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了PHP与文件系统之间的交互，其他几种交互均为客户端-服务器模式，以Socket方式进行连接，都需要安装配置相关组件。&lt;/p&gt;
&lt;p&gt;对于Nginx与PHP-CGI(PHP)的交互，PHP-CGI默认打开9000端口，等待Nginx转发过来的请求，所以需要在Nginx配置文件中添加类似于如下所示的虚拟主机配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;server {
    listen  8000;
    server_name localhost;

    location / {
        root    html;   # 这里为你的网站的根目录
        index   index.php index.html index.htm;
    }

    location ~ \.php$ {
        root    html;   # 这里也设置为你的网站的根目录
        fastcgi_pass    127.0.0.1:9000; # 这里设置为你的PHP-CGI监听的网络地址
        fastcgi_index   index.php;
        fastcgi_param   SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Windows上，直接双击运行php-cgi.exe文件打开PHP-CGI服务，貌似没用，可以在CMD中执行&lt;code&gt;php-cgi.exe -b 127.0.0.1:9000&lt;/code&gt;来打开服务。&lt;/p&gt;
&lt;p&gt;对于Nginx.exe，可以直接双击nginx.exe来运行，但如果要停止nginx的运行或者重新加载配置文件，则可以在CMD中执行如下相应的命令：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;nginx -s stop   fast shutdown
nginx -s quit   graceful shutdown
nginx -s reload  changing configuration, starting new worker processes with a new configuration, graceful shutdown of old worker processes
nginx -s reopen re-opening log files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外，Nginx的虚拟主机配置信息中，root指令指定的网站根目录路径应遵从Unix的格式，而不是Windows的格式，即使用&lt;strong&gt;/&lt;/strong&gt;而不是&lt;strong&gt;\&lt;/strong&gt;来分割目录层次。&lt;/p&gt;
&lt;p&gt;Nginx与PHP的Windows版本可分别从：&lt;a href="http://nginx.org/en/download.html"&gt;Nginx for Windows&lt;/a&gt;，&lt;a href="http://windows.php.net/download/"&gt;PHP for Windows&lt;/a&gt;。无需安装，解压缩即可。PHP-CGI的可执行文件php-cgi.exe也在PHP的压缩包中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于分布式内存对象系统，以Memcached和Redis为例。PHP通过扩展包与它们交互，所以需要下载相应的扩展包，并配置PHP。&lt;/p&gt;
&lt;p&gt;以PHP 5.3版本为例，可分别从&lt;a href="http://downloads.php.net/pierre/"&gt;http://downloads.php.net/pierre/&lt;/a&gt;、&lt;a href="http://blog.phpwind.me/wp-content/plugins/download-monitor/download.php?id=9"&gt;http://blog.phpwind.me/wp-content/plugins/download-monitor/download.php?id=9&lt;/a&gt;下载PHP的memcached扩展包与redis扩展包，注意扩展包对应的php版本号必须与你安装的PHP的版本号一致。&lt;/p&gt;
&lt;p&gt;解压缩后将php_memcache.dll和php_redis.dll文件复制到PHP的ext目录下。&lt;/p&gt;
&lt;p&gt;然后将PHP目录下的php.ini-development文件重命名为php.ini，打开php.ini，首先删除&lt;code&gt;;extension_dir="ext"&lt;/code&gt;一行行首的分号，然后删除&lt;code&gt;;extension=php_memcache.dll&lt;/code&gt;一行行首的分号，并在其后添加一行&lt;code&gt;extension=php_redis.dll&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于Memcached和Redis的服务器端程序，可分别从：&lt;a href="http://downloads.northscale.com/memcached-win32-1.4.4-14.zip"&gt;Memcached for Windows&lt;/a&gt;、&lt;a href="https://github.com/dmajkic/redis/downloads"&gt;Redis for Windows&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;Memcached的默认端口为11211。&lt;/p&gt;
&lt;p&gt;关于Redis的配置见：&lt;a href="http://redis.io/topics/config"&gt;http://redis.io/topics/config&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于windows下redis和php的redis扩展的安装，可进一步参考&lt;a href="http://blog.phpwind.me/?p=152"&gt;http://blog.phpwind.me/?p=152&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PHP与MySQL之间的交互，类似于PHP与分布式内存对象系统之间的交互。只不过PHP的压缩包的ext目录下已经包含了&lt;code&gt;php_mysql.dll&lt;/code&gt;和&lt;code&gt;php_mysqli.dll&lt;/code&gt;扩展包，只需修改php.ini配置文件即可：删除&lt;code&gt;;extension=php_mysql.dll&lt;/code&gt;和&lt;code&gt;;extension=php_mysqli.dll&lt;/code&gt;两行行首的分号。&lt;/p&gt;
&lt;p&gt;MySQL的服务器端程序从MySQL官网下载，默认端口为3306。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;除了上述安装配置，你可能还需要在php.ini中启用&lt;code&gt;extension=php_mbstring.dll&lt;/code&gt;、&lt;code&gt;extension=php_soap.dll&lt;/code&gt;等扩展。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;安装配置完毕后，启动Nginx、PHP-CGI、MySQL（可选）、Redis/Memcached（可选）。在某个Nginx虚拟主机中指定的网站根目录下添加测试文件phpinfo.php，其内容如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
    phpinfo();
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过浏览器访问该网页，若PHP环境配置成功，则会看到一个当前PHP环境的详细信息列表，从中可以看到当前所启动的PHP扩展，若未找到memcache、redis、mysql这几个扩展包信息，则说明未成功启用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果你测试某些以前别人写的PHP代码，发现结果与预期的不相符，则看看是不是那些代码中使用了PHP短标记&lt;code&gt;&amp;lt;?&lt;/code&gt;和&lt;code&gt;?&amp;gt;&lt;/code&gt;。PHP默认不启用短标记，所以你需要修改php.ini，删除&lt;code&gt;;short_open_tag = On&lt;/code&gt;一行之前的分号。&lt;/p&gt;
&lt;p&gt;另外，注意Nginx虚拟主机所使用的端口不要和Windows中其他网络应用的端口冲突。&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="PHP"></category></entry><entry><title>弄清问题，再求解决</title><link href="http://youngsterxyf.github.io/2013/04/09/understand-before-solve/" rel="alternate"></link><published>2013-04-09T00:00:00+08:00</published><updated>2013-04-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-09:/2013/04/09/understand-before-solve/</id><summary type="html">&lt;p&gt;今天同事问我：是否有什么python库或工具能够将网页内容转换成图片格式的。他在做这方面的事情，还没有好的方法，因为觉得我对python比较熟悉，所以问一下。&lt;/p&gt;
&lt;p&gt;但是我从一开始我就犯 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今天同事问我：是否有什么python库或工具能够将网页内容转换成图片格式的。他在做这方面的事情，还没有好的方法，因为觉得我对python比较熟悉，所以问一下。&lt;/p&gt;
&lt;p&gt;但是我从一开始我就犯错误了。其实我至少应该问一下：为什么要解决这个问题？也就是业务需求是什么？并且稍微一想这个问题其实比较含糊。现在的web页面可以很简单，也可能很复杂。那么这个问题里的“网页”是什么样的网页呢？是任何可能的网页么？目的是需要通过图片来展示网页的哪个部分的信息还是整个网页？这些问题我都没问，也没仔细考虑。&lt;/p&gt;
&lt;p&gt;在没有明确需求的情况下，我就认为是将任何形式的网页完整地转换成图片，但又没弄清如果是这种情况问题的难度有多大。&lt;/p&gt;
&lt;p&gt;在听完问题后，我就想到可能有两种方法：1. 先将网页转换成pdf，然后转换成图片，因为我对于将网页转换成pdf格式的方法有点印象；2.可能存在python实现的工具直接将网页转换成图片格式。你是否发现我的思路有个误区：问题的解决方案需要python代码实现，我假设了需要将这个功能嵌入到一个大的程序中。&lt;/p&gt;
&lt;p&gt;然后我就开始蒙头google找方案。经过一番“艰苦卓绝”的查找，发现：1.确实有如xhtml2pdf等工具能将网页转换成pdf格式，但貌似对于中文的支持不是很好；2.没有好的python库或工具能够直接将网页转换成图片格式，有的方案要收费，有的方案需要调用第三方API，而公司的数据明显是不能让第三方获得的。&lt;/p&gt;
&lt;p&gt;在查找解决方案的过程中，我也逐步意识到上述的那些问题，特别是若假设需要将任何形式的网页转换成图片格式，这个难度非常大，为什么呢？因为现在很多网页的部分内容都是由JS生成的，若你的程序只是简单地从服务器获取网页，该网页含有的JS代码并不会执行，将该网页转换成图片格式，图片所包含的信息与浏览器中展示的并不相同。所以你的程序起码需要包含一个JS解释器。OK，难度一下子就上去了。在我逐步了解其中的难度后，我开始尝试换个角度来考虑问题，反思同事所要解决的业务需求是什么。&lt;/p&gt;
&lt;p&gt;在与他的进一步沟通之后，我才知道：一些总结汇报邮件中需要添加数据统计图，而原有的数据统计图在Web监控页面中，由Raphaeljs库绘制成SVG矢量图。由于无法期望邮件的接收者是从网页版邮箱阅读邮件（他们很可能使用各种邮件客户端如Outlook查看邮件），所以发送带有JS的HTML格式的邮件是没用的。&lt;/p&gt;
&lt;p&gt;在了解业务需求后，我们就明白了其实问题本质上不是要将网页转换成图片，而是要获得&lt;strong&gt;图片格式的数据可视化结果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么问题就简单多了，可能从以下三个角度寻找解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将网页完整地转换成图片格式&lt;/li&gt;
&lt;li&gt;将网页中的SVG内容转换成图片格式&lt;/li&gt;
&lt;li&gt;使用本地的数据可视化工具将统计数据源，即Raphaeljs绘制SVG矢量图的JSON数据源绘制成图片&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种方案中第二种最佳，为什么呢？因为第一种需要做一些额外的转换工作，自己实现的难度较大，第三种方案与Web监控页面所使用的是不同的数据可视化工具，所以产生的结果一般是不相同的，除非Raphaeljs支持图片格式的输出，那么应该就可以使用nodejs来实现。&lt;/p&gt;
&lt;p&gt;经过网络查找，发现第一种方案与第二种方案都有现成的工具。&lt;/p&gt;
&lt;p&gt;第一种方案：&lt;a href="https://github.com/ariya/phantomjs"&gt;phantomjs&lt;/a&gt;可以完成，phantomjs包含了webkit，所以解释JS什么的就不再是个问题了，它有个&lt;a href="https://github.com/ariya/phantomjs/wiki/Screen-Capture"&gt;Screen Capture&lt;/a&gt;的功能模块支持将网页完整地转换成图片格式，但由于要做很多额外的工作，所以效率比较低。&lt;/p&gt;
&lt;p&gt;第二种方案是从Highcharts的&lt;a href="http://www.highcharts.com/demo/"&gt;Demo&lt;/a&gt;中挖掘出来的，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/highchartjsdemo.png" alt="highchartjs_demo"&gt;&lt;/p&gt;
&lt;p&gt;Demo中可以输出多种图片格式，通过chrome浏览器的开发者工具可以发现其实现是向服务器export.highcharts.com发送一个请求，请求中包含网页中生成的SVG矢量图数据、目标图片格式等信息，服务器对该请求进行处理后返回目标格式图片。那么服务器端是如何将SVG转换成图片格式的呢？在Highcharts的&lt;a href="http://docs.highcharts.com/"&gt;文档&lt;/a&gt;中有个名为&lt;code&gt;Export module&lt;/code&gt;的部分，其中说明了实现原理以及如何搭建这样的一个格式转换服务器。从文档可以看出这个实现方法的核心是借助了&lt;a href="http://xmlgraphics.apache.org/batik/tools/rasterizer.html"&gt;batik-rasterizer.jar&lt;/a&gt;这个Java工具包，它能将SVG转换成图片或PDF格式。&lt;/p&gt;
&lt;p&gt;从上述该问题解决方案的寻找过程可以看出，&lt;strong&gt;很多时候并不是问题有多复杂或有多难，而是我们根本没有明确业务需求，没有搞清楚真正需要解决的问题，而对模糊的问题描述自以为是地作出一些假设，然后蒙头去解决错误的问题，从而浪费了很多时间&lt;/strong&gt;。&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="工作"></category></entry><entry><title>argparse - 命令行选项与参数解析（译）</title><link href="http://youngsterxyf.github.io/2013/03/30/argparse/" rel="alternate"></link><published>2013-03-30T00:00:00+08:00</published><updated>2013-03-30T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-30:/2013/03/30/argparse/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://pymotw.com/2/argparse/"&gt;argparse – Command line option and argument parsing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;argparse模块作为optparse的一个替代被添加到Python2.7。argparse的实现支持一些不易于添加到optparse以及要求向后不兼容API变化的特性，因此以一个新模块添加到标准库。&lt;/p&gt;
&lt;h3&gt;与optparse相比较&lt;/h3&gt;
&lt;p&gt;argparse的API类似于optparse，甚至在很多情况下通过更新所使用的类名 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://pymotw.com/2/argparse/"&gt;argparse – Command line option and argument parsing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;argparse模块作为optparse的一个替代被添加到Python2.7。argparse的实现支持一些不易于添加到optparse以及要求向后不兼容API变化的特性，因此以一个新模块添加到标准库。&lt;/p&gt;
&lt;h3&gt;与optparse相比较&lt;/h3&gt;
&lt;p&gt;argparse的API类似于optparse，甚至在很多情况下通过更新所使用的类名和方法名，使用argparse作为一个简单的替代。然而，有些地方在添加新特性时不能保持直接兼容性。&lt;/p&gt;
&lt;p&gt;你必须视情况决定是否升级已有的程序。如果你已编写了额外的代码以弥补optparse的局限，也许你想升级程序以减少你需要维护的代码量。若argparse在所有部署平台上都可用，那么新的程序应尽可能使用argparse。&lt;/p&gt;
&lt;h3&gt;设置一个解析器&lt;/h3&gt;
&lt;p&gt;使用argparse的第一步就是创建一个解析器对象，并告诉它将会有些什么参数。那么当你的程序运行时，该解析器就可以用于处理命令行参数。&lt;/p&gt;
&lt;p&gt;解析器类是 &lt;strong&gt;ArgumentParser&lt;/strong&gt; 。构造方法接收几个参数来设置用于程序帮助文本的描述信息以及其他全局的行为或设置。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse
parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;This is a PyMOTW sample program&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;定义参数&lt;/h3&gt;
&lt;p&gt;argparse是一个全面的参数处理库。参数可以触发不同的动作，动作由 &lt;strong&gt;add_argument()&lt;/strong&gt; 方法的 &lt;em&gt;action&lt;/em&gt; 参数指定。
支持的动作包括保存参数（逐个地，或者作为列表的一部分），当解析到某参数时保存一个常量值（包括对布尔开关真/假值的特殊处理），统计某个参数出现的次数，以及调用一个回调函数。&lt;/p&gt;
&lt;p&gt;默认的动作是保存参数值。在这种情况下，如果提供一个类型，那么在存储之前会先把该参数值转换成该类型。如果提供 &lt;em&gt;dest&lt;/em&gt; 参数，参数值就保存为命令行参数解析时返回的命名空间对象中名为该 &lt;em&gt;dest&lt;/em&gt; 参数值的一个属性。&lt;/p&gt;
&lt;h3&gt;解析一个命令行&lt;/h3&gt;
&lt;p&gt;定义了所有参数之后，你就可以给 &lt;strong&gt;parse_args()&lt;/strong&gt; 传递一组参数字符串来解析命令行。默认情况下，参数是从 &lt;code&gt;sys.argv[1:]&lt;/code&gt; 中获取，但你也可以传递自己的参数列表。选项是使用GNU/POSIX语法来处理的，所以在序列中选项和参数值可以混合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parse_args()&lt;/strong&gt; 的返回值是一个&lt;strong&gt;命名空间&lt;/strong&gt;，包含传递给命令的参数。该对象将参数保存其属性，因此如果你的参数 &lt;code&gt;dest&lt;/code&gt; 是 &lt;code&gt;"myoption"&lt;/code&gt;，那么你就可以&lt;code&gt;args.myoption&lt;/code&gt; 来访问该值。&lt;/p&gt;
&lt;h3&gt;简单示例&lt;/h3&gt;
&lt;p&gt;以下简单示例带有3个不同的选项：一个布尔选项（&lt;code&gt;-a&lt;/code&gt;），一个简单的字符串选项（&lt;code&gt;-b&lt;/code&gt;），以及一个整数选项（&lt;code&gt;-c&lt;/code&gt;）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, type=int)

print parser.parse_args([&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;-bval&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有几种方式传递值给单字符选项。以上例子使用了两种不同的形式，&lt;code&gt;-bval&lt;/code&gt;和&lt;code&gt;-c val&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_short.py
Namespace(a=True, b=&amp;#39;val&amp;#39;, c=3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在输出中与&lt;code&gt;'c'&lt;/code&gt;关联的值是一个整数，因为程序告诉&lt;strong&gt;ArgumentParser&lt;/strong&gt;在保存之前先转换该参数。&lt;/p&gt;
&lt;p&gt;“长”选项名字，即选项的名字多于一个字符，以相同的方式进行处理。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;Example with long option names&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--noarg&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--witharg&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;witharg&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--witharg2&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;witharg2&amp;quot;&lt;/span&gt;, type=int)

print parser.parse_args([&lt;span style="color: #a31515"&gt;&amp;#39;--noarg&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;--witharg&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;val&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;--withargs=3&amp;#39;&lt;/span&gt;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果也类似：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_long.py
Namespace(noarg=True, witharg=&amp;#39;val&amp;#39;, witharg2=3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;argparse区别于optparse的一个地方是对非选项参数值的处理。optparse只进行选项解析，而argparse是一个全面的命令行参数解析工具，也处理非选项参数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;Example with non-optional arguments&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;count&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, type=int)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;units&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这个例子中，“count”参数是一个整数，“units”参数存储为一个字符串。其中任意一个参数若没有在命令行中提供，或给定的值不能被转换为正确的类型，就会报告一个错误。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_arguments.py 3 inches

Namespace(count=3, units=&amp;#39;inches&amp;#39;)

$ python argparse_arguments.py some inches

usage: argparse_arguments.py [-h] count units
argparse_arguments.py: error: argument count: invalid int value: &amp;#39;some&amp;#39;

$ python argparse_arguments.py

usage: argparse_arguments.py [-h] count units
argparse_arguments.py: error: too few arguments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;参数动作&lt;/h3&gt;
&lt;p&gt;argparse内置6种动作可以在解析到一个参数时进行触发：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;store&lt;/code&gt;
    保存参数值，可能会先将参数值转换成另一个数据类型。若没有显式指定动作，则默认为该动作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;store_const&lt;/code&gt;
    保存一个被定义为参数规格一部分的值，而不是一个来自参数解析而来的值。这通常用于实现非布尔值的命令行标记。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;store_ture&lt;/code&gt;/&lt;code&gt;store_false&lt;/code&gt;
    保存相应的布尔值。这两个动作被用于实现布尔开关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt;
    将值保存到一个列表中。若参数重复出现，则保存多个值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append_const&lt;/code&gt;
    将一个定义在参数规格中的值保存到一个列表中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;version&lt;/code&gt;
    打印关于程序的版本信息，然后退出&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser()

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-s&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;#39;simple_value&amp;#39;&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Store a simple value&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store_const&amp;#39;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;#39;constant_value&amp;#39;&lt;/span&gt;,
        const=&lt;span style="color: #a31515"&gt;&amp;#39;value-to-store&amp;#39;&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Store a constant value&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-t&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;,
        dest=&lt;span style="color: #a31515"&gt;&amp;#39;boolean_switch&amp;#39;&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Set a switch to true&amp;#39;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-f&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store_false&amp;#39;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;,
        dest=&lt;span style="color: #a31515"&gt;&amp;#39;boolean_switch&amp;#39;&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Set a switch to false&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;append&amp;#39;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;#39;collection&amp;#39;&lt;/span&gt;,
        default=[],
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Add repeated values to a list&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-A&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;append_const&amp;#39;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;#39;const_collection&amp;#39;&lt;/span&gt;,
        const=&lt;span style="color: #a31515"&gt;&amp;#39;value-1-to-append&amp;#39;&lt;/span&gt;,
        default=[],
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Add different values to list&amp;#39;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-B&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;append_const&amp;#39;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;#39;const_collection&amp;#39;&lt;/span&gt;,
        const=&lt;span style="color: #a31515"&gt;&amp;#39;value-2-to-append&amp;#39;&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Add different values to list&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--version&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;version&amp;#39;&lt;/span&gt;, version=&lt;span style="color: #a31515"&gt;&amp;#39;%(prog)s 1.0&amp;#39;&lt;/span&gt;)

results = parser.parse_args()
print &lt;span style="color: #a31515"&gt;&amp;#39;simple_value     =&amp;#39;&lt;/span&gt;, results.simple_value
print &lt;span style="color: #a31515"&gt;&amp;#39;constant_value   =&amp;#39;&lt;/span&gt;, results.constant_value
print &lt;span style="color: #a31515"&gt;&amp;#39;boolean_switch   =&amp;#39;&lt;/span&gt;, results.boolean_switch
print &lt;span style="color: #a31515"&gt;&amp;#39;collection       =&amp;#39;&lt;/span&gt;, results.collection
print &lt;span style="color: #a31515"&gt;&amp;#39;const_collection =&amp;#39;&lt;/span&gt;, results.const_collection
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_action.py -h

usage: argparse_action.py [-h] [-s SIMPLE_VALUE] [-c] [-t] [-f]
                          [-a COLLECTION] [-A] [-B] [--version]

optional arguments:
  -h, --help       show this help message and exit
  -s SIMPLE_VALUE  Store a simple value
  -c               Store a constant value
  -t               Set a switch to true
  -f               Set a switch to false
  -a COLLECTION    Add repeated values to a list
  -A               Add different values to list
  -B               Add different values to list
  --version        show program&amp;#39;s version number and exit

$ python argparse_action.py -s value

simple_value     = value
constant_value   = None
boolean_switch   = False
collection       = []
const_collection = []

$ python argparse_action.py -c

simple_value     = None
constant_value   = value-to-store
boolean_switch   = False
collection       = []
const_collection = []

$ python argparse_action.py -t

simple_value     = None
constant_value   = None
boolean_switch   = True
collection       = []
const_collection = []

$ python argparse_action.py -f

simple_value     = None
constant_value   = None
boolean_switch   = False
collection       = []
const_collection = []

$ python argparse_action.py -a one -a two -a three

simple_value     = None
constant_value   = None
boolean_switch   = False
collection       = [&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;three&amp;#39;]
const_collection = []

$ python argparse_action.py -B -A

simple_value     = None
constant_value   = None
boolean_switch   = False
collection       = []
const_collection = [&amp;#39;value-2-to-append&amp;#39;, &amp;#39;value-1-to-append&amp;#39;]

$ python argparse_action.py --version

argparse_action.py 1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;选项前缀&lt;/h3&gt;
&lt;p&gt;argparse选项的默认语法是基于Unix约定的，使用一个“-”前缀来表示命令行开关。argparse支持其他前缀，因此你可以使得你的程序遵照本地平台的默认语法（例如，在Window上使用“/”）或者遵循不同的约定。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;Change the option prefix charaters&amp;#39;&lt;/span&gt;, 
        prefix_chars=&lt;span style="color: #a31515"&gt;&amp;#39;-+/&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_false&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Turn A off&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;+a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Turn A on&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;//noarg&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;++noarg&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将&lt;strong&gt;ArgumentParser&lt;/strong&gt; 方法的&lt;em&gt;prefix_chars&lt;/em&gt; 参数设置为一个字符串，该字符串包含所有允许用来表示选项的字符。需要理解的是虽然&lt;em&gt;prefix_chars&lt;/em&gt;包含允许用于开关的字符，但单个参数定义只能使用一种给定的开关语法。这让你可以对使用不同前缀的选项是否是别名（比如独立于平台的命令行语法的情况）或替代选择（例如，使用“+”表明打开一个开发，“-”则为关闭一个开关）进行显式地控制。在上述例子中，&lt;code&gt;+a&lt;/code&gt;和&lt;code&gt;-a&lt;/code&gt;是不同的参数，&lt;code&gt;//noarg&lt;/code&gt; 也可以 &lt;code&gt;++noarg&lt;/code&gt; 提供，但不是 &lt;code&gt;--noarg&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_prefix_chars.py -h

usage: argparse_prefix_chars.py [-h] [-a] [+a] [//noarg]

Change the option prefix characters

optional arguments
    -h, --help  show this help message and exit
    -a  Turn A off
    +a  Turn A on
    //noarg,++noarg

$ python argparse_prefix_chars.py +a

Namespace(a=True, noarg=False)

$ python argparse_prefix_chars.py -a

Namespace(a=False, noarg=False)

$ python argparse_prefix_chars.py //noarg

Namespace(a=None, noarg=True)

$ python argparse_prefix_chars.py ++noarg

Namespace(a=None, noarg=True)

$ python argparse_prefix_chars.py --noarg

usage: argparse_prefix_chars.py [-h] [-a] [+a] [//noarg]
argparse_prefix_chars.py: error: unrecognized arguments: --noarg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;参数来源&lt;/h3&gt;
&lt;p&gt;目前为止所见的例子中，提供给解析器的参数列表来自于显式传递的一个列表，或隐式地从sys.argv获取的。显式传递列表在你使用argparse来处理类命令行但并不是来自命令行（比如来自一个配置文件）的指令之时比较有用。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; ConfigParser &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; ConfigParser
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; shlex

parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, type=int)

config = ConfigParser()
config.read(&lt;span style="color: #a31515"&gt;&amp;#39;argparse_witH_shlex.ini&amp;#39;&lt;/span&gt;)
config_value = config.get(&lt;span style="color: #a31515"&gt;&amp;#39;cli&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;options&amp;#39;&lt;/span&gt;)
print &lt;span style="color: #a31515"&gt;&amp;#39;Config: &amp;#39;&lt;/span&gt;, config_value

argument_list = shlex.split(config_value)
print &lt;span style="color: #a31515"&gt;&amp;#39;Arg List:&amp;#39;&lt;/span&gt;, argument_list

print &lt;span style="color: #a31515"&gt;&amp;#39;Results:&amp;#39;&lt;/span&gt;, parser.parse_args(argument_list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;shlex使得切分存储在配置文件中的字符串非常容易。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_with_shlex.py

Config: -a -b 2
Arg List: [&amp;#39;-a&amp;#39;, &amp;#39;-b&amp;#39;, &amp;#39;2&amp;#39;]
Results: Namespace(a=True, b=&amp;#39;2&amp;#39;, c=None)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另一种自己处理配置文件的方法是使用&lt;em&gt;fromfile_prefix_chars&lt;/em&gt;指定一个包含一组要待处理参数的输入文件来告诉argparse怎样识别参数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse
&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; ConfigParser &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; ConfigParser
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; shlex

parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;,
        fromfile_prefix_chars=&lt;span style="color: #a31515"&gt;&amp;#39;@&amp;#39;&lt;/span&gt;
        )

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, type=int)

print parser.parse_args([&lt;span style="color: #a31515"&gt;&amp;#39;@argparse_fromfile_prefix_chars.txt&amp;#39;&lt;/span&gt;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该示例代码在找到一个以&lt;em&gt;@&lt;/em&gt;为前缀的参数时即停止往下读取，然后从以该参数命名的文件中查找更多的参数。例如，输入文件&lt;code&gt;argparse_fromfile_prefix_chars.txt&lt;/code&gt;包含一系列参数，一行一个：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-a
-b
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么处理该文件产生的输出为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_fromfile_prefix_chars.py

Namespace(a=True, b=&amp;#39;2&amp;#39;, c=None)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;自动生成选项&lt;/h3&gt;
&lt;p&gt;经过配置argparse会自动添加选项用来生成帮助信息以及为你的应用程序显示版本信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ArgumentParser&lt;/strong&gt;的参数&lt;em&gt;add_help&lt;/em&gt; 控制帮助信息相关的选项。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(add_help=&lt;span style="color: #0000ff"&gt;True&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, type=int)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;帮助选项（-h和--help）默认是添加的，但可以通过将&lt;em&gt;add_help&lt;/em&gt;设置为false来禁用。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(add_help=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, type=int)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然&lt;code&gt;-h&lt;/code&gt;和&lt;code&gt;--help&lt;/code&gt;是事实上的请求帮助的标准选项名称，但一些应用或argparse的使用要么不需要提供帮助要么需要将这两个选项名称用于其他目标。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_with_help.py -h

usage: argparse_with_help.py [-h] [-a] [-b B] [-c C]

optional arguments:
    -h, --help  show this help message and exit
    -a
    -b B
    -c C

$ python argparse_without_help.py -h

usage: argparse_without_help.py [-a] [-b B] [-c C]
argparse_without_help.py: error: unrecognized arguments: -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当在&lt;strong&gt;ArgumentParser&lt;/strong&gt;构造方法设置&lt;em&gt;版本&lt;/em&gt;后，就会添加版本选项（&lt;code&gt;-v&lt;/code&gt;和&lt;code&gt;--version&lt;/code&gt;）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(version=&lt;span style="color: #a31515"&gt;&amp;#39;1.0&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, type=int)

print parser.parse_args()

print &lt;span style="color: #a31515"&gt;&amp;#39;This is not printed&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两种形式的选项爱那个都会打印程序的版本字符串，然后立即退出程序。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_with_version.py -h

usage: argparse_with_version.py [-h] [-v] [-a] [-b B] [-c C]

optional arguments:
    -h, --help  show this help message and exit
    -v, --version   show program&amp;#39;s version number and exit
    -a
    -b B
    -c C

$ python argparse_with_version.py -v

1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;解析器组&lt;/h3&gt;
&lt;p&gt;argparse包含若干特性用于组织你的参数解析器，使得实现更为简单，也能提高输出帮助信息的可用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享解析器规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常常需要实现一套命令行程序，这些程序都带一组参数，只是在某些方面有特殊化。例如，如果所有程序都需要在用户进行任何实际的操作之前对用户进行认证，那么它们就都需要支持&lt;code&gt;--user&lt;/code&gt;和&lt;code&gt;--password&lt;/code&gt;选项。你可以共享的选项来定义一个“父母”解析器，然后令单个程序的解析器从该“父母”解析器继承共享选项，这样就不必显式为每个&lt;strong&gt;ArgumentParser&lt;/strong&gt;添加共享选项。&lt;/p&gt;
&lt;p&gt;第一步是以共享的参数定义建立“父母”解析器。由于“父母”解析器的后代使用者会添加相同的帮助选项，从而会引发一个异常，所以在基础解析器中我们关闭自动帮助选项生成。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(add_help=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--user&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--password&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，以&lt;em&gt;父母解析器&lt;/em&gt;集创建另一个解析器：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse_parent_base

parser = argparse.ArgumentParser(parents=[argparse_parent_base.parser])

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--local-arg&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;得到的程序带有三个选项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_uses_parent.py -h

usage: argparse_uses_parent.py [-h] [--user USER] [--password PASSWORD]
                           [--local-arg]

optional arguments:
    -h, --help           show this help message and exit
    --user USER
    --password PASSWORD
    --local-arg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;冲突的选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前一个例子指出以相同的参数名字为一个解析器添加两个参数处理器会引发一个异常。可以通过传递一个&lt;em&gt;conflict_handler&lt;/em&gt;来改变冲突消除行为。argparse有两个内置的冲突处理器&lt;code&gt;error&lt;/code&gt;（默认）和&lt;code&gt;resolve&lt;/code&gt;，&lt;code&gt;resolve&lt;/code&gt;会基于冲突选项的添加顺序来选择一个参数处理器。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(conflict_handler=&lt;span style="color: #a31515"&gt;&amp;#39;resolve&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;quot;Short alone&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--long-b&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;quot;Long and short together&amp;quot;&lt;/span&gt;)

print parser.parse_args([&lt;span style="color: #a31515"&gt;&amp;#39;-h&amp;#39;&lt;/span&gt;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于最后一个处理器所给定的参数名已被使用，那么本例中独立选项&lt;code&gt;-b&lt;/code&gt;将被&lt;code&gt;--long-b&lt;/code&gt;的别名所覆盖。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_conflict_handler_resolve.py

usage: argparse_conflict_handler_resolve.py [-h] [-a A] [--long-b LONG_B]

optional arguments:
    -h, --help  show this help message and exit
    -a A
    --long-b LONG_B, -b LONG_B
            Long and short together
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;切换&lt;strong&gt;add_argument()&lt;/strong&gt;的调用顺序就可以启用独立的选项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(conflict_handler=&lt;span style="color: #a31515"&gt;&amp;#39;resolve&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--long-b&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;Long and short together&amp;#39;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;Short alone&amp;#39;&lt;/span&gt;)

print parser.parse_args([-h])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在两个选项可以一起使用了。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_conflict_handler_resolve2.py

usage: argparse_conflict_handler_resolve2.py [-h] [-a A] [--long-b LONG_B] [-b B]

optional arguments:
    -h, --help  show this help message and exit
    -a A
    --long-b LONG_B Long and short together
    -b B    Short alone
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参数群组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;argparse能将参数定义组合成“群组”。默认情况下是使用两个群组，一个是选项的群组，另一个是必须的与位置相关的参数群组。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;)

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--optional&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;positional&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;群组在输出的帮助信息中显示为分开的“与位置相关的参数”和“可选参数”两个部分：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_default_grouping.py

usage: argparse_default_grouping.py [-h] [--optional] positional

Short sample app

positional arguments:
    positional

optional arguments:
    -h, --help  show this help message and exit
    --optional
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你可以调整群组来提高帮助信息中群组的逻辑性，这样相关选项或值能记录在一起。可以使用自定义群组来重写之前的共享选项的示例，如此在帮助信息中身份认证的选项就可以显示在一起。&lt;/p&gt;
&lt;p&gt;在基础解析器中使用&lt;strong&gt;add_argument_group()&lt;/strong&gt;来创建一个“身份认证”群组，然后逐个添加身份认证相关的选项到该群组。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparser.ArgumentParser(add_help=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)

group = parser.add_argument_group(&lt;span style="color: #a31515"&gt;&amp;#39;authentication&amp;#39;&lt;/span&gt;)

group.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--user&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)
group.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--password&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;与之前一样，程序使用基于群组的父母解析器列表作为&lt;em&gt;parents&lt;/em&gt;的值。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse_parent_with_group

parser = argparse.ArgumentParser(parents=[argparse_parent_with_group.parser])

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--local-arg&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在输出的帮助信息一起显示身份认证选项。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_uses_parent_with_group.py -h

usage: argparse_uses_parent_with_group.py [-h] [--user USER] [--password PASSWORD] [--local-arg]

optional arguments:
    -h, --help  show this message and exit
    --local-arg

authentication:
    --user USER
    --password PASSWORD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;互斥选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义互斥的选项是选项分组特性的一个特例，使用&lt;strong&gt;add_mutually_exclusive_group()&lt;/strong&gt;而不是&lt;strong&gt;add_argument_group()&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser()

group = parser.add_mutually_exclusive_group()
group.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;)
group.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;argparse会为你强制执行互斥性，因此一次使用仅能给出该群组的选项中的一个。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_mutually_exclusive.py -h

usage: argparse_mutually_exclusive.py [-h] [-a | -b]

optional arguments:
    -h, --help  show this help message and exit
    -a
    -b

$ python argparse_mutually_exclusive.py -a

Namespace(a=True, b=False)

$ python argparse_mutually_exclusive.py -b

Namespace(a=False, b=True)

$ python argparse_mutually_exclusive.py -a -b

usage: argparse_mutually_exclusive.py [-h] [-a | -b]
argparse_mutually_exclusive.py: error: argument -b: not allowed with argument -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;嵌套解析器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述的父母解析器方式是在相关命令之间共享选项的方式之一。另一种方式是将多个命令组合进一个程序中，使用子解析器来处理命令行的每个部分。就像&lt;code&gt;svn&lt;/code&gt;，&lt;code&gt;hg&lt;/code&gt;，以及其他带有多个命令行行为或子命令的程序那样。&lt;/p&gt;
&lt;p&gt;一个用于处理文件系统目录的程序可能会像这样定义命令用于创建、删除、以及列出一个目录的内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser()

subparsers = parser.add_subparsers(help=&lt;span style="color: #a31515"&gt;&amp;#39;commands&amp;#39;&lt;/span&gt;)

&lt;span style="color: #008000"&gt;# A list command&lt;/span&gt;
list_parser = subparsers.add_parser(&lt;span style="color: #a31515"&gt;&amp;#39;list&amp;#39;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;List contents&amp;#39;&lt;/span&gt;)
list_parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;dirname&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;Directory to list&amp;#39;&lt;/span&gt;)

&lt;span style="color: #008000"&gt;# A create command&lt;/span&gt;
create_parser = subparsers.add_parser(&lt;span style="color: #a31515"&gt;&amp;#39;create&amp;#39;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;Create a directory&amp;#39;&lt;/span&gt;)
create_parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;dirname&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;New directory to create&amp;#39;&lt;/span&gt;)
create_parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--read-only&amp;#39;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Set permissions to prevent writing to the directory&amp;#39;&lt;/span&gt;)

&lt;span style="color: #008000"&gt;# A delete command&lt;/span&gt;
delete_parser = subparsers.add_parser(&lt;span style="color: #a31515"&gt;&amp;#39;delete&amp;#39;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;Remove a directory&amp;#39;&lt;/span&gt;)
delete_parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;dirname&amp;#39;&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;, help=&lt;span style="color: #a31515"&gt;&amp;#39;The directory to remove&amp;#39;&lt;/span&gt;)
delete_parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--recursive&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;-r&amp;#39;&lt;/span&gt;, default=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;, action=&lt;span style="color: #a31515"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;,
        help=&lt;span style="color: #a31515"&gt;&amp;#39;Remove the contents of the directory, too&amp;#39;&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出的帮助信息显示作为“命令”的命名子解析器能够在命令行中作为位置参数进行指定。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_subparsers.py -h

usage: argparse_subparsers.py [-h] {list, create, delete} ...

positional arguments:
    {list, create, delete} commands
        list    List contents
        create  Create a directory
        delete  Remove a directory

optional arguments:
    -h, --help  show this help message and exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每个子解析器也有自己的帮助信息，描述那个命令的参数和选项。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_subparsers.py create -h

usage: argparse_subparsers.py create [-h] [--read-only] dirname

positional arguments:
    dirname New directory to create

optional arguments:
    -h, --help  show this help message and exit
    --read-only Set permissions to prevent writing to the directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数被解析后，&lt;strong&gt;parse_args()&lt;/strong&gt;返回的&lt;strong&gt;Namespace&lt;/strong&gt;对象仅包含与指定的命令相关的值。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_subparsers.py delete -r foo

Namespace(dirname=&amp;#39;foo&amp;#39;, recursive=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;高级参数处理&lt;/h3&gt;
&lt;p&gt;至今为止的示例展示了简单的布尔标识、字符串或数字参数选项、以及位置参数。对于变长参数列表、枚举类型数据、以及常量，argparse支持复杂的参数规格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变形参列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以配置单个参数的定义使其能够匹配所解析的命令行的多个参数。根据需要或期望的参数个数，设置&lt;em&gt;nargs&lt;/em&gt;为这些标识值之一：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;值  含义
N   参数的绝对个数（例如：3）
?   0或1个参数
*   0或所有参数
+   所有，并且至少一个参数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser()

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--three&amp;#39;&lt;/span&gt;, nargs=3)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--optional&amp;#39;&lt;/span&gt;, nargs=&lt;span style="color: #a31515"&gt;&amp;#39;?&amp;#39;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--all&amp;#39;&lt;/span&gt;, nargs=&lt;span style="color: #a31515"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;, dest=&lt;span style="color: #a31515"&gt;&amp;#39;all&amp;#39;&lt;/span&gt;)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--one-or-more&amp;#39;&lt;/span&gt;, nargs=&lt;span style="color: #a31515"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;)

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解析器强制执行参数计数指令，生成一个精确的语法图作为命令帮助文本的一部分。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_nargs.py -h

usage: argparse_nargs.py [-h] [--three THREE THREE THREE]
                     [--optional [OPTIONAL]] [--all [ALL [ALL ...]]]
                     [--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]]

optional arguments:
-h, --help            show this help message and exit
--three THREE THREE THREE
--optional [OPTIONAL]
--all [ALL [ALL ...]]
--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]

$ python argparse_nargs.py

Namespace(all=None, one_or_more=None, optional=None, three=None)

$ python argparse_nargs.py --three

usage: argparse_nargs.py [-h] [--three THREE THREE THREE]
                     [--optional [OPTIONAL]] [--all [ALL [ALL ...]]]
                     [--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]]
argparse_nargs.py: error: argument --three: expected 3 argument(s)

$ python argparse_nargs.py --three a b c

Namespace(all=None, one_or_more=None, optional=None, three=[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;])

$ python argparse_nargs.py --optional

Namespace(all=None, one_or_more=None, optional=None, three=None)

$ python argparse_nargs.py --optional with_value

Namespace(all=None, one_or_more=None, optional=&amp;#39;with_value&amp;#39;, three=None)

$ python argparse_nargs.py --all with multiple values

Namespace(all=[&amp;#39;with&amp;#39;, &amp;#39;multiple&amp;#39;, &amp;#39;values&amp;#39;], one_or_more=None, optional=None, three=None)

$ python argparse_nargs.py --one-or-more with_value

Namespace(all=None, one_or_more=[&amp;#39;with_value&amp;#39;], optional=None, three=None)

$ python argparse_nargs.py --one-or-more with multiple values

Namespace(all=None, one_or_more=[&amp;#39;with&amp;#39;, &amp;#39;multiple&amp;#39;, &amp;#39;values&amp;#39;], optional=None, three=None)

$ python argparse_nargs.py --one-or-more

usage: argparse_nargs.py [-h] [--three THREE THREE THREE]
                     [--optional [OPTIONAL]] [--all [ALL [ALL ...]]]
                     [--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]]
argparse_nargs.py: error: argument --one-or-more: expected at least one argument
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参数类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;argparse将所有参数值都看作是字符串，除非你告诉它将字符串转换成另一种数据类型。&lt;strong&gt;add_argument()&lt;/strong&gt;的&lt;em&gt;type&lt;/em&gt;参数以一个转换函数作为值，被&lt;strong&gt;ArgumentParser&lt;/strong&gt;用来将参数值从一个字符串转换成另一种数据类型。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser()

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-i&amp;#39;&lt;/span&gt;, type=int)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-f&amp;#39;&lt;/span&gt;, type=float)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--file&amp;#39;&lt;/span&gt;, type=file)

&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
    print parser.parse_args()
&lt;span style="color: #0000ff"&gt;except&lt;/span&gt; IOError, msg:
    parser.error(str(msg))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;任何需要单个字符串参数的可调用对象都可以传递给&lt;em&gt;type&lt;/em&gt;，包含内置类型如&lt;strong&gt;int()&lt;/strong&gt;, &lt;strong&gt;float()&lt;/strong&gt;, 以及&lt;strong&gt;file()&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_type.py -i 1

Namespace(f=None, file=None, i=1)

$ python argparse_type.py -f 3.14

Namespace(f=3.14, file=None, i=None)

$ python argparse_type.py --file argparse_type.py

Namespace(f=None, file=&amp;lt;open file &amp;#39;argparse_type.py&amp;#39;, mode &amp;#39;r&amp;#39; at 0x1004de270&amp;gt;, i=None)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果类型转换失败，argparse会引发一个异常。&lt;em&gt;TypeError&lt;/em&gt;和&lt;em&gt;ValueError&lt;/em&gt;会被自动捕获，并为用户转换为一个简单的错误消息。其他异常，如下面一个例子中输入文件不存在，则其&lt;em&gt;IOError&lt;/em&gt;必须由调用者来处理。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_type.py -i a

usage: argparse_type.py [-h] [-i I] [-f F] [--file FILE]
argparse_type.py: error: argument -i: invalid int value: &amp;#39;a&amp;#39;

$ python argparse_type.py -f 3.14.15

usage: argparse_type.py [-h] [-i I] [-f F] [--file FILE]
argparse_type.py: error: argument -f: invalid float value: &amp;#39;3.14.15&amp;#39;

$ python argparse_type.py --file does_not_exist.txt

usage: argparse_type.py [-h] [-i I] [-f F] [--file FILE]
argparse_type.py: error: [Errno 2] No such file or directory: &amp;#39;does_not_exist.txt&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要想将一个输入参数限制为一个预定义集中的某个值，则使用&lt;em&gt;choices&lt;/em&gt;参数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser()

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;--mode&amp;#39;&lt;/span&gt;, choices=(&lt;span style="color: #a31515"&gt;&amp;#39;read-only&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;read-write&amp;#39;&lt;/span&gt;))

print parser.parse_args()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果&lt;code&gt;--mode&lt;/code&gt;的参数值不是所允许的值中的一个，就会产生一个错误并停止执行。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_choices.py -h

usage: argparse_choices.py [-h] [--mode {read-only,read-write}]

optional arguments:
-h, --help            show this help message and exit
--mode {read-only,read-write}

$ python argparse_choices.py --mode read-only

Namespace(mode=&amp;#39;read-only&amp;#39;)

$ python argparse_choices.py --mode invalid

usage: argparse_choices.py [-h] [--mode {read-only,read-write}]
argparse_choices.py: error: argument --mode: invalid choice: &amp;#39;invalid&amp;#39;
(choose from &amp;#39;read-only&amp;#39;, &amp;#39;read-write&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;文件参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然&lt;strong&gt;文件&lt;/strong&gt;对象可以单个字符串参数值来实例化，但并不允许你指定访问模式。&lt;strong&gt;FileType&lt;/strong&gt;让你能够更加灵活地指定某个参数应该是个文件，包括其访问模式和缓冲区大小。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

parser = argparse.ArgumentParser()

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-i&amp;#39;&lt;/span&gt;, metavar=&lt;span style="color: #a31515"&gt;&amp;#39;in-file&amp;#39;&lt;/span&gt;, type=argparse.FileType(&lt;span style="color: #a31515"&gt;&amp;#39;rt&amp;#39;&lt;/span&gt;))
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-o&amp;#39;&lt;/span&gt;, metavar=&lt;span style="color: #a31515"&gt;&amp;#39;out-file&amp;#39;&lt;/span&gt;, type=argparse.FileType(&lt;span style="color: #a31515"&gt;&amp;#39;wt&amp;#39;&lt;/span&gt;))

&lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
    results = parser.parse_args()
    print &lt;span style="color: #a31515"&gt;&amp;#39;Input file:&amp;#39;&lt;/span&gt;, results.i
    print &lt;span style="color: #a31515"&gt;&amp;#39;Output file:&amp;#39;&lt;/span&gt;, results.o
&lt;span style="color: #0000ff"&gt;except&lt;/span&gt; IOError, msg:
    parser.error(str(msg))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上例中与参数名关联的值是一个打开文件句柄。在使用完该文件后应自己负责关闭该文件。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_FileType.py -h

usage: argparse_FileType.py [-h] [-i in-file] [-o out-file]

optional arguments:
-h, --help   show this help message and exit
-i in-file
-o out-file

$ python argparse_FileType.py -i argparse_FileType.py -o temporary_file.\
txt

Input file: &amp;lt;open file &amp;#39;argparse_FileType.py&amp;#39;, mode &amp;#39;rt&amp;#39; at 0x1004de270&amp;gt;
Output file: &amp;lt;open file &amp;#39;temporary_file.txt&amp;#39;, mode &amp;#39;wt&amp;#39; at 0x1004de300&amp;gt;

$ python argparse_FileType.py -i no_such_file.txt

usage: argparse_FileType.py [-h] [-i in-file] [-o out-file]
argparse_FileType.py: error: argument -i: can&amp;#39;t open &amp;#39;no_such_file.txt&amp;#39;: [Errno 2] No such file or directory: &amp;#39;no_such_file.txt&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;自定义动作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了前面描述的内置动作之外，你也可以提供一个实现了Action API的对象来自定义动作。作为&lt;em&gt;action&lt;/em&gt;传递给&lt;strong&gt;add_argument()&lt;/strong&gt;的对象应接受描述所定义形参的实参，并返回一个可调用对象，作为&lt;em&gt;parser&lt;/em&gt;的实参来处理形参，&lt;em&gt;namespace&lt;/em&gt;存放解析的结果、参数值，以及触发动作的&lt;em&gt;option_string&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;argparse提供了一个&lt;strong&gt;Action&lt;/strong&gt;类作为要定义的新动作的基类。构造方法是处理参数定义的，所以你只要在子类中覆盖&lt;strong&gt;&lt;strong&gt;call&lt;/strong&gt;()&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;CustomAction&lt;/span&gt;(argparse.Action):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self,
            option_strings,
            dest,
            nargs=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
            const=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
            default=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
            type=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
            choices=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
            required=&lt;span style="color: #0000ff"&gt;False&lt;/span&gt;,
            help=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;,
            metavar=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;):
        argparse.Action.__init__(self,
                option_strings=option_strings,
                dest=dest,
                nargs=nargs,
                const=const,
                default=default,
                type=type,
                choices=choices,
                required=required,
                help=help,
                metavar=metavar)
        print
        print &lt;span style="color: #a31515"&gt;&amp;#39;Initializing CustomAction&amp;#39;&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; name,value &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; sorted(locals().items()):
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; name == &lt;span style="color: #a31515"&gt;&amp;#39;self&amp;#39;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; value &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;
            print &lt;span style="color: #a31515"&gt;&amp;#39;  %s = %r&amp;#39;&lt;/span&gt; % (name, value)
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __call__(self, parser, namespace, values, option_string=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;):
        print
        print &lt;span style="color: #a31515"&gt;&amp;#39;Processing CustomAction for &amp;quot;%s&amp;quot;&amp;#39;&lt;/span&gt; % self.dest
        print &lt;span style="color: #a31515"&gt;&amp;#39;  parser = %s&amp;#39;&lt;/span&gt; % id(parser)
        print &lt;span style="color: #a31515"&gt;&amp;#39;  values = %r&amp;#39;&lt;/span&gt; % values
        print &lt;span style="color: #a31515"&gt;&amp;#39;  option_string = %r&amp;#39;&lt;/span&gt; % option_string

        &lt;span style="color: #008000"&gt;# Do some arbitrary processing of the input values&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; isinstance(values, list):
            values = [ v.upper() &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; v &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; values ]
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
            values = values.upper()
        &lt;span style="color: #008000"&gt;# Save the results in the namespace using the destination&lt;/span&gt;
        &lt;span style="color: #008000"&gt;# variable given to our constructor.&lt;/span&gt;
        setattr(namespace, self.dest, values)

parser = argparse.ArgumentParser()

parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, action=CustomAction)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;-m&amp;#39;&lt;/span&gt;, nargs=&lt;span style="color: #a31515"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;, action=CustomAction)
parser.add_argument(&lt;span style="color: #a31515"&gt;&amp;#39;positional&amp;#39;&lt;/span&gt;, action=CustomAction)

results = parser.parse_args([&lt;span style="color: #a31515"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;-m&amp;#39;&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;multi-value&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;positional-value&amp;#39;&lt;/span&gt;])
print
print results
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;values&lt;/em&gt;的类型取决于&lt;em&gt;nargs&lt;/em&gt;的值。如果该参数允许多个值，则&lt;em&gt;values&lt;/em&gt;会是一个列表，即使其仅包含一个列表项。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;option_string&lt;/em&gt;的值也取决于原有的参数规范。对于位置相关的、必需的参数，&lt;em&gt;option_string&lt;/em&gt;始终为&lt;strong&gt;None&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python argparse_custom_action.py

Initializing CustomAction
    dest = &amp;#39;a&amp;#39;
    option_strings = [&amp;#39;-a&amp;#39;]
    required = False

Initializing CustomAction
    dest = &amp;#39;m&amp;#39;
    nargs = &amp;#39;*&amp;#39;
    option_strings = [&amp;#39;-m&amp;#39;]
    required = False

Initializing CustomAction
    dest = &amp;#39;positional&amp;#39;
    option_strings = []
    required = True

Processing CustomAction for &amp;quot;a&amp;quot;
    parser = 4299616464
    values = &amp;#39;value&amp;#39;
    option_string = &amp;#39;-a&amp;#39;

Processing CustomAction for &amp;quot;m&amp;quot;
    parser = 4299616464
    values = [&amp;#39;multi-value&amp;#39;]
    option_string = &amp;#39;-m&amp;#39;

Processing CustomAction for &amp;quot;positional&amp;quot;
    parser = 4299616464
    values = &amp;#39;positional-value&amp;#39;
    option_string = None

Namespace(a=&amp;#39;VALUE&amp;#39;, m=[&amp;#39;MULTI-VALUE&amp;#39;], positional=&amp;#39;POSITIONAL-VALUE&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>读文笔记：What Powers Instagram</title><link href="http://youngsterxyf.github.io/2013/03/27/what-powers-instagram/" rel="alternate"></link><published>2013-03-27T00:00:00+08:00</published><updated>2013-03-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-27:/2013/03/27/what-powers-instagram/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances-dozens-of"&gt;What Powers Instagram: Hundreds of Instances, Dozens of Technologies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;该文从多个方面介绍Instagram整个系统栈(stack)的组成，罗列所使用的组件。我觉得重要的不是用了哪些组件和工具 …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances-dozens-of"&gt;What Powers Instagram: Hundreds of Instances, Dozens of Technologies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;该文从多个方面介绍Instagram整个系统栈(stack)的组成，罗列所使用的组件。我觉得重要的不是用了哪些组件和工具，而是在构建一个系统时，应注意哪些问题，从哪些层面对系统进行优化。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;构建系统的核心原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持简单&lt;/li&gt;
&lt;li&gt;不重复造轮子&lt;/li&gt;
&lt;li&gt;尽可能使用经实践验证可靠的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OS/虚拟主机&lt;/h3&gt;
&lt;p&gt;在Amazon EC2上运行Ubuntu Linux 11.04。之前的Ubuntu版本在高流量的情况会产生各种不可预料的冻结事件（freezing episodes）。&lt;/p&gt;
&lt;h3&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;对Instagram的每个请求都会经过负载均衡机器。以前使用两台&lt;strong&gt;Nginx&lt;/strong&gt;机器，并在两者之间使用DNS轮循（Round-Robin）。
这种方法的缺点是当有机器退出使用时DNS需要花些时间来更新。后来使用Amazon的Elastic负载均衡器，并在ELB层面终止SSL（注：不太懂这个），
从而降低nginx的CPU负载。&lt;/p&gt;
&lt;h3&gt;应用服务器&lt;/h3&gt;
&lt;p&gt;Django；多个应用服务器，由于无状态，所以容易横向扩展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;a href="http://gunicorn.org/"&gt;Gunicorn&lt;/a&gt;作为WSGI服务器。曾使用mod_wsgi和Apache，但Gunicorn更容易配置，CPU负载更小。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://fabric.readthedocs.org/en/1.3.3/index.html"&gt;Fabric&lt;/a&gt;来一次性在多个虚拟主机实例上运行命令（比如部署代码）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据存储&lt;/h3&gt;
&lt;p&gt;大多数数据（用户信息、图片元数据、标签等）都存在PostgreSQL中。将数据切分到多个主机实例上（分区集群shard cluster）。&lt;/p&gt;
&lt;p&gt;使用&lt;a href="http://hoytech.com/vmtouch/"&gt;vmtouch&lt;/a&gt;来诊断与控制文件系统缓存（即哪些数据在内存中）。&lt;/p&gt;
&lt;p&gt;所有PostgreSQL实例都使用流式复制以主-副本配置方式运行，并使用EBS快照频繁备份系统。&lt;/p&gt;
&lt;p&gt;使用&lt;a href="http://pgfoundry.org/projects/pgbouncer/"&gt;Pgbouncer&lt;/a&gt;作为PostgreSQL的连接池。&lt;/p&gt;
&lt;p&gt;图片直接存储在Amazon S3上。使用Amazon CloudFront作为CDN。&lt;/p&gt;
&lt;p&gt;广泛使用&lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;，驱动主要的数据源(main feed)、活动数据源(activity feed)、会话系统（&lt;a href="https://gist.github.com/mikeyk/910392"&gt;Instagram的Django会话后端&lt;/a&gt;）。也以主-副本设置运行Redis，副本机器不断地将数据库保存到磁盘，并使用EBS快照来备份这些DB转储数据。因为Redis支持写副本，所以在多台Redis机器之间进行在线故障转移（online failover）非常容易。&lt;/p&gt;
&lt;p&gt;使用Memcached做缓存，通过pylibmc和libmemcached连接memcached。&lt;/p&gt;
&lt;h3&gt;任务队列与推送通知&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;任务队列系统：&lt;a href="http://gearman.org/"&gt;Gearman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;推送通知：&lt;a href="https://github.com/samuraisam/pyapns"&gt;pyapns&lt;/a&gt;，性价比高&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;监控&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;a href="http://munin-monitoring.org/"&gt;Munin&lt;/a&gt;为整个系统的各种指标绘制图表，如果某些指标超出了常规范围会提醒管理员。基于&lt;a href="http://samuelks.com/python-munin/"&gt;Python-Munin&lt;/a&gt;编写Munin插件为非系统级的指标绘制图表。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://pingdom.com/"&gt;Pingdom&lt;/a&gt;对服务进行外部监控。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://pagerduty.com/"&gt;PagerDuty&lt;/a&gt;来处理通知和事件。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="https://pypi.python.org/pypi/django-sentry"&gt;Sentry&lt;/a&gt;来记录Python错误报告，这样任何时候都可以登录系统（实时地）看到系统中正在发生什么错误。&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="笔记"></category></entry><entry><title>学习JavaScript - 我的经验与建议（译）</title><link href="http://youngsterxyf.github.io/2013/03/25/learning-js/" rel="alternate"></link><published>2013-03-25T00:00:00+08:00</published><updated>2013-03-25T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-25:/2013/03/25/learning-js/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://sivers.org/learn-js"&gt;learning JavaScript - my experience and advice&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自从我曾&lt;a href="http://sivers.org/os"&gt;几&lt;/a&gt;&lt;a href="http://sivers.org/srs"&gt;次&lt;/a&gt;&lt;a href="http://sivers.org/prog"&gt;提到&lt;/a&gt;自己在刚过去的几个月中学习了JavaScript，很多人就发email给我询问我是如何学习JavaScript的以及推荐如何学习。以下就是我的经验和最 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://sivers.org/learn-js"&gt;learning JavaScript - my experience and advice&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自从我曾&lt;a href="http://sivers.org/os"&gt;几&lt;/a&gt;&lt;a href="http://sivers.org/srs"&gt;次&lt;/a&gt;&lt;a href="http://sivers.org/prog"&gt;提到&lt;/a&gt;自己在刚过去的几个月中学习了JavaScript，很多人就发email给我询问我是如何学习JavaScript的以及推荐如何学习。以下就是我的经验和最佳建议。&lt;/p&gt;
&lt;p&gt;注：我是想真正地学习JavaScript---不是捷径，或快速技巧，或元工具（meta-tools）之类让我不必要学习JavaScript的东西。我想学习、掌握、阅读、理解以及记住JavaScript这门语言，从而在以后的日子里能够理解所有其他以JavaScript编写的很酷的东西。&lt;/p&gt;
&lt;p&gt;首先---很多人可能会告诉你去阅读&lt;a href="http://shop.oreilly.com/product/9780596517748.do"&gt;Douglas Crockford的著作《JavaScript语言精粹》&lt;/a&gt;。但当我开始阅读这本书时，才发现它是如此的紧凑简洁以致我根本不知道它在说啥！&lt;/p&gt;
&lt;p&gt;你知道何时一个专家是在谈论自己的领域，就不知道如何为其他人做点简化么？感觉这本书对于那些已有20年的C、Java或C++编程经验来说非常完美，他们只需要快速概览必知的JavaScript知识点。&lt;/p&gt;
&lt;p&gt;但它真的不是要教你学习JavaScript。它不会指导你学习任何东西。因此我建议先跳过这本书。&lt;/p&gt;
&lt;p&gt;相反，从&lt;a href="http://eloquentjavascript.net/"&gt;Marijn Haverbeke的著作《JavaScript编程精解》&lt;/a&gt;开始学习吧。&lt;/p&gt;
&lt;p&gt;这本书一开始非常简单易学，简直是太简单了，这能鼓舞你，让你自信起来。你就能得意洋洋地说“这很简单嘛！”&lt;/p&gt;
&lt;p&gt;&lt;a href="http://eloquentjavascript.net/contents.html"&gt;阅读这里的在线版本&lt;/a&gt;，因为你可以直接在浏览器中测试实验。&lt;/p&gt;
&lt;p&gt;然后，在读完几个章节后，&lt;strong&gt;转而阅读&lt;/strong&gt;&lt;a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-3rd-Edition.productCd-1118222199.html"&gt;《JavaScript高级程序设计》，第三版---Nicholas Zakas著&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这是一本终极教程，花很多篇幅详细解释大量知识点，覆盖几乎所有东西。每个章节你都应花费几个小时来阅读，等你读完这本书时，你知道的也就和大多数自称JavaScript程序员的人一样多了。&lt;/p&gt;
&lt;p&gt;有趣的是，读完这本书后，我又回过头来阅读&lt;a href="http://shop.oreilly.com/product/9780596517748.do"&gt;《JavaScript语言精粹》&lt;/a&gt;，现在我能理解书中讲述的东西了。但由于&lt;a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-3rd-Edition.productCd-1118222199.html"&gt;《JavaScript高级程序设计》&lt;/a&gt;一书的内容是如此全面，所以也就覆盖了所有的“精粹”了。&lt;/p&gt;
&lt;p&gt;当然，你必须记住你正在学习的东西，因此我强烈推荐你记下学习的每个新知识点，最好是记在一个抽认卡程序中，&lt;a href="http://sivers.org/srs"&gt;就像这样&lt;/a&gt;。因为要学习很多东西，所以你必须在几周或几个月后提醒自己学习过哪些东西。&lt;/p&gt;
&lt;p&gt;如果你想阅读更多书籍来在大脑中巩固JavaScript，那继续学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/9780596806149.do"&gt;《JavaScript Cookbook》 - Shelley Powers著&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://effectivejs.com/"&gt;《JavaScript高效编程》 - David Herman著&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.manning.com/resig/"&gt;《JavaScript忍者的秘密》 - John Resig和Bear Bibeault著&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些书都非常好。你会发现自己能更快地阅读这些书，因为你已比较熟悉JavaScript。阅读的同时最好写写书中的示例程序，把玩把玩。&lt;/p&gt;
&lt;h3&gt;阅读一些真实世界的JavaScript代码&lt;/h3&gt;
&lt;p&gt;在写了上千页短小示例代码片段后，你会想看看两个非常流行而强大的JavaScript项目的源代码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://underscorejs.org/docs/underscore.html"&gt;Underscore.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://backbonejs.org/docs/backbone.html"&gt;Backbone.js&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你会发现之前的一切都是有意义的，现在你能够顺畅地阅读和理解JavaScript代码。&lt;/p&gt;
&lt;h3&gt;然后是jQuery，以及更多...&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://jquery.com/"&gt;jQuery&lt;/a&gt;绝对是无处不在的，你要想完整地学习JavaScript就必须学习它。&lt;/p&gt;
&lt;p&gt;学习了纯JavaScript冗长的处理问题的方式，你会很喜欢jQuery提供的快捷方式。&lt;/p&gt;
&lt;p&gt;我真的很喜欢&lt;a href="http://www.headfirstlabs.com/books/hfjquery/"&gt;《深入浅出jQuery》&lt;/a&gt;一书，绝对是傻瓜式书籍。这本书非常精彩地引导你学习jQuery，边学边应用你学习过的东西。&lt;/p&gt;
&lt;p&gt;如果你仍然渴望学习更多关于JavaScript的东西，那么深入学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;a href="http://shop.oreilly.com/product/0636920024309.do"&gt;《CoffeeScript小书》 - Alex MacCaw著&lt;/a&gt;学习&lt;a href="http://coffeescript.org/"&gt;CoffeeScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://javascriptissexy.com/learn-backbone-js-completely/"&gt;沿着这条路线&lt;/a&gt;学习&lt;a href="http://backbonejs.org/"&gt;Backbone.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://javascriptissexy.com/learn-node-js-completely-and-with-confidence/"&gt;沿着这条路线&lt;/a&gt;学习&lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;然后放下书，去使用JavaScript吧！&lt;/h3&gt;
&lt;p&gt;你也许会想这还用说吗，但如果我不说，有些人又会抱怨了。因此，看看你现有的网站，去应用你学会的东西。或者从头开始做个新的站点，尽可能用JavaScript来实现，即使只是一个实验性作品。&lt;/p&gt;
&lt;h3&gt;其他建议？看你的了！&lt;/h3&gt;
&lt;p&gt;好了...上述就是我的一点经验，对于结果我相当满意。&lt;/p&gt;
&lt;p&gt;也请你在此分享其他的建议或经验吧。&lt;/p&gt;</content><category term="其他"></category><category term="JavaScript"></category><category term="翻译"></category></entry><entry><title>pip install lxml编译失败问题解决</title><link href="http://youngsterxyf.github.io/2013/03/17/pip-install-lxml-problem/" rel="alternate"></link><published>2013-03-17T00:00:00+08:00</published><updated>2013-03-17T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-17:/2013/03/17/pip-install-lxml-problem/</id><summary type="html">&lt;p&gt;以前在遇到这个问题时，都是偷懒使用&lt;code&gt;sudo apt-get install python-lxml&lt;/code&gt;（Debian系的Linux发行版）直接安装已打包好的deb包。但一方面这样安装的不是最新的库，另一方面 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;以前在遇到这个问题时，都是偷懒使用&lt;code&gt;sudo apt-get install python-lxml&lt;/code&gt;（Debian系的Linux发行版）直接安装已打包好的deb包。但一方面这样安装的不是最新的库，另一方面我希望把所有的Python第三方库都限制在virtualenv中使用，所以希望使用&lt;code&gt;pip install lxml&lt;/code&gt;，那么这个问题就必须解决了。&lt;/p&gt;
&lt;p&gt;Google了一把，在&lt;a href="http://stackoverflow.com/questions/5178416/pip-install-lxml-error"&gt;这里&lt;/a&gt;找到了解答。&lt;/p&gt;
&lt;p&gt;其实在编译失败的log里，已经有提示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make sure the development packages of libxml2 and libxslt are installed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以正确编译需先安装libxml2和libxslt这两个包。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt-get install libxml2
sudo apt-get install libxslt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外，还需安装Python开发包python-dev：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt-get install python-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;OK，再执行&lt;code&gt;pip install lxml&lt;/code&gt;就没问题啦。&lt;/p&gt;</content><category term="其他"></category><category term="Python"></category></entry><entry><title>读书笔记：JavaScript语言精粹</title><link href="http://youngsterxyf.github.io/2013/03/14/read-js-thegoodparts/" rel="alternate"></link><published>2013-03-14T00:00:00+08:00</published><updated>2013-03-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-14:/2013/03/14/read-js-thegoodparts/</id><summary type="html">&lt;h2&gt;第2章：语法&lt;/h2&gt;
&lt;p&gt;JavaScript提供两种注释形式，一种是用&lt;code&gt;/* */&lt;/code&gt;包围的注释块，另一种是以&lt;code&gt;//&lt;/code&gt;为开头的行注释。
建议避免使用&lt;code&gt;/* */&lt;/code&gt;，而用&lt;code&gt;//&lt;/code&gt;注释代替它。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;标识符由一个字母开头 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;第2章：语法&lt;/h2&gt;
&lt;p&gt;JavaScript提供两种注释形式，一种是用&lt;code&gt;/* */&lt;/code&gt;包围的注释块，另一种是以&lt;code&gt;//&lt;/code&gt;为开头的行注释。
建议避免使用&lt;code&gt;/* */&lt;/code&gt;，而用&lt;code&gt;//&lt;/code&gt;注释代替它。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;标识符由一个字母开头，其后可选择性地加上一个或多个字母、数字或下划线。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JavaScript只有一个数字类型。它在内部被表示为64位的浮点数。与其他大多数编程语言不同的是，它没有分离出整数类型，所以1和1.0的值相同。&lt;/p&gt;
&lt;p&gt;如果一个数字字面量有指数部分，那么这个字面量的值等于e之前的数字与10的e之后数字的次方相乘。&lt;/p&gt;
&lt;p&gt;NaN是一个数值，它表示一个不能产生正常结果的运算结果。NaN不等于任何值，包括它自己。可以用函数isNaN(number)检测NaN.&lt;/p&gt;
&lt;p&gt;Infinity表示所有大于1.79769313486231570e+308的值。&lt;/p&gt;
&lt;p&gt;JavaScript有一个对象Math，它包含一套作用于数字的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;字符串字面量可以被包在一对单引号或双引号中，它可能包含0个或多个字符。\（反斜杠）是转义字符。JavaScript中的所有字符都是16位的。&lt;/p&gt;
&lt;p&gt;JavaScript没有字符类型。要表示一个字符，只需创建仅包含一个字符的字符串即可。&lt;/p&gt;
&lt;p&gt;字符串是不可变的。一旦字符串被创建，就永远无法改变它。但可以通过+运算符连接其他字符串来创建一个新字符串。两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同（===）的字符串。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个编译单元包含一组可执行的语句。在Web浏览器中，每个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签提供一个被编译且立即执行的编译单元。因为缺少链接器，JavaScript把它们一起抛到一个公共的全局名字空间中。&lt;/p&gt;
&lt;p&gt;当var语句被用在函数内部时，它定义的是这个函数的私有变量。（最佳实践：定义任何变量都使用var）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for in&lt;/code&gt;语句会枚举一个对象的所有属性名（键名）。通常需要检测&lt;code&gt;object.hasOwnProperty(variable)&lt;/code&gt;来确定这个属性名是该对象的成员，还是来自于原型链。&lt;/p&gt;
&lt;h2&gt;第3章：对象&lt;/h2&gt;
&lt;p&gt;JavaScript的简单数据类型包括数字、字符串、布尔值（true和false）、null值和undefined值。其他所有的值都是对象。&lt;/p&gt;
&lt;p&gt;数字、字符串和布尔值“貌似”对象，因为它们拥有方法，但它们是不可变的。JavaScript中的对象是可变的键控集合（keyed collections）。&lt;/p&gt;
&lt;p&gt;对象是属性的容器，其中每个属性都拥有名字和值。属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除undefined值之外的任何值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;要检索对象里包含的值，可以采用在&lt;code&gt;[]&lt;/code&gt;后缀中括住一个字符串表达式的方式。如果字符串表达式是一个字符串字面量，而且它是一个合法的JavaScript标识符且不是保留字，则也可以用&lt;code&gt;.&lt;/code&gt;表示法代替。优秀考虑使用&lt;code&gt;.&lt;/code&gt;表示法，因为它更紧凑且可读性更好。&lt;/p&gt;
&lt;p&gt;如果你尝试检索一个并不存在的成员属性的值，将返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;||&lt;/code&gt;运算符可以用来填充默认值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; status = flight.status || &lt;span style="color: #a31515"&gt;&amp;quot;unknow&amp;quot;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;尝试从undefined的成员属性中取值将会导致TypeError异常。可以通过&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;运算符来避免错误。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;flight.equipment        &lt;span style="color: #008000"&gt;// undefined&lt;/span&gt;
flight.equipment.model      &lt;span style="color: #008000"&gt;// throw &amp;quot;TypeError&amp;quot;&lt;/span&gt;
flight.equipment &amp;amp;&amp;amp; flight.equipment.model  &lt;span style="color: #008000"&gt;// undefined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;对象通过引用来传递。它们永远不会被拷贝：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; x = stooge;
x.nickname = &lt;span style="color: #a31515"&gt;&amp;#39;Curly&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; nick = stooge.nickname;
&lt;span style="color: #008000"&gt;// 因为x和stooge是指向同一个对象的引用，所以nick为&amp;#39;Curly&amp;#39;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; a = {}, b = {}, c = {};
&lt;span style="color: #008000"&gt;// a、b和c每个都引用一个不同的空对象&lt;/span&gt;
a = b = c = {};
&lt;span style="color: #008000"&gt;// a、b和c都引用同一个空对象&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;每个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到&lt;code&gt;Object.prototype&lt;/code&gt;这个JavaScript中标准的对象。&lt;/p&gt;
&lt;p&gt;原型连接在更新时是不起作用的。当对某个对象做出改变时，不会触及该对象的原型。原型连接只有在检索值的时候才被用到。&lt;/p&gt;
&lt;p&gt;原型关系是一种动态的关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;使用&lt;code&gt;for in&lt;/code&gt;枚举一个对象中的所有属性名时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是完全避免使用&lt;code&gt;for in&lt;/code&gt;语句，而是创建一个数组，在其中以正确的顺序包含属性名。通过使用&lt;code&gt;for&lt;/code&gt;而不是&lt;code&gt;for in&lt;/code&gt;，可以得到我们想要的属性。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;delete运算符可以用来删除对象的属性。它将移除对象中确定包含的属性，但不会触及原型链中的任何对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最小化使用全局变量的一个方法是在你的应用中只创建唯一一个全局变量：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; MYAPP = {};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该变量此时变成了你的应用的容器：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;MYAPP.stooge = {
    &lt;span style="color: #a31515"&gt;&amp;quot;first-name&amp;quot;&lt;/span&gt;: &lt;span style="color: #a31515"&gt;&amp;quot;Joe&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;last-name&amp;quot;&lt;/span&gt;: &lt;span style="color: #a31515"&gt;&amp;quot;Howard&amp;quot;&lt;/span&gt;
};

MYAPP.flight = {
    airline: &lt;span style="color: #a31515"&gt;&amp;quot;Oceanic&amp;quot;&lt;/span&gt;,
    number: 815,
    departure: {
        IATA: &lt;span style="color: #a31515"&gt;&amp;quot;SYD&amp;quot;&lt;/span&gt;,
        time: &lt;span style="color: #a31515"&gt;&amp;quot;2004-09-22 14:55&amp;quot;&lt;/span&gt;,
        city: &lt;span style="color: #a31515"&gt;&amp;quot;Sydney&amp;quot;&lt;/span&gt;
    },
    arrival: {
        IATA: &lt;span style="color: #a31515"&gt;&amp;quot;LAX&amp;quot;&lt;/span&gt;,
        time: &lt;span style="color: #a31515"&gt;&amp;quot;2004-09-23 10:42&amp;quot;&lt;/span&gt;,
        city: &lt;span style="color: #a31515"&gt;&amp;quot;Los Angeles&amp;quot;&lt;/span&gt;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;第4章：函数&lt;/h2&gt;
&lt;p&gt;除了声明时定义的形式参数，每个函数在调用之时会接收两个附加的参数：this和arguments。参数this的值取决于调用的模式。在JavaScript中一共有四种调用模式：方法调用模式、函数调用模式、构造器调用模式和apply调用模式。&lt;/p&gt;
&lt;p&gt;JavaScript中，当实参（arguments）的个数与形参（parameters）的个数不匹配时不会导致运行时错误。如果实参值过多时，超出的参数值将被忽略。如果实参值过少，缺失的值将会被替换为undefined。对参数值不会进行类型检查：任何类型的值都可以被传递给参数。&lt;/p&gt;
&lt;p&gt;arguments并不是一个真正的数组。它只是一个“类似数组(array-like)”的对象。arguments拥有一个length属性，但它缺少所有的数组方法。&lt;/p&gt;
&lt;p&gt;在函数调用模式中，this被绑定到全局对象。&lt;/p&gt;
&lt;p&gt;一个函数总是会返回一个值。如果没有指定返回值，则返回undefined。&lt;/p&gt;
&lt;p&gt;如果函数以在前面加上new前缀的方式来调用(即构造函数)，且返回值不是一个对象，则返回this（该新对象）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JavaScript提供的异常处理机制中，一个try语句只会有一个将捕获所有异常的catch代码块。如果你的处理手段取决于异常的类型，那么异常处理器必须检查异常对象的name属性以确定异常的类型。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于变量声明，由于JavaScript缺少块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;可以通过闭包实现对象的私有属性：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; myObject = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; value = 0;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; {
        increment: &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; (inc) {
            value += &lt;span style="color: #0000ff"&gt;typeof&lt;/span&gt; inc === &lt;span style="color: #a31515"&gt;&amp;#39;number&amp;#39;&lt;/span&gt; ? inc : 1;
        },
        getValue: &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; value;
        }
    }
}();        &lt;span style="color: #008000"&gt;//注意这里调用了匿名函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;模块是一个提供接口却隐藏状态与实现的函数或对象。通过使用函数去产生模块，几乎可以完全摒弃全局变量的使用。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;String.prototype.method = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; (name, func) {
    &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.prototype[name] = func;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;;
};

String.method(&lt;span style="color: #a31515"&gt;&amp;#39;deentityify&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #008000"&gt;// 字符实体表。映射字符实体的名字到对应的字符。&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; entity = {
        quot: &lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;,
        lt: &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;,
        gt: &lt;span style="color: #a31515"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;
    };
    &lt;span style="color: #008000"&gt;// 返回deentityify方法&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #008000"&gt;// 这才是deentityify方法。它调用字符串的replace的方法，&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// 查找‘&amp;amp;’开头和‘;’结束的子字符串。如果这些字符可以在字符实体表中找到，&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// 那么就将该字符实体替换为映射表中的值。&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.replace(&lt;span style="color: #a31515"&gt;/&amp;amp;([^&amp;amp;;]+);/g&lt;/span&gt;,
            &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; (a, b){
                &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; r = entity[b];
                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;typeof&lt;/span&gt; r === &lt;span style="color: #a31515"&gt;&amp;#39;string&amp;#39;&lt;/span&gt; ? r : a;
            }
        );
    };
}());   &lt;span style="color: #008000"&gt;// 注意这里，匿名函数已被调用&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;模块模式利用了函数作用域和闭包来创建绑定对象与私有成员的关联，在上述例子中，只有deentityify方法有权访问字符实体表这个数据对象。&lt;/p&gt;
&lt;p&gt;使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;有些方法没有返回值。例如，一些设置或修改对象的某个状态却不返回任何值的方法就是典型的例子。如果让这些方法返回this而不是undefined，就可以启用级联。在一个级联中，可以在单独一条的语句中依次调用同一个对象的很多方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;套用(curry)允许将函数与传递给它的参数相结合去产生一个新的函数。&lt;/p&gt;
&lt;p&gt;curry方法通过创建一个保存着原始函数和被套用的参数的闭包来工作。它返回另一个函数，该函数被调用时，会返回调用原始函数的结果，并传递调用curry时的参数加上当前调用函数的所有参数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Function.prototype.method = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; (name, func) {
    &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.prototype[name] = func;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;;
};
Function.method(&lt;span style="color: #a31515"&gt;&amp;#39;curry&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #008000"&gt;// 由于arguments并非真正的数组，所以需要应用slice方法来构造常规的数组&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; slice = Array.prototype.slice,
        args = slice.apply(arguments),
        that = &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; that.apply(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, args.concat(slice.apply(arguments)));
    };
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;第5章：继承&lt;/h2&gt;
&lt;p&gt;当一个函数对象被创建时，Function构造器产生的函数对象会运行类似这样的一些代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.prototype = {&lt;span style="color: #0000ff"&gt;constructor&lt;/span&gt;: &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;新函数对象被赋予一个prototype属性，其值包含一个constructor属性且属性值为该新函数对象。该prototype对象是存放继承特征的地方。因为JavaScript语言没有提供一种方法去确定哪个函数是打算用来作构造器的，所以每个函数都会得到一个prototype对象。constructor属性没什么用，重要的是prototype对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;函数化构造器实现私有保护&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; people = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; (spec) {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; that = {
        prefix: &lt;span style="color: #a31515"&gt;&amp;#39;People: &amp;#39;&lt;/span&gt;
    };
    that.get_name = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.prefix + spec.name;
    };
    that.says = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.prefix + (spec.saying || &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;);
    };
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; that;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;第6章：数组&lt;/h2&gt;
&lt;p&gt;JavaScript中，每个数组都有一个length属性。如果你用大于或等于当前length的数字作为下标来存储一个元素，那么length值会被增大以容纳新元素，不会发生数组越界错误。&lt;/p&gt;
&lt;p&gt;length属性的值是这个数组的最大整数属性名加上1.它不一定等于数组里的属性的个数。&lt;/p&gt;
&lt;p&gt;你可以直接设置length的值。设置更大的length不会给数组分配更多的空间。而把length设小将导致所有下标大于等于新length的属性被删除。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由于JavaScript的数组其实就是对象，所以delete运算符可以用来从数组中移除元素。不幸的是，这样会在数组中留下一个空洞。这是因为排在被删除元素之后的元素保留着它们最初的属性。JavaScript的数组有一个splice方法，可以删除一些元素并将它们替换为其他的元素。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;numbers = [&lt;span style="color: #a31515"&gt;&amp;#39;zero&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;one&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;two&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;shi&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;go&amp;#39;&lt;/span&gt;];

&lt;span style="color: #0000ff"&gt;delete&lt;/span&gt; numbers[2];
&lt;span style="color: #008000"&gt;// 现在numbers为[&amp;#39;zero&amp;#39;, &amp;#39;one&amp;#39;, undefined, &amp;#39;shi&amp;#39;, &amp;#39;go&amp;#39;]&lt;/span&gt;

numbers.splice(2, 1);
&lt;span style="color: #008000"&gt;// 现在numbers为[&amp;#39;zero&amp;#39;, &amp;#39;one&amp;#39;, &amp;#39;shi&amp;#39;, &amp;#39;go&amp;#39;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;在JavaScript编程中，一个常见的错误是在必须使用数组时使用了对象，或者在必须使用对象时使用了数组。其实规则很简单：当属性名是小而连续的整数时，应该使用数组。否则，使用对象。&lt;/p&gt;
&lt;p&gt;由于对数组使用&lt;code&gt;typeof&lt;/code&gt;的结果为&lt;code&gt;object&lt;/code&gt;，所以需要其他方法来判别一个变量是否为数组：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; is_array = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; (value) {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; Object.prototype.toString.apply(value) === &lt;span style="color: #a31515"&gt;&amp;#39;[object Array]&amp;#39;&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;第7章：正则表达式&lt;/h2&gt;
&lt;p&gt;一个&lt;em&gt;正则表达式分支&lt;/em&gt;包含一个或多个&lt;em&gt;正则表达式序列&lt;/em&gt;。这些序列被|（竖线）字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它尝试按顺序依次匹配这些序列项。所以：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #a31515"&gt;&amp;quot;into&amp;quot;&lt;/span&gt;.match(&lt;span style="color: #a31515"&gt;/in|int/&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;会在into中匹配，但它不会匹配int，因为in已被成功匹配了。&lt;/p&gt;
&lt;p&gt;一个&lt;em&gt;正则表达式序列&lt;/em&gt;包含一个或多个&lt;em&gt;正则表达式因子&lt;/em&gt;。每个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数。如果没有指定这个量词，那么该因子只会被匹配一次。&lt;/p&gt;
&lt;p&gt;一个&lt;em&gt;正则表达式因子&lt;/em&gt;可以是一个字符、一个由圆括号包围的组、一个字符类，或者是一个转义序列。除了控制字符和特殊字符以外，所有的字符都会被按照字面处理：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\ / [ ] ( ) { } ? + * | . ^ $&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果希望上面列出的字符按字面去匹配，那么必须要用一个\前缀来进行转义。&lt;/p&gt;
&lt;p&gt;一个未被转义的&lt;code&gt;.&lt;/code&gt;会匹配除行结束符以外的任何字符。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;正则表达式分组共有4种：&lt;/p&gt;
&lt;p&gt;1.
捕获型：一个捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获型分组都被指定了一个数字。在正则表达式中第1个捕获&lt;code&gt;(&lt;/code&gt;的是分组1，第2个捕获&lt;code&gt;(&lt;/code&gt;的是分组2。&lt;/p&gt;
&lt;p&gt;2.
非捕获型：非捕获型分组有一个&lt;code&gt;(?:&lt;/code&gt;前缀。非捕获型分组仅做简单的匹配，并不会捕获所匹配的文本。这会带来微弱的性能优势。非捕获型分组不会干扰捕获型分组的编号。&lt;/p&gt;
&lt;p&gt;3.
向前正向匹配（Positive lookahead）：向前正向匹配分组有一个&lt;code&gt;(?=&lt;/code&gt;前缀。它类似于非捕获型分组，但在这个组匹配后，文本会倒回到它开始的地方，实际上并不匹配任何东西。这不是一个好的特性。（什么意思？）&lt;/p&gt;
&lt;p&gt;4.
向前负向匹配（Negative lookahead）：向前负向匹配分组有一个&lt;code&gt;(?!&lt;/code&gt;前缀。类似于向前正向匹配分组，但只有当它匹配失败时它才继续向前进行匹配。这不是一个好的特性。&lt;/p&gt;
&lt;h2&gt;第8章：方法&lt;/h2&gt;
&lt;h3&gt;Array&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;array.concat(item...)&lt;/strong&gt;方法会产生一个新数组，它包含一份array的浅复制（shallow copy）并把一个或多个参数item附加在其后。如果参数item是一个数组，那么它的每个元素会被分别添加。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; a = [&lt;span style="color: #a31515"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;];
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; b = [&lt;span style="color: #a31515"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;];
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; c = a.concat(b, &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;);
&lt;span style="color: #008000"&gt;// c为[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39;, true]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;array.join(separator)&lt;/strong&gt;方法把一个array构造成一个字符串。目前在大多数情况下，对字符串连接建议首选使用+运算符，因为相比join方法，+运算符的性能更高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.pop()&lt;/strong&gt;，其可以这样实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Array.method(&lt;span style="color: #a31515"&gt;&amp;#39;pop&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.splice(&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.length - 1, 1)[0];
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;array.push(item...)&lt;/strong&gt;与concat方法不同的是，该方法会修改array。可以这样实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Array.method(&lt;span style="color: #a31515"&gt;&amp;#39;push&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.splice.apply(
        &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;,
        [&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.length, 0].
            concat(Array.prototype.slice.apply(arguments)));
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.length;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;array.reverse()&lt;/strong&gt;方法反转array里的元素的顺序，并返回array本身：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; a = [&lt;span style="color: #a31515"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;];
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; b = a.reverse();
&lt;span style="color: #008000"&gt;// a和b都是[&amp;#39;c&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;array.shift()&lt;/strong&gt;方法移除数组array中的第1个元素并返回该元素。如果数组array为空，则会返回undefined。shift操作通常要比pop慢得多，可以这样实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Array.method(&lt;span style="color: #a31515"&gt;&amp;#39;shift&amp;#39;&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.splice(0, 1)[0];
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;array.slice(start, end)&lt;/strong&gt;方法对array中的一段做浅复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.sort(comparefn)&lt;/strong&gt;方法对array中的内容进行排序。默认比较函数把要排序的元素都视为字符串。可以使用自己的比较函数来替换默认的比较函数。你的比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第2个参数应该排列在前面，则返回一个正数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.splice(start, deleteCount, item...)&lt;/strong&gt;方法从array中移除一个或多个元素，并用新的item替换它们。其返回一个包含被移除元素的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.unshift(item...)&lt;/strong&gt;方法像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分而不是尾部，返回array的新的length。&lt;/p&gt;
&lt;h3&gt;Function&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;function.apply(thisArg, argArray)&lt;/strong&gt;方法调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。&lt;/p&gt;
&lt;h3&gt;Number&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;number.toFixed(fractionDigits)&lt;/strong&gt;方法把number转换成一个十进制数形式的字符串。可选参数fractionDigits控制其小数点后的数字位数，必须在0～20之间，默认为0。&lt;strong&gt;number.toPrecision(precision)&lt;/strong&gt;方法的功能与其几乎相同，除了precision的值为0~21之间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;number.toString(radix)&lt;/strong&gt;方法把number转换成为一个字符串。可选参数radix控制基数，默认为10。&lt;/p&gt;
&lt;h3&gt;String&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;string.charAt(pos)&lt;/strong&gt;方法返回在string中pos位置处的字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.charCodeAt(pos)&lt;/strong&gt;方法同charAt一样，只不过返回的不是一个字符串，而是以整数形式表死的在string中pos位置处的字符的字符码位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.indexOf(searchString, position)&lt;/strong&gt;方法在string内查找另一个字符串searchString。如果找到，返回第一个匹配字符的位置，否则返回-1。可选参数position可设置从string的某个指定位置开始超找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.lastIndexOf(searchString, position)&lt;/strong&gt;方法和indexOf方法类似，只不过它是从该字符串的末尾开始查找而不是从开头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.search(regexp)&lt;/strong&gt;方法和indexOf方法类似，只是它接受一个正则表达式对象作为参数而不是一个字符串。&lt;/p&gt;
&lt;h2&gt;第9章：代码风格&lt;/h2&gt;
&lt;p&gt;优秀的程序拥有一个前瞻性的结构，它会预见到未来所需要的可能修改，但不会让其成为过度的负担。优秀的程序也有一种清晰的表达方式。如果一个程序被表达得很好，那么我们就能更加容易地去理解它，以便成功地修改或修复它。&lt;/p&gt;
&lt;p&gt;通过在一个清晰且始终如一的风格下编写，你的程序会变得易于阅读。&lt;/p&gt;
&lt;h2&gt;附录A：糟粕&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有三种方式定义全局变量。第一种是脱离任何函数安排一个var语句：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; foo = value;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二种是直接添加一个属性到全局对象上。全局对象是所有全局变量的容器。在Web浏览器里，全局对象名为window：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;window.foo = value;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三种是直接使用未经声明的变量。这被称为隐式的全局变量：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;foo = value;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这本来是为了方便初学者而有意让变量在使用前无须声明。JavaScript的策略是让那些忘记预先声明的变量成为全局变量，这导致查找bug非常困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于JavaScript没有块级作用域，所以最好是在每个函数的开头部分声明所有变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动插入分号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript有一个机制，它试图通过自动插入分号来修正有缺损的程序。千万不要依靠它，它可能会掩盖更为严重的错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parseInt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;parseInt是一个将字符串转换为整数的函数。它在遇到非数字时停止解析。如果该字符串的第一个字符是0,那么该字符串将被基于八进制而不是十进制来求值。幸运的是，parseInt可以接受一个基数作为参数。我建议你总是提供这个基数参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;+运算符可以用于加法运算或字符串连接。但究竟会如何执行取决于其参数的类型。如果其中一个运算数是一个空字符串，它会把另一个运算数转换成字符串并返回。如果两个运算数都是数字，则返回两者之和。否则，它把两个运算数都转换为字符串并连接起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript的对象永远不会有真的空对象，因为它们可以从原型链中取得成员元素。&lt;/p&gt;
&lt;h2&gt;附录B：鸡肋&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;==&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建议永远不要使用&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;。相反，请始终使用&lt;code&gt;===&lt;/code&gt;和&lt;code&gt;!==&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;with语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;function语句对比函数表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript既有function语句（&lt;em&gt;函数声明&lt;/em&gt;），同时也有函数表达式（匿名函数？包含赋值过程么？）。令人困惑的是两者看起来好像就是相同的。&lt;/p&gt;
&lt;p&gt;（&lt;em&gt;区分：函数声明所有代码被执行之前运行。函数表达式仅当解释器到达代码时候才运行。&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;function语句在解析时会发生被提升的情况。这意味着不管function语句被防治在哪里，它都会被移动到被定义时所在作用域的顶层。这放宽了函数必须先声明后使用的要求，而我认为这会导致混乱。在if语句中使用function语句也是被禁止的。结果表明大多数的浏览器都允许在if语句里使用function语句，但它们在解析时的处理上各不相同，从而造成了可移植性的问题。&lt;/p&gt;
&lt;p&gt;一个语句不能以一个函数表达式开头，因为官方的语法假定以单词function开头的语句是一个function语句（&lt;em&gt;这里说得我有点糊涂了啊！&lt;/em&gt;）。解决方法就是把函数表达式括在一个圆括号之中：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; hidden_variable;
    &lt;span style="color: #008000"&gt;// 这个函数可能对环境有一些影响，但不会引入新的全局变量。&lt;/span&gt;
})();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在很多语言中，void是一种类型，表示没有值。而在JavaScript中，void是一个运算符，接受一个运算数并返回undefined。这没什么用。&lt;/p&gt;
&lt;h2&gt;附录C：JSLint&lt;/h2&gt;
&lt;p&gt;（&lt;em&gt;待阅读&lt;/em&gt;）&lt;/p&gt;
&lt;h2&gt;附录E：JSON&lt;/h2&gt;
&lt;p&gt;JSON有6种类型的值：对象、数组、字符串、数字、布尔值（true和false）和特殊值null。空白（空格符、制表符、回车符和换行符）可被插到任何值的前后，从而使得JSON文本更容易被人阅读。为了减少传输和存储的成本，空白可以被省略。&lt;/p&gt;
&lt;p&gt;JSON对象是一个容纳“名/值”对的无序集合。&lt;/p&gt;
&lt;p&gt;JSON数组是一个值的有序序列。其值可以是任何类型的JSON值，包括数组和对象。&lt;/p&gt;
&lt;p&gt;JSON字符串要被包围在一对双引号之间。\字符被用于转义。&lt;/p&gt;
&lt;p&gt;JSON数字与JavaScript的数字相似。整数的首位不允许为0,因为一些语言用它来标示八进制。这种基数的混乱在数据交换格式中是不可取的。数字可以是整数、实数或科学计数。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JSON特别易于用在Web应用中，因为JSON就是JavaScript。使用eval函数可以把一段JSON文本转化成一个有用的数据结构：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; myData = eval(&lt;span style="color: #a31515"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; + myJSONText + &lt;span style="color: #a31515"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在JavaScript的语法中，表达式语句（Expression Statement）不允许以左花括号“{”开始，因为那会与块语句（Block Statements）产生混淆，所以在使用eval()解析JSON文本时，为了解决此问题，可以将JSON文本套上一对圆括号。圆括号早此处作为表达式的分组运算符，能对包围在其中的表达式进行求值。&lt;/p&gt;
&lt;p&gt;但使用eval来解析JSON文本可能会存在安全问题，所以应该使用JSON.parse方法来替代eval。如果文本中包含任何危险数据，JSON.parse将会抛出一个异常。&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category><category term="JavaScript"></category></entry><entry><title>JavaScript初学者应知的24条最佳实践（译）</title><link href="http://youngsterxyf.github.io/2013/03/11/js-best-practices-for-beginners/" rel="alternate"></link><published>2013-03-11T00:00:00+08:00</published><updated>2013-03-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-11:/2013/03/11/js-best-practices-for-beginners/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://net.tutsplus.com/tutorials/javascript-ajax/24-javascript-best-practices-for-beginners/"&gt;24 JavaScript Best Practices for Beginners&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（注：阅读原文的时候没有注意发布日期，觉得不错就翻译了，翻译到JSON.parse那一节觉得有点不对路才发现是2009年发布的文章，不过还是不错的啦。另外 …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://net.tutsplus.com/tutorials/javascript-ajax/24-javascript-best-practices-for-beginners/"&gt;24 JavaScript Best Practices for Beginners&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（注：阅读原文的时候没有注意发布日期，觉得不错就翻译了，翻译到JSON.parse那一节觉得有点不对路才发现是2009年发布的文章，不过还是不错的啦。另外，文章虽说24条最佳实践，其实只有23条，不知道原作者怎么漏了一条。）&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1.优先使用===，而不是==&lt;/h3&gt;
&lt;p&gt;JavaScript使用两种相等性操作符：===|!==和==|!=。通常认为做比较的最佳实践是使用前一组操作符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"若两个操作数的类型和值相同，那么===比较的结果为真，!==比较的结果为假。" --- JavaScript语言精粹(JavaScript: The Good Parts)
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，如果使用==和!=，当比较不同类型的操作数时，你就会碰到问题啦。在这种情况下，这组操作符会尝试对操作数的值做无用的强制转换。&lt;/p&gt;
&lt;h3&gt;2.Eval就是糟糕的代名词&lt;/h3&gt;
&lt;p&gt;对于那些不熟悉JavaScript的人来说，函数"evel"让我们能够访问JavaScript编译器。我们可以通过给"eval"传递一个字符串参数来得到该字符串执行的结果。&lt;/p&gt;
&lt;p&gt;这不仅会极大地降低你的脚本的性能，也会造成一个巨大的安全隐患，因为这赋予传递进来的纯文本太多的能力。要尽可能地避免eval函数的使用。&lt;/p&gt;
&lt;h3&gt;3.不要懒手&lt;/h3&gt;
&lt;p&gt;技术上来说，你确实可能侥幸地省略多数花括号和分号。大多数浏览器都能够正确地解释如下代码片段：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(someVariableExists)
    x = &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然而，再考虑一下这段代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(someVariableExists)
    x = &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;
    anotherFunctionCall();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可能会有人认为上一段代码等价于：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(someVariableExists) {
    x = &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;;
    anotherFunctionCall();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很不幸，他错了。事实上，它的本意是：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(someVariableExists)
    x = &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;;
anotherFunctionCall();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你应该也注意到了，代码中缩进模仿了花括号的功能。毋庸置疑，这是非常恐怖的做法，无论如何都应该避免。唯一可以省略花括号的时候是在一行式的语句中，但即使这种情况，也是很有争议的。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(2 + 2 === 4) &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;nicely done&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;始终要想着以后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果以后的某个时候，你需要在这种if语句中增加更多的命令，那该怎么办呢？没法子，你就只能重写这块代码了。处理这个问题的底线是对于省略写法保持谨慎。&lt;/p&gt;
&lt;h3&gt;4.使用JS Lint&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.jslint.com/"&gt;JSLint&lt;/a&gt;是Douglas Crockford编写的一个调试器。简单地将你的脚本拷贝进去，它就会快速地扫描你的代码中任何明显的问题和错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"JSLint获取一份JavaScript源码，然后扫描代码。如果发现问题，就会返回一条信息描述这个问题以及这个问题在源码中的大致位置。问题虽然经常是语法错误，却不一定是。JSLint也会查看一些风格习惯以及结构问题。它并不证明你的代码是否正确，只是提供另外的一双眼睛来帮助发现问题。"---JSLint文档
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在结束脚本代码的编写之前，对其执行一次JSLint，能够保证你不会犯一些愚蠢的错误。&lt;/p&gt;
&lt;h3&gt;5.将脚本置于页面的底部&lt;/h3&gt;
&lt;p&gt;这条技巧在本系列前面的文章中也推荐过。因为它在此处也非常合适（As it's highly appropriate though），所有我将那段信息直接粘贴在这里。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/javascriptButton.png" alt="javascriptButton.png"&gt;&lt;/p&gt;
&lt;p&gt;记住---这条最佳实践的主要目标是尽可能快速地为用户加载页面。当加载一个脚本时，浏览器直到整个脚本文件全部加载完毕才能继续。因此，用户必须等上更长的时间才能注意到任何的进度。&lt;/p&gt;
&lt;p&gt;如果JS文件的目的仅仅是增加功能---例如，在点击某个按钮后---那么就将那些文件放在底部，body结束标签之前吧。这绝对是一个最佳实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;p&amp;gt;And now you know my favorite kinds of corn. &amp;lt;/p&amp;gt;
&amp;lt;script type=&lt;span style="color: #a31515"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; src=&lt;span style="color: #a31515"&gt;&amp;quot;path/to/file.js&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&lt;span style="color: #a31515"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; src=&lt;span style="color: #a31515"&gt;&amp;quot;path/to/anotherFile.js&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6.在For语句之外声明变量&lt;/h3&gt;
&lt;p&gt;当执行一个冗长的"for"语句之时，仅仅让解释引擎做必须干的活吧。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;糟糕的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; i = 0; i &amp;lt; someArray.length; i++) {
    &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; container = document.getElementById(&lt;span style="color: #a31515"&gt;&amp;#39;container&amp;#39;&lt;/span&gt;);
    container.innerHtml += &lt;span style="color: #a31515"&gt;&amp;#39;my number: &amp;#39;&lt;/span&gt; + i;
    console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意上面代码片段中的每次迭代都需要检查数组的长度，并且每次都要遍历DOM树找到"container"元素---效率多低啊！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; container = document.getElementById(&lt;span style="color: #a31515"&gt;&amp;#39;container&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; i = 0, len = someArray.length; i &amp;lt; len; i++) {
    container.innerHtml += &lt;span style="color: #a31515"&gt;&amp;#39;my number: &amp;#39;&lt;/span&gt; + i;
    console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;感谢有位朋友留下评论展示如何进一步优化上面的代码块。&lt;/p&gt;
&lt;h3&gt;7.构建字符串的最快方式&lt;/h3&gt;
&lt;p&gt;当需要遍历一个数组或者对象之时，不要总是使用你能信手粘来的"for"语句。创造性地找个能够完成工作的最快速的方案。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; arr = [&lt;span style="color: #a31515"&gt;&amp;#39;item 1&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;item 2&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;item 3&amp;#39;&lt;/span&gt;, ...];
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; list = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&amp;#39;&lt;/span&gt; + arr.join(&lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;&amp;#39;&lt;/span&gt;) + &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;"我不会以测试基准来烦你；你只须相信我（或者自己去测试一下）---这是目前为止最快的方式！"&lt;/p&gt;
&lt;p&gt;使用原生方法（比如join()），不用管抽象层面背后发生了什么，通常会比任何非原生方法快得多。 --- James Padolsey, james.padolsey.com"
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;8.减少全局变量&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;"通过将全局的东西封装进单个命名空间，能够大大降低与其他应用、部件、代码库交互混乱的概率。"--- Douglas Crockford
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; name = &lt;span style="color: #a31515"&gt;&amp;#39;jeffrey&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; lastname = &lt;span style="color: #a31515"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;;

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; doSomething() {...}

console.log(name);      &lt;span style="color: #008000"&gt;// Jeffrey -- or window.name&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;更好的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; DudeNameSpace = {
    name: &lt;span style="color: #a31515"&gt;&amp;#39;Jeffrey&amp;#39;&lt;/span&gt;,
    lastname: &lt;span style="color: #a31515"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;,
    doSometing: &lt;span style="color: #0000ff"&gt;function&lt;/span&gt;() {...}
}
console.log(DudeNameSpace.name);    &lt;span style="color: #008000"&gt;// Jeffrey&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意我们是怎样将全局性的“足迹”减少为一个命名可笑的"DudeNameSpace"对象的。&lt;/p&gt;
&lt;h3&gt;9.注释你的代码&lt;/h3&gt;
&lt;p&gt;一开始看起来似乎没有必要，但请相信我，你将会想尽可能好地注释你的代码。当你几个月后再次回到项目，会发生什么呢？发现你根本没法轻松地记起当初对每一行代码的想法。或者，如果你的某个同事需要修改你的代码，那又会怎么样呢？始终，一直记着注释你代码的重要部分吧。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// Cycle through array and echo out each name&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; i = 0, len = array.length; i &amp;lt; len; i++) {
    console.log(array[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;10.拥抱渐进增强&lt;/h3&gt;
&lt;p&gt;始终考虑到如何处理JavaScript禁用的情况。也许你会想“大多数我网页的阅读器都是启用JavaScript的，因此我不担心这个问题。”然而，这会是一个巨大的错误。&lt;/p&gt;
&lt;p&gt;你曾花时间去看过关闭JavaScript后你的漂亮的滑动条是什么样么？（&lt;a href="https://addons.mozilla.org/en-US/firefox/addon/web-developer/"&gt;下载&lt;/a&gt;Web开发者工具栏以方便干这事。）也许它会完全破坏你的站点。按照以往经验，设计你的站点时应假设将会禁用JavaScript。那么，一旦你这样做了，那么开始渐进地增强你的网页布局吧！&lt;/p&gt;
&lt;h3&gt;11.不要传递字符串给"SetInterval"或"SetTimeOut"&lt;/h3&gt;
&lt;p&gt;考虑一下如下代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;setInterval(
&lt;span style="color: #a31515"&gt;&amp;quot;document.getElementById(&amp;#39;container&amp;#39;).innerHTML += &amp;#39;my new number: &amp;#39; + i&amp;quot;&lt;/span&gt;, 3000
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码不仅低效，而且其行为与"eval"函数相同。永远不要传给字符串给SetInterval和SetTimeOut。相反，应传递一个函数名。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;setInterval(someFunction, 3000);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;12.不要使用"With"语句&lt;/h3&gt;
&lt;p&gt;乍一看，"With"语句似乎是个聪明的想法。基本概念是它们能够为访问深度嵌套对象提供一种简写方式。例如...&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;with&lt;/span&gt; (being.person.man.bodyparts) {
    arms = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
    legs = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;取代如下写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;being.person.man.bodyparts.arms = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
being.person.man.bodyparts.legs = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很不幸，经过一些测试，会发现这种简写在设置新成员时表现非常糟糕。作为替代，你应该使用var。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o = being.person.man.bodyparts;
o.arms = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
o.legs = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;13.使用{}而不是New Object()&lt;/h3&gt;
&lt;p&gt;JavaScript中有多种创建对象的方式。也许更传统的方式是使用"new"构造器，像这样：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Object();
o.name = &lt;span style="color: #a31515"&gt;&amp;#39;Jeffrey&amp;#39;&lt;/span&gt;;
o.lastname = &lt;span style="color: #a31515"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;;
o.someFuncion = &lt;span style="color: #0000ff"&gt;function&lt;/span&gt;() {
    console.log(&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然而，这种方式因其行为并不是我们所想的那样而被认为是“糟糕的实践。相反，我推荐你使用更健壮的对象字面方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o = {
    name: &lt;span style="color: #a31515"&gt;&amp;#39;Jeffrey&amp;#39;&lt;/span&gt;,
    lastName: &lt;span style="color: #a31515"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;,
    someFunction: &lt;span style="color: #0000ff"&gt;function&lt;/span&gt;() {
        console.log(&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.name);
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意如果你只是想简单地创建个空对象，{}就派上用场了。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o = {};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;"对象字面量使我们能够编写支持很多特性的代码，并对代码的实现者来说代码仍然相对直观。不需要直接调用构造器或维护传递给函数的参数的正确顺序，等等。" --- dyn-web.com
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;14.使用[]而不是New Array()&lt;/h3&gt;
&lt;p&gt;这同样适用于创建一个新数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过得去的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; a = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Array();
a[0] = &lt;span style="color: #a31515"&gt;&amp;#39;Joe&amp;#39;&lt;/span&gt;;
a[1] = &lt;span style="color: #a31515"&gt;&amp;#39;Plumber&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; a = [&lt;span style="color: #a31515"&gt;&amp;#39;Joe&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;Plumber&amp;#39;&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;"JavaScript中一个常见的错误是需要数组时使用对象或需要对象时使用数组。规则很简单：当属性名是小的连续整数时，你应该使用数组。否则，使用对象"---Douglas Crockford
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;15.一长串变量？省略"var"关键字，使用逗号替代&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; someItem = &lt;span style="color: #a31515"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; anotherItem = &lt;span style="color: #a31515"&gt;&amp;#39;another string&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; oneMoreItem = &lt;span style="color: #a31515"&gt;&amp;#39;one more string&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; someItem = &lt;span style="color: #a31515"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;,
    anotherItem = &lt;span style="color: #a31515"&gt;&amp;#39;another string&amp;#39;&lt;/span&gt;,
    oneMoreItem = &lt;span style="color: #a31515"&gt;&amp;#39;one more string&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;相当的不言自明。我不知道这里是否有任何真正的速度提升，但是它使你的代码更加简洁了。&lt;/p&gt;
&lt;h3&gt;16.始终，始终使用分号&lt;/h3&gt;
&lt;p&gt;技术上来说，大多数浏览器都允许你的省略一些分号。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; someItem = &lt;span style="color: #a31515"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; doSomething() {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;something&amp;#39;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;话虽如此，但这是一种非常糟糕的做法，可能导致更大的问题，问题查找起来也更困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; someItem = &lt;span style="color: #a31515"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; doSomething() {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;something&amp;#39;&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;18."For in"语句&lt;/h3&gt;
&lt;p&gt;遍历对象内的成员时，你也会得到方法函数。为了解决这个问题，应始终将你的代码包装在一个if语句中来过滤信息。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(key &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; object) {
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(object.hasOwnProperty(key)) {
        ... then &lt;span style="color: #0000ff"&gt;do&lt;/span&gt; something...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;引自&lt;em&gt;JavaScript: 语言精粹， Douglas Crockford著&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;19.使用Firebug的"Timer"特性来优化代码&lt;/h3&gt;
&lt;p&gt;需要一种快速简单的方法来检测一个操作花费多长时间么？使用Firebug的"timer"特性记录结果。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; TimeTracker() {
    console.time(&lt;span style="color: #a31515"&gt;&amp;quot;MyTimer&amp;quot;&lt;/span&gt;);
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(x=5000; x &amp;gt; 0; x--){}
    console.timeEnd(&lt;span style="color: #a31515"&gt;&amp;quot;MyTimer&amp;quot;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;20.阅读，阅读，再阅读&lt;/h3&gt;
&lt;p&gt;我是一个Web开发博客的超级粉丝（比如这个博客！），但吃午餐或者睡前，博客确实不是书籍的替代品。始终在你的床前桌上放一本wen开发书籍吧。如下是一些我最喜欢的JavaScript书籍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.packtpub.com/object-oriented-javascript-applications-libraries/book"&gt;面向对象的JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://oreilly.com/catalog/9780596517748/"&gt;JavaScript：语言精粹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.packtpub.com/learning-jquery-1.3/book"&gt;学习jQuery 1.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://oreilly.com/catalog/9780596527464/"&gt;学习JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多阅读几遍。我仍旧在读！&lt;/p&gt;
&lt;h3&gt;21.自执行函数(Self-Executing Functions)&lt;/h3&gt;
&lt;p&gt;相比调用函数，当页面加载或调用父函数时，让函数自动执行会简单些。简单地将你的函数包装在圆括号内，并添加额外的一对圆括号，其本质上就调用了这个函数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; doSomething() {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; {
        name: &lt;span style="color: #a31515"&gt;&amp;#39;jeff&amp;#39;&lt;/span&gt;,
        lastName: &lt;span style="color: #a31515"&gt;&amp;#39;way&amp;#39;&lt;/span&gt;
    };
 })();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;22.原始(raw)JavaScript代码的执行速度始终快于使用代码库&lt;/h3&gt;
&lt;p&gt;JavaScript代码库，如jQuery和Mootools，能够为你节省大量的编码时间---特别是使用AJAX操作。话虽如此，始终谨记代码库的执行速度始终是比不上原始JavaScript代码的（假设了代码的正确性）。&lt;/p&gt;
&lt;p&gt;jQuery的"each"方法用来做遍历非常赞，但使用原生"for"语句始终会快一些。&lt;/p&gt;
&lt;h3&gt;23.Crockford的JSON.Parse&lt;/h3&gt;
&lt;p&gt;虽然JavaScript 2应该有一个内置的JSON解析器，但写本文之时，我们仍旧需要自己实现。Douglas Crockford，JSON的创造者，已经实现了一个解析器供你使用。可以从&lt;a href="https://github.com/douglascrockford/JSON-js"&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;简单地导入该脚本，你就能获得一个新的JSON全局对象，用于解析你的.json文件。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; response = JSON.parse(xhr.responseText);

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; container = document.getElementById(&lt;span style="color: #a31515"&gt;&amp;#39;container&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; i = 0, len = response.length; i &amp;lt; len; i++) {
    container.innerHTML += &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;li&amp;gt;&amp;#39;&lt;/span&gt; + response[i].name + &lt;span style="color: #a31515"&gt;&amp;#39; : &amp;#39;&lt;/span&gt; + response[i].email + &lt;span style="color: #a31515"&gt;&amp;#39;&amp;lt;/li&amp;gt;&amp;#39;&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;24.删除"Language"&lt;/h3&gt;
&lt;p&gt;几年前，在script标签内常见有"language"属性。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;script type=&lt;span style="color: #a31515"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; language=&lt;span style="color: #a31515"&gt;&amp;quot;javascript&amp;quot;&lt;/span&gt;&amp;gt;
...
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然而，这个属性很早就被弃用了，所以就不要再使用了。&lt;/p&gt;
&lt;h3&gt;就这些了，同志们&lt;/h3&gt;
&lt;p&gt;现在你知道这JavaScript初学者应该知道的24条基本技巧。有机会也让我知道一下你的小贴士吧。感谢阅读。&lt;/p&gt;</content><category term="其他"></category><category term="JavaScript"></category><category term="翻译"></category></entry><entry><title>电脑重装记</title><link href="http://youngsterxyf.github.io/2013/03/09/reinstall-my-computer/" rel="alternate"></link><published>2013-03-09T00:00:00+08:00</published><updated>2013-03-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-09:/2013/03/09/reinstall-my-computer/</id><summary type="html">&lt;p&gt;一台电脑使用时间长了，速度就会越来越慢，也会越来越“脏”，因为经过时间的积累，电脑里多了很多的软件、文件等，这些文件 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;一台电脑使用时间长了，速度就会越来越慢，也会越来越“脏”，因为经过时间的积累，电脑里多了很多的软件、文件等，这些文件和软件中很多以后是不需要的，在当时因为各种原因而下载或安装了，那么我们就会经常去清理，但对于有点洁癖的人来说，这是不够的，所以会过段时间后就会选择重装电脑，一切重新开始。当然一般都是等到无法忍受的时候，不得已而为之，为什么呢？因为电脑重装后，要想重新打造成一个令自己满意的使用环境需要花一些时间和精力，所以破旧立新也是需要勇气的。&lt;/p&gt;
&lt;p&gt;我笔记本的操作系统是Ubuntu+KDE，从安装使用到现在将近一年了，期间经过7个月的实习，所以将笔记本打造成一个开发环境和测试服务器，Nginx+PHP+Mysql+Memcached啥的都安装全了，还有其他的一些软件都不知道安装了些什么。另外，由于做兴趣项目，我主要选择Python进行开发，对于Python第三方库主要有两种安装方式：一种是使用操作系统本身的软件包管理工具，Ubuntu下即为apt-get；另一种是使用Python的包管理工具，如easy_install，pip。通过这两种方式我的系统里安装了很多大大小小的Python第三方库，也懒得去整理了，所以干脆重装，原来实习时使用的那一套开发环境和测试服务器之后也不一定用得到，并且决定之后所有的Python第三方库全部在virtualenv下安装，保持系统干净。&lt;/p&gt;
&lt;p&gt;那么仍旧装Ubuntu呢还是装其它的Linux发行版呢？如ArchLinux、Gentoo Linux。我想这应该看需求，如果你是想折腾系统或不断尝试最新的软件包的话，那当然首选Gentoo，或Archlinux。但因为我只是希望有个稳定的开发环境和使用环境，不想太多折腾，所以决定还是选择Kubuntu。&lt;/p&gt;
&lt;p&gt;重装电脑也是个繁琐的过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先需要制作安装盘，由于刻录CD/DVD啥的太麻烦，所以我一般使用&lt;a href="http://unetbootin.sourceforge.net/"&gt;UNetbootin&lt;/a&gt;制作U盘安装盘，方便得多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后就是保存各种数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器书签、扩展程序---可使用浏览器的同步功能；&lt;/li&gt;
&lt;li&gt;记录原来系统中安装的软件列表---对于Debian系的Linux，可以使用命令&lt;code&gt;dpkg --get-selections | awk '{print $1}' &amp;gt; software_list.txt&lt;/code&gt;来得到；&lt;/li&gt;
&lt;li&gt;除了使用系统软件包管理工具安装的软件，可能你还手动编译过软件或下载使用免安装的软件，如果以后会用到的话也可以一并保存；&lt;/li&gt;
&lt;li&gt;各种软件的配置文件，比如.vimrc，.bashrc，Nginx配置文件等，我是将这些配置文件像代码一样使用版本控制存放在Github上的；&lt;/li&gt;
&lt;li&gt;系统环境的各种字体配置，比如vim我使用YaHei Manaco字体，命令行终端使用Source Code Pro字体，其它的主要使用Lucida Sans Unicode字体、WenQuanYi Micro Hei、WenQuanYi Zen Hei和YaHei Consolas Hybrid字体；&lt;/li&gt;
&lt;li&gt;最后最重要的就是各种文档音频视频数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;备份好各种数据后，就可以重装了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但最耗时间的是怎么把一个刚重装好的系统重新打造成一个自己满意的使用环境，因为如果当初安装某些软件时候没做笔记而又忘了怎么折腾的话，你就又得重新查资料寻找安装方法了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述文字记录了我重装电脑之前的一些想法，以及给自己提个醒---不要忘记备份各种数据。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;安装完成后，遇到如下几个问题：&lt;/p&gt;
&lt;p&gt;1.
中文显示不太正常，使用命令&lt;code&gt;apt-cache search wenquanyi&lt;/code&gt;，找出所有文泉驿开源字体，安装即可。&lt;/p&gt;
&lt;p&gt;2.
&lt;code&gt;pip install gevent&lt;/code&gt;安装gevent，没法正常编译，只好使用&lt;code&gt;sudo apt-get install python-gevent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;em&gt;2013-03-17补&lt;/em&gt;：先&lt;code&gt;sudo apt-get install libevent-dev&lt;/code&gt;安装libevent-dev就可以正常编译了）&lt;/p&gt;
&lt;p&gt;3.
&lt;a href="https://github.com/milkbikis/powerline-shell"&gt;powerline-shell&lt;/a&gt;中的特殊字体在终端中没法正常显示，按照文档说明使用工具&lt;a href="https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher"&gt;fontpatcher&lt;/a&gt;来生成适用于powerline-shell的字体。可fontpatcher依赖于fontforge，&lt;code&gt;pip install fontforge&lt;/code&gt;却说找不到fontforge，好吧，还是&lt;code&gt;sudo apt-get install python-fontforge&lt;/code&gt;安装。然后按照普通字体的安装方式安装即可。&lt;/p&gt;
&lt;p&gt;4.
KDE的Nepomuk Semantic Desktop功能耗资源比较厉害，在System Settings -&amp;gt; Desktop Search关闭这项功能。&lt;/p&gt;
&lt;p&gt;5.
添加fcitx输入法开机自启动：&lt;code&gt;cd ~/.kde/Autostart; ln -s /usr/bin/fcitx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后附上一张重装后的桌面截图：&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/print-scr.png" alt="print-scr.png"&gt;&lt;/p&gt;</content><category term="其他"></category><category term="笔记"></category></entry><entry><title>PHP之道---PHP基础知识（译）</title><link href="http://youngsterxyf.github.io/2013/03/08/php-basics/" rel="alternate"></link><published>2013-03-08T00:00:00+08:00</published><updated>2013-03-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-08:/2013/03/08/php-basics/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://wulijun.github.com/php-the-right-way/pages/The-Basics.html"&gt;PHP: The Right Way - The Basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="http://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;比较操作符&lt;/h2&gt;
&lt;p&gt;比较操作符往往是PHP的一个被忽视的方面，这会导致很多意想不到的结果。其中的一个问题源于严格比 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://wulijun.github.com/php-the-right-way/pages/The-Basics.html"&gt;PHP: The Right Way - The Basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="http://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;比较操作符&lt;/h2&gt;
&lt;p&gt;比较操作符往往是PHP的一个被忽视的方面，这会导致很多意想不到的结果。其中的一个问题源于严格比较（布尔值为整数的比较）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$a = 5;     &lt;span style="color: #008000"&gt;// 5为一个整数&lt;/span&gt;

var_dump($a == 5);      &lt;span style="color: #008000"&gt;// 比较值；返回true&lt;/span&gt;
var_dump($a == &lt;span style="color: #a31515"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;);        &lt;span style="color: #008000"&gt;// 比较值（忽略类型）；返回true&lt;/span&gt;
var_dump($a === 5);         &lt;span style="color: #008000"&gt;// 比较类型/值（整数 vs. 整数）；返回true&lt;/span&gt;
var_dump($a === &lt;span style="color: #a31515"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;);       &lt;span style="color: #008000"&gt;// 比较类型/值（整数 vs. 整数）；返回false&lt;/span&gt;

&lt;span style="color: #a31515"&gt;/**&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * 严格比较&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  */&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (strpos(&lt;span style="color: #a31515"&gt;&amp;#39;testing&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;)) {    &lt;span style="color: #008000"&gt;// 在位置0找到&amp;#39;test&amp;#39;，0被解释为布尔值&amp;#39;false&amp;#39;&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// code...&lt;/span&gt;
}

vs.

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (strpos(&lt;span style="color: #a31515"&gt;&amp;#39;testing&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;) !== &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;) {  &lt;span style="color: #008000"&gt;// true，因为做了严格比较（0 !== false）&lt;/span&gt;
    &lt;span style="color: #008000"&gt;// code...&lt;/span&gt;
}
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;比较操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/types.comparisons.php"&gt;比较列表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;条件语句&lt;/h2&gt;
&lt;h3&gt;If语句&lt;/h3&gt;
&lt;p&gt;在函数或类中使用'if/else'之时，有个常见的误解---'else'必须一起使用以声明潜在的结果。然而，如果，结果是定义返回值，则'else'是不需要的，因为'return'会结束函数，使得'else'变得毫无意义。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; test($a)
{
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($a) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
    } &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;;
    }
}

vs.

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; test($a)
{
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($a) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;;       &lt;span style="color: #008000"&gt;// 不需要else分支&lt;/span&gt;
}
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/control-structures.if.php"&gt;If语句&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Switch语句&lt;/h3&gt;
&lt;p&gt;Switch语句是一种避免输入无穷尽的if和elseif的绝妙方式，但需要注意几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Switch语句仅比较值，并不关心类型（等价于'=='）&lt;/li&gt;
&lt;li&gt;逐个分支地迭代直到找到一个匹配项。如果没找到匹配项，则使用缺省(default)分支（如果定义了）&lt;/li&gt;
&lt;li&gt;若匹配项的代码体没有'break'语句，则会继续执行接下来的每个分支，直到遇到一个break/return语句&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在函数内，使用'return'可以减少'break'的使用，因为'return'能够结束函数&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$answer = test(2);      &lt;span style="color: #008000"&gt;// &amp;#39;case 2&amp;#39;和&amp;#39;case3&amp;#39;的代码体会得到执行&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; test($a)
{
    &lt;span style="color: #0000ff"&gt;switch&lt;/span&gt; ($a) {
        &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; 1:
            &lt;span style="color: #008000"&gt;// code...&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;      &lt;span style="color: #008000"&gt;// break用于结束switch语句&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; 2:
            &lt;span style="color: #008000"&gt;// code...  // 没有break，继续比较&amp;#39;case 3&amp;#39;&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;case&lt;/span&gt; 3:
            &lt;span style="color: #008000"&gt;// code...&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; $result;     &lt;span style="color: #008000"&gt;// 当前位置在函数内，&amp;#39;return&amp;#39;会结束函数&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;default&lt;/span&gt;:
            &lt;span style="color: #008000"&gt;// code...&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; $error;
    }
}
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/control-structures.switch.php"&gt;Switch语句&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://phpswitch.com/"&gt;PHP switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全局命名空间&lt;/h2&gt;
&lt;p&gt;使用命名空间之时，你可能发现内置函数被你所写的函数覆盖了。推荐在全局函数的函数名之前添加一个反斜杠来修正这个问题。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;namespace&lt;/span&gt; phptherightway;

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; fopen()
{
    $file = \fopen();       &lt;span style="color: #008000"&gt;// 我们的函数名与内部函数的函数名相同。&lt;/span&gt;
                            &lt;span style="color: #008000"&gt;// 通过添加&amp;#39;\&amp;#39;指定从全局命名空间执行函数&lt;/span&gt;
}

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; array()
{
    $iterator = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; \ArrayIterator();       &lt;span style="color: #008000"&gt;// ArrayIterator是一个内置类。&lt;/span&gt;
                                            &lt;span style="color: #008000"&gt;// 若类名之前没有一个反斜杠，解释器会试图在你的命名空间中解析它&lt;/span&gt;
}
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.namespaces.global.php"&gt;全局命名空间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/userlandnaming.rules.php"&gt;全局规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;字符串&lt;/h2&gt;
&lt;h3&gt;拼接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果代码行超过了推荐的行长度（120个字符），那么应该考虑拼接代码行&lt;/li&gt;
&lt;li&gt;为了便于阅读，最好使用拼接操作符而不是拼接赋值操作符&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在变量原本的命名空间内，当拼接使用了新行，则应该缩进&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$a = &lt;span style="color: #a31515"&gt;&amp;#39;Multi-line example&amp;#39;&lt;/span&gt;;      &lt;span style="color: #008000"&gt;// 拼接赋值操作符(.=)&lt;/span&gt;
$a .= &lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;
$a .= &lt;span style="color: #a31515"&gt;&amp;#39;of what not to do&amp;#39;&lt;/span&gt;;

vs.

$a = &lt;span style="color: #a31515"&gt;&amp;#39;Multi-line example&amp;#39;&lt;/span&gt;       &lt;span style="color: #008000"&gt;// 拼接操作符(.)&lt;/span&gt;
    . &lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;                      &lt;span style="color: #008000"&gt;// 缩进新行&lt;/span&gt;
    . &lt;span style="color: #a31515"&gt;&amp;#39;of what to do&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/language.operators.string.php"&gt;字符串操作符&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;字符串类型&lt;/h3&gt;
&lt;p&gt;字符串类型在PHP社区内是个不变的特性，但希望本节内容能够解释清楚字符串类型之间的区别以及各自的好处/用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单引号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单引号是创建字符串最简单的方式，并且通常执行速度也是最快的，因为PHP不会解析这种字符串（不解析其中是否存在变量），所以单引号最适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要解析的字符串&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将变量写为纯文本值（Writing of a variable into plain text）&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;This is my string, look at how pretty it is.&amp;#39;&lt;/span&gt;;        &lt;span style="color: #008000"&gt;//不需要解析一个简单的字符串&lt;/span&gt;

&lt;span style="color: #a31515"&gt;/**&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * 输出:&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  *&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * This is my string, look at how pretty it is.&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  */&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.single"&gt;单引号&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双引号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双引号是字符串处理的瑞士军刀，但执行速度比较慢，因为字符串要经过解析。双引号最适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转义字符串&lt;/li&gt;
&lt;li&gt;内含多个变量和纯文本的字符串&lt;/li&gt;
&lt;li&gt;压缩多行拼接，提高可读性&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;phptherightway is &amp;#39;&lt;/span&gt; . $adjective . &lt;span style="color: #a31515"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;    &lt;span style="color: #008000"&gt;// 一个单引号的使用示例，&lt;/span&gt;
    . &lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;                                      &lt;span style="color: #008000"&gt;// 为变量和转义字符串使用了多行拼接&lt;/span&gt;
    . &lt;span style="color: #a31515"&gt;&amp;#39;I love learning &amp;#39;&lt;/span&gt; . $code . &lt;span style="color: #a31515"&gt;&amp;#39;!&amp;#39;&lt;/span&gt;;

vs.

&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;phptherightway is $adjective.\n I love learning $code!&amp;quot;&lt;/span&gt;;      &lt;span style="color: #008000"&gt;// 没有使用多行拼接，&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;                                                                  // 双引号允许我们使用可解析的字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用双引号创建的字符串中包含变量时，经常出现变量名与后面另一个字符相接触的情况，从而导致PHP不解析该变量，因为它被"伪装"起来了。为了解决这个问题，可以使用一对大括号把变量包围起来。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$juice = &lt;span style="color: #a31515"&gt;&amp;#39;plum&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;I drank some juice made of $juices&amp;quot;&lt;/span&gt;;      &lt;span style="color: #008000"&gt;// $juice得不到解析&lt;/span&gt;

vs.

$juice = &lt;span style="color: #a31515"&gt;&amp;#39;plum&amp;#39;&lt;/span&gt;;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;I drank some juice made of{&lt;/span&gt;$juice&lt;span style="color: #a31515"&gt;}s&amp;quot;&lt;/span&gt;;     &lt;span style="color: #008000"&gt;// $juice得到解析&lt;/span&gt;

&lt;span style="color: #a31515"&gt;/**&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * 大括号内的复杂变量也能得到解析&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  */&lt;/span&gt;

$juice = &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;orange&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;plum&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;I drank some juice made of {&lt;/span&gt;$juice[1]&lt;span style="color: #a31515"&gt;}s&amp;quot;&lt;/span&gt;;     &lt;span style="color: #008000"&gt;// $juice[1]将得到解析&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.double"&gt;双引号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Nowdoc语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PHP 5.3引入了Nowdoc语法，其行为与单引号相同，除了她适用于多行字符串的使用，而不需要拼接。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$str = &amp;lt;&amp;lt;&amp;lt;&lt;span style="color: #a31515"&gt;&amp;#39;EOD&amp;#39;&lt;/span&gt;         &lt;span style="color: #008000"&gt;// 通过&amp;lt;&amp;lt;&amp;lt;初始化&lt;/span&gt;
Example of string
spanning multiple lines
using nowdoc syntax.
$a does &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; parse.
EOD;                    &lt;span style="color: #008000"&gt;// &amp;#39;EOD&amp;#39;关闭符必须单独一行，并且处于最左边&lt;/span&gt;

&lt;span style="color: #a31515"&gt;/**&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * 输出:&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * &lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * Example of string&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * spanning multiple lines&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * using nowdoc syntax.&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * $a does not parse.&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  */&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.nowdoc"&gt;Nowdoc语法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Heredoc语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Heredoc语法的行为与双引号相同，除了它适用于多行字符串的使用，而不需要拼接。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$a = &lt;span style="color: #a31515"&gt;&amp;#39;Variables&amp;#39;&lt;/span&gt;;

$str = &amp;lt;&amp;lt;&amp;lt;EOD       &lt;span style="color: #008000"&gt;// 使用&amp;lt;&amp;lt;&amp;lt;初始化&lt;/span&gt;
Example of string
spanning multiple lines
using heredoc syntax.
$a are parsed.
EOD;                    &lt;span style="color: #008000"&gt;// &amp;#39;EOD&amp;#39;关闭符必须单独一行，且处于最左边位置&lt;/span&gt;

&lt;span style="color: #a31515"&gt;/**&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * 输出：&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  *&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * Example of string&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * spanning multiple lines&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * using heredoc syntax.&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * Variables are parsed.&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  */&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc"&gt;Heredoc语法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;三元操作符&lt;/h2&gt;
&lt;p&gt;三元操作符是一种压缩代码的好方式，但经常被滥用。当需要多层或嵌套使用三元操作符时，建议一行代码仅使用一次三元操作符以提高代码可读性。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$a = 5;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; ($a == 5) ? &lt;span style="color: #a31515"&gt;&amp;#39;yay&amp;#39;&lt;/span&gt; : &lt;span style="color: #a31515"&gt;&amp;#39;nay&amp;#39;&lt;/span&gt;;

vs.

&lt;span style="color: #008000"&gt;// 嵌套三元操作符&lt;/span&gt;
$b = 10;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; ($a) ? ($a == 5) ? &lt;span style="color: #a31515"&gt;&amp;#39;yay&amp;#39;&lt;/span&gt; : &lt;span style="color: #a31515"&gt;&amp;#39;nay&amp;#39;&lt;/span&gt; : ($b == 10) ? &lt;span style="color: #a31515"&gt;&amp;#39;excessive&amp;#39;&lt;/span&gt; : &lt;span style="color: #a31515"&gt;&amp;#39;:(&amp;#39;&lt;/span&gt;;    &lt;span style="color: #008000"&gt;// 过度嵌套，牺牲了可读性&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用三元操作符'返回'一个值需使用正确的语法。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$a = 5;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; ($a == 5) ? &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;true&lt;/span&gt; : &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;;        &lt;span style="color: #008000"&gt;// 这个例子会抛出错误&lt;/span&gt;

vs.

$a = 5;
&lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ($a == 5) ? &lt;span style="color: #a31515"&gt;&amp;#39;yay&amp;#39;&lt;/span&gt; : &lt;span style="color: #a31515"&gt;&amp;#39;nope&amp;#39;&lt;/span&gt;;          &lt;span style="color: #008000"&gt;// 这个例子会返回&amp;#39;yay&amp;#39;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;三元操作符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;变量声明&lt;/h2&gt;
&lt;p&gt;有时，程序员会试图通过将预定义变量声明为一个不同的名字使得代码更加"干净"。事实上，这样会让脚本的内存消耗加倍。如下例子，我们假设一个示例文本字符串包含1MB的数据，通过拷贝这个变量，脚本执行时就会增加到2MB。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$about = &lt;span style="color: #a31515"&gt;&amp;#39;A very long string of text&amp;#39;&lt;/span&gt;;      &lt;span style="color: #008000"&gt;// 使用了2MB内存&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; $about;

vs.

&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;A very long string of text&amp;#39;&lt;/span&gt;;          &lt;span style="color: #008000"&gt;// 仅使用1MB内存&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/speed/articles/optimizing-php"&gt;性能技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="PHP"></category><category term="翻译"></category></entry><entry><title>数据压缩理论简介（译）</title><link href="http://youngsterxyf.github.io/2013/02/27/A-introduction-to-compression/" rel="alternate"></link><published>2013-02-27T00:00:00+08:00</published><updated>2013-02-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-02-27:/2013/02/27/A-introduction-to-compression/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://imrannazar.com/An-Introduction-to-Compression"&gt;A introduction to compression&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近我在思考GIF和JPEG图片格式之间的不同：为什么某些图片存储为GIF格式所占的磁盘空间更大，而另一些图片以JPEG格式存储要占用更大的磁盘空间？事实证明，这是因为不同的图片格式 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://imrannazar.com/An-Introduction-to-Compression"&gt;A introduction to compression&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近我在思考GIF和JPEG图片格式之间的不同：为什么某些图片存储为GIF格式所占的磁盘空间更大，而另一些图片以JPEG格式存储要占用更大的磁盘空间？事实证明，这是因为不同的图片格式使用了不同的压缩方法。&lt;/p&gt;
&lt;p&gt;压缩是一组程序的简便说法，这些程序能够将数据装进更小的存储空间中，也能将数据从压缩编码中重新取回。这是一个双向的过程：输入文件能够产生经过压缩的输出，并且算法根据压缩后的输出能够重新给你一个输入的拷贝。&lt;/p&gt;
&lt;h2&gt;冗余：行程长度编码（Run-Length Encoding）&lt;/h2&gt;
&lt;p&gt;使压缩成为可能的是冗余：事实表明大多数的数据都以某种方式重复自己。例如，在一个文档中可能多次使用同一个单词，或者一张图片的多处包含相同的颜色。一个非常简单的冗余数据片段的示例如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redundancy: Before compression&lt;/p&gt;
&lt;p&gt;AAAAABBWWWWWWWWWPPPPQZMMMMVVV&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这种情况下，冗余是明显的；整个样本中重复出现了一系列字母。压缩这种数据的一种简单方式是通过重复次数来代表重复出现的字母，从而削减了样本的总长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redundancy: After compression&lt;/p&gt;
&lt;p&gt;A5B2W9P4Q1Z1M4V3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法读取样本编码后的版本将能够完美地重现原来的数据："A" 5次，"B"
2次，等等。这个简单算法的使用非常广泛，被称为行程长度编码（RLE）：写下字符的每次行程有多长。以古老的PCX图像格式为例来说明一种广泛使用的标准RLE。
&lt;center&gt;&lt;img src="/assets/uploads/pics/compression-stripes.png" alt="compression-stripes.png"&gt;&lt;/center&gt;
&lt;center&gt;图1：条纹（&lt;a href="http://www.thisisnotparis.com/"&gt;Gottschal&lt;/a&gt;/&lt;a href="http://www.gluecksbazillus.de/"&gt;Schuster&lt;/a&gt;）&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图1中有很多单色的实心方块。这张图片宽500个像素，高190个像素；作为一张原始位图，使用一个字节来表示一个像素，那么这张图片就产生95kB的数据。PCX算法计算图片中每行像素的行程长度，为相同颜色的连续像素保存行程长度：以这种方式，图片的大小减到了52kB。&lt;/p&gt;
&lt;h2&gt;频率：哈夫曼（Huffman）编码&lt;/h2&gt;
&lt;p&gt;RLE的一个主要问题是它处理的是数据中的连续值：图1中，RLE算法对图片的每个水平行进行独立的处理，然而其实所有的行都是相同的。这个问题可以通过整体地看待数据来缓解，构建一个表来记录在整个数据集中每个值出现的次数。&lt;/p&gt;
&lt;p&gt;哈夫曼编码是一种借助这种“频率表”的方法，这种表记录着每个值出现的频率，并且为每一项分配一个编码。频率越高的项编码越短，较少出现的项也就得到长的编码。在计算中，这些编码一般是二进制编码，然后就可以组合成字节进行文件存储。&lt;/p&gt;
&lt;p&gt;使用上面的例子，一个哈夫曼编码的过程如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Huffman encoding: Before compression&lt;/p&gt;
&lt;p&gt;AAAAABBWWWWWWWWWPPPPQZMMMMVVV&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table border="1" align="center" width="40%"&gt;
  &lt;tr&gt;&lt;th&gt;值&lt;/th&gt;&lt;th&gt;频率&lt;/th&gt;&lt;th&gt;编码&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Q&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;000000&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Z&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;000001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;00001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;V&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;0001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;P&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;M&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;011&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;01&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;W&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;center&gt;
表1：频率和哈夫曼表
&lt;/center&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Huffman encoding: After compression&lt;/p&gt;
&lt;p&gt;01 01 01 01 01 00001 00001 1 1 1 1 1 1 1 1 1 001 001 001 001 000000 000001 011 011 011 011 0001 0001 0001&lt;/p&gt;
&lt;p&gt;此处省略了一行乱码，避免atom和rss报错...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用哈夫曼编码，数据从29个字符减少到10个字节。当然这没包含频率与编码表，这个表必须和压缩后的数据一起存储才有意义；本例中，频率表比压缩后的数据还要大，但在多数情况下，频率表的大小是微不足道的。&lt;/p&gt;
&lt;p&gt;当然，将RLE和哈夫曼编码结合使用是可能的，首先执行RLE，然后将压缩后的结果交给哈夫曼算法处理。对于简单的图片，这会产生特别好的结果：上面的图1通过使用GIF文件格式可以从一个95kB的位图压缩成一个4kB的文件，GIF文件格式就是结合使用了RLE，哈夫曼编码以及其他算法。&lt;/p&gt;
&lt;h2&gt;感知：有损编码&lt;/h2&gt;
&lt;p&gt;上述方法可以用于以一种能够完美重现的方式对数据进行压缩。这种压缩的用例包括文档和软件程序，对于这种用例来说，任意值的丢失或损坏都可能使得文件不再有价值。&lt;/p&gt;
&lt;p&gt;在特定情况下，对于需要处理的数据进行完美重现是不必要的：一个近似的结果就足够了。通常，这些情况出现在多媒体应用中：超出人类听觉范围的声音不需要记录，人眼无法识别的颜色与梯度的细微之处也无需重现。&lt;/p&gt;
&lt;p&gt;一个经典的示例是MPEG音频标准---通过去除高频声音相关的额外数据来降低音频文件的大小。这个标准的Layer-3规格允许多种去除数据的设定，这样渐进地从音频样本中去除更多的信息。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-mp3.gif"
alt="compression-mp3.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图2：经MPEG音频Layer-3编码的Yardım Et (&lt;a href="http://www.morveotesi.com/"&gt;Mor ve Ötesi&lt;/a&gt;, "Dünya Yalan Söylüyor")
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;上图2中，两个波形叠加在一起：红色的为原来的歌曲波形，覆盖在其上的蓝色是经充分压缩的变体。展示的样本长度为1.5秒；作为原来波形文件的一部分，这段样本存储为160kB的数据。经压缩的变体，长度相同，但仅占用48kB的空间。&lt;/p&gt;
&lt;p&gt;这是通过MPEG音频压缩算法得到的，调整歌曲的频率属性，去除超出人类听力范围（高至大约20kHz）的部分。这样，如上可见，并未显著地影响产生的波形，因此经压缩的声音不会明显地不同于原有的声音。&lt;/p&gt;
&lt;h2&gt;扔掉数据：视觉有损编码&lt;/h2&gt;
&lt;p&gt;正如声音文件的高频部分人耳无法辨别，图片也有高频部分：颜色的变化之处不足以人眼区分，或者由黑到白的渐变过程是如此的迅速导致无法看到渐变的部分。与声音处理一样，也可以从图片中去除这些高频部分；这就是JPEG图片格式的前提。&lt;/p&gt;
&lt;p&gt;JPEG应用了MPEG音频所使用算法的一种变种，从包含于图片的频率部分抽取一个二维映射；该算法继而裁剪到这个频率部分，并重新合成图片。如下所示是这个过程的一个例子。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-jpeg-sharp.gif" alt="compression-jpeg-sharp.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图3：JPEG压缩应用于一张块状图
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图3中，一张由4个16x16像素方块构成的图片，与该图片经JPEG编码后的图片进行比较。颜色或亮度上的尖锐变化被定义为高视觉频率的结果。这正是JPEG要去除的地方。结果，编码后图片的边缘比较模糊。4个方块的接触点特别模糊。&lt;/p&gt;
&lt;p&gt;但JPEG的强大之处并不是编码具有尖锐变化边沿和角落的图片，而是低视觉频率的图片；照片就是其中的一个典型例子。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-jpeg-photo.gif" alt="compression-jpeg-photo.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图4：JPEG压缩应用于一张照片
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图4中，一张安塔利亚港的300x300图片，经过JPEG编码。原来的位图为270kB，经去除尖锐边缘和颜色变化，JPEG能够产生一张22kB的图片。对于人眼而言，图片的变化很小；即使像素有所改变，图片所展示的景色也完好无损。&lt;/p&gt;
&lt;p&gt;这就是有损编码背后的主要概念：确切的数据并不重要，重要的是数据所呈现的信息。将JPEG算法用于编码软件程序是不明智的，但当数据表达了不必要的过多信息之时，有损编码就派上用场了。&lt;/p&gt;
&lt;h2&gt;感知冗余：视频编码&lt;/h2&gt;
&lt;p&gt;说到视频剪辑，通过结合无损和有损编码背后的原则，进一步压缩数据是有可能的。构建一个视频剪辑片段的最简单最幼稚的方法是合并连续的图片，作为视频帧来看待：MJPEG视频文件格式就是将一系列的JPEG图片看到独立的视频帧。&lt;/p&gt;
&lt;p&gt;这种方法忽视了视频片段中固有的数据冗余：一个给定帧中包含的大多数信息同样会包含于其前一帧中。任何特定帧中仅有一小部分是新的信息；通过计算这部分信息所处的位置，然后仅存储这部分信息数据，那么就有可能大大地缩减视频帧的数据大小。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-mpeg-diff.gif" alt="compression-mpeg-diff.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图5：连续视频帧，以及它们的不同之处（&lt;a href="http://jpl.nasa.gov/"&gt;NASA JPL&lt;/a&gt;）
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图5中，较之第一帧，视频的第二帧显示的变化非常小：仅仅航天飞机的排气羽流有显著的运动。事实上，发射塔后面的航天飞机固体助推器（SRB）(译注：见Wikipedia词条&lt;a href="http://zh.wikipedia.org/wiki/%E8%88%AA%E5%A4%A9%E9%A3%9E%E6%9C%BA%E5%9B%BA%E4%BD%93%E5%8A%A9%E6%8E%A8%E5%99%A8"&gt;航天飞机固体助推器&lt;/a&gt;)和天空在两帧之间完全没有变化。那么就不用存储图片的这些部分，可能存储一个值：“没有变化”就可以了。&lt;/p&gt;
&lt;p&gt;MPEG视频标准利用了这种内在的冗余作为算法的一部分。理论上，仅仅拍摄（a shot）的初始帧需要完整存储：拍摄的任何运动部分都可以作为与前一帧的相异之处来存储。初始帧，也称为一个内帧，存储为一张标准的JPEG图片，而后续的差异帧被称为间帧，或预测帧。&lt;/p&gt;
&lt;p&gt;实际上，MPEG视频标准是以“流”来设计的，这样就能够从拍摄（a shot）的中间开始观看视频片段。但若仅提供视频的一个内帧（I-帧），那么预测帧（P-帧）是不可能插入它们的差异的。所以，通常会把I-帧每隔一定时间插入到视频片段中，而不管拍摄的场景（a shot）是否变化。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-mpeg-graph.gif" alt="compression-mpeg-graph.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图6：一个4秒的MPEG视频片段的帧大小（&lt;a href="http://news.bbc.co.uk/"&gt;BBC News&lt;/a&gt;）
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;上图6中，视频片段每间隔25帧或一秒插入I-帧。后续的每个P-帧都比I-帧小得多，由于政治家在接受采访时一般都不会频繁移动，因此不同视频帧之间的不同之处更少。&lt;/p&gt;
&lt;p&gt;图6使用的例子是一个4秒的400x224视频片段。以原始位图形式粗糙农户，生成文件的大小有26.7MB；通过结合使用有损编码和冗余的技术，MPEG视频标准能够将视频大小缩减到300kB，减小了99%。&lt;/p&gt;
&lt;h2&gt;总结：什么情况下可以有损编码&lt;/h2&gt;
&lt;p&gt;本文所列举的有损编码的例子都是应用于特殊情况的：音频，视频，图片。仅对于这些或者其他相关的东西，感知才是压缩过程中的一个重大因素。对于其他压缩目标，比如文档或软件程序，数据是什么样的就保存为什么样，非常重要。&lt;/p&gt;
&lt;p&gt;人们一直在开发更加高级的特殊压缩方法，但数据压缩的多数常见实现都是基于本文讲述的技术：去除冗余和重复信息。当存在大量冗余数据时，数据压缩会表现得非常好，所以不要试图去压缩一个已经压缩过的文件。&lt;/p&gt;</content><category term="其他"></category><category term="理论"></category><category term="翻译"></category></entry><entry><title>JavaScript：继承和原型链（译）</title><link href="http://youngsterxyf.github.io/2013/02/27/Inheritance-and-the-prototype-chain/" rel="alternate"></link><published>2013-02-27T00:00:00+08:00</published><updated>2013-02-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-02-27:/2013/02/27/Inheritance-and-the-prototype-chain/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Inheritance_and_the_prototype_chain"&gt;Inheritance and the prototype chain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于具备基于类的编程语言（如Java或C++）经验的程序员来说，JavaScript有点混乱，因为它是一种动态语言，并且不提供&lt;code&gt;class&lt;/code&gt;的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Inheritance_and_the_prototype_chain"&gt;Inheritance and the prototype chain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于具备基于类的编程语言（如Java或C++）经验的程序员来说，JavaScript有点混乱，因为它是一种动态语言，并且不提供&lt;code&gt;class&lt;/code&gt;的实现（虽然关键字&lt;code&gt;class&lt;/code&gt;是保留的，不可用作变量名）。&lt;/p&gt;
&lt;p&gt;说到继承，JavaScript只有一种结构：对象。每个对象都有一个内部链接指向另一个对象，这个对象称为&lt;strong&gt;原型&lt;/strong&gt; (prototype)。那个原型对象也有自己的原型，如此直到某个对象以&lt;code&gt;null&lt;/code&gt;作为其原型。&lt;code&gt;null&lt;/code&gt;，根据定义，没有原型，作为这种&lt;strong&gt;原型链&lt;/strong&gt;的最后一环而存在。&lt;/p&gt;
&lt;h2&gt;以原型链实现继承&lt;/h2&gt;
&lt;h3&gt;继承属性&lt;/h3&gt;
&lt;p&gt;JavaScript对象可看作是动态地装载属性（这里指&lt;strong&gt;自有属性&lt;/strong&gt;）的"包包"，并且每个对象都有一个链指向一个原型对象。如下即为当尝试访问一个属性时发生的事情：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 假设有个对象o，其原型链如下所示：&lt;/span&gt;
&lt;span style="color: #008000"&gt;// {a: 1, b: 2} ---&amp;gt; {b: 3, c: 4} ---&amp;gt; null&lt;/span&gt;
&lt;span style="color: #008000"&gt;// &amp;#39;a&amp;#39;和&amp;#39;b&amp;#39;是o的自有属性。&lt;/span&gt;

&lt;span style="color: #008000"&gt;// 本例中，someObject.[[Prototype]]指定someObject的原型。&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 这完全是一种标记符号（基于ECMAScript标准中所使用的），不可用于脚本中。&lt;/span&gt;

console.log(o.a);   &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o有一个自有属性&amp;#39;a&amp;#39;吗？是的，其值为1&lt;/span&gt;

console.log(o.b);   &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o有自有属性&amp;#39;b&amp;#39;吗？是的，其值为2&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o的原型也有一个属性&amp;#39;b&amp;#39;，但是这里不会被访问。这被称为“属性隐藏”（property shadowing）&lt;/span&gt;

console.log(o.c);   &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o有自有属性&amp;#39;c&amp;#39;吗？没有，检查它的原型&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o.[[Prototype]]有自有属性&amp;#39;c&amp;#39;吗？是的，其值为4。&lt;/span&gt;

console.log(o.d);   &lt;span style="color: #008000"&gt;// undefined&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o有自有属性&amp;#39;d&amp;#39;吗？没有，检查其原型&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o.[[Prototype]]有自有属性&amp;#39;d&amp;#39;吗？没有，检查其原型&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o.[[Prototype]].[[Prototype]]为null，停止搜索，没有找到属性，返回undefined。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将一个属性分配给一个对象会创建一个自有属性。对于获取和设置属性的行为规则，唯一的例外是当一个继承而来的属性带有一个&lt;a href="https://developer.mozilla.org/en/docs/JavaScript/Guide/Working_with_Objects?redirectlocale=en-US&amp;amp;redirectslug=Core_JavaScript_1.5_Guide%2FWorking_with_Objects#Defining_getters_and_setters"&gt;属性值获取器或设置器&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;继承"方法"&lt;/h3&gt;
&lt;p&gt;JavaScript没有以基于类的编程语言定义方法的形式出现的"方法"。JavaScript中，任何函数都可以作为一个属性被添加到一个对象。一个继承而来的函数，操作起来与任何其他属性相同，包括如上所示的属性隐藏（在这里，称为&lt;em&gt;方法覆盖&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;当执行一个继承而来的函数时，&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/this"&gt;this&lt;/a&gt;的值指向继承对象，而不是原型对象，该函数是原型对象的自有属性。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o = {
    a: 2,
    m: &lt;span style="color: #0000ff"&gt;function&lt;/span&gt;(b) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.a + 1;
    }
};

console.log(o.m()); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 这里当调用o.m时，&amp;#39;this&amp;#39;引用o&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; p = Object.create(o);
&lt;span style="color: #008000"&gt;// p是一个继承自o的对象&lt;/span&gt;

p.a = 12;   &lt;span style="color: #008000"&gt;// 为p创建一个自有属性&amp;#39;a&amp;#39;&lt;/span&gt;
console.log(p.m()); &lt;span style="color: #008000"&gt;// 13&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 这里调用p.m时，&amp;#39;this&amp;#39;引用p&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 因此，当p继承了o的函数m，&amp;#39;this.a&amp;#39;意味着p.a，p的自有属性&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;创建对象的不同方式，以及由此产生的原型链&lt;/h2&gt;
&lt;h3&gt;以语法结构创建对象&lt;/h3&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o = {a: 1};

&lt;span style="color: #008000"&gt;// 新创建的对象o有Object.prototype作为其[[Prototype]]&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o没有名为&amp;#39;hasOwnProperty&amp;#39;的自有属性&lt;/span&gt;
&lt;span style="color: #008000"&gt;// hasOwnProperty是Object.prototype的自有属性。因此o从Object.prototype继承了hasOwnProperty&lt;/span&gt;
&lt;span style="color: #008000"&gt;// Object.prototype以null为其prototype。&lt;/span&gt;
&lt;span style="color: #008000"&gt;// o ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; a = [&lt;span style="color: #a31515"&gt;&amp;quot;yo&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;whadup&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;?&amp;quot;&lt;/span&gt;];

&lt;span style="color: #008000"&gt;// 数组继承自Array.prototype（它具有indexOf, forEach等方法）。&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 该原型链如下所示：&lt;/span&gt;
&lt;span style="color: #008000"&gt;// a ---&amp;gt; Array.prototype ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; f() {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 2;
}

&lt;span style="color: #008000"&gt;// 函数继承自Function.prototype（它具有call，bind等方法）：&lt;/span&gt;
&lt;span style="color: #008000"&gt;// f ---&amp;gt; Function.prototype ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;使用构造器&lt;/h3&gt;
&lt;p&gt;JavaScript中，"构造器""就"是一个恰好以&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/new"&gt;new操作符&lt;/a&gt;调用的函数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; Graph() {
    &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.vertexes = [];
    &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.edges = [];
}

Graph.prototype = {
    addVertex: &lt;span style="color: #0000ff"&gt;function&lt;/span&gt;(v) {
        &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.vertexes.push(v);
    }
};

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; g = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Graph();
&lt;span style="color: #008000"&gt;// g是一个带有自有属性&amp;#39;vertexes&amp;#39;和&amp;#39;edges&amp;#39;的对象。&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 执行new Graph()后，g.[[Prototype]]是Graph.prototype的值。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;使用Object.create&lt;/h3&gt;
&lt;p&gt;ECMAScript
5引入了一个新方法：&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create"&gt;Object.create&lt;/a&gt;。调用这个方法会创建一个新对象。这个对象的原型是该函数的第一个参数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; a = {a: 1};
&lt;span style="color: #008000"&gt;// a ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; b = Object.create(a);
&lt;span style="color: #008000"&gt;// b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;
console.log(b.a);   &lt;span style="color: #008000"&gt;// 1 (继承而来)&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; c = Object.create(b);
&lt;span style="color: #008000"&gt;// c ---&amp;gt; b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; d = Object.create(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;);
&lt;span style="color: #008000"&gt;// d ---&amp;gt; null&lt;/span&gt;
console.log(d.hasOwnProperty);  &lt;span style="color: #008000"&gt;// undefined，因为d并不继承自Object.prototype&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="JavaScript"></category><category term="翻译"></category></entry><entry><title>Python格式字符串（译）</title><link href="http://youngsterxyf.github.io/2013/01/26/python-string-format/" rel="alternate"></link><published>2013-01-26T00:00:00+08:00</published><updated>2013-01-26T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-26:/2013/01/26/python-string-format/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://mkaz.com/solog/python-string-format"&gt;Python String Format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每次使用Python的格式字符串（string formatter），2.7及以上版本的，我都会犯错，并且有生之年，我想我都理解不了它们的文档。我非常习惯于更老的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://mkaz.com/solog/python-string-format"&gt;Python String Format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每次使用Python的格式字符串（string formatter），2.7及以上版本的，我都会犯错，并且有生之年，我想我都理解不了它们的文档。我非常习惯于更老的
&lt;code&gt;%&lt;/code&gt; 方法。所以着手编写自己的格式字符串手册。若你有一些其他好的示例请告知我。&lt;/p&gt;
&lt;h2&gt;格式字符串手册&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数字格式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的表格展示了使用Python的后起新秀str.format()格式化数字的多种方法，包含浮点数格式化与整数格式化示例。可使用
&lt;code&gt;print("FORMAT".format(NUMBER));&lt;/code&gt; 来运行示例，因此你可以运行：
&lt;code&gt;print("{:.2f}".format(3.1415926));&lt;/code&gt; 来得到第一个示例的输出。&lt;/p&gt;
&lt;table border="1" align="center" width="80%"&gt;
&lt;tr&gt;&lt;th width="10%"&gt;数字&lt;/th&gt;&lt;th width="10%"&gt;格式&lt;/th&gt;&lt;th width="12%"&gt;输出
&lt;/th&gt;&lt;th width="65%"&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 3.1415926 &lt;/td&gt;
    &lt;td&gt; {:.2f} &lt;/td&gt;
    &lt;td&gt; 3.14 &lt;/td&gt;
    &lt;td&gt; 保留小数点后两位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 3.1415926 &lt;/td&gt;
    &lt;td&gt; {:+.2f} &lt;/td&gt;
    &lt;td&gt; +3.14 &lt;/td&gt;
    &lt;td&gt; 带符号保留小数点后两位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; -1 &lt;/td&gt;
    &lt;td&gt; {:+.2f} &lt;/td&gt;
    &lt;td&gt; -1.00 &lt;/td&gt;
    &lt;td&gt; 带符号保留小数点后两位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 2.71828 &lt;/td&gt;
    &lt;td&gt; {:.0f} &lt;/td&gt;
    &lt;td&gt; 3 &lt;/td&gt;
    &lt;td&gt; 不带小数 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 5 &lt;/td&gt;
    &lt;td&gt; {:0&amp;gt;2d} &lt;/td&gt;
    &lt;td&gt; 05 &lt;/td&gt;
    &lt;td&gt; 数字补零 (填充左边, 宽度为2) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 5 &lt;/td&gt;
    &lt;td&gt; {:x&amp;lt;4d} &lt;/td&gt;
    &lt;td&gt; 5xxx &lt;/td&gt;
    &lt;td&gt; 数字补x (填充右边, 宽度为4) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 10 &lt;/td&gt;
    &lt;td&gt; {:x&amp;lt;4d} &lt;/td&gt;
    &lt;td&gt; 10xx &lt;/td&gt;
    &lt;td&gt; 数字补x (填充右边, 宽度为4) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 1000000 &lt;/td&gt;
    &lt;td&gt; {:,} &lt;/td&gt;
    &lt;td&gt; 1,000,000 &lt;/td&gt;
    &lt;td&gt; 以逗号分隔的数字格式 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 0.25 &lt;/td&gt;
    &lt;td&gt; {:.2%} &lt;/td&gt;
    &lt;td&gt; 25.00% &lt;/td&gt;
    &lt;td&gt; 百分比格式 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 1000000000 &lt;/td&gt;
    &lt;td&gt; {:.2e} &lt;/td&gt;
    &lt;td&gt; 1.00e+09 &lt;/td&gt;
    &lt;td&gt; 指数记法 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; {:10d} &lt;/td&gt;
    &lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;13&lt;/td&gt;
    &lt;td&gt; 右对齐 (默认, 宽度为10) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; {:&amp;lt;10d} &lt;/td&gt;
    &lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; 左对齐 (宽度为10)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; {:^10d} &lt;/td&gt;
    &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;13 &lt;/td&gt;
    &lt;td&gt; 中间对齐 (宽度为10) &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;string.format()基础&lt;/h2&gt;
&lt;p&gt;如下是两个基本字符串替换的示例，符号 &lt;code&gt;{}&lt;/code&gt;
是替换变量的占位符。若没有指定格式，则直接将变量值作为字符串插入。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;s1 = &lt;span style="color: #a31515"&gt;&amp;quot;so much depends upon {}&amp;quot;&lt;/span&gt;.format(&lt;span style="color: #a31515"&gt;&amp;quot;a red wheel barrow&amp;quot;&lt;/span&gt;)
s2 = &lt;span style="color: #a31515"&gt;&amp;quot;glazed with {} water beside the {} chickens&amp;quot;&lt;/span&gt;.format(&lt;span style="color: #a31515"&gt;&amp;quot;rain&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;white&amp;quot;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你也可以使用变量的位置数值，在字符串中改变它们，进行格式化时，会更加灵活。如果搞错了顺序，你可以轻易地修正而不需要打乱所有的变量。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;s1 = &lt;span style="color: #a31515"&gt;&amp;quot; {0} is better than {1} &amp;quot;&lt;/span&gt;.format(&lt;span style="color: #a31515"&gt;&amp;quot;emacs&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;vim&amp;quot;&lt;/span&gt;)
s2 = &lt;span style="color: #a31515"&gt;&amp;quot; {1} is better than {0} &amp;quot;&lt;/span&gt;.format(&lt;span style="color: #a31515"&gt;&amp;quot;emacs&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;vim&amp;quot;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;更老的格式字符串符号"%"&lt;/h2&gt;
&lt;p&gt;Python2.6之前，格式字符串的使用方法相对更简单些，虽然其能够接收的参数数量有限制。这些方法在Python3.3中仍然有效，但已有含蓄的警告称将完全淘汰这些方法，目前还没有明确的时间进度表。[&lt;a href="http://www.python.org/dev/peps/pep-3101/"&gt;PEP-3101&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式化浮点数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pi = 3.14159
print(&lt;span style="color: #a31515"&gt;&amp;quot; pi = %1.2f &amp;quot;&lt;/span&gt;, % pi)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;多个替换值&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;s1 = &lt;span style="color: #a31515"&gt;&amp;quot;cats&amp;quot;&lt;/span&gt;
s2 = &lt;span style="color: #a31515"&gt;&amp;quot;dogs&amp;quot;&lt;/span&gt;
s3 = &lt;span style="color: #a31515"&gt;&amp;quot; %s and %s living together&amp;quot;&lt;/span&gt; % (s1, s2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;没有足够的参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用老的格式化方法，我经常犯错"TypeError: not enough arguments for formating
string"，因为我数错了替换变量的数量，编写如下这样的代码很容易漏掉变量。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;set =  (%s, %s, %s, %s, %s, %s, %s, %s) &lt;span style="color: #a31515"&gt;&amp;quot; % (a,b,c,d,e,f,g,h,i)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于新的Python格式字符串，可以使用编号的参数，这样你就不需要统计有多少个参数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;set = set = &lt;span style="color: #a31515"&gt;&amp;quot; ({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}) &amp;quot;&lt;/span&gt;.format(a,b,c,d,e,f,g)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;更多.format()的格式字符串方法&lt;/h2&gt;
&lt;p&gt;format()函数提供了相当多的附加特性和功能，如下是一些有用的使用.format()的技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以将新的格式字符串用作模板引擎，使用命名参数，这样就不要求有严格的顺序。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;madlib = &lt;span style="color: #a31515"&gt;&amp;quot; I {verb} the {object} off the {place} &amp;quot;&lt;/span&gt;.format(verb=&lt;span style="color: #a31515"&gt;&amp;quot;took&amp;quot;&lt;/span&gt;, object=&lt;span style="color: #a31515"&gt;&amp;quot;cheese&amp;quot;&lt;/span&gt;, place=&lt;span style="color: #a31515"&gt;&amp;quot;table&amp;quot;&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; I took the cheese off the table
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;多次复用同一个变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;%&lt;/code&gt; 格式字符串，要求变量有严格的次序，而.format()方法允许如上所示那样任意排列参数，也允许复用。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;str = &lt;span style="color: #a31515"&gt;&amp;quot;Oh {0}, {0}! wherefore art thou {0}?&amp;quot;&lt;/span&gt;.format(&lt;span style="color: #a31515"&gt;&amp;quot;Romeo&amp;quot;&lt;/span&gt;)
&amp;gt;&amp;gt;&amp;gt; Oh Romeo, Romeo&lt;span style="border: 1px solid #FF0000"&gt;!&lt;/span&gt; wherefore art thou Romeo&lt;span style="border: 1px solid #FF0000"&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;将数值转换为不同的进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用如下字母来将数字转换成字母代表的进制，&lt;strong&gt;d&lt;/strong&gt;ecimal，he&lt;strong&gt;x&lt;/strong&gt;，&lt;strong&gt;o&lt;/strong&gt;ctal, &lt;strong&gt;b&lt;/strong&gt;inary。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;print(&lt;span style="color: #a31515"&gt;&amp;quot;{0:d} - {0:x} - {0:o} - {0:b} &amp;quot;&lt;/span&gt;.format(21))
&amp;gt;&amp;gt;&amp;gt; 21 - 15 - 25 -10101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;将格式作为函数来使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以将.format()用作函数，这就允许在代码中将普通文本和格式区分开来。例如，你可以在程序的开头包含所有需要使用的格式，然后在后面使用。这也是一种处理国际化的好方法，国际化不仅要求不同的文本，且常常要求不同的数字格式。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;## 定义格式&lt;/span&gt;
email_f = &lt;span style="color: #a31515"&gt;&amp;quot;Your email address was {email}&amp;quot;&lt;/span&gt;.format

&lt;span style="color: #008000"&gt;### 在另一个地方使用&lt;/span&gt;
print(email_f(email=&lt;span style="color: #a31515"&gt;&amp;quot;bob@example.com&amp;quot;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;感谢
&lt;a href="http://www.reddit.com/r/Python/comments/174e1i/python_string_format_cookbook/c82ot0h"&gt;earthboundkid&lt;/a&gt;在reddit上提供这一技巧。&lt;/p&gt;
&lt;h2&gt;其他技巧&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;转义大括号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用str.format()时，若你需要使用大括号，只要写两次就可以了：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;print(&lt;span style="color: #a31515"&gt;&amp;quot; The {} set is often represented as { {0} } &amp;quot;&lt;/span&gt;.format(&lt;span style="color: #a31515"&gt;&amp;quot;empty&amp;quot;&lt;/span&gt;))
&amp;gt;&amp;gt;&amp;gt; The empty set &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; often represented &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; {0}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.python.org/3/library/string.html"&gt;Python String Library&lt;/a&gt; - 标准库文档&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>python周刊-第70期（译）</title><link href="http://youngsterxyf.github.io/2013/01/25/issue-70-of-python-weekly/" rel="alternate"></link><published>2013-01-25T00:00:00+08:00</published><updated>2013-01-25T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-25:/2013/01/25/issue-70-of-python-weekly/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://us2.campaign-archive1.com/?u=e2e180baf855ac797ef407fc7&amp;amp;id=7fc9a4c2e2&amp;amp;e=59f9a3c7e0"&gt;issue 70 of Python Weekly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章，教程和讲座(Articles, Tutorials and Talks)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jakevdp.github.com/blog/2013/01/13/hacking-super-mario-bros-with-python/"&gt;使用Python Hacking超级马里奥(Hacking Super Mario Bros. With Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This post shows how you can use matplotlib's animation tool to create animated
gifs based on Super Mario Bros …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://us2.campaign-archive1.com/?u=e2e180baf855ac797ef407fc7&amp;amp;id=7fc9a4c2e2&amp;amp;e=59f9a3c7e0"&gt;issue 70 of Python Weekly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章，教程和讲座(Articles, Tutorials and Talks)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jakevdp.github.com/blog/2013/01/13/hacking-super-mario-bros-with-python/"&gt;使用Python Hacking超级马里奥(Hacking Super Mario Bros. With Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This post shows how you can use matplotlib's animation tool to create animated
gifs based on Super Mario Bros in Python.&lt;/p&gt;
&lt;p&gt;该文展示如何使用matplotlib的动画工具使用Python创建超级马里奥的动画效果gif图。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tech.shift.com/post/40299429203/implementing-a-python-oauth-2-0-provider-part-2"&gt;实现一个Python OAuth 2.0 提供方 - 第2部分 - 授权服务提供方(Implementing a Python OAuth 2.0 Provider - Part2 - Authorization Provider)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Last week, the first part covered the Basics of the OAuth 2.0 Authorization
Flow. This second part will walk through how we used pyoauth2 to set up a
minimal Authorization Provider for SHIFT. This post covers setting up endpoints
for steps 2 and 5 from the overview.&lt;/p&gt;
&lt;p&gt;上周，第一部分阐述了OAuth 2.0授权的基本流程。
该第二部分将大致讲述怎样使用pyoauth2为SHIFT公司建立一个最基本的授权提供方。该文概述授权流程从第2步到第5步端到端的具体实现。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://proppy-appstats.appspot.com/#1"&gt;优化你的App Engine应用(Optimizing Your App Engine App)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this presentation, Johan Euphrosine, Google Developer Program Engineer,
   shows Datastore pattern and Anti-pattern and how to optimize your App Engine
   App with Appstats.&lt;/p&gt;
&lt;p&gt;该演讲稿中，谷歌开发者计划工程师，Johan
Euphrosine，解释了数据存储模式与反模式，以及怎样使用Appstats优化App
Engine应用。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.randalolson.com/2013/01/14/filling-in-pythons-gaps-in-statistics-packages-with-rmagic/"&gt;使用Rmagic来弥补Python统计分析工具包的缺失(Filling in Python's gaps in statistics packages with Rmagic)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rmagic is a package which allows you to run R code within the IPython
interface. This post explains how it works.&lt;/p&gt;
&lt;p&gt;Rmagic是一个允许通过IPython接口执行R代码的Python包。该文解释了Rmagic是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.twilio.com/blog/2013/01/sending-images-via-sms-with-filepicker-and-twilio.html"&gt;使用Filepicker和Twilio实现通过短信息服务发送图片(Sending Images via SMS with Filepicker and Twilio)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Filepicker.io provides APIs to connect, process, and store any piece of content
in your web application. For example if you are building an application that
needs to send files or photos to your users via SMS, then you can use
Filepicker.io with Twilio to make this happen. Let's explore how to build this.&lt;/p&gt;
&lt;p&gt;Filepicker.io提供API用于连接，处理，以及存储你的web应用中的任何内容。例如，如果你正在构建的应用需要通过短消息服务给用户发送文件或照片，那么你可以使用Filepicker.io配合Twilio来实现。该文探讨了如何构建这一功能。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://lightbird.net/larks/versi.html"&gt;Versi教程(Versi Tutorial)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Versi is a clone of the Reversi game. The goal of the game is to capture more
tiles than your enemy. You can capture the enemy's tiles by placing a new piece
on the blank tile so that one or more of enemy pieces are enclosed on a line
between your placed piece and one of your existing pieces.&lt;/p&gt;
&lt;p&gt;Versi是黑白棋游戏的克隆版本。这个游戏的目标是比你的敌人捕获更多的棋子。你可以在空白之处放置新棋子来捕获敌人的棋子，这样，一行中，在刚放置的棋子与你原来就有的棋子之间就包围了一个或多个敌人的棋子。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ganwellresource.blogspot.com/2013/01/monte-carlo-web-server-statistics-using.html"&gt;使用Pandas与Matplotlib进行蒙特卡洛法Web服务器统计分析(Monte Carlo Web-Server Statistics using Pandas and Matplotlib)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The author collected the web-server statistic-data by connecting to random web
servers and asking it for its name. He was able to maintain 80'0000 concurrent
connections on linux using tornados ioloop when he hit the limit of the
upstream-bandwidth at home.&lt;/p&gt;
&lt;p&gt;通过连接到随机选择的web服务器并请求其名称，作者收集了一些web服务器统计数据。文中说明作者使用tornado的ioloop能够维持80'0000个并发连接，直到达到家庭带宽的上限。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://maxburstein.com/blog/realtime-django-using-nodejs-and-socketio/"&gt;使用Django，Node.js以及Socket.IO等实现实时应用(Realtime Django Using Node.js and Socket.IO)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The goal of this post is to show you how to build a realtime chatroom using
Django, Redis, and Socket.IO. At a high level this post will show you how you
can convert your REST based app into a realtime web app.&lt;/p&gt;
&lt;p&gt;该文的目的是阐述如何使用Django, Redis,
    以及Socket.IO构建一个实时网络聊天室。从较高层面来看，该文将阐述如何将基于REST的应用转变为实时web应用。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://astrofrog.github.com/blog/2013/01/13/what-python-installations-are-scientists-using/"&gt;科学家们在使用哪个版本的Python解释器以及相关的库？(What Python Installations Are Scientists Using?)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This post gives you an overview of the results of a survey conducted to find
out what Python, Numpy, and Scipy versions the Scientists are using.&lt;/p&gt;
&lt;p&gt;该文概述了一个调查的结果，该调查旨在找出科学家们正在使用哪个版本的Python解释器，Numpy以及Scipy。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.slideshare.net/mpirnat/web-development-with-python-and-django"&gt;Python与Django Web开发(Web Development with Python and Django)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Slides from CodeMash 2013 Precompiler session, "Web Development with Python and
Django", including a breezy introduction to the Python programming language and
the Django web framework. The example code repository is available
&lt;a href="https://github.com/finiteloopsoftware/django-precompiler/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;来自CodeMash 2013预编译器会议的幻灯片，“Python与Django
Web开发”，生动地介绍了Python程序设计语言和Django
Web框架。示例代码库见&lt;a href="https://github.com/finiteloopsoftware/django-precompiler/"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts"&gt;可替代Bash实用脚本的Python脚本(Python Scripts as a Replacement for Bash Utility Scripts)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Instead of replacing a series of bash commands with one Python script, it often
is better to have Python do only the heavy lifting in the middle. This allows
for more modular and reusable scripts, while also tapping into the power of all
that Python offers. Using stdin as a file object allows Python to read input,
     which is piped to it from other commands, and writing to stdout allows it
     to continue passing the information through the piping system. Combining
     information like this can make for some very powerful programs.&lt;/p&gt;
&lt;p&gt;相较于使用一个Python脚本来替换一系列的bash命令，仅使用Python来完成其中的重活会更好些。这样的脚本模块化和可复用性更好，同时利用了Python的优势。将标准输入作为一个文件对象来使用，允许Python读取其他命令通过管道提供给它的输入。写到标准输出也允许Python通过管道系统继续传递信息。像这样把信息结合起来能够产生一些非常强大的程序。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythontesting.net/framework/pytest-introduction/"&gt;pytest入门(pytest introduction)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A post giving you an overview of pytest, a simple example, then throw pytest at
my markdown.py project. It also cover fixtures, test discovery, and running
unittests with pytest.&lt;/p&gt;
&lt;p&gt;该文章先概述pytest，而后给出一个简单的示例，并将pytest应用于作者的markdown.py项目。文章也涵盖了Pytest的一些测试夹具，测试发现，以及配合pytest执行unittests。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://raspberry-python.blogspot.com/2013/01/pyhacking-step-by-step.html"&gt;PyHacking攻略(PyHacking step by step)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://benplesser.com/2013/01/10/beefing-up-the-python-shell-to-build-apps-faster-and-dryer/"&gt;增强Python Shell以更快速地构建应用，同时减少重复工作(Beefing up the Python Shell to build apps faster and DRYer)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.linuxjournal.com/content/getting-started-salt-stack-other-configuration-management-system-built-python"&gt;Salt Stack起步---另一个Python实现的配置管理系统(Getting Started with Salt Stack-the Other Configuration Management System Built with Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.rootshell.be/2013/01/11/managing-apple-icloud-notes-with-python/"&gt;使用Python管理Apple iCloud笔记(Managing Apple iCloud Notes with Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youtube.com/watch?v=BZyXe3MhEyI"&gt;如何使用Python实现一个可撤销可重做的Maya命令(How to implement an undoable and redoable Maya command in Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://eli.thegreenplace.net/2013/01/16/python-paralellizing-cpu-bound-tasks-with-concurrent-futures/"&gt;Python-使用concurrent.futures并行化计算密集型任务(Python - paralellizing CPU-bound tasks with concurrent.futures)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有趣的项目，工具和库(Interesting Projects, Tools and Libraries)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/gleitz/howdoi"&gt;howdoi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Are you a hack programmer? Do you find yourself constantly Googling for how to
do basic programming tasks? Howdoi gives quick answers to many proragmming
questions via the command line.&lt;/p&gt;
&lt;p&gt;你是一个程序员新手？你发现自己经常使用Google搜索如何完成一些基本的编程任务？对于许多编程问题，Howdoi能够通过命令行快速地给出答案。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://baboon-project.org/"&gt;Baboon Project&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Do you waste your time in resolving merge conflicts with your favorite source code manager? Do you want to get rid of "Merge Hell"? Baboon is the solution for you! It's a lightweight daemon that detects merge conflicts before they actually happen. In fact, it detects them in real time.&lt;/p&gt;
&lt;p&gt;你还在浪费时间解决你喜爱的源码管理工具中的合并冲突？你想摆脱“合并地狱”么？Baboon就是这样的一个解决方案！它是一个轻量的后台程序，目标是在合并冲突真正发生之前就检测到。事实上，它能够实时检测存在的合并冲突。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://code.google.com/p/topy/"&gt;ToPy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ToPy solves the problem to obtain a 2D(or 3D, depending on the input file) solid-void (black and white) solution. The result is (a) an optimally stiff structure for minimum compliance problems, (b) an optimal distribution of two materials for heat conduction problems and (c) an optimal distribution of material for efficient mobility.&lt;/p&gt;
&lt;p&gt;ToPy旨在解决获取一个2D（或3D，根据输入文件而定）实-虚（黑和白）结构方案的问题。程序的结果是(a)最小合规问题的一个最佳刚性结构，(b)热传导问题中两种材料的一个最佳分布以及(c)有效流动性问题中材料的一个最佳分布。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/simpleai-team/simpleai"&gt;Simple AI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This lib implements many of the artificial intelligence algorithms described on the book "Artificial Intelligence, a Modern Approach", from Stuart Russel and Peter Norvig. We strongly recommend you to read the book, or at least the introductory chapters and the ones related to the components you want to use, because we won't explain the algorithms here.&lt;/p&gt;
&lt;p&gt;这个代码库实现了许多Stuart Russel和Peter Norvig所著“人工智能---一种现代方法”一书中描述的人工智能算法。我们强烈推荐你阅读这本书，或者至少是入门的章节以及与你想要使用的部分相关的章节，因为我们不会解释这些算法。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rubik/radon"&gt;Radon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Radon is a tool for Python that computes various metrics from the source code.&lt;/p&gt;
&lt;p&gt;Radon是一个为Python源码计算多种度量指标的工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/louist87/Scrappy"&gt;Scrappy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python module to rename media collections based on scrapes from thetvdb.com. CLI and GUI tools.&lt;/p&gt;
&lt;p&gt;基于从thetvdb.com网站获取的信息对媒体集进行重命名的Python模块。命令行和图形用户界面工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rhec/pyelasticsearch"&gt;pyelasticssearch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pyelasticsearch is a clean, future-proof, high-scale API to elasticsearch.&lt;/p&gt;
&lt;p&gt;pyelasticsearch为elasticsearch(译注：一种开源的分布式搜索引擎，官网见http://www.elasticsearch.org/ )提供一个干净的、经得起时间考验的、高可扩展的API。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ubershmekel/import_or_pip"&gt;import_or_pip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A python module that lets you import a module or pip install it if it isn't found.&lt;/p&gt;
&lt;p&gt;该Python模块允许你在程序中import一个模块或者当没找到要import的模块时会使用pip自动安装。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://bitbucket.org/larsyencken/doko"&gt;doko&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A simple command-line utility (and Python module) to determine your current location.&lt;/p&gt;
&lt;p&gt;一个简单的命令行工具（以及Python模块）用于确定你当前的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书籍(Books)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/gp/product/1589482824/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;tag=pythonweekly-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1589482824"&gt;ArcGIS Python脚本编程(Python Scripting for ArcGIS)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python Scripting for ArcGIS is a guide to help experienced users of ArcGIS for Desktop get started with Python scripting. This book teaches how to write Python code that works with spatial data to automate geoprocessing tasks in ArcGIS. Readers can thus learn the skill set needed to create custom tools.&lt;/p&gt;
&lt;p&gt;ArcGIS Python脚本编程是一本帮助有经验的ArchGIS桌面用户入门Python脚本编程的指南。该书讲解了如何编写Python代码处理空间数据以自动化ArcGIS中的地理数据处理任务。因此，读者能够学习到一些用于创建定制化工具的技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即将来临的大事和在线研讨会(Upcoming Events and Webinars)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://meetup.bostonpython.com/events/77229092/"&gt;马萨诸塞州,剑桥-2013年1月-波士顿Python会议(Boston Python Meetup January 2013 - Cambridge, MA)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There will be following two presentations&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zipline - A new, BSD-licensed quantitative trading system which allows easy backtesting of investment algorithms on historical data.&lt;/li&gt;
&lt;li&gt;Hython - A lisp variant that's fully hosted on and fully interoperable (in both directions) with Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将会有以下两个报告&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zipline - 一个新的、基于BSD许可协议的量化交易系统，允许轻松地对历史数据进行投资算法的事后检验。&lt;/li&gt;
&lt;li&gt;Hython - 一个完全模仿Python语法并完全可与Python互操作（双向的）的lisp变种语言。（译注：是这个&lt;a href="https://github.com/MaskRay/Hython"&gt;hython&lt;/a&gt;么？）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.djangonyc.org/events/98408042/"&gt;纽约州，纽约-2013年1月-Django-NYC会议(Django-NYC Meetup January 2013 - New York, NY)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This month we'll be taking a look at security. Our guide will be Levi Gross from Matasano. Most of the times security talks are boring. They speak about abstract topics like SQL injection and Cross Site Scripting however, rarely do they show you these bugs in the wild (due to the legal concerns). In this talk we will take a practical look at Django's security features and limitations.&lt;/p&gt;
&lt;p&gt;本月我们将讨论安全问题。我们的指导者为来自Matasano的Levi Gross。多数时候，关于安全的演讲总是很枯燥。他们谈论SQL注入和跨网站脚本攻击一类的抽象话题，却很少向你展示在真实环境下的这些bug（考虑到法律问题）。本次演讲中我们将从实际出发看看Django的安全特性与限制。&lt;/p&gt;</content><category term="其他"></category><category term="python"></category><category term="python-weekly"></category><category term="翻译"></category></entry><entry><title>回顾12，展望13（技术篇）</title><link href="http://youngsterxyf.github.io/2013/01/22/technology-12-13/" rel="alternate"></link><published>2013-01-22T00:00:00+08:00</published><updated>2013-01-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-22:/2013/01/22/technology-12-13/</id><summary type="html">&lt;p&gt;终归是个搞技术的，所以怎么也得搞个总结与展望的特别篇，讲述过去一年的技术学习与成果，规划接下来一年技术学习 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;终归是个搞技术的，所以怎么也得搞个总结与展望的特别篇，讲述过去一年的技术学习与成果，规划接下来一年技术学习的计划。&lt;/p&gt;
&lt;p&gt;2012年，阅读较少，写的代码较多，经过几个小项目以及实习，终于觉得自己有点攻城师的样子了，甚感欣慰，哈哈。&lt;/p&gt;
&lt;p&gt;罗列一下个人的小项目，虽然不复杂，代码量不多，代码也写得不漂亮，但自认为有那么点用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;百度音乐下载器：&lt;a href="https://github.com/youngsterxyf/Baidu_Music_Downloader"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/Baidu_Music_Downloader/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简易FTP搜索引擎：&lt;a href="https://github.com/youngsterxyf/simpleFTPsearch"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/simpleFTPsearch/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;，&lt;a href="http://202.120.40.101/services/ftpsearch/"&gt;应用&lt;/a&gt;（注：这个小项目断断续续做了一年，经历了几个版本，以及几次更新，目前看起来还不错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于Web的机器人远程控制：&lt;a href="https://github.com/youngsterxyf/WebBasedRobot"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/WebBasedRobot/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;（注：这个项目就是我那尽是水的毕业设计啦，哈哈）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在线代码高亮，分享以及运行：&lt;a href="https://github.com/youngsterxyf/colorfulCode"&gt;代码&lt;/a&gt;（注：这个项目其实很不完整的啦，代码编译与执行部分根本没做防护措施，根本没法实际使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Loven的个人静态站点：&lt;a href="https://github.com/Loven-Project/lovenworks"&gt;代码&lt;/a&gt;（注：其实绝大部分的代码都是loven自己写的啦，我主要写了实现总体动态效果的javascript程序，而且还是仿照的，不过难度比原来被仿照网站的要大很多）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;顺便说说实习做的事情，正好为G1C1做个广告，哈哈。&lt;/p&gt;
&lt;p&gt;实习主要实现&lt;a href="http://www.17gong1.com/"&gt;一起公益网&lt;/a&gt;的部分功能，最后还完成了该网站的静态化，所以现在的一起公益网是个静态网站，不需要数据库，用户也无法提交数据。&lt;/p&gt;
&lt;p&gt;后来一小段时间还维护&lt;a href="http://gong1pin.com/"&gt;公益品网&lt;/a&gt;，这网站有点意思的，欢迎大家访问看看。&lt;/p&gt;
&lt;p&gt;过去一年写的代码中，个人兴趣小项目基本都是基于Python、JS实现，实习工作主要使用PHP。&lt;/p&gt;
&lt;p&gt;除了写代码，我还迷上了翻译技术文章，markdown和restructedText格式的一些最早的翻译稿见&lt;a href="https://github.com/youngsterxyf/Translation"&gt;https://github.com/youngsterxyf/Translation&lt;/a&gt;。后来的放在基于jekyll与github
pages搭建的&lt;a href="http://youngsterxyf.github.com"&gt;博客&lt;/a&gt;&lt;s&gt;（注：近期随着Github被墙了）&lt;/s&gt;上。除了零碎的文章翻译，还开始翻译《The
AWK Programming
Language》一书，翻译稿见&lt;a href="https://awk.readthedocs.org/en/latest/"&gt;AWK程序设计语言&lt;/a&gt;，目前为止才完成第一章的翻译，再接再励！&lt;/p&gt;
&lt;p&gt;其实12年，我还是读了点书的，但觉得阅读效果不好，决心重头开始阅读，故在此不表。&lt;/p&gt;
&lt;p&gt;这样看来，12年，我虽做了些技术活，但都是些没啥技术难度的小应用，但令自己欣慰的是在学习方式上自己逐渐从死学转到实战，在应用中学习。13年希望自己挖掘一些自己感兴趣有技术深度的小项目来做。&lt;/p&gt;
&lt;h2&gt;13年技术学习计划&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;编程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编程语言对于码农来说是最重要的工具。程序员必须通过编程语言将想法转化为程序由计算机来执行。不会一种甚或多种编程语言的人称得上程序员么？不会编程的计算机从业人员是合格的么？而且，不同的项目选择不同的编程语言实现很多时候也是很关键的，所以程序员不管从实用还是从学习还是从兴趣角度，都应该多掌握几门编程语言。&lt;/p&gt;
&lt;p&gt;目前，我最喜欢也最熟悉的编程语言是Python；基本掌握的有PHP，C/C++，Java；不熟悉但能写点程序的有JavaScript，Go；简单接触过只有肤浅的感性认识的有Scheme，Ruby，Haskell等。&lt;/p&gt;
&lt;p&gt;从实用角度出发，2013年希望进一步掌握熟悉Python（甚至达到精通的程度），熟练使用PHP（工作可能需要使用），多写写C语言代码（方便进一步熟悉底层），尝试写一些Go语言程序（觉得Go简洁而强大，以后在服务器端应该大有前景），进一步了解JavaScript的特性（虽然基于各种库写了千行代码，但根本不熟悉这门语言，JS必将在web前端一统江湖啊），另外，由于要做运维工作，所以需熟悉Shell编程。&lt;/p&gt;
&lt;p&gt;从兴趣角度，以及为了更全面地理解编程语言，希望自己能掌握一门函数式语言，暂定Haskell，因为目前看来Haskell的社区很活跃，学习资料也多，Haskell也有点学术研究产物的感觉，与工程实践产物的语言相互补充，因为自己不喜欢Java，所以也不考虑基于JVM的Clojure等函数式语言，虽然它貌似很火。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;觉得以前自己过于折腾，总想找到更好的工具来使用，却不知所谓更好的多半要更熟悉才能明白，所以针对常用工具链中的每一环精通一个工具，相比同时掌握几个功能类似的工具，更为重要，回顾自己的折腾史，大浪淘尽沙，终觉着如下几个工具值得学习精通。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Linux ---
挑一个发行版深入使用学习，不同的发行版本质上大同小异，因为对于我这种层次的码农来说，Linux最重要的是命令行及其工具链，极其便于编程开发与批量任务。当然，也不必排斥Windows之流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VIM ---
虽然接触使用VIM的时间较长，但没有用心学习过，决心之后长久投入其怀抱，学好用好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git ---
天天使用Github，但由于是一个人在自娱自乐，所以只会Git的基本用法，遇到特殊情况就有些头疼了，而且我们得熟悉天天在一起的伙伴，是不？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Latex ---
虽然对于普通的文档编辑，office之流已经够用了，但对于一个有志青年，在初步认识Latex之后，大悟文档编辑也可以有更高的追求，一切复杂都抵不过纯文本的简单之美。故希望在基于office满足基本的文档编辑需求之外，自己能够有个Latex的理想追求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;理论学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2013年想进一步学习&lt;em&gt;编译原理&lt;/em&gt;、&lt;em&gt;分布式系统&lt;/em&gt;、&lt;em&gt;网络&lt;/em&gt;，特别是&lt;em&gt;编译原理&lt;/em&gt;，本科时候完全水过，根本没有正儿八经地学习。网络的话，是觉得现在的开发与应用对网络的依赖性越来越强。分布式系统，是认为任何大的系统，本质上都趋向于分布式，原理都相似。&lt;/p&gt;
&lt;p&gt;虽说理论要学习，但得以&lt;em&gt;实践&lt;/em&gt;为主导，在实践的同时加强理论学习。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;个人小项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;昨天刚看到一篇文章&lt;a href="http://www.dev.gd/20130122-the-joys-of-having-a-forever-project.html"&gt;《The joys of having a Forever
Project》&lt;/a&gt;
。确实我们应该始终有自己想做的事情，作为程序员，也就应该有自己想做的项目，这种项目或出于方便大众、节约大家的时间，或为了验证自己的理论学习，或为了实现自己的某个创意想法，原因不一而足，但一旦自己空闲的时候，就愿意为其写几行代码，那么在生活工作的劳累中你也能够感受到自身的充实圆满。&lt;/p&gt;
&lt;p&gt;关于个人小项目，目前仅有一个，就是想为自己和女朋友做个website，记录共同走过的光阴，个性化展示文字，图片，视频等。&lt;/p&gt;
&lt;p&gt;其他的以后看是否有新的想法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;书籍阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非技术的书籍目前想阅读《历史研究》、《GEB》、《明朝那些事儿》。《历史研究》是本大部头，很早就买了，一直没静下心来；《GEB》也是本大部头，之前翻过几页，觉得不是很理解，就放下了，现在想重新拿起来读一遍；《明朝那些事儿》这书，原本并不在意，后来有次在某个桌游店翻了几页，觉着甚是不错，将历史写得生动有趣，与黄仁宇的《万历十五年》相比，虽没有那样的学术严谨性，但有趣好读是很重要的嘛。&lt;/p&gt;
&lt;p&gt;技术书籍，根据前面说明希望学习的技术，目前想阅读《C++对象模型》、《编译原理》（龙书）、《Python源码剖析》、《TCP/IP详解》（第一卷）（第二卷有点厚，估计只能翻翻，没那么多时间阅读）。分布式系统方面，估计会阅读一些经典论文。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;源码阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一直觉得自己写的代码不甚高明，不简洁也没有美感，所以想阅读一些优秀的开源项目源码，借鉴一些别人的东西。目前想阅读memcached（分布式缓存）、requests（Python的HTTP库），另外随着阅读《Python源码剖析》，也阅读一点Python的源码。&lt;/p&gt;
&lt;p&gt;希望13年，在这方面有所突破，阅读一两个不大的项目源码。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;翻译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人觉得“慢”才能有所积淀。也有话说“学习的最好方式是教别人学”。所以翻译这个事情虽然会耗费许多时间，但要想翻译得对，翻译得好理解，所谓“信达雅”，必须对文本及其相关的东西有充分的理解，才能办到。那么翻译的过程也就成了一个深入学习的过程，时间长久的“慢”的积累，就会有较大的进步。另外，翻译也能帮助别人。&lt;/p&gt;
&lt;p&gt;目前翻译任务主要有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;继续翻译《The AWK Programming Language》一书，现在才翻译了一章，所以任重而道远啊；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Requests文档；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若读到写得好且有深度的技术文章，也会翻译。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;如此看来，13年要做的事情好多啊，有点过度计划的感觉啊，哈哈。不过只要自己能够分清主次轻重缓急，应该不会有问题。&lt;/p&gt;
&lt;p&gt;希望自己每天进步一点点。&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category><category term="技术"></category></entry><entry><title>回顾2012，展望2013</title><link href="http://youngsterxyf.github.io/2013/01/18/review12-lookinto13/" rel="alternate"></link><published>2013-01-18T00:00:00+08:00</published><updated>2013-01-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-18:/2013/01/18/review12-lookinto13/</id><summary type="html">&lt;p&gt;过去的一年里发生了很多事情，很大一部分原来就已在&lt;a href="http://youngsterxyf.github.io/2012/01/01/2011-summary/"&gt;2011年终-回顾与展望&lt;/a&gt;一文中提及---实习、找工作、毕业，除此之外还有：我和女朋友定亲了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;过去的一年里发生了很多事情，很大一部分原来就已在&lt;a href="http://youngsterxyf.github.io/2012/01/01/2011-summary/"&gt;2011年终-回顾与展望&lt;/a&gt;一文中提及---实习、找工作、毕业，除此之外还有：我和女朋友定亲了，总算朝着婚姻近了一步，哈哈。&lt;/p&gt;
&lt;h2&gt;实习&lt;/h2&gt;
&lt;p&gt;关于实习有太多的话想说。7个月的时间里浓缩了太多的欢乐，太欢乐了。原本以为我的读书生涯就要这么平淡无奇地结束了，没想到在这个结尾处竟然给了我个大惊喜，所谓惊喜并不是这份实习有多牛逼，而是遇到了一群欢乐的人，一群“重口味”的人，一群彪悍的人，而其中绝大部分是女人，噢，女生更恰当些。&lt;/p&gt;
&lt;p&gt;在G1C1，我快乐地写代码，上班是种享受，我想以后很可能不会再有这样的享受了。在G1C1，我逐步地发展成为一个吃货，所以毫无疑问地胖了，原本我以为自己会一直瘦下去。另外，我也黑了，因为经过了无数次地“被黑”，但她们说我应该高兴才对，她们“黑”我是因为“爱”我。关于“黑”这件事情，刚入职的时候，我是很同情wenbin的，因为见他被“黑”得体无完肤的，可我也没逃脱作为一个G1C1码农的宿命，wenbin走后，替代了他的角色，而我走后，comen则替代了我的角色，可惜之后就不会再有了。&lt;/p&gt;
&lt;p&gt;吃，是Google的特色，故在G1C1也不例外。因为G1C1不与其他部门在一起，所以没法吃食堂。但我们也不亏，老大带着我们吃遍了办公室方圆几里地叫得出名的饭店，吃饱吃好，并且一天一换。并且吃饭的场景实在不得不让码农感到幸福，男女比例经常是6：1，与“交大男女七比一，一对情侣三对基”的情形那是恰好相反，而且我们实验室甚至比七比一的情况还严重。所以我一直来回感受两种极端。又由于女生的食量多半偏小，作为男生，最后“扫盘”的工作那自然是义不容辞的，胖也就必然的结果了。&lt;/p&gt;
&lt;p&gt;因为工作内容比较多元化，所以G1C1实习生的专业背景与就读学校覆盖面很大，可以说是“一锅大杂烩”。专业不同，并没有妨碍交流，反而使工作氛围更加活跃，具备专业特色的阐述方式与内容相互碰撞交融。&lt;/p&gt;
&lt;p&gt;很想逐个介绍我所知道的G1C1er们，可苦于胸无半点墨水，只好作罢。但你们应知道，应相信，现在，以后，我都会一直念着你们，想着你们。感谢和你们一起度过的美好青春时光。&lt;/p&gt;
&lt;h2&gt;找工作&lt;/h2&gt;
&lt;p&gt;我的求职经历并不顺利，主要原因是对于求职的“求”字在认识上有所偏差。我不喜欢“求”，我认为找工作就和找对象一样，我想找你，你认可我，才行。我就这样，你不要我，拉倒。这种想法导致我并没有认真准备笔试面试。其实找工作和学校里的应试是一样一样的，所以你得做题，各种应试的题目，除了一流的公司，一般公司考的都是老题目或者类似的题目。另外，要注意找工作的目标不是向公司证明你的能力，而是拿到offer，“不择手段”地拿到offer。&lt;/p&gt;
&lt;p&gt;对自己未来几年做了基本的定位之后，我没有参加银行、国企一类公司的招聘，集中应聘技术型的私企外企大小公司，由于裸考裸面，结果多半不太理想。这里对于应聘的公司不做评价，求职的具体过程也不详述，只是真心感谢那些认可我赏识我的人，还有虽然拒了我但真心帮助我的人，谢谢你们。&lt;/p&gt;
&lt;p&gt;最后，腾讯收了我，虽然待遇和职位的工作内容不是很理想，但我想应该是个不错的机会，值得以后好好努力工作，感谢当时的几个面试官，也就是我以后的同事，当然还要特别感谢yuye同学，你也算是一个“奇葩”吧，哈哈，没有任何贬义哦。&lt;/p&gt;
&lt;p&gt;我之所以选择技术作为我的职业目标，一方面当然是因为我本来学的就是技术，但更重要的是因为做技术比较纯粹，我希望自己以后心里能一直很踏实安心。&lt;/p&gt;
&lt;h2&gt;毕业&lt;/h2&gt;
&lt;p&gt;说到毕业论文，一个字足以概括---“水”。哈哈，但幸好顺利毕业了，虽然过程很痛苦，很煎熬。现在的我无所事事，坐等毕业，哈哈。&lt;/p&gt;
&lt;p&gt;这次毕业与本科毕业有什么本质区别呢？那就是这次我是真的要结束读书的生活了，正式进入社会，需要承担的责任也是完全不相同的，并且以后我应该不会继续深造求学了。&lt;/p&gt;
&lt;p&gt;回顾十几年的读书生涯，实在难舍。&lt;/p&gt;
&lt;h2&gt;定亲&lt;/h2&gt;
&lt;p&gt;和女朋友相关的文字，我写得很少，自己也觉得有点对不住女朋友。其原因一方面是从我们认识到现在4年多的时间里，我正逐步地趋向沉默，文字表达越来越少；另一方面是我觉得幸福其实是一件挺私密的事情，不能多晒。所以，我不说并不是因为我不幸福，其实我一直幸福得偷着乐呢，哈哈。&lt;/p&gt;
&lt;p&gt;定亲的过程并没有想的那么顺利，要考虑很多问题，要和双方父母亲人沟通，特别是要和女朋友沟通，从恋爱逐步走向婚姻，会遇到很多很多现实的细节。面对现实，会产生矛盾，但没有什么大不了的，相爱的人请记住，矛盾没有什么大不了的，不要夸张了问题而放弃了情感。&lt;/p&gt;
&lt;h2&gt;谈谈自己&lt;/h2&gt;
&lt;p&gt;回顾从大一到现在的几年时间，我的变化应该算是蛮大的，我逐步地不再关注那些大层面上的事情，不去想那些形而上的问题。那些事情，那些问题，想不透，看不穿，也不会真的有解。这辈子，我们能做的其实很少很少，做些力所能及的事情也算是不浪费生命吧。也许有人认为这是“认命”了，认为我在逐渐成为一个“单向度”的人，但其实我还是想趁活着多扑腾几下的，按照自己的想法去活，只不过想法换了个方面。&lt;/p&gt;
&lt;h2&gt;未来一年&lt;/h2&gt;
&lt;p&gt;也得为这新的一年做点规划，定点目标啥的。可以从工作、健康、情感、技术等几个方面来谈吧。&lt;/p&gt;
&lt;p&gt;对于工作，我希望自己能够踏实些，逐步精通工作相关的技术，多认识一些人，对所处的技术行业有个更清晰的认识。&lt;/p&gt;
&lt;p&gt;身心健康应该始终放在第一位，要多运动锻炼，坚持跑步什么的，多出去走走，断然拒绝“宅”的习惯，特别是要多和女朋友出去玩，这个可以做个详细的计划。时间是靠自己安排的，理由也会有千万，但都不应接受其成为不注意身心健康的原因。&lt;/p&gt;
&lt;p&gt;情感方面，希望自己能够一如既往，并且更加耐心，细心，注意交流沟通。另外，要尽快完成婚姻的流程。&lt;/p&gt;
&lt;p&gt;说到技术，还是老毛病，有太多东西想学，不过现在学习方式在逐步进入良性循环，心态上也不会那么盲目了。接下来的一年里，自己必须不避重就轻，要攻关把核心技术练扎实，多写代码，多整理总结。&lt;/p&gt;
&lt;p&gt;过去的一年里，书籍阅读不多，也不见得是件坏事。不过新的一年里，应该要精读一些书，包括文史与技术类的，多思考。&lt;/p&gt;
&lt;p&gt;上述也说不上是规划，只是对自己提点要求和期望，希望自己在各方面都有所进步。&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category><category term="文字"></category></entry><entry><title>可扩展的Web架构与分布式系统（译）</title><link href="http://youngsterxyf.github.io/2013/01/16/scalable-web-architecture-and-distributed-systems/" rel="alternate"></link><published>2013-01-16T00:00:00+08:00</published><updated>2013-01-16T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-16:/2013/01/16/scalable-web-architecture-and-distributed-systems/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.aosabook.org/en/distsys.html"&gt;Scalable Web Architecture and Distributed Systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开源软件已成为一些最大型网站的基础组件。并且随着那些网站的发展，围绕它们的架构出现 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://www.aosabook.org/en/distsys.html"&gt;Scalable Web Architecture and Distributed Systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开源软件已成为一些最大型网站的基础组件。并且随着那些网站的发展，围绕它们的架构出现了一些最佳实践与指导性原则。本章尝试阐述设计大型网站需要考虑的一些关键问题，以及一些实现这些目标的组件。&lt;/p&gt;
&lt;p&gt;本章主要侧重于Web系统，虽然其中一些内容也适用于其它分布式系统。&lt;/p&gt;
&lt;h2&gt;Web分布式系统设计原则&lt;/h2&gt;
&lt;p&gt;构建和运维一个可扩展Web站点或者应用到底意味着什么？说到底这种系统只不过是通过互联网将用户与远程资源相连接---使其可扩展的是分布于多个服务器的资源，或者对这些资源的访问。&lt;/p&gt;
&lt;p&gt;类似于生活中的大多数东西，从长远来说，构建一个web服务之前花些时间提前规划是很有帮助的。理解大型网站背后一些需要考虑的因素与权衡取舍，在创建小一些的web站点时能让你作出更明智的决策。以下是影响大规模web系统设计的一些核心原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可用性：&lt;/strong&gt;
一个网站的正常运行时间对于许多公司的声誉与运作都是至关重要的。对于一些更大的在线零售站点，几分钟的不可用都会造成数千或数百万美元的营收损失，因此系统设计得能够持续服务，并且能迅速从故障中恢复是技术和业务的最基本要求。分布式系统中的高可用性需要仔细考虑关键部件的冗余，从部分系统故障中迅速恢复，以及问题发生时优雅降级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能：&lt;/strong&gt;
对于多数站点而言，网站的性能已成为一个重要的考虑因素。网站的速度影响着使用和用户满意度，以及搜索引擎排名，与营收和是否能留住用户直接相关。因此，创建一个针对快速响应与低延迟进行优化的系统非常重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可靠性：&lt;/strong&gt;
系统必须是可靠的，这样相同数据请求才会始终返回相同的数据。数据变换或更新之后，同样的请求则应该返回新的数据。用户应该知道一点：如果东西写入了系统，或者得到存储，那么它会持久化并且肯定保持不变以便将来进行检索。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可扩展性：&lt;/strong&gt;
对于任何大型分布式系统而言，大小(size)只是需要考虑的规模(scale)问题的一个方面。同样重要的是努力去提高处理更大负载的能力，这通常被称为系统的可扩展性。可扩展性以系统的许多不同参数为参考：能够处理多少额外流量？增加存储容量有多容易？能够处理多少更多的事务？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可管理性：&lt;/strong&gt;
系统设计得易于运维是另一个重要的考虑因素。系统的可管理性等价于运维（维护和更新）的可扩展性。对于可管理性需要考虑的是：问题发生时易于诊断与理解，便于更新或修改，系统运维起来如何简单（例如：常规运维是否不会引发失败或异常？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本：&lt;/strong&gt;
成本是一个重要因素。很明显这包括硬件和软件成本，但也要考虑系统部署和维护这一方面。系统构建所花费的开发者时间，系统运行所需要的运维工作量，以及培训工作都应该考虑进去。成本是拥有系统的总成本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些原则中的每一个都为设计分布式web架构提供了决策依据。然而，它们之间也会相互不一致，这样实现一个目标的代价是牺牲另一个目标。一个基本的例子：简单地通过增加更多的服务器（可扩展性）来解决容量问题是以可管理性（你需要运维额外的一台服务器）和成本（服务器的价钱）为代价的。&lt;/p&gt;
&lt;p&gt;设计任何一种web应用，考虑这些核心原则都是非常重要的，即使明知某个设计也许会牺牲其中的一个或多个原则。&lt;/p&gt;
&lt;h2&gt;1.2. 基础概念&lt;/h2&gt;
&lt;p&gt;说到系统架构，需要考虑几个事情：什么是合适的部件，这些部件如何组合在一起，以及什么是正确的权衡取舍。在需要之前扩大投资通常不是一种明智的商业主张;然而，在设计上的一些远见在将来能够节省大量的时间和资源。&lt;/p&gt;
&lt;p&gt;本节主要阐述对于几乎所有大型web应用来说都是非常重要的一些核心因素：&lt;em&gt;服务&lt;/em&gt;，&lt;em&gt;冗余&lt;/em&gt;， &lt;em&gt;分区&lt;/em&gt;， 以及&lt;em&gt;故障处理&lt;/em&gt;。这些因素中的每一个都涉及选择与折中，特别是在上一节所描述的那些原则的上下文中。为了详细地解释这些东西，最好是从一个例子开始。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;例子：图片托管应用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可能在以前的某个时候，你在网上张贴过图片。对于托管和提供大量图片的大网站来说，构建一个性价比高、高可用、以及低延迟（快速检索）的架构是存在诸多挑战的。&lt;/p&gt;
&lt;p&gt;想象存在这样一个系统，用户可以上传图片到中央服务器，也可以通过web链接或者API请求图片，就像Flickr或Picasa一样。为了简单起见，我们假设这个应用有两个关键部分：上传（写）图片到服务器和查询图片。当然我们希望图片上传很高效，同时我们非常关注当有人请求一张图片时（例如，网页或者其他应用请求图片），系统能够快速地交付。这非常类似于web服务器或内容分发网络（CDN）边缘服务器（CDN将这种服务器用于在多个地方存储内容，这样内容就在地理/物理距离上更接近用户，从而更加快速）提供的功能。&lt;/p&gt;
&lt;p&gt;系统的另一些重要方面有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于将要存储的图片数量没有限制，因此需要考虑存储的可扩展性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图片下载/请求的延迟要低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果用户上传了某张图片，那么这张图片就得一直存在（图片数据的可靠性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统应该易于维护（可管理性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于图片托管的利润空间不大，所以系统应有较高的性价比。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图1.1是系统的一张功能简化图。&lt;/p&gt;
&lt;p&gt;&lt;img src ="/assets/uploads/pics/imageHosting1.jpg" alt="imageHosting1.jpg"&gt;
&lt;center&gt;图1.1：图片托管应用的简化架构图&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在这个图片托管例子中，系统必须明显地快速，数据存储可靠，并且所有这些属性高度可扩展。构建该应用的一个小型版本轻而易举，也很容易搭载在单个服务器上；然而，那样本章就没多大意思了。假设我们想构建一个能够发展得和Flickr一样庞大的应用。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;服务&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;考虑可扩展的系统设计时，对功能进行解耦，然后将系统的每一部分看作能够自己提供服务，并具备明确定义的接口。实践中，人们评价以这种方式设计的系统具备面向服务器的架构（SOA）。对这类系统来说，每个服务都有自己截然不同的功能上下文，并通过一个抽象接口与该上下文之外的一切（通常是另一个服务公开的API）进行交互。&lt;/p&gt;
&lt;p&gt;将系统解构为一组相互补充的服务也就将不同组件的操作进行解耦。这种抽象有助于在服务、底层环境以及服务的消费者之间建立清晰的关系。这样明确的划分有助于隔离问题，也允许每个组件独立于其他组件进行扩展。这类面向服务的系统设计非常类似于程序设计的面向对象设计。&lt;/p&gt;
&lt;p&gt;在我们的例子中，所有上传和检索图片的请求都是在同一个服务器上处理的；然而，将这两个功能分割成两个独立的服务在系统需要扩展时非常有意义。&lt;/p&gt;
&lt;p&gt;现在假设该服务被大量使用；这种情况下很容易看到写操作对读取图片所花时间的影响有多大（因为这两个功能将竞争共享资源）。依赖于这种架构，这个影响会很大。即使上传和下载速度相同（多数IP网络不是这样的，而是以下载速度：上传速度为3：1的比例进行设计），文件读取操作通常是从缓存中读，而写操作最终是要写道磁盘（在最终一致的情况下，也许还要多次写）。即使所有东西都在内存中或者都从磁盘上读取（如SSD），数据库写操作几乎总是比读操作慢。（Pole Position，一个数据库基准测试的开源工具，&lt;a href="http://polepos.org/"&gt;http://polepos.org/&lt;/a&gt;，测试结果见&lt;a href="http://polepos.sourceforge.net/results/PolePositionClientServer.pdf"&gt;http://polepos.sourceforge.net/results/PolePositionClientServer.pdf&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;该设计的另一个潜在问题是像Apache或lighttpd这样的web服务器通常有可以维持的并发连接数量的上限（默认值为500左右，但可以更高）。在高流量下，写操作会迅速消耗完允许的并发连接数。由于读操作可以是异步的，或借助于其他性能优化方法，如gzip压缩或分块传输编码，web服务器可以在读操作之间更快速地切换服务，以及在客户端之间快速切换从而能够在每秒内服务于比连接最大值（使用Apache，将最大连接数设置为500，每秒服务数千个读操作请求并不罕见）更多的请求。另一方面，写操作倾向于在图片上传期间维持一个打开的连接，在多数家庭网络中，上传一个1MB的文件需要花费多于1秒的时间，这样web服务器仅可以处理500个这样的并发写操作。
&lt;img src ="/assets/uploads/pics/imageHosting2.png" alt="imageHosting2.png"&gt;
&lt;center&gt;图1.2：切分读写操作&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;为这类瓶颈做规划是将图片的读写操作切分成独立服务的一个很好的案例。如图1.2所示。这就允许我们单独地对两者中任意一个做扩展（因为通常读操作总是比写操作多），也有助于厘清每个点上正在发生的事情。最后，这也分离了未来的忧患，从而更易于排解故障和对读操作较慢这类问题进行扩展。&lt;/p&gt;
&lt;p&gt;这种方法的优势在于我们能够将问题独立于其他问题地进行解决---我们无需担心相同上下文中新图片的写操作和检索。这两个服务仍然基于全局图片语料，但可以通过与服务相适应的方法（例如：排队请求，或缓存常用图片---更多相关内容见下文）随意地优化它们的性能。从维护与成本的角度来看，每个服务都可以按需独立地扩展，这一点非常重要，因为如果服务是掺杂混合的，在上述场景中，一个服务会无意地影响另一个服务的性能。&lt;/p&gt;
&lt;p&gt;当然，若你有两个不同的端点，那么上述例子能够工作得很好（事实上这非常类似于多个云存储提供商的实现和内容分发网络）。虽然有很多方法可以解决这类瓶颈，但每个都有不同的权衡折中。&lt;/p&gt;
&lt;p&gt;例如，Flickr通过将用户分散到不同的数据库分片上来解决这个读/写问题，这样每个数据库分片仅能够处理一定数量的用户，并且随着用户的增加，可以添加更多的数据库分片到服务器集群中（见关于Flickr扩展工作的演示文稿：&lt;a href="http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html"&gt;http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html&lt;/a&gt;（墙外））。在第一个例子中，基于实际使用请求，扩展硬件更容易，Flickr则是随着用户群的变化进行扩展（但要求假设在用户之间的使用情况均衡，从而可以添加额外的容量）。对于前者，如果一个服务存在故障或问题，就会削弱整个系统的功能（例如，没人可以写文件），但若Flickr的一个数据库分片存在故障则仅影响使用该分片的用户。第一个例子中，对整个数据集执行操作更方便---例如，更新写操作服务以包含新的元数据或在所有图片元数据上搜索---对于Flickr的架构，需要更新或搜索每个数据库分片（或者需要创建一个搜索服务来整理元数据---事实上它们也这么做了）。&lt;/p&gt;
&lt;p&gt;对于这些系统的讨论并没有正确的答案，但回归到本章开头叙述的原则，确定系统的需求（频繁读或写或两者皆如此，并发级别，查询整个数据集，范围，排序，等等。），基准测试不同的方案选择，理解系统如何会失效，以及准备一个可靠的计划以应对故障的发生是很有用的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;冗余&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了优雅地处理故障，web架构必须具备冗余的服务和数据。例如，若某文件仅有一个拷贝存储在单个服务器上，那么失去该服务器即意味着失去了该文件。丢失数据很少是件好事，处理该问题的常见方法是创建多个或者说冗余的数据拷贝。&lt;/p&gt;
&lt;p&gt;同样的原则也可应用于服务。如果应用程序的功能有个核心组件，那么确保同时运行多个拷贝或版本能够使系统免于单点故障。&lt;/p&gt;
&lt;p&gt;在系统中创建冗余能够消除可能发生故障的单点，为了灾难恢复提供备份或备用的功能。例如，如果生产中运行着两个相同服务的实例，当其中一个发生故障或功能退化时，系统能够失效&lt;em&gt;失效转移&lt;/em&gt;到健全副本。失效备援可以自动发生或者手动介入。&lt;/p&gt;
&lt;p&gt;服务冗余的另一关键部分是创建一个&lt;em&gt;无共享(shared-nothing)的架构&lt;/em&gt;。使用这种架构，每个节点的运维工作都能独立于其它节点，也没有中心“大脑”来管理状态或协调节点的行为。这有助于提高可扩展性，因为不需要特殊的条件或了解就能添加新的节点。然而，最重要的是这种系统不会有单点故障，因此对于故障更有弹性。&lt;/p&gt;
&lt;p&gt;例如，在我们的图片服务器应用中，所有的图片都在另一处（理想情况是在不同的地理位置，从而能够应对地震或数据中心发生火灾一类的灾难）的硬件上存放着冗余的拷贝，提供图片访问的服务也是冗余的，均潜在地服务于请求（见图1.3.）（负载均衡器是使其成为可能的一种绝佳方法，将在下文详述）。
&lt;img src ="/assets/uploads/pics/imageHosting3.png" alt="imageHosting3.png"&gt;
&lt;center&gt;图1.3：具备冗余的图片托管应用&lt;/center&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;分区&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可能会存在非常大的数据集无法存放在单个服务器上。也可能某个操作需要非常多的计算资源，导致性能降低，需要增强计算能力。对于任一情形，你都有两种选择：纵向或横向扩展。&lt;/p&gt;
&lt;p&gt;纵向扩展即对单个服务器添加更多的资源。因此对于一个非常庞大的数据集来说，这意味着增加更多（或更大的）硬盘，从而单个服务器能够容纳下整个数据集。对于计算操作而言，这意味着将计算迁移到具备更快速的CPU或更大的内存空间的更大的服务器上。任一情况，都是使得单个服务器的资源能够自己解决对于更多资源的需求问题，实现纵向扩展。&lt;/p&gt;
&lt;p&gt;另一方面，横向扩展则是添加更多的节点。针对大数据集的情况，这就是使用第二个服务器来存储数据集的一部分，对于计算资源而言，这意味着将操作或负载分割到额外的节点。为了充分利用横向扩展，应将其作为系统架构的一种本质的设计原则，否则为实现横向扩展而修改系统或分割上下文会相当麻烦。&lt;/p&gt;
&lt;p&gt;说到横向扩展，一种更常见的技术是对服务进行分区，或分块。分区可以是分布式的，这样逻辑功能集之间是相互独立的；可以通过地理边界，或其他标准（如非付费用户 VS. 付费用户）来实现。这些方案的优势是可以提供更强的服务或数据存储能力。&lt;/p&gt;
&lt;p&gt;在我们的图片服务器例子中，&lt;/p&gt;</content><category term="其他"></category><category term="分布式系统"></category><category term="翻译"></category></entry><entry><title>精心挑选的数据可视化工具推荐列表（译）</title><link href="http://youngsterxyf.github.io/2013/01/15/a-carefully-selected-list-of-recommended-tools/" rel="alternate"></link><published>2013-01-15T00:00:00+08:00</published><updated>2013-01-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-15:/2013/01/15/a-carefully-selected-list-of-recommended-tools/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://datavisualization.ch/tools/selected-tools/"&gt;A Carefully Selected List of Recommended Tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当我和很多人谈论我们的工作时，经常被问到我们使用什么技术实现交互式和动态的数据 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文： &lt;a href="http://datavisualization.ch/tools/selected-tools/"&gt;A Carefully Selected List of Recommended Tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当我和很多人谈论我们的工作时，经常被问到我们使用什么技术实现交互式和动态的数据可视化。对于实现交互式的东西，我们有一套首选的代码库、应用程序以及服务，在工作中经常使用。根据项目的需求，我们会选择最合适的工具来完成工作。有时，为构建某些有用的东西你所需要的可能就是一个非常简单的工具。在别的情况下，则可能需要一套用于解决多种问题的工具集。但是如何选择恰当的工具呢？可用的工具数都数不清，所以很多时候朋友的推荐非常有价值。&lt;/p&gt;
&lt;p&gt;这就是为什么我们要将使用得最多并且喜欢使用的工具汇集起来。我们将这个精选工具集称为&lt;strong&gt;&lt;a href="http://selection.datavisualization.ch/"&gt;selection.datavisualization.ch&lt;/a&gt;&lt;/strong&gt; 。它包含绘制地图数据的代码库，创建图表的框架，以及简化数据处理的工具。即使你不喜欢编程，也可以不用写一行代码就能使用某些应用。我们会将该工具列表看作一个动态变化的仓库，随着技术发展增删某些东西。我们希望这能帮助你为下一个工作任务找到最佳的工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://selection.datavisualization.ch"&gt;&lt;img alt="datavisualization_selection" src="http://datavisualization.ch/wp-content/uploads/2012/05/datavisualization_selection_021.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在我来回答一些你最可能会问的问题：不，该列表并没有收录所有相关工具，所以你可能没看到你个人喜欢的。是的，其中提到的某些库刚刚兴起，可能还没到可以应用于产品的时候，而另一些库也已经有了替代者，但它们仍然可以提供良好的服务。&lt;/p&gt;</content><category term="其他"></category><category term="数据可视化"></category><category term="翻译"></category></entry><entry><title>github pages构建失败问题解决</title><link href="http://youngsterxyf.github.io/2013/01/08/fix-github-pages-builds-failed/" rel="alternate"></link><published>2013-01-08T00:00:00+08:00</published><updated>2013-01-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-08:/2013/01/08/fix-github-pages-builds-failed/</id><summary type="html">&lt;p&gt;今天为本博客提交更新后，github
pages自动构建始终不成功。原以为是新提交中引入了错误，于是按照&lt;a href="/2013/01/08/git-cancel-commits/"&gt;Git操作：强制删除提交到远程版本库的数据与版本记 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;今天为本博客提交更新后，github
pages自动构建始终不成功。原以为是新提交中引入了错误，于是按照&lt;a href="/2013/01/08/git-cancel-commits/"&gt;Git操作：强制删除提交到远程版本库的数据与版本记录&lt;/a&gt;的方法取消了所有的更新，但依旧没用。&lt;/p&gt;
&lt;p&gt;由于构建的结果邮件中只有这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The page build failed with the following error: page build failed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于构建失败的原因一丁点都没有告诉我们，所以根本没法调试嘛。&lt;/p&gt;
&lt;p&gt;在阅读github的官方帮助文档&lt;a href="https://help.github.com/articles/pages-don-t-build-unable-to-run-jekyll"&gt;Pages don't build: "Unable to run Jekyll"&lt;/a&gt;后，决定按照其中Syntax errors部分的内容做如下尝试：&lt;/p&gt;
&lt;p&gt;首先，按照&lt;a href="https://github.com/mojombo/jekyll/wiki/install"&gt;jekyll的官方安装文档&lt;/a&gt;安装jekyll：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo gem install jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，在博客的根目录下，执行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;jekyll --safe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;命令会输出详细的信息，如果构建失败，则在输出的信息中查找错误原因，比如本博客构建失败的原因出在文章的头部添加了如下类似的标记：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;category:
    - Algorithms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;导致之后一行的tags标记数据在构建时出错。我直接将每次执行构建 &lt;code&gt;jekyll --safe&lt;/code&gt;
提示的错误信息中相关的category标记直接删除(也许其后加个空行就可以了，没尝试过)，然后重新执行构建，依次循环，直到构建成功。然后将数据提交到远程版本库。&lt;/p&gt;
&lt;p&gt;由于jekyll本地构建时输出的信息也比较隐晦，很难一下子找到问题所在。比如提示
&lt;code&gt;Algorithms&lt;/code&gt; 元素构建出错，&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Not creating a link for ref_id = &amp;quot;0&amp;quot;.Liquid Exception: undefined method `gsub&amp;#39; for [&amp;quot;Algorithms&amp;quot;]:Array in post
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但没说是哪篇文章的哪一行，没办法只好使用grep查找：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;grep Algorithms _posts/*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;找出所有存在Algorithms单词的文章，然后逐个文章打开查看。&lt;/p&gt;</content><category term="其他"></category><category term="github"></category><category term="jekyll"></category></entry><entry><title>Git操作：强制删除提交到远程版本库的数据与版本记录</title><link href="http://youngsterxyf.github.io/2013/01/08/git-cancel-commits/" rel="alternate"></link><published>2013-01-08T00:00:00+08:00</published><updated>2013-01-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-08:/2013/01/08/git-cancel-commits/</id><summary type="html">&lt;p&gt;今天因为某些尚不明了的问题导致，博客的Git pages始终构建失败，于是想在远程版本库中删除前几次提交。在&lt;a href="http://www.douban.com/note/189603387/"&gt;该网页&lt;/a&gt;上找到了解决方案：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;今天因为某些尚不明了的问题导致，博客的Git pages始终构建失败，于是想在远程版本库中删除前几次提交。在&lt;a href="http://www.douban.com/note/189603387/"&gt;该网页&lt;/a&gt;上找到了解决方案：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git reset --hard HEAD~2                   &lt;span style="color: #008000"&gt;# 取消当前版本之前的两次提交&lt;/span&gt;
git push origin HEAD --force              &lt;span style="color: #008000"&gt;# 强制提交到远程版本库，从而删除之前的两次提交数据&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Git"></category><category term="版本控制"></category></entry><entry><title>装饰器与函数式Python（译）</title><link href="http://youngsterxyf.github.io/2013/01/04/Decorators-and-Functional-Python/" rel="alternate"></link><published>2013-01-04T00:00:00+08:00</published><updated>2013-01-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-04:/2013/01/04/Decorators-and-Functional-Python/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.brianholdefehr.com/decorators-and-functional-python"&gt;Decorators and Functional Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装饰器是Python的一大特色。除了在语言中的原本用处，还帮助我们以一种有趣的方式（函数式）进行思考。&lt;/p&gt;
&lt;p&gt;我打算自底 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://www.brianholdefehr.com/decorators-and-functional-python"&gt;Decorators and Functional Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装饰器是Python的一大特色。除了在语言中的原本用处，还帮助我们以一种有趣的方式（函数式）进行思考。&lt;/p&gt;
&lt;p&gt;我打算自底向上解释装饰器如何工作。首先解释几个话题以帮助理解装饰器。然后，深入一点探索几个简单的装饰器以及它们如何工作。最后，讨论一些更高级的使用装饰器的方式，比如：传递可选参数给装饰器或者串接几个装饰器。&lt;/p&gt;
&lt;p&gt;首先以我能想到的最简单的方式来定义Python函数是什么。基于该定义，我们可以类似的简单方式来定义装饰器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数是一个完成特定任务的可复用代码块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好的，那么装饰器又是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是一个修改其他函数的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在在装饰器的定义上进行详述，先解释一些先决条件。&lt;/p&gt;
&lt;h2&gt;函数是一等对象&lt;/h2&gt;
&lt;p&gt;Python中，所有东西都是对象。这意味着可以通过名字引用函数，以及像其他对象那样传递。例如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; traveling_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;Here I am!&amp;quot;&lt;/span&gt;

function_dict = {
    &lt;span style="color: #a31515"&gt;&amp;quot;func&amp;quot;&lt;/span&gt;: traveling_function
}

trav_func = function_dict[&lt;span style="color: #a31515"&gt;&amp;#39;func&amp;#39;&lt;/span&gt;]
trav_func()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; Here I am!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;traveling_function&lt;/code&gt; 被赋值给 &lt;code&gt;function_dict&lt;/code&gt; 字典中键 &lt;code&gt;func&lt;/code&gt; 的值，仍旧可以正常调用。&lt;/p&gt;
&lt;h2&gt;一等函数允许高阶函数&lt;/h2&gt;
&lt;p&gt;我们可以像其他对象那样传递函数。可以将函数作为值传递给字典，放在列表中，或者作为对象的属性进行赋值。那为什么不能作为参数传给另一个函数呢？当然可以！如果一个函数接受另一个函数作为其参数或者返回另一个函数，则称之为高阶函数。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; self_absorbed_function():
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m an amazing function!&amp;quot;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; printer(func):
    print &lt;span style="color: #a31515"&gt;&amp;quot;The function passed to me says: &amp;quot;&lt;/span&gt; + func()

&lt;span style="color: #008000"&gt;# Call `printer` and give it `self_absorbed_function` as an argument&lt;/span&gt;
printer(self_absorbed_function)
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; The function passed to me says: I&amp;#39;m an amazing function!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在你也看到函数可以作为参数传给另一个函数，而且传给函数的函数还可以调用。这允许我们创建一些有意思的函数，例如装饰器。&lt;/p&gt;
&lt;h2&gt;装饰器基础&lt;/h2&gt;
&lt;p&gt;本质上，装饰器就是一个以另一个函数为参数的函数。大多数情况下，它们会返回所包装函数的一个修改版本。来看个我们能想到的最简单的装饰器---同一性（identity）装饰器，或许对我们理解装饰器的工作原理有所帮助。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; identity_decorator(func):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; wrapper():
        func()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; wrapper

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; a_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m a normal function.&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# `decorated_function` 是 `identity_function` 返回的函数，也就是嵌套函数 `wrapper`&lt;/span&gt;
decorated_function = identity_function(a_function)

&lt;span style="color: #008000"&gt;# 如下调用 `identity_function` 返回的函数&lt;/span&gt;
decorated_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; I&amp;#39;m a normal function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里， &lt;code&gt;identity_decorator&lt;/code&gt;
根本没有修改它包装的函数，只是简单地返回一个函数（wrapper），这个函数在被调用之时，会去调用原来作为 &lt;code&gt;identity_decorator&lt;/code&gt; 参数的函数。这是个没有用处的装饰器！&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;identity_decorator&lt;/code&gt; 的有趣之处是 &lt;code&gt;wrapper&lt;/code&gt; 能够访问变量 &lt;code&gt;func&lt;/code&gt; ，即使
&lt;code&gt;func&lt;/code&gt; 并非是它的参数。这归因于闭包。&lt;/p&gt;
&lt;h2&gt;闭包&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是一个花哨的术语，意为声明一个函数时，该函数会维持一个指向声明所处词法环境的引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上例中定义的函数 &lt;code&gt;wrapper&lt;/code&gt; 能够在其局部作用域（local scope）中访问
&lt;code&gt;func&lt;/code&gt;。这意味着在 &lt;code&gt;wrapper&lt;/code&gt; （返回并赋值给变量 &lt;code&gt;decorated_function&lt;/code&gt; ）的整个生命周期内，它都可以访问 &lt;code&gt;func&lt;/code&gt; 变量。一旦 &lt;code&gt;identity_decorator&lt;/code&gt;返回，那么访问 &lt;code&gt;func&lt;/code&gt; 的唯一方式就是通过 &lt;code&gt;decorated_function&lt;/code&gt; 。 &lt;code&gt;func&lt;/code&gt; 只作为一个变量存在于 &lt;code&gt;decorated_function&lt;/code&gt; 作用域环境的内部。&lt;/p&gt;
&lt;h2&gt;一个简单的装饰器&lt;/h2&gt;
&lt;p&gt;现在我们来创建一个确实有点用的装饰器。这个装饰器所做的就是记录它所修改的函数被调用了多少次。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; logging_decorator(func):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; wrapper():
        wrapper.count += 1
        print &lt;span style="color: #a31515"&gt;&amp;quot;The function I modify has been called {0} time(s)&amp;quot;&lt;/span&gt;.format(wrapper.count)
        func()
    wrapper.count = 0
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; wrapper

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; a_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m a normal function.&amp;quot;&lt;/span&gt;

modified_function = logging_decorator(a_function)

modified_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; The function I modify has been called 1 time(s).&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; I&amp;#39;m a normal function.&lt;/span&gt;

modified_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; The function I modify has been called 2 time(s).&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; I&amp;#39;m a normal function.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们说装饰器会修改函数，这样来想对理解也是有帮助的。但如例子所见，
&lt;code&gt;logging_decorator&lt;/code&gt; 返回的是一个类似于 &lt;code&gt;a_function&lt;/code&gt;
的新函数，只是多了一个日志特性。&lt;/p&gt;
&lt;p&gt;上例中， &lt;code&gt;logging_decorator&lt;/code&gt; 不仅接受一个函数作为参数，并且返回一个函数，
&lt;code&gt;wrapper&lt;/code&gt; 。每次 &lt;code&gt;logging_decorator&lt;/code&gt; 返回的函数得到调用，它就对 &lt;code&gt;wrapper.count&lt;/code&gt; 的值加1，打印出来，然后调用 &lt;code&gt;logging_decorator&lt;/code&gt; 包装的函数。&lt;/p&gt;
&lt;p&gt;你也许正疑惑为什么我们的计数器是 &lt;code&gt;wrapper&lt;/code&gt; 的一个属性而不是一个普通的变量。难道 &lt;code&gt;wrapper&lt;/code&gt; 的闭包环境不是让我们访问在其局部作用域中声明的任意变量么？是的，但有个问题。Python中，闭包允许对其函数作用域链中任一变量的进行任意读操作，但只允许对可变对象（列表、字典、等等）进行写操作。整数在Python中是非可变对象，因此我们不能修改 &lt;code&gt;wrapper&lt;/code&gt; 内部整型变量的值。相反，我们将计数器作为 &lt;code&gt;wrapper&lt;/code&gt; 的一个属性---一个可变对象，因此可以随我们自己增大它的值。&lt;/p&gt;
&lt;h2&gt;装饰器语法&lt;/h2&gt;
&lt;p&gt;在前一个例子中，我们看到可以将一个函数作为参数传给装饰器，从而使用装饰器函数对该函数进行包装。然而，Python还有一个语法模式使得这一切更加直观，更容易阅读，一旦你熟悉了装饰器。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# In the previous example, we used our decorator function by passing the&lt;/span&gt;
&lt;span style="color: #008000"&gt;# function we wanted to modify to it, and assigning the result to a variable&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; some_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m happiest when decorated.&amp;quot;&lt;/span&gt;

&lt;span style="color: #008000"&gt;# Here we will make the assigned variable the same name as the wrapped function&lt;/span&gt;
some_function = logging_decorator(some_function)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# We can achieve the exact same thing with this syntax:&lt;/span&gt;

@logging_decorator
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; some_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m happiest when decorated&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用装饰器语法，鸟瞰其中发生的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解释器到达被装饰的函数，编译 &lt;code&gt;some_function&lt;/code&gt;，并将其命名为 'some_function'。&lt;/li&gt;
&lt;li&gt;然后将该函数传递给装饰行中指定的装饰器函数（ &lt;code&gt;logging_function&lt;/code&gt; ）。&lt;/li&gt;
&lt;li&gt;装饰器函数（通常是用来包装原函数的另一个函数）的返回值取代原来的函数（&lt;code&gt;some_function&lt;/code&gt; ），绑定到变量名 &lt;code&gt;some_function&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将这些步骤记住，让我们来更清晰地解释 &lt;code&gt;identity_decorator&lt;/code&gt; 。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; identity_decorator(func):
    &lt;span style="color: #008000"&gt;# Everything here happens when the decorator LOADS and is passed&lt;/span&gt;
    &lt;span style="color: #008000"&gt;# the function as decribed in step 2 above&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; wrapper():
        &lt;span style="color: #008000"&gt;# Things here happen each time the final wrapped function gets CALLED&lt;/span&gt;
        func()
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; wrapper
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;希望那些注释有助于理解。每次调用被包装的函数，仅执行装饰器返回的函数中的指令。返回函数之外的指令仅执行一次---上述步骤2中描述的：装饰器首次接收到传递给它的待包装函数之时。&lt;/p&gt;
&lt;p&gt;在观察更多的有意思的装饰器之前，我想再解释一样东西。&lt;/p&gt;
&lt;h2&gt;*args与**kwargs&lt;/h2&gt;
&lt;p&gt;以前你也许有时会把这两者相混淆了。让我们一次性地讨论它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过在形参列表中使用 &lt;code&gt;*args&lt;/code&gt; 语法，python函数能够接收可变数量的位置参数(positional arguments)。 &lt;code&gt;*args&lt;/code&gt; 会将所有没有关键字的参数放入一个参数元组中，在函数里可以访问元组中的参数。相反，将 &lt;code&gt;*args&lt;/code&gt; 用于函数调用时的实参列表之时，它会将参数元组展开成一系列的位置参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; function_with_many_arguments(*args):
    print args

&lt;span style="color: #008000"&gt;# `args` within the function will be a tuple of any arguments we pass&lt;/span&gt;
&lt;span style="color: #008000"&gt;# which can be used within the function like any other tuple&lt;/span&gt;
function_with_many_arguments(&lt;span style="color: #a31515"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;, 123, &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;)
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; (&amp;#39;hello&amp;#39;, 123, True)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; function_with_3_parameters(num, boolean, string):
    print &lt;span style="color: #a31515"&gt;&amp;quot;num is &amp;quot;&lt;/span&gt; + str(num)
    print &lt;span style="color: #a31515"&gt;&amp;quot;boolean is &amp;quot;&lt;/span&gt; + str(boolean)
    print &lt;span style="color: #a31515"&gt;&amp;quot;string is &amp;quot;&lt;/span&gt; + string

arg_list = [1, &lt;span style="color: #0000ff"&gt;False&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;decorators&amp;#39;&lt;/span&gt;]

&lt;span style="color: #008000"&gt;# arg_list will be expanded into 3 positional arguments by the `*` symbol&lt;/span&gt;
function_with_3_parameters(*arg_list)
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; num is 1&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; boolean is False&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt;&amp;gt; string is decorators&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重述一遍：在形参列表中， &lt;code&gt;*args&lt;/code&gt;会将一系列的参数压缩进一个名为'args'的元组，而在实参列表中， &lt;code&gt;*args&lt;/code&gt; 会将一个可迭代的参数数据结构展开为一系列的位置实参应用于函数。&lt;/p&gt;
&lt;p&gt;如你所见在实参展开的例子中， &lt;code&gt;*&lt;/code&gt; 符号可与'args'之外的名字一起使用。当压缩/展开一般的参数列表，使用 &lt;code&gt;*args&lt;/code&gt; 的形式仅仅是一种惯例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;**kwargs&lt;/code&gt; 与 &lt;code&gt;*args&lt;/code&gt; 的行为类似，但用于关键字参数而非位置参数。如果在函数的形参列表中使用 &lt;code&gt;**kwargs&lt;/code&gt; ，它会收集函数收到的所有额外关键字参数，放入一个字典中。如果用于函数的实参列表，它会将一个字典展开为一系列的关键字参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; funtion_with_many_keyword_args(**kwargs):
    print kwargs

function_with_many_keyword_args(a=&lt;span style="color: #a31515"&gt;&amp;#39;apples&amp;#39;&lt;/span&gt;, b=&lt;span style="color: #a31515"&gt;&amp;#39;bananas&amp;#39;&lt;/span&gt;, c=&lt;span style="color: #a31515"&gt;&amp;#39;cantalopes&amp;#39;&lt;/span&gt;)
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; {&amp;#39;a&amp;#39;:&amp;#39;apples&amp;#39;, &amp;#39;b&amp;#39;:&amp;#39;bananas&amp;#39;, &amp;#39;c&amp;#39;:&amp;#39;cantalopes&amp;#39;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; multiply_name(count=0, name=&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;):
    print name * count

arg_dict = {&lt;span style="color: #a31515"&gt;&amp;#39;count&amp;#39;&lt;/span&gt;: 3, &lt;span style="color: #a31515"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;: &lt;span style="color: #a31515"&gt;&amp;#39;Brian&amp;#39;&lt;/span&gt;}

multiply_name(**arg_dict)
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; BrianBrianBrian&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;既然你理解了 &lt;code&gt;*args&lt;/code&gt; 与 &lt;code&gt;**kwargs&lt;/code&gt; 的工作原理，那么我们就继续研究一个你会发现很有用的装饰器。&lt;/p&gt;
&lt;h2&gt;缓存制表（Memoization）&lt;/h2&gt;
&lt;p&gt;缓存制表是避免潜在的昂贵的重复计算的一种方法，通过缓存函数每次执行的结果来实现。这样，下一次函数以相同的参数执行，就可以从缓存中获取返回结果，不需要再次计算结果。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; functools &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; wraps

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; memoize(func):
    cache = {}

    @wraps(func)
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; wrapper(*args):
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; args &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; cache:
            cache[args] = func(*args)
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; cache[args]
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; wrapper

@memoize
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; an_expensive_function(arg1, arg2, arg3):
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你可能注意到了示例代码中一个奇怪的 &lt;code&gt;@wraps&lt;/code&gt; 装饰器。在完整地讨论 &lt;code&gt;memoize&lt;/code&gt;
之前我将简要地解释这个装饰器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用装饰器的一个副作用是被包装的函数失去了本来有的 &lt;code&gt;__name__&lt;/code&gt; ， &lt;code&gt;__doc__&lt;/code&gt; ， 以及 &lt;code&gt;__module__&lt;/code&gt; 属性。 &lt;code&gt;wraps&lt;/code&gt; 函数是一个包装另一个装饰器返回的函数的装饰器，将那三个属性的值恢复为函数未装饰之时的值。例如： 如果不使用 &lt;code&gt;wraps&lt;/code&gt; 装饰器， &lt;code&gt;an_expensive_function&lt;/code&gt; 的名字（通过 &lt;code&gt;an_expensive_function.__name__&lt;/code&gt; 可以看到）将是 'wrapper' 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我认为 &lt;code&gt;memoize&lt;/code&gt; 是一个很好的装饰器用例。它服务于一个很多函数都需要的目的，通过将它创建为一个通用装饰器，我们可以将它的功能应用于任一能够从其中获益的函数。这就避免了在多种不同的场合重复实现这个功能。因为不需要重复自己，所以我们的代码更容易维护，并且更容易阅读和理解。只要读一个单词你就能立刻理解函数使用了缓存制表。&lt;/p&gt;
&lt;p&gt;需要提醒的是：缓存制表仅适用于纯函数。也就是说给定一个特定的参数设置，函数确定总会产生相同的结果。如果函数依赖于不作为参数传递的全局变量、I/O、或者其它任意可能影响返回值的东西，缓存制表会产生令人迷惑的结果！并且，一个纯函数不会有任何副作用。因此，如果你的函数会增大一个计数器，或者调用另一个对象的方法，或者其它任意不在函数的返回结果中表示的东西，当结果是从缓存中返回时，副作用操作并不会得到执行。&lt;/p&gt;
&lt;h2&gt;类的装饰器&lt;/h2&gt;
&lt;p&gt;最初，我们说装饰器是一个修改另一个函数的函数，但其实它们可以用于修改类或者方法。对类进行装饰并不常见，但某些情况下作为元类(metaclass)的一个替代，类的装饰器是一个有用的工具。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;foo = [&lt;span style="color: #a31515"&gt;&amp;#39;important&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;stuff&amp;#39;&lt;/span&gt;]

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; add_foo(klass):
    klass.foo = foo
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; klass


@add_foo
&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Person&lt;/span&gt;(object):
    &lt;span style="color: #0000ff"&gt;pass&lt;/span&gt;

brian = Person()

print brian.foo
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; [&amp;#39;important&amp;#39;, &amp;#39;foo&amp;#39;, &amp;#39;stuff&amp;#39;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在，类 &lt;code&gt;Person&lt;/code&gt; 的任一对象都有一个超级重要的 &lt;code&gt;foo&lt;/code&gt;
属性！注意，因为我们装饰的是一个类，所以装饰器返回的不是一个函数，而是一个类。更新一下装饰器的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是一个修改函数、或方法、或类的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;装饰器类&lt;/h2&gt;
&lt;p&gt;事实证明我早先对你隐瞒了一些其它事情。不仅装饰器可以装饰一个类，并且装饰器也可以是一个类！对于装饰器的唯一要求就是它的返回值必须可调用(callable)。这意味着装饰器必须实现 &lt;code&gt;__call__&lt;/code&gt; 魔术方法，当你调用一个对象时，会隐式调用这个方法。函数当然是隐式设置这个方法的。我们重新将 &lt;code&gt;identity_decorator&lt;/code&gt; 创建为一个类来看看它是如何工作的。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;IdentityDecorator&lt;/span&gt;(object):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, func):
        self.func = func

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __call__(self):
        self.func()


@IdentityDecorator
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; a_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m a normal function.&amp;quot;&lt;/span&gt;

a_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; I&amp;#39;m a normal function.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如下是上例中发生的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 &lt;code&gt;IdentityDecorator&lt;/code&gt; 装饰 &lt;code&gt;a_function&lt;/code&gt; 时，它的行为就和装饰器函数一样。这个代码片段等价于上例中的装饰器语法： &lt;code&gt;a_function = IdentityDecorator(a_function)&lt;/code&gt; 。调用（实例化）该装饰器类时，需将其装饰的函数作为一个实参传递给它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例化 &lt;code&gt;IdentityDecorator&lt;/code&gt; 之时，会以被装饰的函数作为实参调用初始化函数 &lt;code&gt;__init__&lt;/code&gt; 。本例中，初始化函数所做的事情就是将被装饰函数赋值给一个属性，这样之后就可以通过其它方法进行调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，调用 &lt;code&gt;a_function&lt;/code&gt; （实际上是返回的包装了 &lt;code&gt;a_function&lt;/code&gt; 的 &lt;code&gt;IdentityDecorator&lt;/code&gt; 对象）之时，会调用对象的 &lt;code&gt;__call__&lt;/code&gt; 方法。这仅是一个同一性装饰器，所以方法只是简单地调用了该类所装饰的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次更新一下我们对装饰器的定义！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是一个修改函数、方法或者类的可调用对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;带参数的装饰器&lt;/h2&gt;
&lt;p&gt;有时，需要根据不同的情况改变装饰器的行为。你可以通过传参来做到这一点。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; functools &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; wraps

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; argumentative_decorator(gift):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; func_wrapper(func):
        @wraps(func)
        &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; returned_wrapper(*args, **kwargs):
             print &lt;span style="color: #a31515"&gt;&amp;quot;I don&amp;#39;t like this &amp;quot;&lt;/span&gt; + gift + &lt;span style="color: #a31515"&gt;&amp;quot;you gave me!&amp;quot;&lt;/span&gt;
             &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; func(gift, *args, **kwargs)
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; returned_wrapper
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; func_wrapper

@argumentative_decorator(&lt;span style="color: #a31515"&gt;&amp;quot;sweater&amp;quot;&lt;/span&gt;)
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; grateful_function(gift):
    print &lt;span style="color: #a31515"&gt;&amp;quot;I love the &amp;quot;&lt;/span&gt; + gift + &lt;span style="color: #a31515"&gt;&amp;quot;!Thank you!&amp;quot;&lt;/span&gt;

grateful_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; I don&amp;#39;t like this sweater you gave me!&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; I love the sweater! Thank you!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来看看如果不使用装饰器语法这个装饰器函数是如何工作的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# If we tried to invoke without an argument:&lt;/span&gt;
grateful_function = argumentative_function(grateful_function)

&lt;span style="color: #008000"&gt;# But when given an argument, the pattern changes to:&lt;/span&gt;
grateful_function = argumentative_decorator(&lt;span style="color: #a31515"&gt;&amp;quot;sweater&amp;quot;&lt;/span&gt;)(grateful_function)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要注意的地方是：当给定参数，首先仅以那些参数调用装饰器---被包装的函数并不在参数中。装饰器调用返回后，装饰器要包装的函数被传递给装饰器初始调用返回的函数（本例中，为 &lt;code&gt;argumentative_decorator("sweater")&lt;/code&gt; 的返回值）。&lt;/p&gt;
&lt;p&gt;逐步地：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解释器到达被装饰函数之处，编译 &lt;code&gt;grateful_function&lt;/code&gt; ，并将其绑定到名字'grateful_function'。&lt;/li&gt;
&lt;li&gt;传递参数"sweater"调用 &lt;code&gt;argumentative_decorator&lt;/code&gt; ，返回 &lt;code&gt;func_wrapper&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;以 &lt;code&gt;grateful_function&lt;/code&gt; 为参调用 &lt;code&gt;func_wrapper&lt;/code&gt; ，返回 &lt;code&gt;returned_wrapper&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;最后， &lt;code&gt;returned_wrapper&lt;/code&gt; 取代原来的函数 &lt;code&gt;grateful_function&lt;/code&gt; ，并绑定到名字'grateful_function' 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我想这一过程相比没有装饰器参数理解起来更难一点，但是如果你花些时间将其理解通透，我希望是有意义的。&lt;/p&gt;
&lt;h2&gt;带可选参数的装饰器&lt;/h2&gt;
&lt;p&gt;有多种方式让装饰器接受可选参数。根据你是想使用位置参数、关键字参数还是两者皆是，需要使用稍微不同的模式。如下我将展示一种接受一个可选关键字参数的方式：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; functools &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; wraps

GLOBAL_NAME = &lt;span style="color: #a31515"&gt;&amp;quot;Brian&amp;quot;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; print_name(function=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;, name=GLOBAL_NAME):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; actual_decorator(function):
        @wraps(function)
        &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; returned_func(*args, **kwargs):
            print &lt;span style="color: #a31515"&gt;&amp;quot;My name is &amp;quot;&lt;/span&gt; + name
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; function(*args, **kwargs)
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; returned_func

    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; function:    &lt;span style="color: #008000"&gt;# User passed in a name argument&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; waiting_for_func(function):
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; actual_decorator(function)
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; waiting_for_func

    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; actual_decorator(function)

@print_name
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; a_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;I like the name!&amp;quot;&lt;/span&gt;

@print_name(name=&lt;span style="color: #a31515"&gt;&amp;#39;Matt&amp;#39;&lt;/span&gt;)
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; another_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;Hey, that&amp;#39;s new!&amp;quot;&lt;/span&gt;

a_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; My name is Brian&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; I like that name!&lt;/span&gt;

another_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; My name is Matt&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; Hey, that&amp;#39;s new!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果我们传递关键字参数 &lt;code&gt;name&lt;/code&gt; 给 &lt;code&gt;print_name&lt;/code&gt;
，那么它的行为就与前一个例子中的 &lt;code&gt;argumentative_decorator&lt;/code&gt; 相似。即，首先以
&lt;code&gt;name&lt;/code&gt; 为参调用 &lt;code&gt;print_name&lt;/code&gt; 。然后，将待包装的函数传递给首次调用返回的函数。&lt;/p&gt;
&lt;p&gt;如果我们没有提供 &lt;code&gt;name&lt;/code&gt; 实参， &lt;code&gt;print_name&lt;/code&gt; 的行为就与前面我们看到的不带参数的装饰器一样。装饰器仅以待包装的函数作为唯一的参数进行调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print_name&lt;/code&gt;
支持两种可能性。它会检查是否收到作为参数的被包装函数。如果没有，则返回函数
&lt;code&gt;waiting_for_func&lt;/code&gt;
，该函数可以被包装函数作为参数进行调用。如果收到被包装函数作为参数，则跳过中间步骤，直接调用 &lt;code&gt;actual_decorator&lt;/code&gt; 。&lt;/p&gt;
&lt;h2&gt;串接装饰器&lt;/h2&gt;
&lt;p&gt;现在来探索一下今天要讲的最后一个装饰器的特性：串接。你可以在任意给定的函数之上堆叠使用多个装饰器， 这种构建函数的方式与使用多重继承构建类相类似。不过最好不要疯狂使用这种特性。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;@print_name(&lt;span style="color: #a31515"&gt;&amp;#39;Sam&amp;#39;&lt;/span&gt;)
@logging_decorator
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; some_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;I&amp;#39;m the wrapped function!&amp;quot;&lt;/span&gt;

some_function()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; My name is Sam&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; The function I modify has been called 1 time(s).&lt;/span&gt;
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; I&amp;#39;m the wrapped function!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当你串接使用装饰器时，它们堆叠的顺序是自底向上的。将被包装的函数 &lt;code&gt;some_function&lt;/code&gt; 经编译后传递给它之上的第一个装饰器（ &lt;code&gt;logging_decorator&lt;/code&gt; ）。然后第一个装饰器的返回值被传递给第二个装饰器。依此逐个应用链上每个装饰器。&lt;/p&gt;
&lt;p&gt;因为我们使用的两个装饰器都是 &lt;code&gt;print&lt;/code&gt;
一个值，然后执行传递给它们的函数，这意味着当调用被包装函数时，链中的最后一个装饰器 &lt;code&gt;print_name&lt;/code&gt; 打印输出中的第一行。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我认为装饰器最大的好处之一在于让你能够从更高的抽象层次进行思考。假如你开始阅读一个函数定义，看到有一个 &lt;code&gt;memoize&lt;/code&gt; 装饰器，你立刻就能明白你正在看的是一个使用缓存制表的函数。如果缓存制表的代码包含在函数体内，就会需要额外的脑力进行解析，并且会有引入误解的可能。使用装饰器也允许代码复用，从而节省时间、简化调试，并且使得重构更加容易。&lt;/p&gt;
&lt;p&gt;玩玩装饰器也是一种很好的学习函数式概念（如高阶函数与闭包）的方式。&lt;/p&gt;
&lt;p&gt;我希望本文阅读起来很愉快，并且内容翔实。&lt;/p&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>Python：字典剧本（译）</title><link href="http://youngsterxyf.github.io/2013/01/04/Python-The-Dictionary-Playbook-cn/" rel="alternate"></link><published>2013-01-04T00:00:00+08:00</published><updated>2013-01-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-04:/2013/01/04/Python-The-Dictionary-Playbook-cn/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://blog.amir.rachum.com/post/39501813266/python-the-dictionary-playbook"&gt;Python: The Dictionary Playbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我经常碰到关于Python中字典的各种样板代码，因此我决定在此展示一些，并分享完成相同操作的更加简洁的方式。&lt;/p&gt;
&lt;p&gt;上演： &lt;strong&gt;字典剧 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文： &lt;a href="http://blog.amir.rachum.com/post/39501813266/python-the-dictionary-playbook"&gt;Python: The Dictionary Playbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我经常碰到关于Python中字典的各种样板代码，因此我决定在此展示一些，并分享完成相同操作的更加简洁的方式。&lt;/p&gt;
&lt;p&gt;上演： &lt;strong&gt;字典剧本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="playbook" src="/assets/uploads/pics/The_playbook.png"&gt;&lt;/p&gt;
&lt;p&gt;1.
“你在吗？”&lt;/p&gt;
&lt;p&gt;这个相当简单，但不可错过 - 找出某个键(key)是否存在于字典中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;蹩脚的版本&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dct.has_key(key)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Pythonic的方式&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;key &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
“尤达测试”(译注：尤达的意思见&lt;a href="http://en.wikipedia.org/wiki/Yoda"&gt;yoda&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;对于那些掌握了“你在吗”剧本的程序员来说，这通常是另一个简单但是令人讨厌的事情。它不仅仅可用于字典数据类型，但非常普通。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;干这事，你必须不能这样&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;not&lt;/span&gt; key &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;英语，你会说吗？&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;key &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.
“无论如何也要得到其值”&lt;/p&gt;
&lt;p&gt;这个非常流行。你有一个字典和一个键，然后想修改这个键对应的值。例如，将该值加1（比方说你正在计算某些东西）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;样板&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; key &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct:
    dct[key] = 0
dct[key] = dct[ket] + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;巧妙的方式&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dct[key] = dct.get(key, 0) + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果存在该键， &lt;code&gt;dct.get(key[, default])&lt;/code&gt; 返回 &lt;code&gt;dct[key]&lt;/code&gt; ，否则返回 &lt;code&gt;default&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;更棒的方式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你使用Python 2.7，并且想统计元素的数目，可以使用&lt;a href="http://docs.python.org/2/library/collections.html#collections.Counter"&gt;Counter&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; d = [1, 1, 1, 2, 2, 3, 1, 1]
&amp;gt;&amp;gt;&amp;gt; Counter(d)
Counter({1: 5, 2: 2, 3: 1})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里有个更完整的例子：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; counter = Counter()
... for _ in range(10):
...     num = int(raw_input(&amp;quot;Enter a number: &amp;quot;))
...     counter.update([num]) 
...
... for key, value in counter.iteritems():
...     print &amp;quot;You have entered {}, {} times!&amp;quot;.format(key, value) 
Enter a number: 1
Enter a number: 1
Enter a number: 2
Enter a number: 3
Enter a number: 51
Enter a number: 1
Enter a number: 1
Enter a number: 1
Enter a number: 2
Enter a number: 3
You have entered 1, 5 times!
You have entered 2, 2 times!
You have entered 3, 2 times!
You have entered 51, 1 times!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.
“创造可能”(译注：这里"make it happen"还不知道该如何翻译)&lt;/p&gt;
&lt;p&gt;有时你的字典中包含可变对象，你想初始化并修改它们。比方你要把一些数据整理存入一个字典，其值是列表（示例来自&lt;a href="http://stackoverflow.com/questions/3483520/use-cases-for-the-setdefault-dict-method/3483652#3483652"&gt;Stack Overflow上的这个解答&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;详细说明&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dct = {}
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (key, value) &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; data:
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; key &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct:
        dct[key].append(value)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;:
        dct[key] = [value]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;以pythonic方式实现&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dct = {}
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (key, value) &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; data:
    group = dct.setdefault(key, [])     &lt;span style="color: #008000"&gt;#key可能已经存在&lt;/span&gt;
    group.append(value)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果键存在， &lt;code&gt;setdefault(key, [])&lt;/code&gt; 返回 &lt;code&gt;dct[key]&lt;/code&gt; ，否则将键对应的值设置为 &lt;code&gt;default&lt;/code&gt; 并返回。与 &lt;code&gt;get&lt;/code&gt; 相比，当缺省值是一个你可以修改的对象时，这种方式使你不需要将修改后的值再次插入字典中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Rocking it out&lt;/em&gt; (译注：真心不知道这句该如何翻译)&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dct = defaultdict(list)
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (key, value) &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; data:
    dct[key].append(value)      &lt;span style="color: #008000"&gt;# 所有键都有一个缺省值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;defaultdict&lt;/code&gt; 非常赞！不言自明 —— 带有缺省值的字典。这意味这每次访问 &lt;code&gt;dct&lt;/code&gt; 中的某个键，如果不存在（通常会抛出一个 &lt;code&gt;KeyError&lt;/code&gt; 异常），则以缺省值作为其值创建该键。这就好似使用 &lt;code&gt;setdefault&lt;/code&gt; 来完成每次访问。&lt;/p&gt;
&lt;p&gt;我发现 &lt;code&gt;defaultdict&lt;/code&gt; 的一个有趣用法是实现&lt;a href="http://en.wikipedia.org/wiki/Sparse_matrix"&gt;稀疏数据结构&lt;/a&gt;。设置好 &lt;em&gt;defaultdict&lt;/em&gt; 的缺省值，以坐标（或者任何合适的东西）作为其键。我曾这样去表示多维网格，肯定比使用复杂的列表嵌套简单得多。&lt;/p&gt;
&lt;p&gt;更有意思的一个使用示例见&lt;a href="https://gist.github.com/2012250"&gt;一行代码定义树&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>一行Python代码定义树（译）</title><link href="http://youngsterxyf.github.io/2013/01/04/one-line-tree-in-Python/" rel="alternate"></link><published>2013-01-04T00:00:00+08:00</published><updated>2013-01-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-04:/2013/01/04/one-line-tree-in-Python/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://gist.github.com/2012250"&gt;One-line Tree in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Python内置的&lt;a href="http://docs.python.org/2/library/collections.html#collections.defaultdict"&gt;defaultdict&lt;/a&gt;可以轻松定义一棵树：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; tree(): &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; defaultdict(tree)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就这样！&lt;/p&gt;
&lt;p&gt;这段代码简单地说明一棵树是一个字典，其缺省 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://gist.github.com/2012250"&gt;One-line Tree in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Python内置的&lt;a href="http://docs.python.org/2/library/collections.html#collections.defaultdict"&gt;defaultdict&lt;/a&gt;可以轻松定义一棵树：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; tree(): &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; defaultdict(tree)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就这样！&lt;/p&gt;
&lt;p&gt;这段代码简单地说明一棵树是一个字典，其缺省的值（译注：与键对应的值的概念）是树。&lt;/p&gt;
&lt;p&gt;（如果你正随着我写下代码，请先确保 &lt;code&gt;from collections import defaultdict&lt;/code&gt; ）&lt;/p&gt;
&lt;p&gt;（还有：Hacker News读者@zbuc指出这种方法被称为&lt;a href="https://en.wikipedia.org/wiki/Autovivification"&gt;自动唤醒&lt;/a&gt;。Cool！）&lt;/p&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;h3&gt;JSON形式&lt;/h3&gt;
&lt;p&gt;现在我们可以创建JSON式的嵌套字典，而无需显式创建子级字典——当我们引用它们，就会神奇地自动产生：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;users = tree()
users[&lt;span style="color: #a31515"&gt;&amp;#39;harold&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;] = &lt;span style="color: #a31515"&gt;&amp;#39;hrldcpr&amp;#39;&lt;/span&gt;
users[&lt;span style="color: #a31515"&gt;&amp;#39;handler&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;] = &lt;span style="color: #a31515"&gt;&amp;#39;matthandlersux&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以使用 &lt;code&gt;print(json.dumps(users))&lt;/code&gt; 将这棵树作为JSON打印出来（译注：先 &lt;code&gt;import json&lt;/code&gt; ），得到如下输出：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{&amp;quot;harold&amp;quot;: {&amp;quot;username&amp;quot;: &amp;quot;hrldcpr&amp;quot;}, &amp;quot;handler&amp;quot;: {&amp;quot;username&amp;quot;: &amp;quot;matthandlersux&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;无需赋值&lt;/h3&gt;
&lt;p&gt;我们甚至根本不用赋值操作就可以构建树结构：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;taxonomy = tree()
taxonomy[&lt;span style="color: #a31515"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Felidae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Felis&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;cat&amp;#39;&lt;/span&gt;]
taxonomy[&lt;span style="color: #a31515"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Felidae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Panthera&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;lion&amp;#39;&lt;/span&gt;]
taxonomy[&lt;span style="color: #a31515"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Canidae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Canis&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;dog&amp;#39;&lt;/span&gt;]
taxonomy[&lt;span style="color: #a31515"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Canidae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Canis&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;coyote&amp;#39;&lt;/span&gt;]
taxonomy[&lt;span style="color: #a31515"&gt;&amp;#39;Plantae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Solanales&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Solanaceae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Solanum&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;tomato&amp;#39;&lt;/span&gt;]
taxonomy[&lt;span style="color: #a31515"&gt;&amp;#39;Plantae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Solanales&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Solanaceae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Solanum&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;potato&amp;#39;&lt;/span&gt;]
taxonomy[&lt;span style="color: #a31515"&gt;&amp;#39;Plantae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Solanales&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Convolvulaceae&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;Ipomoea&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;sweet potato&amp;#39;&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这次我们打印得好看些，不过需要先将其转换成标准字典：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; dicts(t): &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; {k: dicts(t[k]) &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; k &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; t}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在可以使用 &lt;code&gt;pprint(dicts(taxonomy))&lt;/code&gt; 漂亮地打印该数据结构（译注：先 &lt;code&gt;from pprint import pprint&lt;/code&gt; ）：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{&amp;#39;Animalia&amp;#39;: {&amp;#39;Chordata&amp;#39;: {&amp;#39;Mammalia&amp;#39;: {&amp;#39;Carnivora&amp;#39;: {&amp;#39;Canidae&amp;#39;: {&amp;#39;Canis&amp;#39;: {&amp;#39;coyote&amp;#39;: {},
                                                                            &amp;#39;dog&amp;#39;: {}}},
                                                      &amp;#39;Felidae&amp;#39;: {&amp;#39;Felis&amp;#39;: {&amp;#39;cat&amp;#39;: {}},
                                                                  &amp;#39;Panthera&amp;#39;: {&amp;#39;lion&amp;#39;: {}}}}}}},
 &amp;#39;Plantae&amp;#39;: {&amp;#39;Solanales&amp;#39;: {&amp;#39;Convolvulaceae&amp;#39;: {&amp;#39;Ipomoea&amp;#39;: {&amp;#39;sweet potato&amp;#39;: {}}},
                           &amp;#39;Solanaceae&amp;#39;: {&amp;#39;Solanum&amp;#39;: {&amp;#39;potato&amp;#39;: {},
                                                      &amp;#39;tomato&amp;#39;: {}}}}}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们引用的子级结构都以字典形式存在，叶子为空字典。&lt;/p&gt;
&lt;h3&gt;迭代&lt;/h3&gt;
&lt;p&gt;迭代遍历这棵树会比较有趣，也是因为结构在引用的时候就会自动产生。&lt;/p&gt;
&lt;p&gt;例如，假设我们正在解析一个新动物的列表，添加到上面的 &lt;code&gt;taxonomy&lt;/code&gt; 中，我们希望调用如下这样的一个函数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;add(taxonomy, &lt;span style="color: #a31515"&gt;&amp;#39;Animalia,Chordata,Mammalia,Cetacea,Balaenopteridae,Balaenoptera,blue whale&amp;#39;&lt;/span&gt;.split(&lt;span style="color: #a31515"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以简单地这样实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; add(t, keys):
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; key &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; keys:
        t = t[key]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再一次我们根本没有对字典赋值，仅通过引用这些键就创建了新的结构：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{&amp;#39;Animalia&amp;#39;: {&amp;#39;Chordata&amp;#39;: {&amp;#39;Mammalia&amp;#39;: {&amp;#39;Carnivora&amp;#39;: {&amp;#39;Canidae&amp;#39;: {&amp;#39;Canis&amp;#39;: {&amp;#39;coyote&amp;#39;: {},
                                                                            &amp;#39;dog&amp;#39;: {}}},
                                                      &amp;#39;Felidae&amp;#39;: {&amp;#39;Felis&amp;#39;: {&amp;#39;cat&amp;#39;: {}},
                                                                  &amp;#39;Panthera&amp;#39;: {&amp;#39;lion&amp;#39;: {}}}},
                                        &amp;#39;Cetacea&amp;#39;: {&amp;#39;Balaenopteridae&amp;#39;: {&amp;#39;Balaenoptera&amp;#39;: {&amp;#39;blue whale&amp;#39;: {}}}}}}},
 &amp;#39;Plantae&amp;#39;: {&amp;#39;Solanales&amp;#39;: {&amp;#39;Convolvulaceae&amp;#39;: {&amp;#39;Ipomoea&amp;#39;: {&amp;#39;sweet potato&amp;#39;: {}}},
                           &amp;#39;Solanaceae&amp;#39;: {&amp;#39;Solanum&amp;#39;: {&amp;#39;potato&amp;#39;: {},
                                                      &amp;#39;tomato&amp;#39;: {}}}}}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这个可能不是很有用，且需要一些令人费解的代码（见如上 &lt;code&gt;add()&lt;/code&gt; ）。但是如果你喜欢Python，我希望这个会让你觉得有趣或者值得去理解。&lt;/p&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>几个组合命令</title><link href="http://youngsterxyf.github.io/2012/12/12/several-command-line/" rel="alternate"></link><published>2012-12-12T00:00:00+08:00</published><updated>2012-12-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-12:/2012/12/12/several-command-line/</id><summary type="html">&lt;p&gt;1.
Debian系Linux下查找某个软件包(以indent为例)：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-cache search indent | awk &lt;span style="color: #a31515"&gt;&amp;#39;{if($1~/^indent$/) print $0}&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;APT包管理工具也提供了类似功能的命令选项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-cache pkgnames &lt;span style="color: #a31515"&gt;&amp;#39;indent&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只不过这个输出仅有包名没有简介信息。&lt;/p&gt;
&lt;p&gt;2.
对当前目录下的所有C源码文件使用indent进行格式化：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls | grep &lt;span style="color: #a31515"&gt;&amp;#39;\.c$&amp;#39;&lt;/span&gt; | xargs indent …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;1.
Debian系Linux下查找某个软件包(以indent为例)：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-cache search indent | awk &lt;span style="color: #a31515"&gt;&amp;#39;{if($1~/^indent$/) print $0}&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;APT包管理工具也提供了类似功能的命令选项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-cache pkgnames &lt;span style="color: #a31515"&gt;&amp;#39;indent&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只不过这个输出仅有包名没有简介信息。&lt;/p&gt;
&lt;p&gt;2.
对当前目录下的所有C源码文件使用indent进行格式化：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls | grep &lt;span style="color: #a31515"&gt;&amp;#39;\.c$&amp;#39;&lt;/span&gt; | xargs indent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其实如下也是可以的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;indent *.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但因为shell会对*进行展开，如果当前目录下的C源码文件数目很大时，可能会造成命令行长度过长的问题。&lt;/p&gt;</content><category term="其他"></category><category term="Linux"></category><category term="命令行"></category></entry><entry><title>高性能MySQL - 1.MySQL架构</title><link href="http://youngsterxyf.github.io/2012/12/11/high-performance-MySQL-1/" rel="alternate"></link><published>2012-12-11T00:00:00+08:00</published><updated>2012-12-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-11:/2012/12/11/high-performance-MySQL-1/</id><summary type="html">&lt;h2&gt;MySQL逻辑架构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="mysql-arch" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/mysql-arch.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1.
每个客户连接在服务器进程中都拥有自己的线程，每个连接所属的查询都会在指定的某个单独线程中完成，这些线 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;MySQL逻辑架构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="mysql-arch" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/mysql-arch.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1.
每个客户连接在服务器进程中都拥有自己的线程，每个连接所属的查询都会在指定的某个单独线程中完成，这些线程轮流运行在某个CPU核心或CPU上。服务器负责缓存线程，因此不需要为每个新的连接重建或撤销线程。&lt;/p&gt;
&lt;p&gt;2.
MySQL会解析查询，并创建一个内部数据结构(解析树)，然后对其进行各种优化。其中包括重写查询，决定查询的读表顺序，以及选择需使用的索引等。用户可以通过特殊的关键字给优化器传递各种提示，影响它的决策过程。另外还可以请求服务器给出优化过程的各种说明，使用户可以知晓服务器是如何进行优化决策的，为用户提供一个参考基准，方便用户重写查询、架构和修改相关配置，便于应用尽可能高效地运行。&lt;/p&gt;
&lt;p&gt;优化器并不关心某个表使用哪种存储引擎，但存储引擎对服务器的查询优化过程有影响。优化器会请求存储引擎为某种具体操作提供性能与开销方面的信息，以及表内数据的统计信息。&lt;/p&gt;
&lt;p&gt;不过，在解析查询之前，服务器会"询问"查询缓存，它只能保存SELECT语句和相应的结果。如果能在缓存中找到将要执行的查询，服务器就不必重新解析、优化或重新执行查询，只需直接返回已有结果即可。&lt;/p&gt;
&lt;h2&gt;并发控制&lt;/h2&gt;
&lt;p&gt;1.
读锁(Read Lock)/写锁(Write Lock)：并发控制的概念很简单-在处理并发写或并发读时，系统会使用一套锁系统来解决问题。这种锁系统由两类锁组成，通常称之为 &lt;strong&gt;共享锁&lt;/strong&gt; (Shared Lock)和 &lt;strong&gt;排他锁&lt;/strong&gt; (Exclusive Lock)，或者叫 &lt;strong&gt;读锁&lt;/strong&gt; (Read Lock)和 &lt;strong&gt;写锁&lt;/strong&gt; (Write Lock)。&lt;/p&gt;
&lt;p&gt;2.
锁粒度(Lock Granularity)：一种提高共享资源并发性的方法就是让锁定对象更有选择性。要记住只锁定部分需修改的数据，而不是所有的资源。任何时间，在给定的资源上，被加锁的数据量越小，就可以允许更多的并发修改，只要相互之间互不冲突即可。问题是加锁也会消耗系统资源。每一种锁操作，如获得锁、检查锁是否已解除，以及释放锁等，都会增加系统的开销。所谓的锁策略，就是在锁开销和数据安全之间寻求一种平衡。为此，MySQL提供了多种选择。每种MySQL存储引擎都可以实现独有的锁策略或锁粒度。&lt;/p&gt;
&lt;p&gt;表锁(Table Lock)：开销最小的锁策略&lt;/p&gt;
&lt;p&gt;行级锁(Row Locks)：最大并发处理的锁策略&lt;/p&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;p&gt;事务是一组原子性的SQL查询语句，也可以被看作一个工作单元。如果数据库引擎能够成功地对数据库应用所有的查询语句，它就会执行所有查询，但是，如果任何一条查询语句因为崩溃或其他原因而无法执行，那么所有的语句就都不会执行。也就是说，事务内的语句要么全部执行，要么一句也不执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;原子性(Atomicity) - 一个事务必须被视为一个单独的内部"不可分"的工作单元，以确保整个事务要么全部执行，要么全部回滚。&lt;/p&gt;
&lt;p&gt;一致性(Consistency) - 数据库总是从一种一致性状态转换到另一种一致性状态。&lt;/p&gt;
&lt;p&gt;隔离性(Isolation) - 某个事务的结果只有在完成后才对其他事务可见。&lt;/p&gt;
&lt;p&gt;持久性(Durability) - 一旦一个事务提交，事务所做的数据改变将是永久的。&lt;/p&gt;
&lt;p&gt;1.
隔离级：SQL标准定义了4类隔离级，&lt;/p&gt;
&lt;p&gt;READ UNCOMMITTED(读取未提交内容) - 在READ UNCOMMITTED隔离级，所有事务都可以"看到"未提交事务的执行结果。在这种级别上，可能会产生很多问题，所以很少用于实际应用。读取未提交数据，也被称为" &lt;strong&gt;脏读&lt;/strong&gt; "(Dirty Read)。&lt;/p&gt;
&lt;p&gt;READ COMMITTED(读取提交内容) - 大多数数据库系统的默认隔离级别是READ COMMITTED(但这不是MySQL默认的！)。它满足了隔离性的早先定义。也支持所谓的" &lt;strong&gt;不可重复读&lt;/strong&gt; "(Nonrepeatable Read)。这意味着用户运行同一语句两次，看到的结果是不同的。&lt;/p&gt;
&lt;p&gt;REPEATABLE READ(可重复读) - 确保同一事务的多个实例在并发读取数据时，会"看到同样的"数据行。不过理论上，这会导致另一个问题： &lt;strong&gt;幻读&lt;/strong&gt; (Phantom Read)。简单来说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的"幻影"行。InnoDB和Falcon存储引擎通过多版本并发控制机制解决了幻读问题。（MySQL的默认事务隔离级）&lt;/p&gt;
&lt;p&gt;SERIALIZABLE(可串行化) - 最高级别的隔离级，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，SERIALIZABLE是在每个读的数据行上加锁。在这个级别，可能导致大量的超时(Timeout)现象和锁竞争(Lock Contention)现象&lt;/p&gt;
&lt;h2&gt;多版本并发控制&lt;/h2&gt;
&lt;p&gt;MVCC(Multiversion Concurrency Control)是通过及时保存在某些时刻的数据快照，而得以实现的。这意味着同一事务的多个实例，在同时运行时，无论实例运行多久，它们看到的数据视图是一致的。而同一时间，对于同一张表，不同事务看到的数据却是不同的。&lt;/p&gt;
&lt;p&gt;InnoDB通过为每个数据行增加两个隐含值的方式来实现MVCC。这两个隐含值记录了行的创建时间，以及它的过期时间(或者叫删除时间)
。每一行都存储了事件发生时的系统版本号，用来替代事件发生时的实际时间。每一次，开始一个新事务时，版本号都会自动递增。每个事务都会保存它在开始时的"当前系统版本"
的记录，而每个查询都会根据事务的版本号，检查每行数据的版本号。&lt;/p&gt;
&lt;h2&gt;MySQL的存储引擎&lt;/h2&gt;
&lt;p&gt;在文件系统中，MySQL会把每个数据库保存为数据目录下的一个子目录。当创建一个表时，MySQL会在和表名同名的、以.frm为后缀的文件中存储表的定义。因为MySQL使用文件系统来存储数据库名和表定义，大小写敏感将依赖于具体的平台。在Windows平台上，MySQL的实例(Instance)名、表名、数据库名都是大小写不敏感的; 在Unix类平台上，则是大小写敏感的。&lt;/p&gt;
&lt;p&gt;1.
&lt;strong&gt;MyISAM引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，MyISAM将每个表存为两个文件：数据文件和索引文件。两个文件的扩展名分别为.MYD和.MYI。MyISAM的格式是平台通用的，这意味着用户可以在不同架构的服务器上毫无问题地相互拷贝数据文件和索引文件。&lt;/p&gt;
&lt;p&gt;MyISAM表可以包含动态行和静态行(即固定长度行)。MySQL会根据表定义决定选用何种格式。MyISAM表的可容纳的行总数，一般只受限于数据库服务器的可用磁盘空间大小，以及操作系统允许创建的最大文件大小。&lt;/p&gt;
&lt;p&gt;MyISAM的特性：&lt;/p&gt;
&lt;p&gt;-加锁与并发 - MyISAM对整张表进行加锁，而不是行。&lt;/p&gt;
&lt;p&gt;-...&lt;/p&gt;
&lt;p&gt;2.
&lt;strong&gt;InnoDB引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB专为事务处理设计的一款存储引擎，特别是用于处理大量短期(Short-lived)事务，短期事务是指一般能正常完成，不需要回滚的事务。&lt;/p&gt;
&lt;p&gt;InnoDB将所有数据共同存储在一个或几个数据文件中，这种数据文件一般称之为 &lt;strong&gt;表空间&lt;/strong&gt; 。在MySQL 4.1版以及更新版本中，InnoDB也支持将每个表和相关索引存储为单独的分离文件。&lt;/p&gt;
&lt;p&gt;InnoDB使用MVCC机制获取高并发性能，并且实现所有四个标准隔离级别。默认隔离级别是REPEATABLE READ，在这个隔离级上，使用间隙锁策略防止"幻读"问题的产生。&lt;/p&gt;
&lt;p&gt;InnoDB表是基于 &lt;strong&gt;聚簇索引&lt;/strong&gt;
建立的，能提供一种非常快速的主键查找性能。不过，它的辅助索引(Secondary Index，也就是非主键索引)也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义很多索引，则争取尽量把主键定义得小一些。InnoDB不会压缩索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择合适的引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑的因素：事务，并发，备份，崩溃后恢复，特有特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高性能MySQL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://cupoy.iteye.com/blog/251796"&gt;什么是脏读、不可重复读、幻读&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="数据库"></category><category term="MySQL"></category></entry><entry><title>日志信息命令行实时输出</title><link href="http://youngsterxyf.github.io/2012/12/10/tail-and-xtail/" rel="alternate"></link><published>2012-12-10T00:00:00+08:00</published><updated>2012-12-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-10:/2012/12/10/tail-and-xtail/</id><summary type="html">&lt;p&gt;Web开发中很多时候需要边看web服务器的日志输出边调试代码。一般的做法使用tail命令输出日志文件的末尾几行日志信息。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tail -10 /var/log/nginx/access.log  &lt;span style="color: #008000"&gt;# 输出末尾10行&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但这样的输出是静态的。在这个命令执行之后，日志文件里新增的日志 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Web开发中很多时候需要边看web服务器的日志输出边调试代码。一般的做法使用tail命令输出日志文件的末尾几行日志信息。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tail -10 /var/log/nginx/access.log  &lt;span style="color: #008000"&gt;# 输出末尾10行&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但这样的输出是静态的。在这个命令执行之后，日志文件里新增的日志信息无法直接看到。调试的时候，一遍又一遍地使用这样的命令去查询就显得非常麻烦。那有没有办法来监听日志文件的变化，实时输出最新的日志信息呢？ &lt;strong&gt;xtail&lt;/strong&gt; 就专为这个问题而存在的。它可以监听文件或者目录(监听目录就是监听该目录下的所有文件)。比如我在写本文时，在另一个命令行窗口里执行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;xtail ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么每次vim保存内容时，那个窗口就会产生事件输出最新的文件内容。&lt;/p&gt;
&lt;p&gt;这样在调试web程序的时候就很方便啦。&lt;/p&gt;
&lt;p&gt;其实tail本身就支持监听文件并实时命令行输出。在xtail的&lt;a href="http://www.unicom.com/sw/xtail"&gt;项目主页&lt;/a&gt;上有这样的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xtail watches the growth of files. It's like running a tail -f on a bunch of files at once. My favorite usage is:&lt;/p&gt;
&lt;p&gt;$ xtail /var/log/*&lt;/p&gt;
&lt;p&gt;You can specify both filenames and directories on the command line. If you specify a directory, it watches all the files in that directory. It will notice when new files are created (and start watching them) or when old files are deleted (and stop watching them).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从中可以看出，tail的-f选项是支持文件监听并实时输出的。tail的man page里说明如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-f, --follow[={name|descriptor}]&lt;/p&gt;
&lt;p&gt;output appended data as the file grows; -f,  --follow,  and --follow=descriptor are equivalent
&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="其他"></category><category term="linux"></category><category term="命令"></category><category term="调试"></category></entry><entry><title>VMware面试题目总结</title><link href="http://youngsterxyf.github.io/2012/12/06/VMware-interview/" rel="alternate"></link><published>2012-12-06T00:00:00+08:00</published><updated>2012-12-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-06:/2012/12/06/VMware-interview/</id><summary type="html">&lt;p&gt;&lt;strong&gt;一面&lt;/strong&gt;中主要有三道题：&lt;/p&gt;
&lt;p&gt;1.
实现strcpy。函数原型：char&lt;em&gt; strcpy(char&lt;/em&gt; dest, const char* src)。&lt;/p&gt;
&lt;p&gt;后来发现自己实现的有问题。正确的实现应该如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* strcpy(&lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* dest, &lt;span style="color: #0000ff"&gt;const …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;一面&lt;/strong&gt;中主要有三道题：&lt;/p&gt;
&lt;p&gt;1.
实现strcpy。函数原型：char&lt;em&gt; strcpy(char&lt;/em&gt; dest, const char* src)。&lt;/p&gt;
&lt;p&gt;后来发现自己实现的有问题。正确的实现应该如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* strcpy(&lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* dest, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* src)
{
    assert(dest!=NULL &amp;amp;&amp;amp; src!=NULL);
    &lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* ret = dest;
    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt;((*dest++ = *src++) != &lt;span style="color: #a31515"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;);
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个题目做得不好，我对自己很失望啊。&lt;/p&gt;
&lt;p&gt;2.
给2n+1个数，其中n个数均出现了2次，有1个数只出现了1次，如何找出这个数？&lt;/p&gt;
&lt;p&gt;如果用python的dict数据结构来实现会很简单，一次遍历统计每个数出现的次数就可以了。如果是这样的话，就不需要将题目限制为只有一个1个数只出现了一次了，所以肯定有更好的算法。&lt;/p&gt;
&lt;p&gt;其实更好的方法是这样的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; findAppearOnce(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *array, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; len){
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; result=0;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; i=0;i&amp;lt;len;i++)
        result^=array[i];
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为两个相同的数异或的结果是0。&lt;/p&gt;
&lt;p&gt;3.
Linux内核态和用户态的区别？进程与线程的区别？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二面&lt;/strong&gt;主要考察英语口语和听力，不记得是否有算法题了，好像没有。英语说得结结巴巴的，幸好交流还不是很困难。&lt;/p&gt;
&lt;p&gt;除英语外，还有问题：&lt;/p&gt;
&lt;p&gt;1.
项目中遇到过的有难度的问题有哪些？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三面&lt;/strong&gt;的面试官感觉各种懂啊，根据我的简历中涉及的相关知识进行提问，各种不会，我真是弱暴了。&lt;/p&gt;
&lt;p&gt;1.
网络数据包如何从网络结点A经过路由器到达结点B？数据包的MAC header和IP eader各主要包含了什么数据？在经过路由器时发生了什么变化？&lt;/p&gt;
&lt;p&gt;2.
git merge？因为我说没用过git的merge功能，因为我github上的项目都是个人项目，所有代码都在master主干上提交的，所以面试官就没在继续问，估计是想问问merge的原理吧？&lt;/p&gt;
&lt;p&gt;3.
有三个文件，找出在三个文件中均出现过的byte。返回的结果是一个byte类型的数组。&lt;/p&gt;
&lt;p&gt;我当时的基本思路和一面中第2道题目的思路差不多，也是遍历三个文件，dict的key为byte值，value为出现过该byte的文件。但这样占的内存有点大。(后来想想，其实还好啦，byte就8位，也就256个不同的值)&lt;/p&gt;
&lt;p&gt;另一个稍微改进一点的方法是：在三个文件中均出现过的byte，也就是三个文件中byte集合的交集。所以可以选取最小的文件，以其中的byte做key，遍历第二个文件，对在1,2文件中均出现的byte设置value标记。第二个文件遍历完成后，取出做过value标记的byte(设为集合X)，然后遍历第三个文件，对在X和第三个文件中均出现的byte做标记，第三个文件遍历完成后，做过value标记的byte即为结果。但这应该不是最佳算法。还有待继续思考。&lt;/p&gt;
&lt;p&gt;更新：同学给出的方案是-使用bitmap，每个文件弄个256位的bitmap，出现的byte就在相应的位上置1，然后三个bitmap按位与一下。靠谱！&lt;/p&gt;
&lt;p&gt;4.
不使用微博的API，使用爬虫尽可能多地抓取某个人(比如李开复)的直接粉丝和间接粉丝(随便有多间接)？如何避免重复抓取相同的粉丝数据？&lt;/p&gt;
&lt;p&gt;5.
前段时间有人说对于JAVA的hash函数(应该是hashCode()方法)，一定规律的多个数都可以生成相同的hash值，对于这个问题，在应用中应该如何解决？&lt;/p&gt;
&lt;p&gt;我的思路是在hash之前，对待hash的值加盐(salt)混合再hash。&lt;/p&gt;
&lt;p&gt;6.
TCP与UDP的区别？UDP主要用于哪些方面？TCP连接3次握手，断开连接4次握手，为什么要4次握手？&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;连接终止使用了四路握手过程(four-way handshake)，在这个过程中每个终端的连接都能独立地被终止。因此，一个典型的拆接过程需要每个终端都提供一对FIN和ACK。而建立连接始终是由客户端发起连接的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7.
访问某些网站时，请求结果是“连接被重置”的报告，那么连接被重置的原理是什么？&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;连接被重置的本质，是因为收到了破坏连接的一个 TCP Reset 包
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;具体可参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;“西厢计划”原理小解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.google.com/p/scholarzhang/"&gt;“西厢计划”项目主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chinagfw.org/2010/05/tcpgfw.html"&gt;对TCP连接被重置解决方案的探究――跨过GFW通向自由网络的可行途径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hi.baidu.com/gmbiarxfezhmuxe/item/4ac2d1f218abbe1be3e3bd4d"&gt;简述TCP三次握手过程，并说明为什么要3次握手&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;VMware的工作环境很不错，各种Mac，屏幕超大啊(这显得我很diaosi啊)，面试官也很不错，问题也比较有水平。可惜我今天的状态实在不好，各种不会，铁定跪了。唉！diaosi的命。&lt;/p&gt;</content><category term="其他"></category><category term="VMware"></category><category term="面试"></category></entry><entry><title>博大精深的ps命令</title><link href="http://youngsterxyf.github.io/2012/12/06/profound-ps/" rel="alternate"></link><published>2012-12-06T00:00:00+08:00</published><updated>2012-12-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-06:/2012/12/06/profound-ps/</id><summary type="html">&lt;p&gt;Linux命令行里如何获取所有的进程号(pid)？&lt;/p&gt;
&lt;p&gt;1.
第一种方法是通过ps -e或者ps aux获得所有进程的信息，然后通过管道传给grep或者awk进行数据过滤，比如&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -e | awk &lt;span style="color: #a31515"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
其实通过ps自身的选项就可以实现： &lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -eo pid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而且输出还是排好序的。&lt;/p&gt;
&lt;p&gt;但 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Linux命令行里如何获取所有的进程号(pid)？&lt;/p&gt;
&lt;p&gt;1.
第一种方法是通过ps -e或者ps aux获得所有进程的信息，然后通过管道传给grep或者awk进行数据过滤，比如&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -e | awk &lt;span style="color: #a31515"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
其实通过ps自身的选项就可以实现： &lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -eo pid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而且输出还是排好序的。&lt;/p&gt;
&lt;p&gt;但ps命令在输出进程信息之前先输出一行header，比如ps -e的输出header是：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;PID TTY          TIME CMD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如何去除这个header呢？当然用各种过滤方法可以实现，但ps自身的选项也可以实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -eo pid h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -eo pid --no-headers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Linux"></category><category term="命令行"></category><category term="工具"></category></entry><entry><title>2012校招-sonicWALL的两道编程笔试题</title><link href="http://youngsterxyf.github.io/2012/12/05/sonicWALL-exam/" rel="alternate"></link><published>2012-12-05T00:00:00+08:00</published><updated>2012-12-05T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-05:/2012/12/05/sonicWALL-exam/</id><summary type="html">&lt;h2&gt;求二叉树中两个结点的最近公共祖先&lt;/h2&gt;
&lt;p&gt;比如：对于树&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;         A
       /
      B
    /   \
   C     D
 /   \
E     F
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;p&gt;结点D，F的最近公共祖先为B&lt;/p&gt;
&lt;p&gt;实现：&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/nearest_common_ancestor.c"&gt;见源码&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;求二进制整数部分bits求反后的值&lt;/h2&gt;
&lt;p&gt;比如：对于整 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;求二叉树中两个结点的最近公共祖先&lt;/h2&gt;
&lt;p&gt;比如：对于树&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;         A
       /
      B
    /   \
   C     D
 /   \
E     F
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;p&gt;结点D，F的最近公共祖先为B&lt;/p&gt;
&lt;p&gt;实现：&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/nearest_common_ancestor.c"&gt;见源码&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;求二进制整数部分bits求反后的值&lt;/h2&gt;
&lt;p&gt;比如：对于整数0b1001101，将第2(begin)到第5(end)位(从右往左计数)上的bit求反，得到0b1110001。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;#include&lt;/span&gt; &lt;span style="color: #008000"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&lt;/span&gt;

&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; reverse_somebits(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; a, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; begin, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; end)
{
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; a^((1&amp;lt;&amp;lt;end)|((1&amp;lt;&amp;lt;end)-1))^((1&amp;lt;&amp;lt;begin)-1);
}

&lt;span style="color: #2b91af"&gt;void&lt;/span&gt; ten_to_two(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; a)
{
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(a &amp;lt; 2)
        printf(&lt;span style="color: #a31515"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;, a);
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;{
        ten_to_two(a/2);
        printf(&lt;span style="color: #a31515"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;, a%2);
    }
}

&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; main()
{
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; a = 0b1001101;
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; begin = 2, end = 5;
    printf(&lt;span style="color: #a31515"&gt;&amp;quot;0b&amp;quot;&lt;/span&gt;);
    ten_to_two(reverse_somebits(a, begin, end));
    printf(&lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;);
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注：我的思路没这么简洁，感谢&lt;a href="https://github.com/tinytitan"&gt;涛总&lt;/a&gt;提供这么好的方法。&lt;/p&gt;</content><category term="其他"></category><category term="笔试"></category><category term="算法"></category></entry><entry><title>CentOS + rsync + inotify-tools实时备份配置</title><link href="http://youngsterxyf.github.io/2012/11/29/centos+rsync+inotify-tools-realtime-backup/" rel="alternate"></link><published>2012-11-29T00:00:00+08:00</published><updated>2012-11-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-29:/2012/11/29/centos+rsync+inotify-tools-realtime-backup/</id><summary type="html">&lt;p&gt;现实中，服务器可能会因为各种原因而crash掉，从而造成数据丢失或者服务的暂时不可用。为了提高服务的可用性以及数据的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;现实中，服务器可能会因为各种原因而crash掉，从而造成数据丢失或者服务的暂时不可用。为了提高服务的可用性以及数据的安全性，就需要对数据进行备份，以便数据恢复或者服务的动态切换(将访问请求动态重定向到备份服务器)。&lt;/p&gt;
&lt;p&gt;常见的备份方法是定时的rsync任务或者远程拷贝。但这种方式，如果定时的间隔较大，那么服务器宕掉后，还是会丢失部分数据，动态切换的服务也不是宕机前的最新状态。为了支持实时数据同步，Linux 2.6.13 内核中新引入文件系统变化通知机制inotify，一旦对文件系统有改动，就会触发相关事件任务。通过结合rsync，inotify能够很好地完成实时同步任务。&lt;/p&gt;
&lt;p&gt;主服务器：1.1.1.1
备份服务器：0.0.0.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.
主服务器，备份服务器上安装rsync:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo yum install rsync
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
主服务器上安装inotify-tools:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo yum install inotify-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.
备份服务器上添加配置文件/etc/rsyncd.conf&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;readonly=no
chroot=no
uid=root
gid=root
hosts allow=1.1.1.1
hosts deny=0.0.0.0/32
max connections=10
log file=/var/log/rsyncd.log
pid file=/var/run/rsyncd.pid
lock file=/var/run/rsync.lock
auth users=tongbu
secrets file=/etc/rsync.pass

[website1]
path=/home/yongfeng/apps/website1.org/webroot/upload

[website2]
path=/home/yongfeng/apps/website2.com/webroot/upload

[website3]
path=/home/yongfeng/apps/website3.com/webroot/upload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以及配置文件/etc/rsync.pass&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tongbu:somesecurepassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;给密码文件赋权:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod 400 /etc/rsync.pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（注：tongbu就是用户名，与rsyncd.conf中auth users的值一致。somesecurepassword是密码，会在后面主服务器上的配置密码文件用到）&lt;/p&gt;
&lt;p&gt;4.
在备份服务器上创建需要的目录:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo mkdir -p /home/yongfeng/apps/website1.org/webroot/upload
sudo mkdir -p /home/yongfeng/apps/website2.com/webroot/upload
sudo mkdir -p /home/yongfeng/apps/website3.com/webroot/upload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.
在主服务器上添加配置文件/etc/rsync-client.pass：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;somesecurepassword
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;赋权限:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;chmod 600 /etc/rsync-client.pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.
在主服务器上添加要执行的脚本/home/autoscript/rsyncInotify.sh:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;#!/bin/sh&lt;/span&gt;
src[0]=&lt;span style="color: #a31515"&gt;&amp;#39;/var/www/apps/website1.org/webroot/upload,website1&amp;#39;&lt;/span&gt;
src[1]=&lt;span style="color: #a31515"&gt;&amp;#39;/var/www/apps/website2.com/webroot/upload,website2&amp;#39;&lt;/span&gt;
src[2]=&lt;span style="color: #a31515"&gt;&amp;#39;/var/www/apps/website3.com/webroot/upload,website3&amp;#39;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;src[@]&lt;span style="color: #a31515"&gt;}&lt;/span&gt;; &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
    fromdir=&lt;span style="color: #a31515"&gt;`&lt;/span&gt;echo $item | awk -F&lt;span style="color: #a31515"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;{print $1}&amp;#39;`&lt;/span&gt;
    module=&lt;span style="color: #a31515"&gt;`&lt;/span&gt;echo $item | awk -F&lt;span style="color: #a31515"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;#39;{print $2}&amp;#39;`&lt;/span&gt;

    /usr/bin/inotifywait -mrq --timefmt &lt;span style="color: #a31515"&gt;&amp;#39;%d/%m/%y %H:%M&amp;#39;&lt;/span&gt; --format &lt;span style="color: #a31515"&gt;&amp;#39;%T%w%f&amp;#39;&lt;/span&gt; --event modify,delete,move,create,attrib &lt;span style="color: #a31515"&gt;${&lt;/span&gt;fromdir&lt;span style="color: #a31515"&gt;}&lt;/span&gt; | &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; read file event
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        echo $event&lt;span style="color: #a31515"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;$file
        rsync -avz --delete --password-file=/etc/rsync-client.pass &lt;span style="color: #a31515"&gt;${&lt;/span&gt;fromdir&lt;span style="color: #a31515"&gt;}&amp;#39;/&amp;#39;&lt;/span&gt; tongbu@0.0.0.0::&lt;span style="color: #a31515"&gt;${&lt;/span&gt;module&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;*******************************&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt; &amp;amp;
&lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;赋可执行权限:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod +x rsyncInotify.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7.
在备份服务器的防火墙中添加规则以允许rsync服务请求---可通过直接编辑文件/etc/sysconfig/iptables，在文件中添加一行内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-A INPUT -s 1.1.1.1 -p tcp -m tcp --dport 873 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8.
备份服务器启动rsync服务:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /usr/bin/rsync --daemon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;9.
主服务器启动rsync+inotify服务:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo /home/autoscript/tongbu/rsyncInotify.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;10.
在备份服务器上将rsync服务设置为开机自启动服务---直接编辑配置文件/etc/rc.d/rc.local，添加一行内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/usr/bin/rsync --daemon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;11.
在主服务器上将rsyncInotify.sh设置为开始自启动---直接编辑配置文件/etc/rc.d/rc.local，添加一行内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/home/autoscript/tongbu/rsyncInotify.sh &amp;gt;&amp;gt; /home/autoscript/tongbu/tongbu.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.由于rsync命令并没有提供start, stop或者restart等选项，所以想关闭rsync服务，可直接使用sudo pkill rsync杀死rsync服务进程(额，这样是不是过分了点？但我想到的最简便的方法就是这个了)&lt;/p&gt;
&lt;p&gt;2.同样rsyncInotify.sh也存在这样的问题，即使使用sudo pkill rsyncInotify.sh杀死了进程还不够，因为rsyncInotify.sh脚本中调用了inotifywait命令，所以还得sudo pkill inotifywait，否则可能会因为inotifywait进程开得太多，而无法正常运行rsyncInotify.sh。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://jasonyu.cn/post/271/"&gt;rsync+inotify实现目录实时同步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.leezhong.com/project/2010/12/13/inotify-rsync.html"&gt;inotify-rsync实时同步脚本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href="http://www.lvtao.net/html/1968.html"&gt;rsync常见错误&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="服务器"></category><category term="工具"></category><category term="Linux"></category></entry><entry><title>GoAccess用户手册（译）</title><link href="http://youngsterxyf.github.io/2012/11/29/goaccess-man-page-cn/" rel="alternate"></link><published>2012-11-29T00:00:00+08:00</published><updated>2012-11-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-29:/2012/11/29/goaccess-man-page-cn/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://goaccess.prosoftcorp.com/man"&gt;http://goaccess.prosoftcorp.com/man&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译：youngsterxyf&lt;/p&gt;
&lt;h2&gt;名称&lt;/h2&gt;
&lt;p&gt;goaccess - 快速的web日志分析器与交互式查看器&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;goaccess  [-f 输入文件]  [-c]  [-e]  [-a]&lt;/p&gt;
&lt;h2&gt;描述&lt;/h2&gt;
&lt;p&gt;goaccess是一个实时的web日志分析器，以及交互式查看器，在类Unix系统的终端(terminal)上运行，是一个基 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://goaccess.prosoftcorp.com/man"&gt;http://goaccess.prosoftcorp.com/man&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译：youngsterxyf&lt;/p&gt;
&lt;h2&gt;名称&lt;/h2&gt;
&lt;p&gt;goaccess - 快速的web日志分析器与交互式查看器&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;goaccess  [-f 输入文件]  [-c]  [-e]  [-a]&lt;/p&gt;
&lt;h2&gt;描述&lt;/h2&gt;
&lt;p&gt;goaccess是一个实时的web日志分析器，以及交互式查看器，在类Unix系统的终端(terminal)上运行，是一个基于GPL的自由软件。为需要可视化服务器报告的系统管理员提供快速而重要的HTTP统计信息。首先它会解析web日志文件，从被解析文件中收集数据，然后展示在控制台(console)或者X终端上。收集到的信息会在一个可视化/交互式的窗口中展示给用户，包括：&lt;/p&gt;
&lt;h3&gt;综合统计数字&lt;/h3&gt;
&lt;p&gt;有效请求的总数，无效请求的总数，数据分析的总时间，独立访客总数，被请求的独立文件总数，独立静态文件总数(css, ico, jpg, swf, gif, png)，独立HTTP引荐网站(URL)总数，独立404响应(资源未找到)总数，被解析日志文件的大小，总流量。&lt;/p&gt;
&lt;h3&gt;独立访客&lt;/h3&gt;
&lt;p&gt;相同IP，相同日期以及相同代理(agent)的HTTP请求被看作一个独立请求。(包括网络爬虫)。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;被访问文件&lt;/h3&gt;
&lt;p&gt;总数量基于独立请求文件。基于相同IP，相同日期以及相同代理的HTTP请求被看作一次独立访问这一前提。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;被请求静态文件&lt;/h3&gt;
&lt;p&gt;总数量基于独立请求文件。包括的文件类型：jpg，css，swf，js，gif，png等。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;引荐的URL&lt;/h3&gt;
&lt;p&gt;请求来自于引荐的URL。总数量并非基于上述前提，而是基于请求的总数目。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;404或者资源未找到&lt;/h3&gt;
&lt;p&gt;总数量基于请求总数。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;操作系统类型&lt;/h3&gt;
&lt;p&gt;总数量基于独立访客数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;浏览器类型&lt;/h3&gt;
&lt;p&gt;总数量基于独立访客数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;主机&lt;/h3&gt;
&lt;p&gt;总数量基于请求总数。{详细视图}可用。每个IP的{详细视图}会显示该主机的额外信息，包括反向域名解析，IP的定位。&lt;/p&gt;
&lt;h3&gt;HTTP状态码&lt;/h3&gt;
&lt;p&gt;基于请求总数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;引荐的站点&lt;/h3&gt;
&lt;p&gt;这一部分仅显示主机而不是完整的URL。基于请求总数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;关键词短语&lt;/h3&gt;
&lt;p&gt;这部分会报告Google搜索，Google缓存以及Google翻译中使用的关键词短语。总数目基于请求总数。{详细视图}可用。&lt;/p&gt;
&lt;h2&gt;命令选项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-f  输入文件&lt;/p&gt;
&lt;p&gt;输入文件的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-c&lt;/p&gt;
&lt;p&gt;提示日期和日志格式配置窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-e&lt;/p&gt;
&lt;p&gt;在主机部分不统计(排除)某IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-a&lt;/p&gt;
&lt;p&gt;为解析到的主机开启一些用户代理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义日志/日期格式&lt;/h2&gt;
&lt;p&gt;GoAccess几乎可以解析任何web日志格式。&lt;/p&gt;
&lt;p&gt;预定义选项包括：Common Log Format(CLF)，Combined Log Format(XLF/ELF)，包含虚拟主机和W3C格式(IIS)。&lt;/p&gt;
&lt;p&gt;GoAccess也允许任意自定义格式字符串。&lt;/p&gt;
&lt;p&gt;有两种方式来配置日志格式。最简单的方式是执行带-c选项的GoAccess以提示配置窗口。另外，也可以在~/.goaccessrc中配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;日期格式(date_format)&lt;/p&gt;
&lt;p&gt;空格之后的date_format变量指定了包含常规字符和特殊格式说明符的任意组合。这些字符都以百分号(%)开始。详见：&lt;a href="http://linux.die.net/man/3/strftime"&gt;http://linux.die.net/man/3/strftime&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志格式(log_format)&lt;/p&gt;
&lt;p&gt;空格之后的date_format变量指定了日志格式字符串。&lt;/p&gt;
&lt;p&gt;%d  匹配date_format变量的日期域&lt;/p&gt;
&lt;p&gt;%h  主机(客户端IP地址，IPv4或IPv6)&lt;/p&gt;
&lt;p&gt;%r  来自客户端的请求行&lt;/p&gt;
&lt;p&gt;%s  服务器返回给客户端的状态码&lt;/p&gt;
&lt;p&gt;%b  返回给客户端的对象大小&lt;/p&gt;
&lt;p&gt;%R  "Referer"HTTP请求头&lt;/p&gt;
&lt;p&gt;%u  用户代理HTTP请求头&lt;/p&gt;
&lt;p&gt;%^  忽略该域&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;交互式菜单&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;F1    主帮助页面&lt;/li&gt;
&lt;li&gt;F5    重绘主窗口&lt;/li&gt;
&lt;li&gt;q     退出程序或者当前{详细视图}(窗口)&lt;/li&gt;
&lt;li&gt;o     打开当前激活模块的详细视图&lt;/li&gt;
&lt;li&gt;c     设置或改变配色方案&lt;/li&gt;
&lt;li&gt;TAB   向前迭代模块。从当前激活模块开始。&lt;/li&gt;
&lt;li&gt;SHIFT + TAB   向后迭代模块。从当前激活模块开始。&lt;/li&gt;
&lt;li&gt;RIGHT ARROW   打开当前激活模块的详细视图&lt;/li&gt;
&lt;li&gt;0-9   激活模块，这样用户就可以使用^o^或^RIGHT ARROW^打开{详细视图}&lt;/li&gt;
&lt;li&gt;SHIFT + 0-9   激活超过10的模块&lt;/li&gt;
&lt;li&gt;s     根据日期进行独立访客排序。仅在独立访客模块(1)有效。&lt;/li&gt;
&lt;li&gt;S     根据点击数进行独立访客排序。仅在独立访客模块(1)有效。&lt;/li&gt;
&lt;li&gt;/     向前在任意{详细视图}窗口搜索输入模式(pattern)。&lt;/li&gt;
&lt;li&gt;n     在任意{详细视图}窗口中找到下一次出现的位置。&lt;/li&gt;
&lt;li&gt;t     跳到第一个条目或屏幕顶端&lt;/li&gt;
&lt;li&gt;b     跳到最后一个条目或者屏幕底部&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;最简单且最快速的用法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# goaccess -f access.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将产生一个交互式的文本输出。&lt;/p&gt;
&lt;p&gt;生成一个HTML报告：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# goaccess -f access.log -a &amp;gt; report.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要想产生全面的统计信息，我们可以这样执行GoAccess：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# goaccess -f access.log -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-a标志表明我们想为每个解析到的主机处理一个代理列表。-c标志将提示日期/日志格式配置窗口。仅当curses初始时。&lt;/p&gt;
&lt;p&gt;如果我们想为GoAccess增加更多的灵活性，可以使用一系列的管道。例如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# zcat access.log.*gz | goaccess
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# zcat access.log.* | goaccess
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另一个有用的管道是根据日期过滤web日志。&lt;/p&gt;
&lt;p&gt;如下命令将得到日志文件中2010年12月5日的所有HTTP请求：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# sed -n &amp;#39;/05\/Dec\/2010/,$ p&amp;#39; access.log | goaccess -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果想仅解析从日期a到日期b的一个特定时限的日志，则可以：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# sed -n &amp;#39;/5\/Nov\/2010/,/5\/Dec\/2010/ p&amp;#39; access.log | goaccess -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意这一命令依赖于sed的速度，可能需要更长的解析时间。&lt;/p&gt;
&lt;p&gt;另外，值得指出，如果想以更低的进程调度优先级运行GoAccess，可以这样执行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# nice -n 19 goaccess -f access.log -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;注释&lt;/h2&gt;
&lt;p&gt;每个{详细视图}窗口中，条目总数目为300。&lt;/p&gt;
&lt;p&gt;以管道的方式将日志传给GoAccess会使得实时功能失效。这归因于确定标准输入的实际大小的可移植性问题。然而，未来的某个版本可能会包含这一特性。&lt;/p&gt;
&lt;h2&gt;BUGS&lt;/h2&gt;
&lt;p&gt;如果你认为你发现了一个bug，请发送一封邮件到goaccess@prosoftcorp.com。&lt;/p&gt;
&lt;h2&gt;作者&lt;/h2&gt;
&lt;p&gt;Gerardo Orellana&lt;/p&gt;
&lt;p&gt;欲知更多详情，或者新版本发布，请访问&lt;a href="http://goaccess.prosoftcorp.com"&gt;http://goaccess.prosoftcorp.com&lt;/a&gt;&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="工具"></category></entry><entry><title>pi的一种并行算法</title><link href="http://youngsterxyf.github.io/2012/11/22/pi-parallel-algorithm/" rel="alternate"></link><published>2012-11-22T00:00:00+08:00</published><updated>2012-11-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-22:/2012/11/22/pi-parallel-algorithm/</id><summary type="html">&lt;p&gt;我们都知道圆周率pi的值是3.141592653...，那么这个值是怎么算出来的呢？一种方式是通过某种方式算出圆的面积或者周长，然后根据公式 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我们都知道圆周率pi的值是3.141592653...，那么这个值是怎么算出来的呢？一种方式是通过某种方式算出圆的面积或者周长，然后根据公式$ S = pi \times r^2 $(或$ L = 2 \times pi \times r $)算出pi的值。但如何用计算机通过某种算法计算而得？有没有并行的算法？&lt;/p&gt;
&lt;p&gt;&lt;a href="/assets/uploads/files/mapreduce_intro.pdf"&gt;Introduction to Parallel Programming and MapReduce&lt;/a&gt;一文中介绍了一种基于概率的并行算法---假设有个正方形，里面有个內切圆。&lt;/p&gt;
&lt;p&gt;&lt;img alt="sample pic" src="/assets/uploads/pics/inscribe.png"&gt;&lt;/p&gt;
&lt;p&gt;设内切圆的半径为$ r $，则&lt;/p&gt;
&lt;p&gt;正方形的面积为$ S_z = 4r^2 $&lt;/p&gt;
&lt;p&gt;内切圆的面积为$ S_y = pi \times r^2 $&lt;/p&gt;
&lt;p&gt;那么$ pi = \frac{ S_y }{ r^2 } = \frac{ S_y }{ S_z/4 } = \frac{ 4S_y }{ S_z } $&lt;/p&gt;
&lt;p&gt;大量生成属于正方形里的随机点(x, y)，并统计属于内切圆范围内的点的出现次数，当次数达到一定量级之后，属于内切圆范围内的点的数目与随机点的总数目的比即为$ \frac{ S_y }{ S_z } $的近似值，再乘以4即为pi的近似值。&lt;/p&gt;
&lt;p&gt;并且由于任意两个随机数的生成是相互独立的，所以可以使用多个进程/线程/多个计算机来分别计算一定量的随机数，然后把它们计算所得属于内切圆范围的点的数目相加，再根据公式计算pi值。&lt;/p&gt;
&lt;p&gt;假设r的值为单位1，则程序实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; random
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; math
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; threading

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; worker(taskNum):
    &lt;span style="color: #008000"&gt;# set r = 1&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;global&lt;/span&gt; allcount, mutex
    count = 0

    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; _ &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; xrange(taskNum):
        x = random.uniform(-1, 1)
        y = random.uniform(-1, 1)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; math.sqrt(x**2 + y**2)&amp;lt;=1:
            count += 1
    mutex.acquire()
    allcount += count
    mutex.release()

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; main(task_all_num, worker_num):
    &lt;span style="color: #0000ff"&gt;global&lt;/span&gt; allcount, mutex
    threads = []

    allcount = 0
    mutex = threading.Lock()
    task_num = task_all_num / worker_num
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; _ &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; xrange(0, worker_num):
        threads.append(threading.Thread(target=worker, args=(task_num,)))

    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; t &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; threads:
        t.start()

    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; t &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; threads:
        t.join()

    print &lt;span style="color: #a31515"&gt;&amp;#39;pi: &amp;#39;&lt;/span&gt;, 4.0 * allcount / task_all_num

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:

    TASKALLNUM = 40000000
    WORKERNUM = 40
    main(TASKALLNUM, WORKERNUM)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;程序总共计算4千万次随机数，使用40个线程，计算得pi近似值为3.141298，由于是基于概率的，所以每次计算所得值会有差异，并且理论上来说随机数生成总次数越大，越精确。&lt;/p&gt;</content><category term="其他"></category><category term="算法"></category><category term="并行"></category><category term="Python"></category></entry><entry><title>诗歌选</title><link href="http://youngsterxyf.github.io/2012/11/20/poems/" rel="alternate"></link><published>2012-11-20T00:00:00+08:00</published><updated>2012-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-20:/2012/11/20/poems/</id><summary type="html">&lt;h3&gt;南乡子&lt;/h3&gt;
&lt;h4&gt;和杨元素，时移守密州&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;苏轼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;东武望余杭，云海天涯两杳茫。何日功成名遂了，还乡，醉笑陪公三万场。&lt;/p&gt;
&lt;p&gt;不用诉离觞，痛饮从 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;南乡子&lt;/h3&gt;
&lt;h4&gt;和杨元素，时移守密州&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;苏轼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;东武望余杭，云海天涯两杳茫。何日功成名遂了，还乡，醉笑陪公三万场。&lt;/p&gt;
&lt;p&gt;不用诉离觞，痛饮从来别有肠。今夜送归灯火冷，河塘，堕泪羊公却姓杨。&lt;/p&gt;
&lt;h3&gt;临江仙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;杨慎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;滚滚长江东逝水，浪花淘尽英雄。是非成败转头空，青山依旧在，几度夕阳红。&lt;/p&gt;
&lt;p&gt;白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢，古今多少事。都付笑谈中。&lt;/p&gt;
&lt;h3&gt;结结巴巴&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;伊沙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结结巴巴我的嘴&lt;br /&gt; 
二二二等残废&lt;br /&gt;
咬不住我狂狂狂奔的思维&lt;br /&gt;
还有我的腿&lt;br /&gt;
&lt;br /&gt;
你们四处流流流淌的口水&lt;br /&gt;
散着霉味&lt;br /&gt;
我我我的肺&lt;br /&gt;
多么劳累&lt;br /&gt;
&lt;br /&gt;
我要突突突围&lt;br /&gt;
你们莫莫莫名奇妙&lt;br /&gt;
的节奏&lt;br /&gt;
急待突围&lt;br /&gt;
&lt;br /&gt;
我我我的&lt;br /&gt;
我的机枪点点点射般&lt;br /&gt;
的语言&lt;br /&gt;
充满快慰&lt;br /&gt;
&lt;br /&gt;
结结巴巴我的命&lt;br /&gt;
我的命里没没没有鬼&lt;br /&gt;
你们瞧瞧瞧我&lt;br /&gt;
一脸无所谓&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;父亲和我&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;吕德安&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;父亲和我&lt;br /&gt;
我们并肩走着&lt;br /&gt;
秋雨稍歇&lt;br /&gt;
和前一阵雨&lt;br /&gt;
像隔了多年时光&lt;br /&gt;
&lt;br /&gt;
我们走在雨和雨的间歇里&lt;br /&gt;
肩头清晰地靠在一起&lt;br /&gt;
却没有一句要说的话&lt;br /&gt;
&lt;br /&gt;
我们刚从屋子里出来&lt;br /&gt;
所以没有一句要说的话&lt;br /&gt;
这是长久生活在一起&lt;br /&gt;
造成的&lt;br /&gt;
&lt;br /&gt;
滴水的声音像折下的一支细枝条&lt;br /&gt;
像过冬的梅花&lt;br /&gt;
&lt;br /&gt;
父亲的头发已经全白&lt;br /&gt;
但这近乎于一种灵魂&lt;br /&gt;
会使人不禁肃然起敬&lt;br /&gt;
&lt;br /&gt;
依然是熟悉的街道&lt;br /&gt;
熟悉的人要举手致意&lt;br /&gt;
父亲和我都怀着难言的恩情&lt;br /&gt;
安详地走着&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;假使我们不去打仗&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;田间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假使我们不去打仗&lt;br /&gt;
敌人用刺刀&lt;br /&gt;
杀死了我们&lt;br /&gt;
还要用手指着我们骨头说：&lt;br /&gt;
"看，&lt;br /&gt;
这是奴隶！"&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;相信未来&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;食指&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当蜘蛛网无情地查封了我的炉台&lt;br /&gt;
当灰烬的余烟叹息着贫困的悲哀&lt;br /&gt;
我依然固执地铺平失望的灰烬&lt;br /&gt;
用美丽的雪花写下：相信未来&lt;br /&gt;
&lt;br /&gt;
当我的紫葡萄化为深秋的露水&lt;br /&gt;
当我的鲜花依偎在别人的情怀&lt;br /&gt;
我依然固执地用凝霜的枯藤&lt;br /&gt;
在凄凉的大地上写下：相信未来&lt;br /&gt;
&lt;br /&gt;
我要用手指那涌向天边的排浪&lt;br /&gt;
我要用手掌那托住太阳的大海&lt;br /&gt;
摇曳着曙光那支温暖漂亮的笔杆&lt;br /&gt;
用孩子的笔体写下：相信未来&lt;br /&gt;
&lt;br /&gt;
我之所以坚定地相信未来&lt;br /&gt;
是我相信未来人们的眼睛&lt;br /&gt;
她有拨开历史风尘的睫毛&lt;br /&gt;
她有看透岁月篇章的瞳孔&lt;br /&gt;
&lt;br /&gt;
不管人们对于我们腐烂的皮肉&lt;br /&gt;
那些迷途的惆怅、失败的苦痛&lt;br /&gt;
是寄予感动的热泪、深切的同情&lt;br /&gt;
还是给以轻蔑的微笑、辛辣的嘲讽&lt;br /&gt;
&lt;br /&gt;
我坚信人们对于我们脊骨&lt;br /&gt;
那无数次的探索、迷途、失败和成功&lt;br /&gt;
一定会给予热情、客观、公正的评定&lt;br /&gt;
是的，我焦急地等待着他们的评定&lt;br /&gt;
&lt;br /&gt;
朋友，坚定地相信未来吧&lt;br /&gt;
相信不屈不挠的努力&lt;br /&gt;
相信战胜死亡的年轻&lt;br /&gt;
相信未来、热爱生命&lt;br /&gt;
&lt;br /&gt;
&lt;em&gt;1968年 北京&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="阅读"></category><category term="诗歌"></category></entry><entry><title>面试准备</title><link href="http://youngsterxyf.github.io/2012/11/20/prepareForInterview/" rel="alternate"></link><published>2012-11-20T00:00:00+08:00</published><updated>2012-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-20:/2012/11/20/prepareForInterview/</id><summary type="html">&lt;h3&gt;自我介绍&lt;/h3&gt;
&lt;p&gt;我叫夏永锋，目前是一名上海交大的硕士研究生，将于2013年3月毕业。现在作为一名web开发实习生在Google CSR部门实习。实习的工作内容主要包括：开发维护 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;自我介绍&lt;/h3&gt;
&lt;p&gt;我叫夏永锋，目前是一名上海交大的硕士研究生，将于2013年3月毕业。现在作为一名web开发实习生在Google CSR部门实习。实习的工作内容主要包括：开发维护部门旗下的几个网站以及服务器日常运维。&lt;/p&gt;
&lt;p&gt;我的老家是江西省婺源县，她非常美丽，有“中国最美的乡村”的美誉。&lt;/p&gt;
&lt;p&gt;我喜欢写程序，羽毛球，长跑。我觉得编程是一种乐趣，编程是程序员的魔法。&lt;/p&gt;
&lt;p&gt;My name is Xia yongfeng, currently i am a master candidate from School of Software, Shanghai Jiaotong University. And i will graduate in 2013. Now I am a web development intern in Google CSR. The work content of the internship mainly includes the development and maintenance of some websites of our department, as well as the maintenance of web server.&lt;/p&gt;
&lt;p&gt;My hometown is WuYuan County in Jiangxi Province. She is so beautiful, resulting reputation as "China's most beautiful countryside."&lt;/p&gt;
&lt;p&gt;I love coding, badminton, long-distance running. To me, coding is a pleasure, is just for fun, coding is the magic of programmer.&lt;/p&gt;
&lt;h3&gt;为什么选择我们公司？&lt;/h3&gt;
&lt;p&gt;微软：也许它是世界上最大的软件公司，并且我喜欢微软的技术。&lt;/p&gt;
&lt;p&gt;Microsoft: Maybe it is the biggest software corporation in the world, and i like the technology from Microsoft. I think this is my reason to choose Microsoft.&lt;/p&gt;
&lt;h3&gt;选择你的一个项目介绍一下&lt;/h3&gt;
&lt;p&gt;那么就来说说我的一个个人小项目吧---简易FTP搜索引擎，这个小项目的由来是因为我们实验室有个ftp服务器，经过很多年的积累，上面的文件非常非常多，也比较乱。如果直接用ftp客户端去查找下载会非常麻烦，所以我就想能不能做个类搜索引擎，能够快速地搜索ftp上的文件，并提供下载。项目主要分成两部分---索引部分和搜索部分，索引部分由服务器端的一个python小程序实现，利用linux内核的文件系统实时监控功能，对ftp目录和文件夹进行实时索引，将索引(包含文件名和ftp下载链接)保存在berkerlyDB中。搜索部分是一个类google主页的搜索网页，用户输入查询关键字，服务器上的一个python CGI脚本接收用户输入，根据输入查询数据库，并返回结果。&lt;/p&gt;
&lt;p&gt;I like to talk about a personal small project with you --- a simple FTP search engine. Why do i choose this project？ In our lab，there is a ftp server, existing over several years, many, and more and more files/directories on the server. If we use a ftp client to look for some file and to download it, this will be a terrible thing. So i think why i don't implement a service like search engine to search ftp file and download it quickly. This project can be divided into two main parts --- indexing part and searching part. The indexing part is implemented with a short python program on the server, it use the real-time monitoring function of linux kernel to make real-time index for files and directories in ftp, and store index data(includes filename and download link) into a berkerly DB. And the searching part is a web page like google's main page. user enters keyword for searching, a python cgi script on the server receives the input, then searches the Database, then returns results.&lt;/p&gt;</content><category term="其他"></category><category term="面试"></category><category term="英语"></category></entry><entry><title>笔试题目</title><link href="http://youngsterxyf.github.io/2012/11/20/work-exam/" rel="alternate"></link><published>2012-11-20T00:00:00+08:00</published><updated>2012-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-20:/2012/11/20/work-exam/</id><summary type="html">&lt;h3&gt;2013-网易-校园招聘-C++开发工程师&lt;/h3&gt;
&lt;h4&gt;Fibonacci number&lt;/h4&gt;
&lt;p&gt;F(n)的值是多少？&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fabonacci" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/NumberedEquation6.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规算法&lt;/strong&gt;：根据Fabonacci的定义，递归求值。时间复杂度$ O(2^n) $&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibobacci(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n&amp;gt;=2 &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; fibonacci(n-2) + fibonacci(n-1) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;迭代&lt;/strong&gt;：利 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;2013-网易-校园招聘-C++开发工程师&lt;/h3&gt;
&lt;h4&gt;Fibonacci number&lt;/h4&gt;
&lt;p&gt;F(n)的值是多少？&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fabonacci" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/NumberedEquation6.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规算法&lt;/strong&gt;：根据Fabonacci的定义，递归求值。时间复杂度$ O(2^n) $&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibobacci(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n&amp;gt;=2 &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; fibonacci(n-2) + fibonacci(n-1) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;迭代&lt;/strong&gt;：利用循环取代递归。时间复杂度O(n)&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibonacci(n):
    a, b = 0, 1
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range(n):
        a, b = b, a+b
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;迭代算法的变种&lt;/em&gt; ：利用python的generator，原理一样，只是应用场合不一样。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibonacci():
    a, b = 0, 1
    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; 1:
        &lt;span style="color: #0000ff"&gt;yield&lt;/span&gt; a
        a, b = b, a+b

f = fibonacci()
n = 100
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range(n+1):
    print(next(f)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;利用矩阵运算来加速的算法&lt;/strong&gt;：（还没懂）算法复杂度$ O(\log n) $&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; numpy

fibonacci_matrix = numpy.matrix([1,1],[1,0], dtype=numpy.ndarray)
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibonacci(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; fibonacci_matrix**(n-1)[0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;数学方法:使用Fibonacci序列的通用公式&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; math &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; sqrt

&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibonacci(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; int(((1+sqrt(5))/2)**n/sqrt(5))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然数学方法在4种方法中速度最快，但当n越大，其计算精度偏差越大。&lt;/p&gt;
&lt;h4&gt;图的遍历&lt;/h4&gt;
&lt;p&gt;&lt;img alt="graph" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/graph-sample.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/graph.cpp"&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;大文件处理&lt;/h4&gt;
&lt;p&gt;设计算法从文件中随机取K行(内存够存储K行)，每行被取的概率相等，算法复杂度要低。(具体的记不太清楚了)&lt;/p&gt;
&lt;h4&gt;CAS(Compare And Swap)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;bool&lt;/span&gt; compare_and_swap(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *accum, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *dest, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; newval)
{
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(*accum == *dest)
    {
        *dest = newval;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; true;
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CAS方式实现的进队列操作：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;EnQueue(x)  &lt;span style="color: #008000"&gt;//进队列&lt;/span&gt;
{
    q = new record();
    q-&amp;gt;value = x;
    q-&amp;gt;next = NULL;

    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt; {
        p = tail;   &lt;span style="color: #008000"&gt;//取链表尾指针的快照&lt;/span&gt;
    }&lt;span style="color: #0000ff"&gt;while&lt;/span&gt;(CAS(p-&amp;gt;next, NULL, q) != TRUE)   &lt;span style="color: #008000"&gt;//如果没有把结点链上，再试&lt;/span&gt;

    CAS(tail, p, q);    &lt;span style="color: #008000"&gt;//置尾结点&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lifesider/article/details/6582338"&gt;无锁的数据结构（Lock-Free）及CAS（Compare-and-Swap）机制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Compare-and-swap"&gt;Wikipedia---Compare-and-swap&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://coolshell.cn/articles/8239.html"&gt;无锁队列的实现&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;排序算法&lt;/h4&gt;
&lt;p&gt;不稳定排序算法可能会在相等的键值中改变记录的相对次序，但是稳定排序算法从来不会如此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;稳定的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;冒泡排序(Bubble sort) --- $ O(n^2) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入排序(Insertion sort) --- $ O(n^2) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;桶排序(Bucket sort) --- $ O(n) $，需要$O(k)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数排序(Counting sort) --- $ O(n+k) $，需要$O(n+k)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;归并排序(Merge sort) --- $ O(n \log n) $，需要$O(n)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数排序(Radix sort) --- $ O(n \times k) $，需要$O(n)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不稳定的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;选择排序(Selection sort) --- $ O(n^2) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;希尔排序(Shell sort) --- $ O(n \log n) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆排序(Heap sort) --- $ O(n \log n) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速排序(Quick sort) --- $ O(n \log n) $&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;冒泡排序---Python&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; bubbleSort(L):
    print &lt;span style="color: #a31515"&gt;&amp;#39;start bubble sort:&amp;#39;&lt;/span&gt;
    print L
    count = 0
    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;:
        step = 0
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range(len(L)-1):
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; L[i] &amp;gt; L[i+1]:
                L[i], L[i+1] = L[i+1], L[i]
                print L
                step += 1
                count += 1
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; step == 0:
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; L, &lt;span style="color: #a31515"&gt;&amp;#39;totalstep:&amp;#39;&lt;/span&gt;, count
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;计数排序---C&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;#include&lt;/span&gt; &lt;span style="color: #008000"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&lt;/span&gt;

&lt;span style="color: #2b91af"&gt;void&lt;/span&gt; counting_sort(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *array, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; size)
{
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; i, min, max;
    min = max = array[0];
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(i=1; i&amp;lt;size; i++)
    {
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(array[i] &amp;lt; min)
            min = array[i];
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(array[i] &amp;gt; max)
            max = array[i];
    }

    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; range = max-min+1;
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *count = (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *)malloc(range * &lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;));

    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(i = 0; i &amp;lt; range; i++)
        count[i] = 0;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(i = 0; i &amp;lt; size; i++)
        count[array[i]-min]++;

    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; j, z = 0;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(i=min; i&amp;lt;=max; i++)
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(j=0; j&amp;lt;count[i-min]; j++)
            array[z++] = i;
    free(count);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;快速排序---Python&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; qsort(L):
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; L: &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; []
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; qsort([x &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; x &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; L[1:] &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; x &amp;lt; L[0]]) + L[0:1] + \
        qsort([x &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; x &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; L[1:] &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; x&amp;gt;=L[0]])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2013-小米科技-校园招聘-笔试-软件开发工程师&lt;/h3&gt;
&lt;h4&gt;完全二叉树&lt;/h4&gt;
&lt;p&gt;深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为&lt;strong&gt;完全二叉树&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这种树的特点是:1.叶子结点只可能在层次最大的两层上出现; 2.对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。&lt;/p&gt;
&lt;p&gt;具有n个结点的完全二叉树的深度为$ [\log n]+1 $&lt;/p&gt;
&lt;h4&gt;指针的基本理解&lt;/h4&gt;
&lt;p&gt;已知int* p = &amp;amp;n，请问*p是什么？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;*p是n的值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解指针&lt;/strong&gt; ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个指针都对应一个类型。这个类型表明指针指向哪一类对象。特殊的void* 类型代表通用指针。比如说，malloc函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个指针都有一个值。特殊的NULL(0)值表示该指针没有指向任何地方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针用&amp;amp;运算符创建。（注：因为leal指令是设计用来计算存储器引用的地址的，&amp;amp;运算符的机器代码实现常常用这条指令来计算表达式的值）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组与指针紧密联系。一个数组的名字可以像一个指针变量一样使用(但是不能修改)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将指针从一个类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。例如，如果p是一个char*类型的指针，它的值是P，那么表达式(int*)p+7计算为P+28，而(int*)(p+7)计算为P+7。(回想一下，强制类型转换的优先级高于加法)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针也可以指向函数。例如，如果我们有一个函数，用下面的这个原型定义: &lt;code&gt;int fun(int x, int *p)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后，我们可以声明一个指针fp，将它赋值为这个函数，代码如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) (*fp)(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *);
fp = fun;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后用以下指针来调用这个函数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; y = 1;
&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; result = fp(3, &amp;amp;y);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数指针的值是该函数机器代码表示中第一条指令的地址。&lt;/p&gt;
&lt;h4&gt;93&amp;amp;-8等于多少&lt;/h4&gt;
&lt;p&gt;11011101 &amp;amp; 11111000 = 11011000 = 88&lt;/p&gt;
&lt;h4&gt;已知(he)^2 = she，请求出s, h, e各自的值为多少？&lt;/h4&gt;
&lt;p&gt;s = 6; h = 2; e = 5;&lt;/p&gt;
&lt;h4&gt;给定二维数组a[1...100][1...65]，以行序进行存储，假设数组的基地址为10000，每个元素需要2个存储单元，请求出元素a[56][21]的存储地址。&lt;/h4&gt;
&lt;p&gt;$$ (55 \times 65 + 22) \times 2 + 10000 = 17194 $$&lt;/p&gt;
&lt;h4&gt;给定一个数组a，求数组result，其中result[i]的值为除a[i]之外的其他a的元素值的乘积(假设不会溢出)。算法的时间，空间复杂度要尽可能低。&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;* getProduct(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;* a, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; n)
{
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; allproduct = 1;
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; index;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(index=0; index&amp;lt;n; index++)
        allproduct *= a[index];
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;* productResult = new &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;[n];
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(index=0; index&amp;lt;n; index++)
        productResult[index] = allproduct / a[index];
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; productResult;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;时间复杂度为O(n)&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;* getProduct(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;* a, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; n)
{
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;* productResult = new &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;[n];
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; i, j, temp;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(i=0; i&amp;lt;n; i++)
    {

        temp = 1;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(j=0; j&amp;lt;n; j++)
        {
            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(j != i)
                temp *= a[j];
        }
        productResult[i] = temp;
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; productResult;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;时间复杂度为O(n^2)&lt;/p&gt;
&lt;h4&gt;给定一个数组a，其中有3个元素出现了两次，其余元素仅出现一次。请找出其中仅出现一次的任意一个元素。算法的时间，空间复杂度要低&lt;/h4&gt;
&lt;p&gt;方法一：先排序，然后对元素依次两两比较遍历一遍排好序的数组，如果两个元素不同，则输出第一个元素，并退出循环。如果相同，则跳过下一个元素，再次开始两两比较。&lt;/p&gt;
&lt;p&gt;方法二：先找出数组a中的最大元素x，创建一个大小为x的数组temp，并所有元素初始化为-1。遍历数组a，temp[a[i]]++。再遍历temp，如果temp[i]==0，则返回i，并退出循环。&lt;/p&gt;
&lt;h4&gt;给定n个人，以及m对人之间的关联(以二维数组的方式存储)，人与人之间直接关联或间接关联形成一个朋友圈。请找出给定信息的朋友圈的个数。算法时间空间复杂度要低。并分析其时间空间复杂度。&lt;/h4&gt;
&lt;p&gt;使用 &lt;strong&gt;合并-查找算法&lt;/strong&gt; (&lt;a href="http://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86"&gt;并查集&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连通问题的快速查找算法&lt;/strong&gt;：算法的基础是一个整型数组，当且仅当第p个元素和第q个元素相等时，p和q是连通的。初始时，数组中的第i个元素的值为i，$0 \le i &amp;lt; N$。为实现p与q的合并操作，我们遍历数组，把所有名为p的元素值改为q。我们也可以选择另一种方式，把所有名为q的元素改为p。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;2013-腾讯-校园招聘-笔试-后台开发工程师&lt;/h3&gt;
&lt;h4&gt;黑盒，白盒测试的目的&lt;/h4&gt;
&lt;h4&gt;TCP三次握手包含的指令(SYN, ACK)&lt;/h4&gt;
&lt;h4&gt;完全二叉树的结点数为769,求其叶子结点数目&lt;/h4&gt;
&lt;p&gt;(769-x)*2 = 769-1 =&amp;gt; x=385&lt;/p&gt;
&lt;h4&gt;C++的四种类型转换符&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://www.bccn.net/Article/kfyy/cjj/jszl/200809/7955.html"&gt;C++中四种类型转换运算符的使用方法&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;快速排序&lt;/h4&gt;
&lt;h4&gt;有一个指针void *mPem指向一段分配好的内存空间，现在创建类A的对象a，如何使得a在其上申请内存空间？&lt;/h4&gt;
&lt;p&gt;难道真是A* a = (A*)mPem么?&lt;/p&gt;
&lt;h4&gt;虚继承与多态&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;#include&lt;/span&gt; &lt;span style="color: #008000"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;#include&lt;/span&gt;&lt;span style="color: #008000"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;using&lt;/span&gt; &lt;span style="color: #0000ff"&gt;namespace&lt;/span&gt; std;

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;A&lt;/span&gt;{
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:
        A():a(0){}
        &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; S(){
            printf(&lt;span style="color: #a31515"&gt;&amp;quot;aaa%d&amp;quot;&lt;/span&gt;,0);
        }
        &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; a;
};

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;B&lt;/span&gt;:&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; A
{
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:
        B():a(2){}
        &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; S(){
            printf(&lt;span style="color: #a31515"&gt;&amp;quot;bbb%d&amp;quot;&lt;/span&gt;,1);
        }
        &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; a;
};

&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; main()
{
    A *a = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; B();
    a-&amp;gt;S();
    printf(&lt;span style="color: #a31515"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;,a-&amp;gt;a);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;BITMAP的简单实现：使用char类型数组&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* a;
...
&lt;span style="color: #2b91af"&gt;void&lt;/span&gt; set(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; n) &lt;span style="color: #008000"&gt;//设置第n位为1&lt;/span&gt;
{
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; index = (n-1)/8;
    a[index] |= 1&amp;lt;&amp;lt;(n-1-(n-1)%8)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;矩阵向右旋转90度的实现&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; maxtrix[M][N];
...
&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; reverseMatrix[N][M];
&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; i, j;
&lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(i=0; i&amp;lt;M; i++)
{
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(j=0; j&amp;lt;N; j++)
    {
        reverseMatrix[j][M-1-i] = matrix[i][j];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;数据结构：线性结构与非线性结构&lt;/h4&gt;
&lt;h4&gt;综合考虑等待时间和执行时间的进程调度算法？&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;高响应比优先调度算法&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;无法提高可靠性的RAID是？&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;RAID0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/zh/RAID"&gt;wikipedia-RAID&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;类型的空间占用&lt;/h4&gt;
&lt;p&gt;下列哪个占用的空间最大？&lt;/p&gt;
&lt;p&gt;A.1   B.'1'   C."1"   D.1.0&lt;/p&gt;
&lt;p&gt;答：D&lt;/p&gt;
&lt;h4&gt;union和struct结构的存储与空间占用问题(对齐)&lt;/h4&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;union&lt;/span&gt; &lt;span style="color: #2b91af"&gt;U3&lt;/span&gt; {
    &lt;span style="color: #2b91af"&gt;char&lt;/span&gt; c;
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; i[2];
    &lt;span style="color: #2b91af"&gt;double&lt;/span&gt; v;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于类型union U3*的指针p, p-&amp;gt;c、p-&amp;gt;i[0]和p-&amp;gt;v引用的都是数据结构的起始位置。一个联合的总的大小等于它最大字段的大小。&lt;/p&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2, 4和8)的倍数。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计。例如，假设一个处理器总是从存储器中取出8个字节，则地址必须是为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个存储器操作来读或者写值了。否则，我们可能需要执行两次存储器访问，因为对象可能被分放在两个8字节存储器块中。&lt;/p&gt;
&lt;p&gt;无论数据是否对齐，IA32已经都能正确工作。不过，Intel还是建议要对齐数据以提高存储器系统的性能。Linux沿用的对齐策略是，2字节数据类型(例如short)的地址必须是2的倍数，而较大的数据类型(例如int、int*、float和double)的地址必须是4的倍数。&lt;/p&gt;
&lt;h4&gt;二叉树中序遍历&lt;/h4&gt;
&lt;h4&gt;最小堆(堆排序)&lt;/h4&gt;
&lt;p&gt;堆排序(Heap Sort)只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。&lt;/p&gt;
&lt;p&gt;堆的定义如下：n个元素的序列{K1, K2,...,Kn}当且仅当满足关系时，称之为堆:
Ki &amp;lt;= K2i 并且 Ki &amp;lt;= K2i+1  或  Ki &amp;gt;= K2i 并且 Ki &amp;gt;= K2i+1&lt;/p&gt;
&lt;p&gt;若将和此序列对应的一维数组看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于(或不小于)其左、右孩子结点的值。由此，若序列{Ki,K2,...,Kn}是堆，则堆顶元素(或完全二叉树的根)必为序列中n个元素的最小值(或最大值)。&lt;/p&gt;
&lt;p&gt;若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素中次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。&lt;/p&gt;
&lt;p&gt;由此，实现堆排序需要解决两个问题：(1)如何由一个无序序列建成一个堆？(2)如何在输出栈顶元素之后，调整剩余元素成为一个新的堆？&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/heapSort.c"&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;一个线段上，任取两点，截成三段，能组成三角形的概率&lt;/h4&gt;
&lt;p&gt;1/4 (怎么算？)&lt;/p&gt;
&lt;p&gt;思考1：线段等分成两个区间。两点属于同一区间的概率是1/2，属于不同区间且两点距离大于等于线段长度一半的概率是1/2 * 1/2，则1-1/2-1/4 = 1/4;&lt;/p&gt;
&lt;p&gt;思考2：线性规划。&lt;a href="http://zhidao.baidu.com/question/6678655"&gt;百度知道&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;哈希表&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;哈希函数的构造方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接定址法：取关键字或关键字的某个线性函数值为哈希地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字分析法：假设关键字是以r为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平方取中法：取关键字平方后的中间几位为哈希地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;折叠法：将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和(舍去进位)作为哈希地址，这方法称为折叠法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机数法：选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key)，其中random为随机函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际工作中需视不同的情况采用不同的哈希函数。通常，考虑的因素有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算哈希函数所需时间(包括硬件指令的因素)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键字的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希表的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键字的分布情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录的查找频率&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理冲突的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开放定址法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再哈希法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链地址法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立一个公共溢出区&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;程序员面试宝典&lt;/h3&gt;
&lt;h4&gt;用一个表达式，判断一个数X是否是2的N次方(2,4,8,16,...)，不可用循环语句。&lt;/h4&gt;
&lt;h4&gt;下面程序的结果是多少？&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;#include&lt;/span&gt; &lt;span style="color: #008000"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;#include&lt;/span&gt; &lt;span style="color: #008000"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;using&lt;/span&gt; &lt;span style="color: #0000ff"&gt;namespace&lt;/span&gt; std;
&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; main()
{
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; count = 0;
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; m = 9999;
    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt;(m){
        count++;
        m=m&amp;amp;(m-1);
    }
    cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;There are two int variables: a and b, don't use "if", "?:", "switch" or other judgement statements, find out the biggest one of the two numbers.&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; max = ((a+b)+abs(a-b)) / 2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;如何将a, b的值进行交换，并且不使用任何中间变量?&lt;/h4&gt;
&lt;p&gt;简而言之，用异或语句比较容易，不用担心超界的问题。&lt;/p&gt;
&lt;p&gt;如果采用：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;a=a+b;
b=a-b;
a=a-b;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样做的缺点就是如果a, b都是比较大的两个数，a=a+b时就会超界。&lt;/p&gt;
&lt;p&gt;而采用：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;a=a^b;
b=a^b;
a=a^b;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;无需担心超界的问题，这样就比较好&lt;/p&gt;</content><category term="其他"></category><category term="笔试"></category></entry><entry><title>Python装饰器入门（译）</title><link href="http://youngsterxyf.github.io/2012/07/30/a-primer-on-python-decorators/" rel="alternate"></link><published>2012-07-30T00:00:00+08:00</published><updated>2012-07-30T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-07-30:/2012/07/30/a-primer-on-python-decorators/</id><summary type="html">&lt;p&gt;原文: &lt;a href="http://www.thumbtack.com/engineering/a-primer-on-python-decorators/"&gt;A primer on Python decorators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译: &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python允许你，作为程序员，使用函数完成一些很酷的事情。在Python中，函数是&lt;a href="http://en.wikipedia.org/wiki/First-class_function"&gt;一等对象(first-class object)&lt;/a&gt;，这就意味着你可以像使 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文: &lt;a href="http://www.thumbtack.com/engineering/a-primer-on-python-decorators/"&gt;A primer on Python decorators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译: &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python允许你，作为程序员，使用函数完成一些很酷的事情。在Python中，函数是&lt;a href="http://en.wikipedia.org/wiki/First-class_function"&gt;一等对象(first-class object)&lt;/a&gt;，这就意味着你可以像使用字符串，整数，或者任何其他对象一样使用函数。例如，你可以将函数赋值给变量:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def square(n):
...     return n * n;
&amp;gt;&amp;gt;&amp;gt; square(4)
16
&amp;gt;&amp;gt;&amp;gt; alias = square
&amp;gt;&amp;gt;&amp;gt; alias(4)
16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然而，一等函数的真正威力在于你可以把函数传给其他函数，或者从其他函数中返回函数。Python的内置函数map利用了这种能力：给map传个函数以及一个列表，它会依次以列表中每个元素为参数调用你传给它的那个函数，从而生成一个新的列表。如下所示的例子中应用了上面的那个square函数:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; number = [1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; map(square, numbers)
[1, 4, 9, 16, 25]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果一个函数接受其他函数作为参数，以及/或者返回一个函数，那么它就被称为&lt;a href="http://en.wikipedia.org/wiki/Higher-order_function"&gt;高阶函数&lt;/a&gt; 。虽然map函数只是简单地使用了我们传给它的函数，而没有改变这个函数，但我们也可以使用高阶函数去改变其他函数的行为。&lt;/p&gt;
&lt;p&gt;例如，假设有这样一个函数，会被调用很多次，以致运行代价非常昂贵:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def fib(n):
...      &amp;quot;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;quot;
...      return n if n in [0, 1] else fib(n - 2) + fib(n - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们一般会保存计算过程中每次递归调用的结果，这样，对于函数调用树中经常出现某个n，当需要计算n对应的结果时，就不需要重复计算了。有多种方式可以做到这点。例如，我们可以将这些结果存在一个字典中，当以某个值为参数调用fib函数时，就先到这个字典去查一下其结果是否已经计算出来了。&lt;/p&gt;
&lt;p&gt;但这样的话，每次我们想要调用fib函数，都需要重复那段相同的字典检查样板式代码。相反，如果让fib函数自己在内部负责存储其结果，那么在其他代码中调用fib，就非常方便，只要简单地调用它就行了。这样一种技术被称为&lt;a href="http://en.wikipedia.org/wiki/Memoization"&gt;memoization&lt;/a&gt;(注意没有字母r的哦)。&lt;/p&gt;
&lt;p&gt;我们可以把这种memoization代码直接放入fib函数，但是Python为我们提供了另外一种更加优雅的选择。因为可以编写修改其他函数的函数，那么我们可以编写一个通用的memoization函数，以一个函数作为参数，并返回这个函数的memoization版本:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; memoize(fn):
    stored_results = {}

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; memoized(*args):
        &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
            &lt;span style="color: #008000"&gt;# try to get the cached result&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; stored_results[args]
        &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; KeyError:
            &lt;span style="color: #008000"&gt;# nothing was cached for those args. let&amp;#39;s fix that.&lt;/span&gt;
            result = stored_results[args] = fn(*args)
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; result
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; memoized
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上， &lt;code&gt;memoize&lt;/code&gt; 函数以另一个函数作为参数，函数体中创建了一个字典对象用来存储函数调用的结果：键为被memoized包装后的函数的参数，值为以键为参数调用函数的返回值。 &lt;code&gt;memoize&lt;/code&gt; 函数返回一个新的函数，这个函数会首先检查在 &lt;code&gt;stored_results&lt;/code&gt; 字典中是否存在与当前参数对应的条目；如果有，对应的存储值会被返回；否则，就调用经过包装的函数，存储其返回值，并且返回给调用者。memoize返回的这种新函数常被称为"包装器"函数，因为它只是另外一个真正起作用的函数外面的一个薄层。&lt;/p&gt;
&lt;p&gt;很好，现在有了一个memoization函数，我们可以把fib函数传给它，从而得到一个经过包装的fib，这个版本的fib函数不需要重复以前那样的繁重工作:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fib(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [0, 1] &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; fib(n - 2) + fib(n - 1)
fib = memoize(fib)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过高阶函数memoize，我们获得了memoization带来的好处，并且不需要对fib函数自己做出任何改变，以免夹杂着memoization的代码而模糊了函数的实质工作。但是，你也许注意到上面的代码还算有点别扭，因为我们必须写3遍fib。由于这种模式-传递一个函数给另一个函数，然后将结果返回给与原来那个函数同名的函数变量-在使用包装器函数的代码中极为常见，Python为其提供了一种特殊的语法：装饰器:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;@memoize
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fib(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [0, 1] &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; fib(n - 2) + fib(n -1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里，我们说memoize函数装饰了fib函数。需要注意的是这仅是一种语法上的简便写法(译注：就是我们常说的"语法糖")。这段代码与前面的代码片段做的是同样的事情：定义一个名为fib的函数，把它传给memoize函数，将返回结果存为名为fib的函数变量。特殊的(看起来有点奇怪的)@语法只是减少了冗余。&lt;/p&gt;
&lt;p&gt;你可以将多个装饰器堆叠起来使用，它们会自底向上地逐个起作用。例如，假设我们还有另一个用来帮助调试的高阶函数:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; make_verbose(fn):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; verbose(*args):
        &lt;span style="color: #008000"&gt;# will print (e.g.) fib(5)&lt;/span&gt;
        print &lt;span style="color: #a31515"&gt;&amp;#39;%s(%s)&amp;#39;&lt;/span&gt; % (fb.__name__, &lt;span style="color: #a31515"&gt;&amp;#39;, &amp;#39;&lt;/span&gt;.join(repr(arg) &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; arg &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; args))
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; fn(*args)   &lt;span style="color: #008000"&gt;# actually call the decorated function&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; verbose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面的两个代码片段做的是同样的事情:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;@memoize
@make_verbose
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fib(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [0, 1] &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; fib(n - 2) + fib(n - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fib(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [0, 1] &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; fib(n - 2) + fib(n - 1)
fib = memoize(make_verbose(fib))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有趣的是，Python并没有限制你在@符号后只能写一个函数名：你也可以调用一个函数，从而能够高效地传递参数给装饰器。假设我们并不满足于简单的memoization，还想将函数的结果存储到&lt;a href="http://memcached.org/"&gt;memcached&lt;/a&gt;中。如果你已经写了一个 &lt;code&gt;memcached&lt;/code&gt; 装饰器函数，那么可以(例如)传递一个服务器地址给它:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;@memcached(&lt;span style="color: #a31515"&gt;&amp;#39;127.0.0.1:11211&amp;#39;&lt;/span&gt;)
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fib(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; n &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; [0, 1] &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; fib(n - 2) + fib(n - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;非装饰器语法的写法会如下展开:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fib = memcached(&lt;span style="color: #a31515"&gt;&amp;#39;127.0.0.1:11211&amp;#39;&lt;/span&gt;)(fib)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python配备有一些作为装饰器使用的非常有用的函数。例如，Python有一个 &lt;code&gt;classmethod&lt;/code&gt; 函数，可以创建大致类似于java的静态方法:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Foo&lt;/span&gt;(object):
    SOME_CLASS_CONSTANT = 42

    @classmethod
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; add_to_my_constant(cls, value):
        &lt;span style="color: #008000"&gt;# Here, `cls` will just be Foo, buf if you called this method on a&lt;/span&gt;
        &lt;span style="color: #008000"&gt;# subclass of Foo, `cls` would be that subclass instead.&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; cls.SOME_CLASS_CONSTANT + value

Foo.add_to_my_constant(10)  &lt;span style="color: #008000"&gt;# =&amp;gt; 52&lt;/span&gt;

&lt;span style="color: #008000"&gt;# unlike in Java, you can also call a classmethod on an instance&lt;/span&gt;
f = Foo()
f.add_to_my_constant(10)    &lt;span style="color: #008000"&gt;# =&amp;gt; 52&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;旁注：文档字符串&lt;/h2&gt;
&lt;p&gt;Python函数可以包含更多的信息，而不仅仅是代码：它们也包含有用的帮助信息，比如函数名称，文档字符串:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def fib(n):
...     &amp;quot;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;quot;
...     return n if n in [0, 1] else fib(n - 2) + fib(n - 1)
...
&amp;gt;&amp;gt;&amp;gt; fib.__name__
&amp;#39;fib&amp;#39;
&amp;gt;&amp;gt;&amp;gt; fib.__doc__
&amp;#39;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python内置函数&lt;a href="http://docs.python.org/library/functions.html#help"&gt;help&lt;/a&gt;输出的就是这些信息。但是，当函数被包装之后，我们看到就是包装器函数的名称和文档字符串了:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; fib = memoized(fib)
&amp;gt;&amp;gt;&amp;gt; fib.__name__
&amp;#39;memoized&amp;#39;
&amp;gt;&amp;gt;&amp;gt; fib.__doc__
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那样的信息并没有什么用处。幸运的是，Python包含一个名为 &lt;code&gt;functools.wraps&lt;/code&gt; 的助手函数，能够把函数的帮助信息拷贝到其包装器函数:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; functools
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; memoize(fn):
    stored_results = {}

    @functools.wraps(fn)
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; memoized(*args):
        &lt;span style="color: #008000"&gt;# (as before)&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; memoized
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用装饰器帮助你编写装饰器会使很多事情令人非常满意。现在，如果使用更新过的memoize函数重试前面的代码，我们将会看到得到保留的文档:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; fib = memoized(fib)
&amp;gt;&amp;gt;&amp;gt; fib.__name__
&amp;#39;fib&amp;#39;
&amp;gt;&amp;gt;&amp;gt; fib.__doc__
&amp;#39;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>Python FAQ：Web开发（译）</title><link href="http://youngsterxyf.github.io/2012/07/30/python-faq-webdev/" rel="alternate"></link><published>2012-07-30T00:00:00+08:00</published><updated>2012-07-30T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-07-30:/2012/07/30/python-faq-webdev/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://me.veekun.com/blog/2012/05/05/python-faq-webdev/"&gt;Python FAQ: Webdev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://me.veekun.com/blog/2011/07/22/python-faq/"&gt;Python FAQ&lt;/a&gt;的一部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我只会PHP，那该怎么用Python来编写一个Web应用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个相当复杂的问题，甚至很容易就能写一本书来探讨Web开发与Python …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文： &lt;a href="http://me.veekun.com/blog/2012/05/05/python-faq-webdev/"&gt;Python FAQ: Webdev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://me.veekun.com/blog/2011/07/22/python-faq/"&gt;Python FAQ&lt;/a&gt;的一部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我只会PHP，那该怎么用Python来编写一个Web应用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个相当复杂的问题，甚至很容易就能写一本书来探讨Web开发与Python，以及如何关联两者，所以我很想先把这个问题放一放。但是鉴于我刚&lt;a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/"&gt;相当粗暴地捣毁了PHP&lt;/a&gt;，明智些，还是回答这个问题吧，宜早不宜迟。&lt;/p&gt;
&lt;p&gt;最直接简单的回答是：不要再读了，马上使用&lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;着手构建一样东西。然而，我觉得还有更好回答。&lt;/p&gt;
&lt;p&gt;本文并非是教程。也许将来我会写一篇，但现在已经存在大量的教程了，我认为你可以阅读那些文档。相反，本文是为新手而写的Python Web开发相关事情的概览。&lt;/p&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;p&gt;显然，你需要安装Python。确保使用Python 2，而不是3。Python 3有一些向后不兼容的改变，并非所有的库都更新过。&lt;/p&gt;
&lt;p&gt;安装Python库，可以考虑使用 &lt;code&gt;pip&lt;/code&gt; 。(如果你在使用类Unix操作系统，那么也许可以通过系统包管理器安装pip，否则使用 &lt;code&gt;easy_install pip&lt;/code&gt; ) &lt;code&gt;pip&lt;/code&gt; 是一个小巧的Python包管理器，便于安装，删除，升级，以及检查Python库。当然，尽可能使用你的系统包管理器，不行的话就用 &lt;code&gt;pip&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;pip install --user ...&lt;/code&gt; 将Python库安装到你的home目录，但更好的方式是保持库为每个项目局部可用---这样，你就可以为一个项目升级依赖项而不会破坏其他项目的依赖。(或者破坏Python编写的系统软件。我就曾干过这种事。) &lt;code&gt;virtualenv&lt;/code&gt; 使用单个命令就能助你创建一个独立的Python安装环境。&lt;/p&gt;
&lt;p&gt;当然，你已计划使用源码控制，对吧？我喜欢&lt;a href="http://www.git-scm.com/"&gt;git&lt;/a&gt; ,  但有聊胜于无，其他的也OK的。&lt;/p&gt;
&lt;h2&gt;框架&lt;/h2&gt;
&lt;p&gt;第一个障碍是如何将你代码与浏览器相关连。PHP中，最简单的方式是安装Apache并将它指向一些文件。Python中，如同更大的PHP项目，一般需要使用Web框架。&lt;/p&gt;
&lt;p&gt;框架多半有相似的工作流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装，使用 &lt;code&gt;pip&lt;/code&gt; 这样的工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个项目骨干(skeleton)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目骨干的复杂性视情况而定。对于现已不被使用的Pylons，你会得到一大堆诡异的代码，还需要为新的发布版本手动升级。Flask则简单到没有骨干。复杂性适中的是Pyramid，项目骨干不过是些通用的样板文件(boilerplate)，如果你是从零开始，那么最终会自己来写的这种样板文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置一些东西，比如数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动开发服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般是一个运行你的应用的终端程序，从而不需要一个专用的HTTP服务器。当你修改了代码，开发服务器就会自动重新装载，并且能输出栈跟踪和其他调试信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动手干吧！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，应该用什么框架呢？虽然有不计其数的可选项，但有一些明显最流行。&lt;/p&gt;
&lt;p&gt;我是&lt;a href="http://www.pylonsproject.org/"&gt;Pyramid&lt;/a&gt;的粉丝，它在极简主义与电池内置的庞然大物之间做出最佳的平衡。虽然它是从两个更老的组织良好的项目衍生而来，但在最近才成为一个竞争者。Pyramid设计良好，文档齐全，相当透明(fairly transparent)。一个简单的应用根本不需要自动生成的样板文件，允许你直接运行项目骨干，并且核心代码库扩展性非常好。有用的插件越来越多。&lt;/p&gt;
&lt;p&gt;如果需要更快地上手， &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;则足够简单了，但是可扩展性非常良好。其设计上与众不同地做了一些相当的合理的事情，且对你没有很多强迫。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bottlepy.org/docs/dev/"&gt;Bottle&lt;/a&gt;类似于Flask，但是更简单：它作为单个文件发布，没有任何依赖。是好是坏全看你自己，但这意味着Bottle中没有什么东西可以和其他框架分享的。我承认对Bottle知道的不是很多，但我曾简单地了解过(gave it a brief shot once)，对它没什么大的牢骚。&lt;/p&gt;
&lt;p&gt;另一极端上，&lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt;是为类内容管理系统和其他富内容网站而设计的巨大怪兽。它有庞大的可插部件生态系统，内置从模板到ORM的各种东西，以及大量文档和社区资源。Django常被认为是与Ruby on Rails等价的Python框架。其缺点是让它做些它不想做的事情会很别扭。( &lt;code&gt;#python&lt;/code&gt; 中许多更加愚钝的问题都是由于试图捣鼓Django而产生的)对于首次尝试Web开发来说，Django可能有些重量了。&lt;/p&gt;
&lt;p&gt;还有&lt;a href="http://www.web2py.com/"&gt;web2py&lt;/a&gt;。我，额，不太了解它。据说它会在你的模块名字空间内注入变量，这是令人讨厌的，所以如果你在意那些我认为讨厌的东西就不要用它，否则就用吧，随你自己啦。&lt;/p&gt;
&lt;p&gt;曾经有一个Apache模块 &lt;code&gt;mod_python&lt;/code&gt; ，本质上类似于 &lt;code&gt;mod_perl&lt;/code&gt; ，但很早就被抛弃了。请 &lt;strong&gt;不要&lt;/strong&gt; 使用它。&lt;/p&gt;
&lt;p&gt;最后，你也可以完全"手动"编写Python web代码，但那多半是一次令人沮丧的练习。不会更快，不会有什么教育意义，也不会有什么用。不要自找麻烦。&lt;/p&gt;
&lt;p&gt;我的建议？如果你只是想折腾捣鼓，那就从Flask入手吧，随你添加东西。如果你有想法要做一个网站，并且想旗开得胜(hit the ground running)，那就使用一个Pyramid脚手架(scaffold)，跟随它的叙述性文档进行开发。&lt;/p&gt;
&lt;h2&gt;路由选择(Routing)&lt;/h2&gt;
&lt;p&gt;PHP是根据URL执行一整个文件，Python web应用则倾向"拥有"一整个目录结构(或者甚至是整个域(domain))。因此，将特定的代码连接到特定的代码更加灵活，这种连接通常是由一个路由选择系统来处理。&lt;/p&gt;
&lt;p&gt;路由(routes)是包含可选占位符的URL，就像这样：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/users/{name}
/companies/{id}/products
/blog/{year:\d\d\d\d}/{month:\d\d}/{day:\d\d}/{title}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你可以把这样的一个路由绑定到一个函数，那么当你浏览到 &lt;code&gt;/users/eevee&lt;/code&gt; ，那个函数就会被执行，占位符则以 &lt;code&gt;dict(name=u'eevee')&lt;/code&gt; 这样的结构可供使用。&lt;/p&gt;
&lt;p&gt;一些框架(比如Pyramid)在这一步上走得更远：不是直接将路由绑定到函数，而是给路由一个名字，然后把名字绑定到函数。需要一点额外的工作，但优点是在你的应用中只需维护一个所有页面的核心列表。你也可以一个路由名和占位符值来生成一个URL---那么，之后，你就可以只在一个地方修改一下就能改变一个URL，而不需要接触其他东西，并且开发过程中打字错误会产生一个错误信息而不是一个404页面。&lt;/p&gt;
&lt;p&gt;语法和具体实现会有些不同，但每个框架都是使用这个系统的某个变种。有些有助于创建REST风格的路由或者其他常见模式，或者你可以很容易编写自己的模式。&lt;/p&gt;
&lt;h2&gt;请求周期&lt;/h2&gt;
&lt;p&gt;一次HTTP请求往往会执行某处的一个函数(由一个路由选择)，然后给函数传递一个 &lt;code&gt;request&lt;/code&gt; 对象参数。&lt;/p&gt;
&lt;p&gt;request对象的确切接口依赖于特定的框架，但是它们一般都比较类似：解析过的查询数据，一些cookie，请求消息头，等等。举例来说， &lt;code&gt;webob&lt;/code&gt; (http://www.webob.org) 的 &lt;code&gt;Request&lt;/code&gt; 对象包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.GET&lt;/code&gt; 和 &lt;code&gt;request.POST&lt;/code&gt; 是存储解析过的查询数据的"multidict"。(对于 &lt;code&gt;request.GET['foo']&lt;/code&gt; ，一个multidict返回的是单个值，但使用 &lt;code&gt;getall()&lt;/code&gt; 方法则会返回所有的值)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.params&lt;/code&gt; 是包含上面两者的一个multidict。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.cookies&lt;/code&gt; 是一个cookie的解析字典。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.headers&lt;/code&gt; 是一个HTTP请求消息头的字典，但是其键是大小写敏感的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.is_xhr&lt;/code&gt; 返回是否存在 &lt;code&gt;X-Requested-with: XMLHttpRequest&lt;/code&gt; 消息头，以识别由jQuery这样的库设置的ajax请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;request对象的文档一般非常齐全，因此只要浏览一下你所选择的框架的文档，挑出其中重要的内容。&lt;/p&gt;
&lt;p&gt;当你的应用完成了一些非常酷的事情之后，你要让它返回一个响应消息。通常你能选择是否明确地构建一个 &lt;code&gt;Response&lt;/code&gt; 对象(包括HTTP消息头和其他可手动设置的细节)还是简单返回一块HTML代码，其他所有东西都使用默认设置。很少需要你自己创建一个响应。对于像返回JSON这样的常见工作，每个框架都有某种快捷的或辅助的装饰器。&lt;/p&gt;
&lt;h2&gt;模板&lt;/h2&gt;
&lt;p&gt;组装HTML的工作一般是由模板引擎来完成的。&lt;a href="http://www.makotemplates.org/"&gt;Mako&lt;/a&gt;和&lt;a href="http://jinja.pocoo.org/"&gt;Jiaja2&lt;/a&gt;是两个主要的竞争者。&lt;/p&gt;
&lt;p&gt;我真的喜欢Mako。真的，真的，真的。使用它吧。它使用朴素的Python作为语法，使用起来非常自然。你甚至可以在模板里编写纯粹的Python代码块，但是你得控制住，尽可能避免这样做。:)&lt;/p&gt;
&lt;p&gt;Jinja2也不错，但提醒你一下：Jinja2中，如果 &lt;code&gt;foo&lt;/code&gt; 看起来像一个字典，那么 &lt;code&gt;foo.bar&lt;/code&gt; 就会被当作 &lt;code&gt;foo['bar']&lt;/code&gt; 处理，反之亦然。恰巧我认为这并不是一个好主意，我曾遭遇过许多诡异的问题，都是模板系统中这种"特性"所造成的。(另外， &lt;code&gt;{% %}&lt;/code&gt; 这种语法真的很烦人，但这有些鸡蛋里挑骨头了)。除此之外，Jinja2是一个非常可靠的库，而你肯定会做得更糟，&lt;a href="http://www.cheetahtemplate.org/"&gt;糟得多&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这两个工具速度都很快，会自动编译成Python模块，具备优秀的可调试能力(以疯狂的做法从原来的模板源码中得到栈跟踪信息)，应该足够强大，让你想干啥就能干啥了。大致了解一下这两个，然后选一个就开始使用吧。如果你不知道或者无所谓用哪个，那就用Mako吧。&lt;/p&gt;
&lt;p&gt;(注意，虽然Flask默认使用Jinja2，但使用Mako作为替代也是&lt;a href="https://github.com/tzellman/flask-mako"&gt;相当容易&lt;/a&gt;的。)&lt;/p&gt;
&lt;p&gt;当然还有其他的竞争者：排名第三的可能是Genshi，但它令人极其费解，以至于&lt;a href="http://genshi.edgewall.org/"&gt;主页&lt;/a&gt;上一开始就用了一张流程图； Djano有自己的模板引擎，千方百计想把逻辑剔除出模板(在我看来，对其是不利的)；Bottle同样有自己的极其简单的模板，但是可能很快就会让你感到越来越痛苦；Pyramid的另一个内建模板引擎是Chameleon，将类似HTML的属性标签用于循环和其他逻辑，太TMD古怪了。&lt;/p&gt;
&lt;p&gt;也许你会喜欢其中之一；我并没有都深入使用过它们。&lt;/p&gt;
&lt;p&gt;不管你做什么，都不要使用Cheetah。 &lt;strong&gt;不要&lt;/strong&gt; 使用Cheetah。它邪恶可憎。不要再提到它。&lt;/p&gt;
&lt;h2&gt;模板中的逻辑&lt;/h2&gt;
&lt;p&gt;也许你以前没用过模板，那你不可避免地会遭遇这个问题---一些复杂的表现代码是应该用Python实现，还是放在模板中实现。&lt;/p&gt;
&lt;p&gt;这是无聊的老生常谈，但我想说：就像许多程序设计中的架构决策，归结起来就是要尽可能减少以后因为它而对自己的厌恶感。尽可能保持模板简单，如果不行的话，也不用勉强。谨记你始终可以在简单的Python模块中编写简单的Python函数，然后导入它。一个强大的模板语言对于你的问题可能内建了创造性的解决方案，所以当你在想办法的时候可以先浏览一下文档。&lt;/p&gt;
&lt;h2&gt;Unicode&lt;/h2&gt;
&lt;p&gt;Unicode很烂。这是众所周知的事实。(我在说谎。编码(encoding)处理得很烂。Unicode很伟大。这个问题比较复杂，之后我会写到。)&lt;/p&gt;
&lt;p&gt;Python(2)有两种"字符串"类型： &lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;unicode&lt;/code&gt; 。这是一个巧妙的谎言。事实是：一个 &lt;code&gt;str&lt;/code&gt; 并不真的是一个字符串。它只是一串字节。有时恰巧看起来像一个字符串，但事实上只是一个二进制表示，就像 &lt;code&gt;85 00 00 00&lt;/code&gt; 是数字133的常见二进制表示。一个真正的数字是 &lt;code&gt;int&lt;/code&gt; 类型的，一个真正的字符串是 &lt;code&gt;unicode&lt;/code&gt; 类型的。&lt;/p&gt;
&lt;p&gt;这个问题很复杂，值得单独写一篇文章来解释(迟早我会写的)，但现在可以有些快速的笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你的程序只需要担心真正的字符串(也就是 &lt;code&gt;unicode&lt;/code&gt; 类型的)。字符串进入你的程序时需要解码，离开时需要编码，但是幸运的是，大多数的web框架都会为你做这事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你可以使用 &lt;code&gt;u&lt;/code&gt; 前缀来创建一个 &lt;code&gt;unicode&lt;/code&gt; 的字面字符串，e.g.， &lt;code&gt;u'foo'&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你可以在文件的顶部添加 &lt;code&gt;from __future__ import unicode_literals&lt;/code&gt; 使得文件中的所有字面字符串默认为 &lt;code&gt;unicode&lt;/code&gt; 。如果你确实需要一个 &lt;code&gt;str&lt;/code&gt; 类型字符串，那就使用 &lt;code&gt;b&lt;/code&gt; 前缀吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你想在Python源码中使用非ASCII字符，在顶部添加 &lt;code&gt;#encoding: utf8&lt;/code&gt; 魔术注释。（当然是假定你的源码保存为UTF-8编码的，这样做绝对更好。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;永远&lt;/strong&gt; 不要通过剥离非ASCII字符来解决Unicode问题！这是对很多人的无礼；想象一下当你尝试去使用一个网站，因为某个程序员懒得弄清楚如何处理英文字母，所以不允许你使用英文字母，你会是什么感受？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际上，对于撼动编码问题，重音字母和亚洲字符功不可没。将一些非ASCII字符的莫名其妙的话粘贴到你的网站表单中，看看会发生什么。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;XSS(跨站脚本攻击)&lt;/h2&gt;
&lt;p&gt;实际上，现在的每项相关技术都内建某种形式的自动HTML转义过滤器。理念是：对于这样的一个模板：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;p&amp;gt;Hello, ${name}!&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当给定 &lt;code&gt;name = '&amp;lt;b&amp;gt;'&lt;/code&gt; ，将安全地打印出 &lt;code&gt;Hello, &amp;amp;lt;b&amp;amp;gt;!&lt;/code&gt; 。这意味着，大多数时候，你并不需要担心XSS。&lt;/p&gt;
&lt;p&gt;大多数时候，如果没有别的，你必须核对所使用框架和模板引擎的文档，确保自动HTML转义过滤功能默认开启，如果不是，则开启它。(随便说一下：对于Pyramid，Django和Flask，你能轻松获得此项功能。如果你的模板文件具备一个处理HTML的扩展，Bottle则也能自动做到。)&lt;/p&gt;
&lt;p&gt;那么，棘手的地方就是知道何时以及如何关闭它。如果你在Python代码中构建了某种复杂的HTML，且不想完全转义它，那么仅仅使得转义行为失效是个蹩脚的解决方案。任何转义失效的地方都可能发生注入。幸运的是，许多框架(至少有Pyramid和Flask)使用了&lt;a href="http://pypi.python.org/pypi/MarkupSafe"&gt;markupsafe&lt;/a&gt;库，它能智能地帮助避免这个问题。&lt;/p&gt;
&lt;p&gt;markupsafe提供一个单一的类， &lt;code&gt;Markup&lt;/code&gt; ，继承自 &lt;code&gt;unicode&lt;/code&gt; . &lt;code&gt;Markup(u'Hello!')&lt;/code&gt; ，会产生一个行为上相当像字符串的对象。类方法 &lt;code&gt;Markup.escape&lt;/code&gt; 工作方式相同，但会转义经过包裹的字符串中的任意HTML字符。&lt;/p&gt;
&lt;p&gt;这里有两个鬼祟的花招。第一：一个 &lt;code&gt;Markup&lt;/code&gt; 对象不会被转义两次。请看：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = u&amp;#39;&amp;lt;b&amp;gt;oh noo xss&amp;lt;/b&amp;gt;&amp;#39;
&amp;gt;&amp;gt;&amp;gt; Markup.escape(s)
Markup(u&amp;#39;&amp;amp;lt;b&amp;amp;gt;oh noo xss&amp;amp;lt;/b&amp;amp;gt;&amp;#39;)
&amp;gt;&amp;gt; Markup.escape(Markup.escape(s))
Markup(u&amp;#39;&amp;amp;lt;b&amp;amp;gt;oh noo xss&amp;amp;lt;/b&amp;amp;gt;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因此，一旦创建了一个 &lt;code&gt;Markup&lt;/code&gt; 对象，就可将它用于你的模板，过滤器不会管它---即使它包含HTML。&lt;/p&gt;
&lt;p&gt;另一个把戏是， &lt;code&gt;Markup&lt;/code&gt; 对象重载了所有string的方法，并且自动转义所有的参数。这意味着在Python里，你可以这么干：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; user_input = u&amp;#39;&amp;lt;script&amp;gt;alert(&amp;quot;pwn&amp;quot;);&amp;lt;/script&amp;gt;&amp;#39;
&amp;gt;&amp;gt;&amp;gt; Markup(u&amp;#39;&amp;lt;p&amp;gt;Hello, %s!&amp;lt;/p&amp;gt;&amp;#39;) % user_input
Markup(u&amp;#39;&amp;lt;p&amp;gt;Hello, &amp;amp;lt;script&amp;amp;gt;alert(&amp;amp;#34;pwn&amp;amp;#34;);&amp;amp;lt;/script&amp;amp;gt;!&amp;lt;/p&amp;gt;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因此你可以相当安全地构建一些复杂的HTML代码，而不用太担心转义不够或者过分转义。&lt;/p&gt;
&lt;p&gt;当然，这并不完美。主要问题是你需要将 &lt;code&gt;Markup().join(...)&lt;/code&gt; 用于一些其他的 &lt;code&gt;Markup&lt;/code&gt; 对象，而不是 &lt;code&gt;''.join(...)&lt;/code&gt; 。并且某些操作，比如分片(slicing)，分割(splitting)，以及正则表达式，有可能产生没有意义的结果。 &lt;strong&gt;绝对&lt;/strong&gt; 不要试图分解一个 &lt;code&gt;Markup&lt;/code&gt; 对象或者任何其他HTML字符串；如果实在需要的话，那就使用一个真正的解析器，比如 &lt;code&gt;lxml&lt;/code&gt; ，但是大多数时候，你可以在将普通字符串包裹进HTML之前，对它做任何你需要的转换。&lt;/p&gt;
&lt;h2&gt;表单&lt;/h2&gt;
&lt;p&gt;我厌恶所有处理表单的库。每个单一的库。它们都把作者的疯狂命名方式强加到我的表单。我甚至不喜欢PHP使用 &lt;code&gt;foo[]&lt;/code&gt; 作为字段名称的行为；这有多丑陋啊。&lt;/p&gt;
&lt;p&gt;至今让我讨厌程度最低的是&lt;a href="http://wtforms.simplecodes.com/docs/dev/"&gt;wtform&lt;/a&gt;；它强加的设计上的限制相当少，并且使用起来非常简单。它甚至内建支持配合markupsafe。主要的缺陷是要想去除那些设计上的缺陷比较困难(每个表单元素都有一个与名字相匹配的 &lt;code&gt;id&lt;/code&gt; 属性)，并且实现一种新的字段会有点复杂。&lt;/p&gt;
&lt;p&gt;对于其他的我没法多说些什么，唉。&lt;a href="http://www.formencode.org/en/latest/index.html"&gt;FormEncode&lt;/a&gt;是一个东西。Pyramid的维护者还拥有&lt;a href="http://docs.pylonsproject.org/projects/deform/en/latest/index.html"&gt;deform&lt;/a&gt; 。它们都做了一些愚蠢的事情，也许确实是因为太挑剔了，我才这样烦扰。货比三家吧。&lt;/p&gt;
&lt;p&gt;无论你做啥，都要确保你使用东西不会使得你的项目变得太大。比表单处理库更让我厌恶的一件事是手动编写验证码。&lt;/p&gt;
&lt;h2&gt;"净化(Santizing)"&lt;/h2&gt;
&lt;p&gt;关于PHP界共同趋势的笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要&lt;/strong&gt; "净化(sanitize)"。&lt;/p&gt;
&lt;p&gt;这个词语本身没有什么意义。不存在某种你可以用于任意字符串并使之"安全"的方法。这种想法就是我一直遇到银行网站的联系表单告诉我不能使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 字符的原因；某些傻瓜企业开发者并不知道如何处理数据，所以他强迫所有数据必须简单易懂。&lt;/p&gt;
&lt;p&gt;不要成了一个白痴。&lt;/p&gt;
&lt;p&gt;大多数时候，"净化"是指使得用户输入安全地嵌入HTML，传递给SQL，或者作为命令行参数使用。你根本不需要改变原有数据就能做到所有这些事情。对于HTML，上面提到有一些过滤器，比如markupsafe。对于SQL，有界限参数和ORM。对于执行命令，你应该完全避免使用shell，仅仅将参数作为列表传递(参见 &lt;code&gt;subprocess&lt;/code&gt; (&lt;a href="http://docs.python.org/library/subprocess.html"&gt;http://docs.python.org/library/subprocess.html&lt;/a&gt;))。&lt;/p&gt;
&lt;p&gt;这些就是语言障碍(language barrier)的所有问题：HTML，SQL，以及shell都是结构化语言，你不能把一些莫名的垃圾数据倒给它们，还希望最好的结果。你不会使用字符串连结来创建JSON，所以也别用来执行 &lt;code&gt;convert&lt;/code&gt; (译注：这里的convert应该是用于图片格式转换的convert命令)。使用理解底层结构的工具。&lt;/p&gt;
&lt;p&gt;这并不是说你应该从不修改或过滤用户输入，而是你应该尽可能地避免它，并且当你做的时候应该极其小心。以常见的密码为例，为什么一般都禁止在密码中使用空格或者要将密码限制为16个字符？并没有明确的理由；仅仅是做了的一件事情。&lt;/p&gt;
&lt;p&gt;我仍然被这个问题所困扰：不让我输入 &lt;code&gt;&amp;lt;&lt;/code&gt; 的那个地方还坚持要我输入16个数字的字符串作为我的信用卡号。这就很难一目了然地证实我的输入是否正确---此外，在我的信用卡上的号码中间是有空格的呀！为什么不剔除空格和连字符？&lt;/p&gt;
&lt;p&gt;仔细思考你正在做的事情以及你正试图解决什么问题。人们会使用从右到左的Uniode字符对你的站点做一些愚蠢的事情么？你想阻止他们？没有理由要强迫每个人都使用ASCII；Unicode有&lt;a href="http://www.fileformat.info/info/unicode/category/index.htm"&gt;类别之分&lt;/a&gt;，你可以仅过滤怪异类别的字符。但更好的做法是，修改你的网站，使得说希伯来语的人都能使用它。:)&lt;/p&gt;
&lt;h2&gt;调试&lt;/h2&gt;
&lt;p&gt;如果你有幸(例如，使用Pyramid)，那么当你的程序崩溃时，你会有一个交互式的调试器，允许你检查程序的实时状态。你可以运行任意的Python代码，观察变量的状态，审核堆栈，以及耍着玩。&lt;/p&gt;
&lt;p&gt;如果你不幸，也不用担心；你还可以使用&lt;a href="http://werkzeug.pocoo.org/docs/debug/"&gt;werkzeug调试器&lt;/a&gt;。它相当易于使用；它能包裹任何WSGI应用，然后捕捉异常。(看到没有？WSGI妙得很。)&lt;/p&gt;
&lt;p&gt;只是当你部署应用的时候，要确保关闭调试，否则就会为别人所用；"任意Python代码"意味着任何看到调试屏幕的人都可以做你能在你的电脑做的任何事情。&lt;/p&gt;
&lt;h2&gt;数据库&lt;/h2&gt;
&lt;p&gt;一罐子的蠕虫啊。这话有些武断(This is as opinionated as I'm going to get.)。&lt;/p&gt;
&lt;p&gt;其一：你应该使用ORM。它是尝试将数据表映射到Python类，数据行映射到对象，查询映射到方法的物件。结果更加简单明了，通常更加容易理解，并且有时甚至正确率更高。&lt;/p&gt;
&lt;p&gt;你应该使用的ORM是&lt;a href="http://www.sqlalchemy.org/"&gt;SQLAlchemy&lt;/a&gt;。Pyramid对它有内建支持；如果你使用的框架没有内置支持，SQLAlchemy这么受欢迎，框架文档肯定有说明如何与它相连。如果你在使用Django，它有自己的ORM，虽然没有SQLAlchemy这么好，但要想把Django自带的ORM替换掉非常麻烦，不值得，除非你有迫切的需求。&lt;/p&gt;
&lt;p&gt;许多贬低ORM的人会告诉你ORM会产生糟糕的SQL。是的，糟糕的ORM确实会，但优秀的ORM，比如SQLAlchemy，对于SQL，和你理解得一样好。如果你懂SQL，SQLAlchemy会非常适合你；如果你不懂SQL，SQLAlchemy至少能帮你避免很多编写糟糕SQL的尴尬。记住你总是可以察看执行过的查询；SQLAlchemy可以把它们全部记录下来，并且各种调试工具栏会显示查询执行时间列表。(另外，留心那些执行多次的相同查询，这标示需要预先加载。)&lt;/p&gt;
&lt;p&gt;接下来，使用事务(transaction)。希望你不要对这个有太多的顾虑；如果一个框架集成了SQLAlchemy，它很可能会为你做这事。理念是：当开始一个请求，则开始一个事务，如果发生异常，事务会自动回滚。这是你一开始就想要的行为。这是使用数据库的一半(不对，是1/4)原因。&lt;/p&gt;
&lt;p&gt;还有一件事：既然本文中我所说的都是关于尝试新事物，那么 &lt;strong&gt;不要使用MySQL&lt;/strong&gt; 。在我能想到的任何意义上，MySQL都是数据库中的PHP(the PHP of databases)。考虑一下&lt;a href="http://www.postgresql.org/"&gt;PostgreSQL&lt;/a&gt;，它搭建起来并不会更难，使用起来更友好，也不会让你做在日期栏中存储字符串那样的蠢事。(在我看来，最友好的事情之一是PostgreSQL可以使用你的Unix用户帐号登录，不需要密码)。唯一的有人曾经反对使用Postgres的理由是它"不能扩展"。请放心，我还没看到这种情况的实际例子，总之，当访问者超过百万的时候，你才需要担心这个问题。&lt;/p&gt;
&lt;h2&gt;会话(Sessions)&lt;/h2&gt;
&lt;p&gt;每个框架都支持会话。看起来我们也熟悉：一个会话标识存储于cookie中，并且在后端你能魔法般地得到一个字典，可以往其中存储任意数据。随你怎么用。但尽量不要把它当作垃圾场。这事实证明数据库非常适合存储数据，你明白的。&lt;/p&gt;
&lt;p&gt;额外的特性包括：对CSRF(译注：Cross Site Request Forgery，跨站请求伪造)保护的一等(first-class)支持，以及信息提示(Pyramid，Flask，Django)。去阅读文档吧。&lt;/p&gt;
&lt;p&gt;提醒一句：如果你使用Beaker会话(Pyramid采用这个独立的库)，繁琐的东西会逐渐积累。默认情况下是为每个会话在磁盘上创建一个文件，但是如果使用数据库支持会话，你将得到一个存储了大量会话的数据表，并且这个数据表只增不减。这是一个非常糟糕却不明显的问题，主要的修复方法是手工操作。深表遗憾。&lt;/p&gt;
&lt;h2&gt;部署&lt;/h2&gt;
&lt;p&gt;啊哈，你明白我的意思的，部署有很多种方式，应该花更多的时间来讲述，但这里我没法花那么多的时间。&lt;/p&gt;
&lt;p&gt;如果可能，还是宁愿花些钱吧。提供服务肯定是要有代价的。如果你有自己的专用(虚拟的或者不是)机器随你摆弄，那么这是部署应用最简单的方式---手头有台服务器是件很酷的事情。你可以每月花费$20而获得一个基本的&lt;a href="http://www.linode.com/?r=c5316aa7d1cfce6f5fe611bb455ef1548cc1946c"&gt;Linode&lt;/a&gt;，还存在更便宜的托管服务提供商(但是没那么酷了)。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.heroku.com/"&gt;Heroku&lt;/a&gt;也是值得选择的，其收费等级中有一个免费级，只提供一个工作进程(worker，译注：Heroku官网解释"A worker dyno is a single background process running your code and processing jobs from a queue.")(类似于最低级Linode)，但是每个额外的工作进程都需要你另外支付$36/每月。(可以同时处理的请求数目正比于你持有的工作进程数目。具体需要多少工作进程则要看你的应用以及你如何运行它。)优点是你的应用会被部署得很专业。Heroku现在还支持多个应用副本。&lt;/p&gt;
&lt;p&gt;正如他们所说，部署是个很好的问题：因为这意味着你确实构建了有用的东西。那么在我努力写一篇关于部署选项的文章之时，你赶紧去构建某个应用吧。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Web是复杂的，涉及很多活动件(moving parts)。聪明的人们已经为你解决了很多问题。去捣鼓吧。&lt;/p&gt;
&lt;p&gt;希望本文足够让你开始Web开发了！&lt;/p&gt;
&lt;p&gt;一如既往，我并不知道自己做得怎么样，所以请你告诉怎样做得更好。&lt;/p&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>关于技术的学习方法</title><link href="http://youngsterxyf.github.io/2012/05/11/about-method-of-learning-technology/" rel="alternate"></link><published>2012-05-11T00:00:00+08:00</published><updated>2012-05-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-05-11:/2012/05/11/about-method-of-learning-technology/</id><summary type="html">&lt;p&gt;关于学习，时间短与效果好始终是一对矛盾的统一体。&lt;/p&gt;
&lt;p&gt;很多时候，要想在最短的时间内完成一件事情，最好的方法就是依葫 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;关于学习，时间短与效果好始终是一对矛盾的统一体。&lt;/p&gt;
&lt;p&gt;很多时候，要想在最短的时间内完成一件事情，最好的方法就是依葫芦画瓢，但这样的话，即使完成了事情，也只是知其然而不知其所以然，长久来看，对于学习者的能力不会有多大的提高。&lt;/p&gt;
&lt;p&gt;从长远来看，要想自己基础扎实，能力强，那就得一步一步的来，从基础知识开始，一点一点的搞懂，但这种方式需要花费很多时间，短时间内效果不明显。而且，可能效果没有预期的那么好。&lt;/p&gt;
&lt;p&gt;那么，如果做个权衡呢？&lt;/p&gt;
&lt;p&gt;我想，也许最好的学习方式是：先依葫芦画瓢地实践，获得一些直观感受，最好还有一些疑问。在实践完成之后，在整理自己的疑问，以及实践中涉及的知识要点，通过查阅图书或者网络资料，逐个知识点巩固，逐个解决疑问，并整理成文。这个整理总结的过程可能需要较长的时间。&lt;/p&gt;
&lt;p&gt;这种方式的优势在于：1.能让你快速地完成事情；2.实践中用到的知识多半会在以后的实践中经常用到，掌握的就是一些最重要的东西，而不会学习一些很少使用的深奥偏门知识。&lt;/p&gt;</content><category term="其他"></category><category term="技术"></category><category term="学习方法"></category></entry><entry><title>ubuntu12.04+ngnix+php-fastcgi+mysql+memcached网站开发测试环境搭建</title><link href="http://youngsterxyf.github.io/2012/05/10/ubuntu12.04-nginx-php-factcgi-mysql-memcached/" rel="alternate"></link><published>2012-05-10T00:00:00+08:00</published><updated>2012-05-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-05-10:/2012/05/10/ubuntu12.04-nginx-php-factcgi-mysql-memcached/</id><summary type="html">&lt;p&gt;1.
安装必要的软件&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt-get install nginx php5-cli php5-cgi spawn-fcgi psmisc mysql-server &lt;span style="color: #a31515"&gt;\&lt;/span&gt;
mysql-client php5-mysql memcached php5-memcache php5-curl php5-gd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
打开浏览器访问: 127.0.0.1。就能看到表示nginx安装成功的页面。但这时访问php文件页面还不行。
（注：ngnix的配置文件目录为 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;1.
安装必要的软件&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt-get install nginx php5-cli php5-cgi spawn-fcgi psmisc mysql-server &lt;span style="color: #a31515"&gt;\&lt;/span&gt;
mysql-client php5-mysql memcached php5-memcache php5-curl php5-gd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
打开浏览器访问: 127.0.0.1。就能看到表示nginx安装成功的页面。但这时访问php文件页面还不行。
（注：ngnix的配置文件目录为/etc/ngnix/，默认网站根目录为/usr/share/ngnix/www/；php配置文件目录为/etc/php5/）&lt;/p&gt;
&lt;p&gt;3.
编辑文件/etc/ngnix/sites-available/default，内容如下(可以先把原文件备份一下)：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;server {
    #listen   80; ## listen for ipv4; this line is default and implied
    #listen   [::]:80 default ipv6only=on; ## listen for ipv6

    root /usr/share/nginx/www;
    server_name localhost;

    location / {

        index   index.html index.htm;
    }

    location ~ \.php$ {

        fastcgi_pass    localhost:9000;
        fastcgi_index   index.php;
        fastcgi_param   SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include         fastcgi_params;
        try_files $uri $uri/ /index.html;
    }

    error_page 404 /404.html;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.
修改文件/etc/php5/cgi/php.ini。去除&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#cgi.fix_pathinfo=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一行前面的&lt;code&gt;#&lt;/code&gt;。具体信息请看php.ini的相关注释。&lt;/p&gt;
&lt;p&gt;5.
创建文件/usr/bin/php-fastcgi :&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;#!/bin/bash&lt;/span&gt;

FASTCGI_USER=www-data
FASTCGI_GROUP=www-data

ADDRESS=127.0.0.1
PORT=9000

PIDFILE=/var/run/php-fastcgi/php-fastcgi.pid
CHILDREN=6

PHP5=/usr/bin/php5-cgi
/usr/bin/spawn-fcgi -a $ADDRESS -p $PORT -P $PIDFILE -C $CHILDREN -u $FASTCGI_USER -g $FASTCGI_GROUP -f $PHP5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.
设置/usr/bin/php-fastcgi为可执行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod +x /usr/bin/php-fastcgi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7.
创建文件/etc/init.d/php-fastcgi：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;#!/bin/bash&lt;/span&gt;

PHP_SCRIPT=/usr/bin/php-fastcgi

FASTCGI_USER=www-data
FASTCGI_GROUP=www-data

PID_DIR=/var/run/php-fastcgi
PID_FILE=/var/run/php-fastcgi/php-fastcgi.pid
RET_VAL=0

&lt;span style="color: #0000ff"&gt;case&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt;
    start)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [[ ! -d $PID_DIR ]]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            mkdir $PID_DIR
            chown $FASTCGI_USER:$FASTCGI_GROUP $PID_DIR
            chmod 0770 $PID_DIR
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [[ -r $PID_FILE ]]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;&amp;quot;php-fastcgi already running with PID `cat &lt;/span&gt;$PID_FILE&lt;span style="color: #a31515"&gt;`&amp;quot;&lt;/span&gt;
            RET_VAL=1
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
            $PHP_SCRIPT
            RET_VAL=$?
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    ;;
    stop)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [[ -r $PID_FILE ]]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            kill &lt;span style="color: #a31515"&gt;`&lt;/span&gt;cat $PID_FILE&lt;span style="color: #a31515"&gt;`&lt;/span&gt;
            rm $PID_FILE
            RET_VAL=$?
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;&amp;quot;Could not find PID file &lt;/span&gt;$PID_FILE&lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;
            RET_VAL=1
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    ;;
    restart)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [[ -r $PID_FILE ]]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            kill &lt;span style="color: #a31515"&gt;`&lt;/span&gt;cat $PID_FILE&lt;span style="color: #a31515"&gt;`&lt;/span&gt;
            rm $PID_FILE
            RET_VAL=$?
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;&amp;quot;Could not find PID file &lt;/span&gt;$PID_FILE&lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
        $PHP_SCRIPT
        RET_VAL=$?
    ;;
    status)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [[ -r $PID_FILE ]]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;&amp;quot;php-fastcgi running with PID `cat &lt;/span&gt;$PID_FILE&lt;span style="color: #a31515"&gt;`&amp;quot;&lt;/span&gt;
            RET_VAL=$?
        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;&amp;quot;Could not find PID file &lt;/span&gt;$PID_FILE&lt;span style="color: #a31515"&gt;, php-fastcgi does not appear to be running&amp;quot;&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    ;;
    *)
        echo &lt;span style="color: #a31515"&gt;&amp;quot;Usage: php-fastcgi {start|stop|restart|status}&amp;quot;&lt;/span&gt;
        RET_VAL=1
    ;;
&lt;span style="color: #0000ff"&gt;esac&lt;/span&gt;
exit $RET_VAL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8.
添加可执行权限，以及设置为开机启动&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod +x /etc/init.d/php-fastcgi
sudo update-rc.d php-fastcgi defaults
sudo /etc/init.d/php-fastcgi start
sudo /etc/init.d/nginx start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;9.
创建文件/usr/share/nginx/www/test.php, 内容如下:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
    phpinfo();
&lt;span style="color: #0000ff"&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;10.
打开浏览器访问127.0.0.1/test.php，就能看到关于php信息的表格页面了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://library.linode.com/web-servers/nginx/php-fastcgi/ubuntu-10.04-lucid"&gt;Nginx and PHP-FastCGI on Ubuntu 10.04 LTS (Lucid)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Linux"></category><category term="Nginx"></category><category term="PHP"></category></entry><entry><title>Python对象创建过程（译）</title><link href="http://youngsterxyf.github.io/2012/04/26/python-object-creation-sequence/" rel="alternate"></link><published>2012-04-26T00:00:00+08:00</published><updated>2012-04-26T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-04-26:/2012/04/26/python-object-creation-sequence/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"&gt;Python object creation sequence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[本文讨论的Python版本为3.x]&lt;/p&gt;
&lt;p&gt;本文旨在探究Python中新对象的创建过程。正如我在&lt;a href="&amp;lt;http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"&gt;前一篇文章&lt;/a&gt;中所解释的，对象的创建只是调用可调用对 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文： &lt;a href="http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"&gt;Python object creation sequence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[本文讨论的Python版本为3.x]&lt;/p&gt;
&lt;p&gt;本文旨在探究Python中新对象的创建过程。正如我在&lt;a href="&amp;lt;http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/"&gt;前一篇文章&lt;/a&gt;中所解释的，对象的创建只是调用可调用对象的一种特例。考虑这样的一段Python代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Joe&lt;/span&gt;:
    &lt;span style="color: #0000ff"&gt;pass&lt;/span&gt;

j = Joe()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当j = Joe()被执行时发生了什么呢？Python把它看作对可调用的Joe的一次调用，并且将它路由到内部函数 &lt;code&gt;PyObject_Call&lt;/code&gt; ，将Joe作为PyObject_Call的第一个参数。 &lt;code&gt;PyObject_Call&lt;/code&gt; 根据其第一个参数的类型抽取这个参数类型的 &lt;code&gt;tp_call&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;那么，Joe的类型是什么呢？无论何时我们定义一个新的Python类(class)，它的类型都是 &lt;code&gt;type&lt;/code&gt; ，除非我们明确地为它指定一个 &lt;a href="http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;metaclass&lt;/a&gt;。因此，当 &lt;code&gt;PyObject_Call&lt;/code&gt; 试图查看Joe的类型，将得到类型 &lt;code&gt;type&lt;/code&gt; ，然后选择 &lt;code&gt;type&lt;/code&gt; 的 &lt;code&gt;tp_call&lt;/code&gt; 属性。换句话说，就是调用 &lt;code&gt;Objects/typeobject.c&lt;/code&gt; 文件中的函数 &lt;code&gt;type_call&lt;/code&gt; [1]。&lt;/p&gt;
&lt;p&gt;这是一个有趣并且短小的函数，所以我将它整个地粘贴到这里：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;static&lt;/span&gt; PyObject *
type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj;

    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (type-&amp;gt;to_new == NULL) {
        PyErr_Format(PyExc_TypeError,
                    &lt;span style="color: #a31515"&gt;&amp;quot;cannot create &amp;#39;%.100s&amp;#39; instances&amp;quot;&lt;/span&gt;,
                    type-&amp;gt;tp_name);
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; NULL;
    }

    obj = type-&amp;gt;tp_new(type, args, kwds);
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (obj != NULL) {
        &lt;span style="color: #008000"&gt;/* Ugly exception: when the call was type(something),&lt;/span&gt;
&lt;span style="color: #008000"&gt;            don&amp;#39;t call tp_init on the result. */&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (type == &amp;amp;PyType_Type &amp;amp;&amp;amp;
            PyTuple_Check(args) &amp;amp;&amp;amp; PyTuple_GET_SIZE(args) == 1 &amp;amp;&amp;amp;
            (kwds == NULL ||
                (PyDict_Check(kwds) &amp;amp;&amp;amp; PyDict_Size(kwds) == 0)))
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; obj;
        &lt;span style="color: #008000"&gt;/* If the returned object is not an instance of type,&lt;/span&gt;
&lt;span style="color: #008000"&gt;            it won&amp;#39;t be initialized. */&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (!PyType_IsSubtype(Py_TYPE(obj), type))
            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; obj;
        type = Py_TYPE(obj);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (type-&amp;gt;tp_init != NULL &amp;amp;&amp;amp;
            type-&amp;gt;tp_init(obj, args, kwds) &amp;lt; 0) {
            Py_DECREF(obj);
            obj = NULL;
        }
    }
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; obj; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在我们的例子中传给 &lt;code&gt;type_call&lt;/code&gt; 的参数是什么呢？第一个是Joe自己---它是如何表示的呢？好吧，Joe是一个类(class)，因此它是一个 &lt;em&gt;类型(type)&lt;/em&gt; (&lt;a href="http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/"&gt;Python3中所有类都是类型&lt;/a&gt;)。而类型在CPython虚拟机内部是通过 &lt;code&gt;PyTypeObject&lt;/code&gt; 对象来表示的[2]。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type_call&lt;/code&gt; 首先调用给定类型的 &lt;code&gt;tp_new&lt;/code&gt; 属性。然后，检测一个特殊的情况(为简单起见可忽视先)以确保 &lt;code&gt;tp_new&lt;/code&gt; 返回的是预期类型的对象，然后调用 &lt;code&gt;tp_init&lt;/code&gt; 。如果返回的是一个不同类型的对象，则不将其初始化。&lt;/p&gt;
&lt;p&gt;从Python代码来看，就是发生了这些事情：如果你的类中定义了特殊方法 &lt;code&gt;__new__&lt;/code&gt; ，当创建类的一个新实例时，首先调用这个特殊方法。这个方法必须返回某个对象。通常，返回的即是预期类型的对象，但是并非必须如此。所需类型的对象对其自身调用 &lt;code&gt;__init__&lt;/code&gt; 。示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Joe&lt;/span&gt;:
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __new__(cls, *args, **kwargs):
        obj = super(Joe, cls).__new__(cls)
        print (&lt;span style="color: #a31515"&gt;&amp;#39;__new__ called. got new obj id=0x%x&amp;#39;&lt;/span&gt; % id(obj))
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; obj

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, arg):
        print (&lt;span style="color: #a31515"&gt;&amp;#39;__init__ called (self=0x%x) with arg=%s&amp;#39;&lt;/span&gt; % (id(self), arg))
        self.arg=arg

j = Joe(12)
print(type(j))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;__new__ called. got new obj id=0x7f88e7218290
__init__ called (self=0x7f88e7218290) with arg=12
&amp;lt;class &amp;#39;__main__.Joe&amp;#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;自定义过程&lt;/h2&gt;
&lt;p&gt;如上所示，Joe的类型为 &lt;code&gt;type&lt;/code&gt; ，所以调用函数 &lt;code&gt;type_call&lt;/code&gt; 定义Joe实例的创建过程。可以通过为Joe指定一个自定义的类型来改变这个过程---换句话来说，这种自定义的类型就是一个metaclass。让我们修改前面的示例来为Joe指定一个自定义的metaclass：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;MetaJoe&lt;/span&gt;(type):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __call__(cls, *args, **kwargs):
        print(&lt;span style="color: #a31515"&gt;&amp;#39;MetaJoe.__call__&amp;#39;&lt;/span&gt;)
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Joe&lt;/span&gt;(metaclass=MetaJoe):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __new__(cls, *args, **kwargs):
        obj = super(Joe, cls).__new__(cls)
        print(&lt;span style="color: #a31515"&gt;&amp;#39;__new__ called. got new obj id=0x%x&amp;#39;&lt;/span&gt; % id(obj))
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; obj

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, arg):
        print(&lt;span style="color: #a31515"&gt;&amp;#39;__init__ called (self=0x%x) with arg=%s&amp;#39;&lt;/span&gt; % (id(self), arg))
        self.arg = arg

j = Joe(12)
print(type(j))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在Joe的类型不是 &lt;code&gt;type&lt;/code&gt; ，而是 &lt;code&gt;MetaJoe&lt;/code&gt; 。因此，当 &lt;code&gt;PyObject_Call&lt;/code&gt; 为 &lt;code&gt;j = Joe(12)&lt;/code&gt; 选择要执行的调用函数，它选择的是 &lt;code&gt;MetaJoe.__call__&lt;/code&gt; 。后者先打印一条关于自己的提示，然后返回None，所以我们根本不要期望调用Joe的方法 &lt;code&gt;__new__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;事实上，输出是这样的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;MetaJoe.__call__
&amp;lt;class &amp;#39;NoneType&amp;#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;更深的挖掘 - tp_new&lt;/h2&gt;
&lt;p&gt;很好，现在我们对于对象创建过程有了一个更好的理解，但是这一问题的一个关键部分还没有得到解释。虽然我们几乎总会为类定义方法 &lt;code&gt;__init__&lt;/code&gt; ，但却很少定义 &lt;code&gt;__new__&lt;/code&gt; [3]。此外，快速浏览一下代码就能明显地发现从某种程度上 &lt;code&gt;__new__&lt;/code&gt; 更为重要。这个方法是被用来创建对象的。每个实例仅调用它一次。另一方面，调用 &lt;code&gt;__init__&lt;/code&gt; 时已经得到了一个构造好的对象，且 &lt;code&gt;__init__&lt;/code&gt; 可能根本不会被调用；而且它也可以被调用多次。&lt;/p&gt;
&lt;p&gt;在我们的例子中，传递给 &lt;code&gt;type_call&lt;/code&gt; 的参数type是Joe，而Joe并没有自定义的 &lt;code&gt;__new__&lt;/code&gt; 方法，那么 &lt;code&gt;type-&amp;gt;tp_new&lt;/code&gt; 的工作将交予基本类型(the base type)的结构成员(slot) &lt;code&gt;tp_new&lt;/code&gt; 。Joe(&lt;a href="http://eli.thegreenplace.net/2012/04/03/the-fundamental-types-of-python-a-diagram/"&gt;以及所有其他的Python对象&lt;/a&gt; ，除了object自己)的基本类型是object。CPython内部是通过Objects/typeobject.c中的object_new函数来实现object.tp_new结构成员的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;object_new&lt;/code&gt; 实际上非常简单：先检查某些参数，核实正尝试实例化的类型不是&lt;a href="http://docs.python.org/dev/library/abc.html"&gt;抽象&lt;/a&gt;的，然后：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;return&lt;/span&gt; type-&amp;gt;tp_alloc(type, 0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;tp_alloc&lt;/code&gt; 是CPython内部类型对象的一个低层次结构成员，不可以在Python代码中直接访问它，但是C扩展开发人员应该对它比较熟悉。C扩展程序中的自定义类型(custom type)可能会重载这个结构成员从而为自己的实例提供一个自定义的内存分配方案。然而，大多数的C扩展类型会将其实例的内存分配工作交予 &lt;code&gt;PyType_GenericAlloc&lt;/code&gt; 函数完成。&lt;/p&gt;
&lt;p&gt;这个函数是CPython的公共C API的一部分，也恰好将它赋值给了object的结构成员 &lt;code&gt;tp_alloc&lt;/code&gt; (在Objects/typeobject.c中定义)。它先算出新对象需要多少内存空间[4]，从CPython的内存分配器中分配一个内存块，将分配得的所有内存单元都初始化为0，然后仅初始化基本的PyObject域(类型与引用计数)，做些垃圾收集簿记(GC bookkeeping)的工作并返回。其结果是一个刚分配的实例。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;为了避免只见树木不见森林，让我们一起回顾一下文章开始的那个问题。当CPython执行j = Joe()时发生了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt;&amp;gt; 由于Joe没有明确的metaclass，type就是它的类型，因此调用type的tp_call接口，即是，type_call。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt;&amp;gt; 由于Joe没有明确的基类(base class)，它的基类(base)就是object(译注:意思就是Joe继承自object)，因此，调用object_new。&lt;br /&gt;
&amp;gt;&amp;gt; 由于Joe是一个Python代码定义的类，它没有自定义的tp_alloc接口。因此，object_new调用PyType_GenericAlloc。&lt;br /&gt;
&amp;gt;&amp;gt; PyType_GenericAlloc分配并初始化一块足够大的内存空间用来存储Joe。
&amp;gt;&amp;gt; 然后type_call继续执行并在刚创建对象上调用Joe.&lt;strong&gt;init&lt;/strong&gt;。
&amp;gt;&amp;gt; 由于Joe没有定义__init__，所以调用它的基类的__init__，即object_init。&lt;br /&gt;
&amp;gt;&amp;gt; object_init啥事都没干。
&amp;gt;&amp;gt; 从type_call返回新的对象并将其绑定到名字j。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上，就是创建一个类的对象的乏味的流程，这个类没有自定义的metaclass，没有明确的基类，也没有定义它自己的__new__和__init__方法。然而，本文应该已经解释清楚了如何插入自定义功能从而改变对象创建过程。正如你所见的，Python灵活得令人惊讶，几乎可以自定义上述过程的每个步骤，甚至对于Python代码实现的用户定义的类型也是如此。C扩展中实现的类型可以进行更多的自定义，比如：用于创建类型实例的确切的内存分配策略。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1] type的PyTypeObject结构定义即为Objects/typeobject.c中的PyType_Type。你可以看到type_call被赋值给了它的结构成员tp_call。&lt;/p&gt;
&lt;p&gt;[2] 以后的文章会解说:当创建一个新类时这是怎么实现的。&lt;/p&gt;
&lt;p&gt;[3] 甚至当在类中明确地重载了__new__，我们也几乎可以肯定实际的对象创建被推迟到基类的__new__。&lt;/p&gt;
&lt;p&gt;[4] 任何类型的PyObject头部都有这个信息。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;译注:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;sequence直译成"序列，顺序"，可能会导致不容易理解文章的意思，所以翻译成" &lt;strong&gt;过程&lt;/strong&gt; "更合适一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPython中用C语言的结构(struct)来定义对象(类型也是对象)，一个对象所具有的方法或者属性都是结构的成员，所以把slot翻译成" &lt;strong&gt;结构成员&lt;/strong&gt; "应该比较合适。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="Python"></category><category term="翻译"></category></entry><entry><title>关于指针的一道笔试题</title><link href="http://youngsterxyf.github.io/2012/04/20/an-exercise-about-pointer/" rel="alternate"></link><published>2012-04-20T00:00:00+08:00</published><updated>2012-04-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-04-20:/2012/04/20/an-exercise-about-pointer/</id><summary type="html">&lt;p&gt;同学找实习，遇到这样一道笔试题:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *a[2][3];
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(*a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(**a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(***a) = ?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这题还是有点小意思的。遇到这种题，脑子一定要清楚，注意 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;同学找实习，遇到这样一道笔试题:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *a[2][3];
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(*a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(**a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(***a) = ?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这题还是有点小意思的。遇到这种题，脑子一定要清楚，注意分析。&lt;/p&gt;
&lt;p&gt;对于int *a[2][3]应该这么理解：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a是个数组，有两个元素；元素也是数组，其有3个元素，每个元素是指向int类型的指针。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针的长度固定为4个字节，C语言的int类型也是4个字节。&lt;/p&gt;
&lt;p&gt;这样一分析，这题就简单了。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sizeof(a)意思是求a数组的长度，数组的长度=数组元素的个数*元素的长度，所以sizeof(a) = 2 * 3 * 4 = 24个字节
sizeof(*a)中的*a是指a的第一个元素，所以sizeof(*a)就是求a数组的第一个元素的长度，即sizeof(*a) = 3 * 4 = 12个字节
sizeof(**a)则是求a的第一个元素(也是数组)的第一个元素(是指向int类型的指针)的长度，所以sizeof(**a) = 4个字节(即为一个指针的长度)
sizeof(***a)，因为**a是一个指针类型，那么***a即为*(**a)，那为指针指向的值，这里为int类型，所以sizeof(***a) = 4个字节(int类型的长度)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="笔试"></category><category term="C/C++"></category></entry><entry><title>学习的"道"与"术"</title><link href="http://youngsterxyf.github.io/2012/03/31/dao-and-shu-about-learning/" rel="alternate"></link><published>2012-03-31T00:00:00+08:00</published><updated>2012-03-31T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-03-31:/2012/03/31/dao-and-shu-about-learning/</id><summary type="html">&lt;p&gt;读研以来，一直觉得自己的学习方法不够高效。试图将要学习的东西进行分类，然后以不同的方法学习之。那么该如何分类 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;读研以来，一直觉得自己的学习方法不够高效。试图将要学习的东西进行分类，然后以不同的方法学习之。那么该如何分类呢？我觉得以"道"与"术"区分之比较合适。&lt;/p&gt;
&lt;p&gt;何为"道 "？汉语辞典中有两条解释：&lt;strong&gt;1.指法则、规律；2.学术或宗教的思想体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;何为"术"？：&lt;strong&gt;技艺&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字面理解，“术”更为具体，是完成一件事情的具体过程。而“道”者则是指导实践的思想，是能够举一反三的事物规律。&lt;/p&gt;
&lt;p&gt;那么是否“道”比“术”更重要呢？我想未必。任何理论，任何“道”都最终来源于“术”的实践过程，也最终需要在“术”上得到实施，才能体现其价值。“道”与“术”两者相辅相成。那么在我们学习一门学问的过程中，就存在一个“道”与“术”何者为先的问题，即从“道”还是“术”入手学习？&lt;/p&gt;
&lt;p&gt;孟岩说过这么一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我主张,在具备基础之后,学习任何新东西,都要抓住主线,突出重点。对于关键理论的学习,要集中精力,速战速决。而旁枝末节和非本质性的知识内容,完全可以留给实践去零敲碎打。
原因是这样的,任何一个高级的知识内容,其中都只有一小部分是有思想创新、有重大影响的,而其它很多东西都是琐碎的、非本质的。因此,集中学习时必须把握住真正重要那部分,把其它东西留给实践。对于重点知识,只有集中学习其理论,才能确保体系性、连贯性、正确性,而对于那些旁枝末节,只有边干边学能够让你了解它们的真实价值是大是小,才能让你留下更生动的印象。如果你把精力用错了地方,比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧,而对于真正重要的、思想性东西放在平时零敲碎打,那么肯定是事倍功半,甚至适得其反。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然这段话并没有明确区分学习的“道”与“术”，以及何者为先的问题。但却大致说明了何为正确的学习方法。&lt;/p&gt;
&lt;p&gt;从“道”与“术”的角度来理解，那关键的，核心的，创新的部分即为“道”，“大道”。而那细节的则是“术”的部分，是需要长时间的实践的，也许只有在实践中遇到的细节才是有意义的。&lt;/p&gt;
&lt;p&gt;但那“具备基础之后”的“基础”是什么呢？我想应该是：1.明确问题是什么。这一点是再怎么强调都不为过的。要解决一个问题却没有真正明确问题到底是什么，那你努力多半是白费的。2.这东西是用来干什么用的，是用来解决什么问题的？对于工科学生来说，学习新东西的时候，这一点是需要首先明确的，只有明确了“干什么用的”，才能抓住学习的重点，提高学习的效率。3. 与以前的类似的东西相比，其区别是什么？一样东西，一种理论其价值往往在于对前人的突破，这突破的地方才是我们真正要掌握的。在学习一样东西之前，不妨多问问自己为什么要学这个，这东西对自己有多大的提升？不断地重复学习类似的东西，多半是没有意义的。&lt;/p&gt;
&lt;p&gt;具备了基础之后，对于关键理论的学习，是不是只要抱着书本，理论对理论的学习就行呢？我想这是万万不可的。特别是对于着重于实践性的学问，比如编程，理论对理论地学习，只会让你吃力不讨好。绝大多数的创新理论，核心理论，都不是一下子就能理解的，特别是当你对这一领域的学问并不熟悉的情况下，它需要在反复的实践中逐步地加深理解。&lt;/p&gt;
&lt;p&gt;那么对于关键内容的学习，我觉得这样学习会比较合适：先快速地，在尽可能短的时间内把关键内容浑沦吞枣地过一遍，能理解多少是多少，目的是为了获得一个理论的一个Big Picture，明确理论的各个部分之间的大致关系。然后对于每个部分，以及部分之间的关系，逐个地通过实践来验证你的理解，但这个实践过程并不属于“术”，因为它不是为了技艺，而只是为了验证自己对理论的理解。这一验证过程结束之后，你应该就能够对关键理论有个整体的正确的理解了。&lt;/p&gt;
&lt;p&gt;然后，你就放开手去干吧，去解决那些现实中的问题！&lt;/p&gt;
&lt;p&gt;也许，你会说，不用这么复杂吧？是的，如果你只是为了解决一个实际的问题，而这个问题也存在相近的解决方案，你不想也不需要弄懂这个问题，好吧，那你就直接去找解决方案吧。但你解决这个问题之后，你学到了什么呢？当你再次遇到一个本质上一样的问题的时候，你还是能快速地解决么？没有真正弄懂问题，没有弄懂问题背后的知识，那你就准备着为类似的问题重复地去寻找解决方案吧。恩，看起来有点傻哦。&lt;/p&gt;</content><category term="其他"></category><category term="学习方法"></category></entry><entry><title>Python学习路线(针对具备一定编程经验者)</title><link href="http://youngsterxyf.github.io/2012/02/21/the-path-of-learning-python/" rel="alternate"></link><published>2012-02-21T00:00:00+08:00</published><updated>2012-02-21T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-02-21:/2012/02/21/the-path-of-learning-python/</id><summary type="html">&lt;p&gt;相比C,C++,JAVA等编程语言，Python是易学的。但要想深入地理解Python，并熟练地编写Python风格的Python代码。我想还是有一长段路程要走的。下面即是我的一点经验总结，主要是 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;相比C,C++,JAVA等编程语言，Python是易学的。但要想深入地理解Python，并熟练地编写Python风格的Python代码。我想还是有一长段路程要走的。下面即是我的一点经验总结，主要是为了整理自己学习的思路。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花1-2天的时间阅读一本好的Python入门书籍，并在亲手实践书中的代码。推荐入门书籍：《A byte of Python》(中文翻译《简明Python教程》)或《Practical Programming:An Introduction to Computer Science Using Python》(中文翻译《Python实践教程》)或者其他的比较薄的入门书籍。&lt;/li&gt;
&lt;li&gt;抛开书籍，用Python去写一切你想写的程序。这时最好的参考文档即为：(1).Python命令解释器中的help(),dir()辅助方法；(2).Python官网文档：&lt;a href="http://docs.python.org/"&gt;http://docs.python.org/&lt;/a&gt; 。遇到不清楚的地方就用这两个方法查，再不行就去google一下。&lt;/li&gt;
&lt;li&gt;两三个月之后，积累一点的代码量，再重新找本讲解比较详细的书，重新梳理一下自己对Python的理解，纠正自己实践中一些不好的方式。推荐书籍：《Beginning Python: From Novice to Professional》(中文翻译《Python基础教程》)，《Learning Python》(中文翻译《Python学习手册》)，《Dive into Python》，《Core Python Programming》等。另外，也应该在编码的过程中重复地去查阅Python标准函数库，标准库里已有模块实现的功能就不要自己实现。&lt;/li&gt;
&lt;li&gt;之后，根据实际需要，去了解使用一下Python的各个方面的函数库(比如http://docs.python.org/modindex.html中罗列出来的，以及matplotlib, numpy等用于科学计算，图形图像处理的)，特别是诸多的Web框架(django, web2py, cherrypy, tornado等)，可以先从简单的开始。如果是对Python的底层实现感兴趣，那么就该去看看Python源码，阅读一下《Python源码剖析》; 如果对文本处理感兴趣，可以阅读一下《Text processing in Python》等； 如果对网络感兴趣，可以阅读《Foundations of Python Network Programming》，尝试实现一个简单的web server ...&lt;/li&gt;
&lt;li&gt;Python相关的开源函数库非常非常的多，各个方面的都有，所以学习者应该尝试着去用它们，了解它们，而不是啥都要自己来实现。因为Python擅长的就是快速开发，而且站在前人的肩膀上，我们才能站得更高，看得更远。当然如果你想加深自己对某个方面的理解，也可以尝试去实现一些简单的模块。&lt;/li&gt;
&lt;li&gt;总之一句话：学习Python的关键就是用！而且是要多用别人的。动手实践才是王道！那么多优秀的开源函数库不要浪费了！&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="Python"></category></entry><entry><title>Linux命令习题</title><link href="http://youngsterxyf.github.io/2012/02/15/Linux-Command-Excercise/" rel="alternate"></link><published>2012-02-15T00:00:00+08:00</published><updated>2012-02-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-02-15:/2012/02/15/Linux-Command-Excercise/</id><summary type="html">&lt;p&gt;For each of the outputs listed below, find one sequence of commands connected by pipes that produces the output. For each problem, turn in the command sequence that you used to generate the requested output. (Do NOT turn in the output itself.)&lt;/p&gt;
&lt;p&gt;1.
A listing of all processes that you …&lt;/p&gt;</summary><content type="html">&lt;p&gt;For each of the outputs listed below, find one sequence of commands connected by pipes that produces the output. For each problem, turn in the command sequence that you used to generate the requested output. (Do NOT turn in the output itself.)&lt;/p&gt;
&lt;p&gt;1.
A listing of all processes that you are currently running on the machine you are using, sorted by the command name in alphabetical order (i.e. a process running acroread should be listed before a process running bash). The output should consist only of the processes you are running, and nothing else (i.e. if you are running 6 processes, the output should only have 6 lines). &lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps -e --sort cmd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.
he number of words in the file /usr/share/dict/words (*) which start with the letter a.&lt;/p&gt;
&lt;p&gt;* Note: On some Unix/Linux systems, the dictionary has the filename /usr/dict/words&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cat /usr/share/words | grep ^a.* | wc -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.
A "long" listing of the smallest 5 files in the /etc directory whose name contains the string ".conf", sorted by increasing file size. &lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls -lSrp | grep [^/]$ | grep [&lt;span style="color: #a31515"&gt;\.&lt;/span&gt;]conf$ | head -n 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Linux"></category></entry><entry><title>2011年终-回顾与展望</title><link href="http://youngsterxyf.github.io/2012/01/01/2011-summary/" rel="alternate"></link><published>2012-01-01T00:00:00+08:00</published><updated>2012-01-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-01-01:/2012/01/01/2011-summary/</id><summary type="html">&lt;p&gt;昨晚实验室聚餐，和师兄们喝醉了，明年的这个时候，我也就和他们一样将要毕业。时间，总是往前看觉得很漫长，可回过头去 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨晚实验室聚餐，和师兄们喝醉了，明年的这个时候，我也就和他们一样将要毕业。时间，总是往前看觉得很漫长，可回过头去看看，一年也就是瞬间的事情。&lt;/p&gt;
&lt;p&gt;2011，我从研一走向研二，2012，我将从研二走向研三，继而毕业，工作。&lt;/p&gt;
&lt;p&gt;回顾过去一年，于我自己而言，过得很平淡，也许是大学以来最平淡的一年，只能说也许，因为对于2011，我记不得太多的事情。&lt;/p&gt;
&lt;p&gt;这一年里，我，一个技术男，比以前更宅，话也相对少了很多，直接表现为QQ空间或者校内上的文字写得很少。很少和别人谈论自己，因为我觉得纠结于那个“小我”是件很“小青年”的事情。人与人之间不可避免的隔膜导致了个人的事情不管多大在别人眼里都是微不足道的，在别人的心里掀不起半点波澜，说过了也就忘了。所以那些关于自己的，还是放在心里比较好，毋须说些没意义的。&lt;/p&gt;
&lt;p&gt;这一年里，我想得挺多，但真正做了或者说做好的却很少。这是件严重的事情。特别在技术上，东看西看，东学西学，眼界确实开阔很多，也养成了较为良好的技术趣味。但从技术能力上来说，真不好说，我都不知道自己有几斤几两。&lt;/p&gt;
&lt;p&gt;这一年里，最大的收获，也许是对“学习”的重新认识，以及试图从“学知识”向“做事情”转变(这里的“做事情”特指“解决实际问题”)，以前的自己太喜欢太沉迷于学东西，而忽略了自主地做事情。“生有涯，而知无涯”的无奈是必须面对的，对于有限的人生来说，知识必须对自己有用才值得学，特别是技术相关的知识，那怎么知道哪些知识对自己有用呢？得“边用边学”，需要用的时候再学。所以应多做事情，应找实际的问题，尝试去解决，在解决问题的过程中学习。解决实际问题才是根本，才是目的，而不是学习。学生时代习惯了学，习惯了边学边用，但对于研究生，对于以后的工作来说，光顾着学是没用的，而且一味的学也是非常难以深入的，要对某个方面有个深入的理解，必须通过做事情，发现问题，解决问题。&lt;/p&gt;
&lt;p&gt;这一转变过程让我非常纠结，而且到目前为止还算不上成功。可能对于很多人来说，这个过程可能很简单，但对于我来说，好奇心强，喜欢学东西的来说，确实极其艰难的。每做一件事情，都很可能陷入学习的状态，而不会及时地适可而止。&lt;/p&gt;
&lt;p&gt;这一过程希望在2012年有个很好的进展。&lt;/p&gt;
&lt;p&gt;这一年里，我逐步意识到自己存在的另一个大问题---不够自信，其外在表现为和别人一起时，极其容易将自己的观点让位于别人的观点，即使我并不认为自己的观点存在什么问题，或者别人的观点比我的更正确。我只是不想凌驾于别人之上，不想让自己影响到别人。这听起来似乎不关乎自信，但我想本质上是的。“不够自信”这看起来也似乎不是什么大问题，但我想对于一个成年人，特别是一个男人，自信是非常重要的，对于事业也是件非常重要的事情。以前自己活得太谨慎，不喜欢在公共场合表现自己，觉得提高自己的内在修为才是重要的。但其实活在社会中，适时适当地表现自己，表达自己的观点，坚持自己的看法是非常重要的。有个词叫“内圣外王”，以后我得更加注重“外王”，内外兼修。&lt;/p&gt;
&lt;p&gt;这一年里，我活得又很随性(和“活得谨慎”矛盾而共存)，不太注意自己的言行，脏话口头禅也比较多，虽然在我看来，我的脏话全是在表达一种情绪，仅此而已。但我想在别人来看，其感受也许并不是这样的。我们年轻人还是要注意自己的形象的，呵呵。另外，尽量少评论别人，特别是别人的缺点。&lt;/p&gt;
&lt;p&gt;这一年里，我很懒散，自己都有些看不过去了，“这样的日子，再好的，没有了”，我想不是件好事情。能够自我安慰点是还读了点书，整理一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社科文艺类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;佛祖在一号线&lt;/li&gt;
&lt;li&gt;书虫小札&lt;/li&gt;
&lt;li&gt;复杂性思想导论&lt;/li&gt;
&lt;li&gt;人生&lt;/li&gt;
&lt;li&gt;给研究生的学术建议&lt;/li&gt;
&lt;li&gt;边城&lt;/li&gt;
&lt;li&gt;朱镕基答记者问&lt;/li&gt;
&lt;li&gt;窗里窗外&lt;/li&gt;
&lt;li&gt;联大八年&lt;/li&gt;
&lt;li&gt;笑谈大先生&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技术类&lt;/strong&gt; (部分是按需选取章节阅读)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shell脚本学习指南&lt;/li&gt;
&lt;li&gt;Linux内核设计与实现&lt;/li&gt;
&lt;li&gt;鸟哥的Linux私房菜&lt;/li&gt;
&lt;li&gt;PHP和MySQL Web开发（原书第3版）&lt;/li&gt;
&lt;li&gt;分布式处理实践&lt;/li&gt;
&lt;li&gt;Java Collections&lt;/li&gt;
&lt;li&gt;可爱的Python&lt;/li&gt;
&lt;li&gt;浪潮之巅 &lt;/li&gt;
&lt;li&gt;CSS Web设计快速上手&lt;/li&gt;
&lt;li&gt;编程人生&lt;/li&gt;
&lt;li&gt;C陷阱与缺陷&lt;/li&gt;
&lt;li&gt;调试九法&lt;/li&gt;
&lt;li&gt;黑客与画家&lt;/li&gt;
&lt;li&gt;Python UNIX 和Linux 系统管理指南&lt;/li&gt;
&lt;li&gt;版本控制之道&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较而言，数量上不算少，也不算多，但主要问题还是质量上，觉得自己有些浑沦吞枣，读得太匆忙。这是以后的阅读需要注意的，克制焦躁的心理，慢慢阅读消化。&lt;/p&gt;
&lt;p&gt;新的一年，具体来说，我需要面对的几件大事情，大致包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小论文&lt;/li&gt;
&lt;li&gt;实习&lt;/li&gt;
&lt;li&gt;毕业论文，包括答辩&lt;/li&gt;
&lt;li&gt;找工作&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2012年底，我将要毕业了(虽然，形式上是2013年毕业)，我就要工作了，这也许是和高考相当的一件大事，希望自己能够举重若轻，踏实准备，顺利应对。(再具体点是不是应该说多多coding，多做事情！哈哈)&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category></entry><entry><title>《Classic Shell Scripting》：ls, locate, type, find, df, du, diff, patch</title><link href="http://youngsterxyf.github.io/2011/12/23/classic-shell-scripting-ls-locate-and-so-on/" rel="alternate"></link><published>2011-12-23T00:00:00+08:00</published><updated>2011-12-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-23:/2011/12/23/classic-shell-scripting-ls-locate-and-so-on/</id><summary type="html">&lt;h4&gt;一.ls&lt;/h4&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls [ options ] [ file(s) ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;列出文件目录的内容
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-1 : 数字1.强制为单栏输出。在交互式模式下，ls一般会以适于当前窗口的最小宽度，使用多个列
-a : 显示 …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h4&gt;一.ls&lt;/h4&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls [ options ] [ file(s) ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;列出文件目录的内容
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-1 : 数字1.强制为单栏输出。在交互式模式下，ls一般会以适于当前窗口的最小宽度，使用多个列
-a : 显示所有文件，包括隐藏文件(文件名以点号起始的文件)
-d : 显示与目录本身相关的信息，而非它们包含的文件的信息。
-F : 使用特殊结尾字符，标记特定的文件类型
-g : 仅适用于组：省略所有者名称(隐含-l，小写L选项)
-i : 列出inode编号
-L : 紧接着符号性连接，列出它们指向的文件
-l : 小写的L。以冗长形式列出，带有类型，权限保护，所有者，组，字节计数，最后修改时间和文件名
-r : 倒置默认的排序顺序
-R : 递归列出，下延进入每个子目录
-S : 按照由大到小的文件大小计数排序。仅GNU版本支持
-s : 以块(与系统有关)为单位，列出文件的大小
-t : 按照最后修改时间戳排序
--full-time : 显示完整的时间戳，仅GNU版本支持
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;二.locate&lt;/h4&gt;
&lt;p&gt;locate将文件系统里的所有文件名压缩成数据库，以迅速找到匹配类Shell通配字符的文件名，不必实际查找整个庞大的目录结构&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;locate gcc-3.3.tar
locate &lt;span style="color: #a31515"&gt;&amp;#39;*gcc-3.3*.tar*&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;三.type&lt;/h4&gt;
&lt;p&gt;偶尔你也可能会想知道，调用一个没有路径的命令时，它在文件系统的位置如何。Bourne-Shell家族里的type命令可以告诉你：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;type gcc             &lt;span style="color: #008000"&gt;#gcc在哪？&lt;/span&gt;
type type            &lt;span style="color: #008000"&gt;#type是什么？&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;请注意:type是Shell内置命令，所以它认得别名与函数。&lt;/p&gt;
&lt;h4&gt;四.find&lt;/h4&gt;
&lt;p&gt;假定你想选择大于某个大小的文件，或是三天前修改过，属于你的文件，或者拥有三个或三个以上直接链接的文件，就会需要UNIX工具集里最强力的find命令。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;find [ files-or-directories ] [ options ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;寻找与指定名称模式匹配或具有给定属性的文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-atime n : 选定n天前访问的文件
-ctime n : 选定n天前改过inode的文件
-follow : 接着符号性连接
-group g : 选定组g内的文件(g为用户组ID名称或数字)
-links n : 选定拥有n个直接链接的文件
-ls : 产生类似ls冗长形式的列表，而不是只有文件名
-mtime n : 选定n天前修改过的文件
-name &amp;#39;pattern&amp;#39; : 选定文件名与Shell通配字符模式匹配的文件(通配字符模会使用括号框起来，可避免Shell解释)
-perm mask : 选定与指定八进制权限掩码匹配的文件
-prune : 不向下递归到目录树状结构里
-size n : 选择大小为n的文件
-type t : 选定类型t的文件，类型是单一字母:d为目录，f为文件，l为符号性连接
-user u : 选定用户u拥有的文件(u为用户ID名称或编号)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;警告&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;find输出的是未排序的结果
find提供额外的选项，可对选定的文件执行任意操作。由于这是一个潜在的危险，我们不建议使用这类选项。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;find不同于ls与Shell的地方是：它没有隐藏文件的概念，也就是说：就算是点号开头的文件名，find还是能找到它。&lt;/p&gt;
&lt;p&gt;另一点不同于ls的是：find不排序文件名。它只是以它读到目录的顺序依次显示，事实上这个排序应是随机的。因此，你可能得在find命令后，通过管道加入sort步骤。&lt;/p&gt;
&lt;p&gt;-size选项必须接上一个数字参数。默认值是以512字节为单位的大小，不过很多find实例，允许在数字之后加上c表示字符(字节)，或k表示kilobyte(KB)。如果数字未带有正负号，则指的是必须确实匹配于该文件大小。如果为负，则只有小于该数字(绝对值)的文件大小是匹配的。否则，带有正号，则只有大于该容量的文件才匹配。-links,-atime,-ctime,-mtime选项类似。&lt;/p&gt;
&lt;h4&gt;五.df&lt;/h4&gt;
&lt;p&gt;df(disk free，磁盘可用空间)提供单行摘要，一行显示一个加载的文件系统的已使用的和可用的空间。大部分现代实现都支持-k选项，也就是强制使用kilobyte单位，以及-l(小写L)选项，仅显示本地文件系统，排除网络挂载的文件系统。&lt;/p&gt;
&lt;p&gt;df的输出是未排序的。&lt;/p&gt;
&lt;h4&gt;六.du&lt;/h4&gt;
&lt;p&gt;df会摘要文件系统的可用空间，但它并不会告诉你某个特定的目录树需要多少空间，这是du(disk usage，磁盘用量)的工作。du就像df一样，有两个常见的选项实现：-k(kilobyte单位)与-s(摘要)。&lt;/p&gt;
&lt;p&gt;du会针对每个文件或目录参数---如果无提供这类参数则为当前目录，产生一个输出行。&lt;/p&gt;
&lt;h4&gt;七.diff and patch&lt;/h4&gt;
&lt;p&gt;如果你想知道两个相似的文件有何不同，可使用diff。&lt;/p&gt;
&lt;p&gt;使用diff的惯例是：将旧文件作为第一个参数。&lt;/p&gt;
&lt;p&gt;有时，与diff系出同门的diff3也是相当好用的工具，它的任务与diff稍有不同：diff3比较的是三个文件，例如基本版与由两个不同的人所做出来的两个修改文件，它还会产生一个ed命令的脚本，让用户将两组修改文件合并到基本版里。&lt;/p&gt;
&lt;p&gt;patch工具程序可利用diff的输出，结合原始文件，以重建另一个文件。因为相异的部分，通常比原始文件小很多，软件开发人员常会通过email交换相异处的列表，再使用patch应用它。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;diff -c test.[12] &amp;gt; test.dif   #将相异处的相关内文，存储到test.dif
patch &amp;lt; test.dif               #应用不同之处
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;patch尽可能套用不同之处，然后报告失败的部分，由你自行手动处理。&lt;/p&gt;
&lt;p&gt;虽然patch可使用diff的一般输出，但较通用的方式应是使用diff的-c选项，以取得上下文差异处。这么做会产生较详细冗长的报告，让patch知道文件名，允许它验证变更位置，并回复不匹配之处。&lt;/p&gt;</content><category term="其他"></category><category term="Linux"></category><category term="Shell"></category></entry><entry><title>ArchLinux上安装Consolas字体</title><link href="http://youngsterxyf.github.io/2011/12/23/install-Consolas-font-on-ArchLinux/" rel="alternate"></link><published>2011-12-23T00:00:00+08:00</published><updated>2011-12-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-23:/2011/12/23/install-Consolas-font-on-ArchLinux/</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从&lt;a href="http://www.iplaysoft.com/consolas.html"&gt;http://www.iplaysoft.com/consolas.html&lt;/a&gt;下载Consolas字体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo mkdir -p /usr/share/fonts/yahei
sudo cp YaHei.Consolas.1.11b.ttf /usr/share/fonts/yahei/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改变权限：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod 644 /usr/share/fonts/yahei/YaHei.Consolas.1.11b.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cd /usr …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从&lt;a href="http://www.iplaysoft.com/consolas.html"&gt;http://www.iplaysoft.com/consolas.html&lt;/a&gt;下载Consolas字体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo mkdir -p /usr/share/fonts/yahei
sudo cp YaHei.Consolas.1.11b.ttf /usr/share/fonts/yahei/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改变权限：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chmod 644 /usr/share/fonts/yahei/YaHei.Consolas.1.11b.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cd /usr/share/fonts/yahei/
sudo mkfontscale
sudo mkfontdir
sudo fc-cache -fv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="Linux"></category><category term="字体"></category></entry><entry><title>《Classic Shell Scripting》：文件描述符处理</title><link href="http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-file-descriptors/" rel="alternate"></link><published>2011-12-22T00:00:00+08:00</published><updated>2011-12-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-22:/2011/12/22/classic-shell-scripting-file-descriptors/</id><summary type="html">&lt;p&gt;在系统内部，UNIX是以一个小的整数数字，称为文件描述符(file descriptors)，表示每个进程打开的文件。数字由零开始，至多到系统定义的打开文件数目的限制。传 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在系统内部，UNIX是以一个小的整数数字，称为文件描述符(file descriptors)，表示每个进程打开的文件。数字由零开始，至多到系统定义的打开文件数目的限制。传统上，Shell允许你直接处理至多10个打开文件：文件描述符从0至9（POSIX标准将是否可以处理大于9的文件描述符，保留给各实现自行定义，bash可以，但ksh则否）&lt;/p&gt;
&lt;p&gt;文件描述符0,1与2，各自对应到标准输入，标准输出以及标准错误输出。最常见的操作便是变更这三个文件描述符其中一个的位置，不过也可能处理其他的变动。首先来看的是：将程序的标准输出传送到一个文件，并将起标准错误信息传到另一个文件：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make 1&amp;gt; results 2&amp;gt; ERRS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的命令是将make的标准输出(文件描述符为1)传给results,并将标准错误输出(文件描述符为2)传给ERRS。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make 1&amp;gt; results 2&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;1&amp;gt; results&lt;/code&gt;里的1其实没有必要，供输出重定向的默认文件描述符是标准输出：也就是文件描述符1。下个例子会将输出与错误信息送给相同的文件：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make &amp;gt; results 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需特别留意的一点是:在命令行上，这4个字符2&amp;gt;&amp;amp;1必须连在一起，中间不能有任何空格。&lt;/p&gt;
&lt;p&gt;在此，顺序格外重要，Shell处理重定向时，由左至右。&lt;/p&gt;</content><category term="其他"></category><category term="Linux"></category><category term="Shell"></category></entry><entry><title>《Classic Shell Scripting》：sed and cut</title><link href="http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-sed-and-cut/" rel="alternate"></link><published>2011-12-22T00:00:00+08:00</published><updated>2011-12-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-22:/2011/12/22/classic-shell-scripting-sed-and-cut/</id><summary type="html">&lt;h4&gt;一. sed&lt;/h4&gt;
&lt;p&gt;一般来说，执行文本替换的正确程序应该是sed --- 流编辑器(Stream Editor)。sed的设计就是用来以批处理的方式而不是交互的方式来编辑文件。当你知道要做好几个变更 --- 不管是对一个还是数个文 …&lt;/p&gt;</summary><content type="html">&lt;h4&gt;一. sed&lt;/h4&gt;
&lt;p&gt;一般来说，执行文本替换的正确程序应该是sed --- 流编辑器(Stream Editor)。sed的设计就是用来以批处理的方式而不是交互的方式来编辑文件。当你知道要做好几个变更 --- 不管是对一个还是数个文件时，比较简单的方式是将这些变更部分写到一个编辑中的脚本里，再将此脚本应用到所有需要修改的文件。
你可能会常在管道中间使用sed，以执行替换操作。做法是使用s命令 --- 要求正则表达式寻找，用替代文本替换匹配的文本：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sed &lt;span style="color: #a31515"&gt;&amp;#39;s/:.*//&amp;#39;&lt;/span&gt; /etc/passwd       &lt;span style="color: #008000"&gt;#删除第一个冒号之后的所有东西&lt;/span&gt;
sort -u                          &lt;span style="color: #008000"&gt;#排序列表并删除重复部分&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这里，/字符扮演定界符(delimiter)的角色，从而分隔正则表达式与替代文本。在本例中，替代文本是空的，实际上会有效地删除匹配的文本。虽然/是最常用的定界符，但任何可显示的字符都能作为定界符。在处理文件名称，通常都会以标点符号字符作为定界符(例如分号，冒号或逗点)：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;find /home/tolstoy -type d -print    &lt;span style="color: #008000"&gt;#寻找所有目录&lt;/span&gt;
sed &lt;span style="color: #a31515"&gt;&amp;#39;s;/home/tolstoy/;/home/lt/;&amp;#39;&lt;/span&gt;    &lt;span style="color: #008000"&gt;#修改名称；&lt;/span&gt;
sed &lt;span style="color: #a31515"&gt;&amp;#39;s/^/mkdir /&amp;#39;&lt;/span&gt;                    &lt;span style="color: #008000"&gt;#插入mkdir命令&lt;/span&gt;
sh -x                                 &lt;span style="color: #008000"&gt;#以Shell跟踪模式执行&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;“&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sed [-n] &amp;#39;editing command&amp;#39; [file ...]
sed [-n] -e &amp;#39;editing command&amp;#39; ... [file ...]
sed [-n] -f script-file ... [file ...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-e &amp;#39;editing command&amp;#39; : 将editing command应用于输入数据上。当有多个命令需要应用时，就必须使用-e了。
-f script-file : 自script-file中读取编辑命令。当有多个命令需要执行时，此选项相当有用。
-n : 不是每个最后已修改结果行都正常打印，而是显示以p指定(处理过)的行。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;行为模式&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;读取每个输入文件的每一行，假如没有文件的话，则是标准输入。以每一行来说，sed会执行每一个应用到输入行的editing command。结果会写到标准输出(默认状态下，或是显示地使用p命令及-n选项)。若无-e或-f选项，则sed会把第一个参数看作是要使用的editing command。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;”&lt;/p&gt;
&lt;h4&gt;二. cut&lt;/h4&gt;
&lt;p&gt;cut命令是用来剪下文本文件里的数据，文本文件可以是字段类型或是字符类型。后一种数据类型在遇到需要从文件里剪下特定的列时，特别方便。请注意：一个制表符在此被视为单个字符。&lt;/p&gt;
&lt;p&gt;举例来说，下面的命令可显示系统上每个用户的登录名称及其全名:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cut -d : -f 1,5 /etc/passwd     &lt;span style="color: #008000"&gt;#取出字段&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面的命令取出命令ls -l的输出结果中的文件权限字段:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ls -l | cut -c 1-10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;"&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cut -c list [ file ...]
cut -f list [ -d delim ] [ file ...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;从输入文件中选择一个或多个字段或者一组字符，配合管道，可再做进一步处理。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-c list ： 以字符为主，执行剪下的操作。list为字符编号或一段范围的列表(以逗点隔开)，例如1,3,5-12,42。
-d delim : 通过-f选项，使用delim作为定界符。默认的定界符为制表字符(Tab)
-f list : 以字段为主，做剪下操作。list为字段编号或一段范围的列表(以逗点隔开)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;"&lt;/p&gt;</content><category term="其他"></category><category term="Linux"></category><category term="Shell"></category></entry><entry><title>《Classic Shell Scripting》：sort, uniq, wc, head, tail</title><link href="http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-sort-uniq-wc-head-tail/" rel="alternate"></link><published>2011-12-22T00:00:00+08:00</published><updated>2011-12-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-22:/2011/12/22/classic-shell-scripting-sort-uniq-wc-head-tail/</id><summary type="html">&lt;h4&gt;一.sort&lt;/h4&gt;
&lt;p&gt;就像awk,cut与join一样，sort将输入看作具有多条记录的数据流，而记录是由可变宽度的字段组成，记录是以换行符作为定界符，字段的定界符则是空白字符或是用户指 …&lt;/p&gt;</summary><content type="html">&lt;h4&gt;一.sort&lt;/h4&gt;
&lt;p&gt;就像awk,cut与join一样，sort将输入看作具有多条记录的数据流，而记录是由可变宽度的字段组成，记录是以换行符作为定界符，字段的定界符则是空白字符或是用户指定的单个字符。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sort [ options ] [ file(s)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;将输入行按照键值字段与数据类型选项以及locale排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-b : 忽略开头的空白
-c : 检查输入是否已正确地排序。如输入未经排序，但退出码(exit code)为非零值，则不会有任何输出
-d : 字典顺序，仅文字数字与空白才有意义
-g : 一般数值，以浮点数字类型比较字段
-f : 将混用的字母都看作相同大小写，也就是以不管字母大小写的方式排序。
-i : 忽略无法打印的字符
-k : 定义排序键值字段
-m : 将已排序的输入文件，合并为一个排序后的输出数据流
-n : 以整数类型比较字段
-o outfile : 将输出写到指定的文件，而非标准输出。如果该文件为输入文件之一，则sort在进行排序与写到输出文件之前，会先将它复制到一个临时的文件。
-r : 倒置排序的顺序为由大到小，而非默认的由小到大。
-t char : 使用单个字符char作为默认的字段分隔字符，取代默认的空白字符
-u : 只有惟一的记录：丢弃所有具有相同键值的记录，只留其中的第一条。只有键值字段是重要的，也就是说，被丢弃的记录其他部分可能是不同值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;行为模式&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sort会读取指定的文件，如果未给定文件，则读取标准输入，再将排序好的数据写至标准输出。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;举例如下&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sort -t: -k1,1 /etc/passwd    &lt;span style="color: #008000"&gt;#以用户名称排序&lt;/span&gt;
sort -t: -k3nr /etc/passwd    &lt;span style="color: #008000"&gt;#反向UID的排序&lt;/span&gt;
sort -t: -k4n -k3n /etc/passwd   &lt;span style="color: #008000"&gt;#先以GID排序，再以UID排序&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;sort排序算法并不稳定，幸好GNU实现了coreutils弥补不足，它可以通过--stable选项补救此问题。&lt;/p&gt;
&lt;h4&gt;二.uniq&lt;/h4&gt;
&lt;p&gt;uniq常用于管道中，用来删除已使用sort排序完成的重复记录：sort ... | uniq | ...&lt;/p&gt;
&lt;p&gt;范例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sort latin-numbers | uniq     &lt;span style="color: #008000"&gt;#显示唯一的，排序后的记录，重复则仅取唯一行。&lt;/span&gt;
sort latin-numbers | uniq -c  &lt;span style="color: #008000"&gt;#计数唯一的，排序后的记录&lt;/span&gt;
sort latin-numbers | uniq -d  &lt;span style="color: #008000"&gt;#仅显示重复的记录&lt;/span&gt;
sort latin-numbers | uniq -u  &lt;span style="color: #008000"&gt;#仅显示未重复的记录&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;三.wc&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;echo Testing one two three | wc -c  &lt;span style="color: #008000"&gt;#计算字节数&lt;/span&gt;
echo Testing one two three | wc -l  &lt;span style="color: #008000"&gt;#计算行数&lt;/span&gt;
echo Testing one two three | wc -w  &lt;span style="color: #008000"&gt;#计算字数/单词数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-c选项原本是表示字符数，但因为有多字节字符集的编码存在---像UTF-8，因此在当前系统上，字节数已不再等于字符数了，也因此，POSIX出现了-m选项，用以计算多字节字符，对8位字符数据而言，它等同于-c。&lt;/p&gt;
&lt;p&gt;虽然wc最常处理的是来自于管道的输入数据，但它也接受命令行的文件参数，可以生成一行一个结果: wc /etc/passwd /etc/group&lt;/p&gt;
&lt;h4&gt;四.head and tail&lt;/h4&gt;
&lt;p&gt;有时，你会需要从文本文件里把几行字---多半是靠近开头或结尾的几行，提取出来。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;head [-n] n [ file(s) ]    #取出文件的前n行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同样功能的命令有:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;awk &amp;#39;FNR &amp;lt;= n&amp;#39; [ file(s) ]
sed [-e] nq    [ file(s) ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;tail&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tail [-n] n [ file(s) ]   #取出文件的后n行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Linux"></category><category term="Shell"></category></entry><entry><title>《Classic Shell Scripting》第一、二章阅读笔记</title><link href="http://youngsterxyf.github.io/2011/12/09/classic-shell-scripting-1-2/" rel="alternate"></link><published>2011-12-09T00:00:00+08:00</published><updated>2011-12-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-09:/2011/12/09/classic-shell-scripting-1-2/</id><summary type="html">&lt;h4&gt;第一章：背景知识&lt;/h4&gt;
&lt;p&gt;软件工具的原则&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;一次做好一件事

处理文本行，不要处理二进制数据

使用正则表达式：正则表达式(regular expression)是 …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h4&gt;第一章：背景知识&lt;/h4&gt;
&lt;p&gt;软件工具的原则&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;一次做好一件事

处理文本行，不要处理二进制数据

使用正则表达式：正则表达式(regular expression)是很强的文本处理机制。了解它的运作模式并加以使用，可适度简化编写命令脚本的工作。

默认使用标准输入/输出：在未明确指定文件名的情况下，程序默认会从它的标准输入读取数据，将数据写到它的标准输出，至于错误信息则会传送到标准错误输出。以这样的方式来编写程序，可以轻松地让它们称为数据过滤器(filter)。

避免喋喋不休

输出格式必须与可接受的输入格式一致：专业的工具程序认为遵循某种格式的输入数据，例如标题行之后接着数据行，或在行上使用某种字段分隔符等，所产生的输出也应遵循与输入一致的规则。这么做的好处是，容易将一个程序的执行结果交给另一个程序处理。

让工具去做困难的部分：虽然UNIX程序并非完全符合你的需求，但是现有的工具或许已经可以为你完成90%的工作。接下来，若有需要，你可以编写一个功能特定的小型程序来完成剩下的工作。

构建特定工具前，先想想：你所要做的事情，是否有其他人也需要做？这个特殊的工作是否有可能是某个一般问题的一个特例？如果是的话，请针对一般问题来编写程序。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;第二章：入门&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Shell脚本最常用于系统管理工作，或是用于结合现有的程序以完成小型的，特定的工作。一旦你找出完成工作的方法，可以把用到的命令串在一起，放进一个独立的程序或脚本里，此后只要直接执行该程序便能完成工作。&lt;/li&gt;
&lt;li&gt;使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象。缺点是：它们的效率通常不如编译型语言。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell的基本元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令与参数&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;简单的echo输出&lt;/li&gt;
&lt;li&gt;华丽的printf输出&lt;/li&gt;
&lt;li&gt;基本的I/O重定向&lt;ul&gt;
&lt;li&gt;重定向与管道&lt;/li&gt;
&lt;li&gt;特殊文件:/dev/null与/dev/tty&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本命令查找&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行中，分号(;)可用来分隔同一行里的多条命令。Shell会依次执行这些命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Shell识别三种命令：内建命令，Shell函数以及外部命令：&lt;ol&gt;
&lt;li&gt;内建命令就是由Shell本身所执行的命令。有些命令是由于其必要性才内建的，例如cd用来改变目录，read会将来自用户(或文件)的输入数据传给Shell变量。另一种内建命令的存在则是为了效率，其中最典型的就是test命令，编写脚本时会经常用到它。另外还有I/O命令，例如echo与printf。&lt;/li&gt;
&lt;li&gt;Shell函数是功能健全的一系列程序代码，以Shell语言写成，它们可以像命令那样引用。 ？？？&lt;/li&gt;
&lt;li&gt;外部命令就是由Shell的副本(新的进程)所执行的命令，基本的过程如下：&lt;ol&gt;
&lt;li&gt;建立一个新的进程。此进程即为Shell的一个副本。&lt;/li&gt;
&lt;li&gt;在新的进程里，在PATH变量内所列出的目录中，寻找特定的命令。&lt;/li&gt;
&lt;li&gt;在新的进程里，以所找到的新程序取代执行中的Shell程序并执行。&lt;/li&gt;
&lt;li&gt;程序完成后，最初的Shell会接着从终端读取下一条命令，或执行脚本里的下一条命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Shell变量名称的开头是一个字母或下划线符号，后面可以接着任意长度的字母，数字或下划线符号。&lt;/li&gt;
&lt;li&gt;重定向与管道:&lt;ul&gt;
&lt;li&gt;以&amp;lt;改变标准输入&lt;/li&gt;
&lt;li&gt;以&amp;gt;改变标准输出，&amp;gt;重定向符(redirector)在目的文件不存在时，会新建一个。然而，如果目的文件存在，它就会直接覆盖掉，原本的数据都会丢失&lt;/li&gt;
&lt;li&gt;以&amp;gt;&amp;gt;改变标准输出附加到文件,如同&amp;gt;，如果目的文件不存在，&amp;gt;&amp;gt;重定向符便会新建一个。然而，如果目的文件存在，它不会直接覆盖掉文件，而是将程序产生的数据附加到文件结尾处。&lt;/li&gt;
&lt;li&gt;以|建立管道，管道可以使得执行速度比使用临时文件快上十倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tr命令&lt;/li&gt;
&lt;li&gt;构造管道时，应该试着让每个阶段的数据量变得更少。换句话说，如果你有两个要完成的步骤与先后次序无关，你可以把会让数据量变少的那一个步骤放在管道的前面。这么做可以提升脚本的整体性能，因为UNIX只需要在两个程序间移动少的数据量，每个程序要做的事情也比较少，例如：使用sort排序之前，先以grep找出相关的行，这样可以让sort少做些事。&lt;/li&gt;
&lt;li&gt;特殊文件/dev/null与/dev/tty&lt;/li&gt;
&lt;li&gt;简单的执行跟踪:&lt;ul&gt;
&lt;li&gt;两种方法：&lt;ol&gt;
&lt;li&gt;使用"sh -x scriptname"来执行脚本scriptname；&lt;/li&gt;
&lt;li&gt;在脚本中需要跟踪的命令片段前加一句set -x打开执行跟踪的功能，然后在这个命令片段后再用set +x命令关闭它。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Linux"></category><category term="Shell"></category></entry><entry><title>Linux添加定时任务</title><link href="http://youngsterxyf.github.io/2011/12/07/cron-usage/" rel="alternate"></link><published>2011-12-07T00:00:00+08:00</published><updated>2011-12-07T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-07:/2011/12/07/cron-usage/</id><summary type="html">&lt;p&gt;在Linux下如果希望某个任务定时地执行，一般是使用cron服务器，将任务添加到cron任务列表中。&lt;/p&gt;
&lt;h4&gt;启动，关闭，重启cron(需超级用户权限)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/init.d/cron start
/etc/init.d/cron stop
/etc/init.d/cron restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注:archlinux下为/etc/rc.d/crond …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在Linux下如果希望某个任务定时地执行，一般是使用cron服务器，将任务添加到cron任务列表中。&lt;/p&gt;
&lt;h4&gt;启动，关闭，重启cron(需超级用户权限)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/etc/init.d/cron start
/etc/init.d/cron stop
/etc/init.d/cron restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注:archlinux下为/etc/rc.d/crond start|stop|restart&lt;/p&gt;
&lt;h4&gt;查看用户设置的定时任务列表&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;crontab [-u xxx] -l       #  xxx为用户名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;编辑用户的定时任务列表(超级用户权限)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;crontab -u xxx -e
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;删除用户的定时任务列表(超级用户权限)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;crontab -u xxx -r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;定时任务的编辑规则&lt;/h4&gt;
&lt;p&gt;cron的定时任务由两部分组成：（1）设置的时间（2）该时间下要执行的任务命令。&lt;/p&gt;
&lt;p&gt;时间分5个部分，依次为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;minute              0-59
hour                0-23 
day of month        1-31
month               1-12
day of week         0-7 (0 or 7 is Sun, or use names)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;示例（每天临晨2点备份数据库）&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0 2 * * * mysqldump -hhostname -uusername -ppassword databasename &amp;gt; backupfile.sql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;使设置生效&lt;/h4&gt;
&lt;p&gt;设置完成后，重启cron即可使设置的计划任务定时执行了&lt;/p&gt;
&lt;h3&gt;详细内容参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://fanqiang.chinaunix.net/system/linux/2005-06-13/3306.shtml"&gt;http://fanqiang.chinaunix.net/system/linux/2005-06-13/3306.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fanqiang.chinaunix.net/adm/storage/2005-03-23/2985.shtml"&gt;http://fanqiang.chinaunix.net/adm/storage/2005-03-23/2985.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://now-code.com/archives/196"&gt;http://now-code.com/archives/196&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Linux"></category></entry><entry><title>Linux添加sudo用户权限</title><link href="http://youngsterxyf.github.io/2011/12/07/linux-add-sudo-user/" rel="alternate"></link><published>2011-12-07T00:00:00+08:00</published><updated>2011-12-07T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-07:/2011/12/07/linux-add-sudo-user/</id><summary type="html">&lt;p&gt;Linux中很多命令需要使用超级用户权限，在这些命令前添加sudo然后直接执行是很方便的。&lt;/p&gt;
&lt;p&gt;那么就先要将自己的用户名添加到sudoers中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用su命令切换到超级用户(在提示后输入root的密码)&lt;/li&gt;
&lt;li&gt;使用visudo命令(编辑/etc/sudoers文件)，也可以直接使用 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Linux中很多命令需要使用超级用户权限，在这些命令前添加sudo然后直接执行是很方便的。&lt;/p&gt;
&lt;p&gt;那么就先要将自己的用户名添加到sudoers中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用su命令切换到超级用户(在提示后输入root的密码)&lt;/li&gt;
&lt;li&gt;使用visudo命令(编辑/etc/sudoers文件)，也可以直接使用编辑器编辑&lt;/li&gt;
&lt;li&gt;找到root ALL=(ALL) ALL 这一行，在其下面一行添加xxx ALL=(ALL) ALL，其中xxx为你的用户名&lt;/li&gt;
&lt;li&gt;保存即可起效&lt;/li&gt;
&lt;/ul&gt;</content><category term="其他"></category><category term="Linux"></category></entry></feed>