<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>黑·白 - xiayf</title><link href="http://youngsterxyf.github.io/" rel="alternate"></link><link href="http://youngsterxyf.github.io/feeds/xiayf.atom.xml" rel="self"></link><id>http://youngsterxyf.github.io/</id><updated>2019-06-17T00:00:00+08:00</updated><entry><title>Java 单测伴侣 - mockito</title><link href="http://youngsterxyf.github.io/2019/06/17/mockito/" rel="alternate"></link><published>2019-06-17T00:00:00+08:00</published><updated>2019-06-17T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-06-17:/2019/06/17/mockito/</id><summary type="html">&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码还挺难的，挺花时间，其中最麻烦的是待测代码可能会访问外部资源（比如数据库、HTTP API），如果不能方便地进模拟访问这些外部资源，那么测试起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;但，对于复杂逻辑，如果不经过严格测试，发布到生产环境，又有些不放心，没底气，或者在代码重构时，如果没有覆盖全面的测试，很难评估代码变动带来的影响。&lt;/p&gt;
&lt;p&gt;直到遇到 &lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt;，我才觉得是时候认真写写测试代码了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt; 提供两种对象模拟方式：&lt;strong&gt;mock&lt;/strong&gt; 和 &lt;strong&gt;spy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，mock 模拟的对象是一个完全假的对象，只是具备指定类型的接口，以 &lt;code&gt;java.util.List&lt;/code&gt; 为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.mock;

List mockedList = mock(List.class);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码还挺难的，挺花时间，其中最麻烦的是待测代码可能会访问外部资源（比如数据库、HTTP API），如果不能方便地进模拟访问这些外部资源，那么测试起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;但，对于复杂逻辑，如果不经过严格测试，发布到生产环境，又有些不放心，没底气，或者在代码重构时，如果没有覆盖全面的测试，很难评估代码变动带来的影响。&lt;/p&gt;
&lt;p&gt;直到遇到 &lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt;，我才觉得是时候认真写写测试代码了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt; 提供两种对象模拟方式：&lt;strong&gt;mock&lt;/strong&gt; 和 &lt;strong&gt;spy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，mock 模拟的对象是一个完全假的对象，只是具备指定类型的接口，以 &lt;code&gt;java.util.List&lt;/code&gt; 为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.mock;

List mockedList = mock(List.class);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然 List 是一个 interface，也可以模拟出一个对象实例，这个 mockedList 对象具备 List 接口定义的所有方法，但所有方法都不具备实际的行为操作，对于有返回值的方法，则默认返回方法返回类型的默认值，没有返回值的方法，则纯粹是一个空方法。比如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008000"&gt;// mockedList 并不会真的把 1 存下来&lt;/span&gt;
mockedList.add(1);
&lt;span style="color: #008000"&gt;// 所以，size() 返回默认值，输出 0&lt;/span&gt;
System.out.println(mockedList.size());
&lt;span style="color: #008000"&gt;// 输出 null&lt;/span&gt;
System.out.println(mockedList.get(0));
&lt;span style="color: #008000"&gt;// 输出 null&lt;/span&gt;
System.out.println(mockedList.get(1));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于模拟出来的对象，可以任意指定其方法的返回值，比如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.when;

&lt;span style="color: #008000"&gt;// 调用 size() 方法时，返回 10&lt;/span&gt;
when(mockedList.size()).willReturn(10);
when(mockedList.get(0)).willReturn(&lt;span style="color: #a31515"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;);
when(mockedList.get(1)).thenReturn(&lt;span style="color: #a31515"&gt;&amp;quot;您好！&amp;quot;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// 输出 10&lt;/span&gt;
System.out.println(mockedList.size());
&lt;span style="color: #008000"&gt;// 输出 Hello World!&lt;/span&gt;
System.out.println(mockedList.get(0));
&lt;span style="color: #008000"&gt;// 输出 您好！&lt;/span&gt;
System.out.println(mockedList.get(1));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然我们写测试代码时，并不会使用 System.out.println，然后看输出，而是使用&lt;strong&gt;断言&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.junit.Assert.assertEquals;

assertEquals(10, mockedList.size());
assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;, mockedList.get(0));
assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;您好！&amp;quot;&lt;/span&gt;, mockedList.get(1));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;断言方法非常多，不仅仅只是 assertEquals。&lt;/p&gt;
&lt;p&gt;对于同一个方法，可以模拟多次调用返回不同的值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008000"&gt;// 会覆盖之前 mock 的行为：when(mockedList.size()).willReturn(10);&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 或者这么写：when(mockedList.size()).willReturn(0, -1, 10);&lt;/span&gt;
when(mockedList.size()).thenReturn(0).thenReturn(-1).thenReturn(10);
assertEquals(0, mockedList.size());
assertEquals(-1, mockedList.size());
assertEquals(10, mockedList.size());
&lt;span style="color: #008000"&gt;// 第 3 次之后的 mockedList.size() 调用都返回 10&lt;/span&gt;
assertEquals(10, mockedList.size());

Iterator iterator = mock(Iterator.class);
&lt;span style="color: #008000"&gt;// 或者这么写：when(iterator.next()).thenReturn(0, 1, 10, 1000);&lt;/span&gt;
when(iterator.next()).thenReturn(0).thenReturn(1).thenReturn(10).thenReturn(1000);
assertEquals(0, iterator.next());
assertEquals(1, iterator.next());
assertEquals(10, iterator.next());
assertEquals(1000, iterator.next());
&lt;span style="color: #008000"&gt;// 第 4 次之后的 iterator.next() 调用都返回 1000&lt;/span&gt;
assertEquals(1000, iterator.next());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还可以模拟异常抛出：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;List mockedList = mock(List.class);

when(mockedList.get(-1000)).thenThrow(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; RuntimeException(&lt;span style="color: #a31515"&gt;&amp;quot;参数异常！&amp;quot;&lt;/span&gt;));
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt; {
    mockedList.get(-1000);
} &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt; (Exception e) {
    assertTrue(e &lt;span style="color: #0000ff"&gt;instanceof&lt;/span&gt; RuntimeException);
    assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;参数异常！&amp;quot;&lt;/span&gt;, e.getMessage());
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以基于复杂的逻辑来构造返回值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.invocation.InvocationOnMock;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.stubbing.Answer;

List&amp;lt;Integer&amp;gt; mockedList = mock(List.class);
when(mockedList.get(anyInt())).thenAnswer(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; EchoAnswer());

assertTrue(1 == mockedList.get(1));
assertTrue(10 == mockedList.get(10));

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;EchoAnswer&lt;/span&gt; &lt;span style="color: #0000ff"&gt;implements&lt;/span&gt; Answer&amp;lt;Integer&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; Integer answer(InvocationOnMock var) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; var.getArgument(0);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了 &lt;code&gt;when(...).thenReturn(...)&lt;/code&gt; 风格的测试模拟方式，还有 BDD（Behavior Driven Development 行为驱动开发）风格的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.BDDMockito.given;

&lt;span style="color: #008000"&gt;// given&lt;/span&gt;
given(mockedList.get(0)).willReturn(100);
&lt;span style="color: #008000"&gt;// when&lt;/span&gt;
&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; v = (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) mockedList.get(0);
&lt;span style="color: #008000"&gt;// then&lt;/span&gt;
assertEquals(100, v);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果方法没有返回值，或者其它奇葩的需求，则没法使用 when.thenReturn / willReturn 这样的模拟方法，可以使用 &lt;code&gt;doReturn(...).when(...)...&lt;/code&gt;：
&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.doThrow;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.doReturn;

ArrayList mockedList = mock(ArrayList.class);
&lt;span style="color: #008000"&gt;// clear 方法无返回值&lt;/span&gt;
doThrow(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; RuntimeException(&lt;span style="color: #a31515"&gt;&amp;quot;清除失败&amp;quot;&lt;/span&gt;)).when(mockedList).clear();

&lt;span style="color: #0000ff"&gt;try&lt;/span&gt; {
    mockedList.clear();
} &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt; (Exception e) {
    assertTrue(e &lt;span style="color: #0000ff"&gt;instanceof&lt;/span&gt; RuntimeException);
    assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;清除失败&amp;quot;&lt;/span&gt;, e.getMessage());
}

&lt;span style="color: #008000"&gt;// 没有意义，因为没法使用 断言 来验证，实际运行时会抛异常&lt;/span&gt;
doReturn(10).when(mockedList).clear();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从示例代码可以看出，&lt;code&gt;doReturn(...).when(...)....&lt;/code&gt; 不会做类型校验，mockedList.clear() 返回值类型为 void，但我们模拟让其返回 10；所以，正常情况应该尽可能使用 &lt;code&gt;when(...).thenReturn(...)&lt;/code&gt; 或 &lt;code&gt;given(...).willReturn(...)&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;前述代码示例中，模拟方法的参数都做了硬编码，实际情况通常都不是这么测试，而是模拟方法的参数符合一定的要求即可，比如：在某个范围之内、符合类型的任何值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.anyInt;

&lt;span style="color: #008000"&gt;/*&lt;/span&gt;
&lt;span style="color: #008000"&gt;以任何 int 类型的参数调用 mockedList.get 方法，都返回 100&lt;/span&gt;

&lt;span style="color: #008000"&gt;如果写成 when(mockedList.get(0)).thenReturn(100)，则只有以 0 为参数调用 mockedList.get 方法，才会返回100，其他参数值，返回的都是默认值 0&lt;/span&gt;
&lt;span style="color: #008000"&gt;*/&lt;/span&gt;
when(mockedList.get(anyInt())).thenReturn(100);

assertEquals(100, mockedList.get(0));
assertEquals(100, mockedList.get(1000));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可用的参数匹配器，见 org.mockito.ArgumentMatchers 类的静态方法列表，也可以自己实现 ArgumentMatcher 接口：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;package&lt;/span&gt; org.mockito;

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;ArgumentMatcher&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; matches(T var1);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.ArgumentMatcher;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.intThat;

when(mockedList.get(intThat(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; LimitedInt()))).thenReturn(10);

assertEquals(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, mockedList.get(-1));
assertEquals(10, mockedList.get(1));
assertEquals(10, mockedList.get(99));
assertEquals(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, mockedList.get(100));

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;LimitedInt&lt;/span&gt; &lt;span style="color: #0000ff"&gt;implements&lt;/span&gt; ArgumentMatcher&amp;lt;Integer&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; matches(Integer var) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; var &amp;gt; 0 &amp;amp;&amp;amp; var &amp;lt; 100;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果被模拟的方法包含多个参数，那么这些参数要么全部使用匹配器，要么全部不使用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;模拟某些类（A）的方法，通常会将 mock 出来的对象注入到依赖该类实例的其他类（B）中，来替代真实的依赖，这种方式的目的是为了测试类 B 的行为是否符合预期。&lt;/p&gt;
&lt;p&gt;另一个测试需求是，测试某个类 A' 在某个上下文环境中的行为是否符合预期，比如： A' 的某个方法是否被调用过、调用过几次、调用参数是否符合预期、几个方法之间的调用次序是否符合预期、方法调用耗时是否符合预期等等。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.verify;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.times;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.never;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.verifyZeroInteractions;

List mocked = mock(List.class);

Caller caller = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Caller();
caller.setList(mocked);

&lt;span style="color: #008000"&gt;// 调用 0 次&lt;/span&gt;
caller.run(0);
&lt;span style="color: #008000"&gt;// 验证是否从来没调用过 mocked.size()&lt;/span&gt;
verify(mocked, never()).size();
&lt;span style="color: #008000"&gt;// 验证 没有和 mocked 产生过任何交互&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 因为 Caller.run 中调用了 list.isEmpty()，实际产生了交互，所以这行测试会失败&lt;/span&gt;
verifyZeroInteractions(mocked);

&lt;span style="color: #008000"&gt;// 调用 10 次&lt;/span&gt;
caller.run(10);
&lt;span style="color: #008000"&gt;// 验证是否调用 mocked.size() 10 次&lt;/span&gt;
verify(mocked, times(10)).size();

&lt;span style="color: #008000"&gt;// 再调用一次&lt;/span&gt;
caller.run(1);
&lt;span style="color: #008000"&gt;// 所以是 11 次了&lt;/span&gt;
verify(mocked, times(11)).size();

@Data
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Caller&lt;/span&gt; {
    List list;

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; run(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; count) {
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; idx=0; idx &amp;lt; count; idx++) {
            list.size();
        }
        &lt;span style="color: #008000"&gt;//&lt;/span&gt;
        list.isEmpty();
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;List mocked = mock(List.class);

mocked.add(1);
mocked.add(2);

verify(mocked).add(1);

&lt;span style="color: #008000"&gt;// 是否有其他交互没有验证过？因为 mocked 还调用过 mocked.add(2)，所以这句测试会失败&lt;/span&gt;
verifyNoMoreInteractions(mocked);
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.InOrder;

&lt;span style="color: #008000"&gt;// 也可以验证调用次序&lt;/span&gt;
List mocked1 = mock(List.class);
List mocked2 = mock(List.class);

mocked1.size();
mocked1.isEmpty();
mocked2.isEmpty();

&lt;span style="color: #008000"&gt;// 会记录 mocked1、mocked2 中方法的调用/交互次序，要求：与 mocked1 的交互先于 mocked2&lt;/span&gt;
InOrder inOrder = inOrder(mocked1, mocked2);
&lt;span style="color: #008000"&gt;// mocked1、mocked2 的交互顺序必须和 inOrder.verify 之间的顺序一致&lt;/span&gt;
inOrder.verify(mocked1).size();
inOrder.verify(mocked1).isEmpty();
inOrder.verify(mocked2).isEmpty();
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;也可以验证某个方法被调用时所使用的参数是否符合预期：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.ArgumentCaptor;

List mockedlist = mock(List.class);

Caller caller = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Caller();
caller.setList(mockedlist);
caller.run();

&lt;span style="color: #008000"&gt;// 捕获 mockedList.add 的调用参数&lt;/span&gt;
ArgumentCaptor&amp;lt;Integer&amp;gt; argumentCaptor = ArgumentCaptor.forClass(Integer.class);
verify(mockedlist).add(argumentCaptor.capture());
assertTrue(100 == argumentCaptor.getValue());

@Data
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Caller&lt;/span&gt; {
    List list;

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; run() {
        list.add(100);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;前面的内容都是以 mock 为例，我们再来说说 spy，与 mock 的区别：&lt;/p&gt;
&lt;p&gt;mock 出来的对象是一个完全假的对象，但 spy 通常是基于一个具体的类或类实例，对其篡改某些方法，对于被篡改方法之外的方法，其行为都和调用真实对象的方法一样，不过并没有调用真实对象的方法，也不会对真实对象产生影响：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008000"&gt;// 基于一个实际的类实例&lt;/span&gt;
List&amp;lt;Integer&amp;gt; realList = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(10);
List&amp;lt;Integer&amp;gt; spy = spy(realList);

spy.add(1);

&lt;span style="color: #008000"&gt;// 被窃听的对象并没有发生变化&lt;/span&gt;
assertEquals(0, realList.size());
&lt;span style="color: #008000"&gt;// 间谍对象确实将 1 存了下来&lt;/span&gt;
assertEquals(1, spy.size());
&lt;span style="color: #008000"&gt;// 这句会抛出 java.lang.IndexOutOfBoundsException，因为 realList 还是为空&lt;/span&gt;
assertTrue(1 == realList.get(0));
assertTrue(1 == spy.get(0));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以基于一个具体的类来构造 spy，但这样无法使用带参数的构造方法，也无法指定类型参数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;List&amp;lt;Integer&amp;gt; = spy(ArrayList.class);
assertEquals(0, spy.size());
spy.add(100);
assertEquals(1, spy.size());
assertTrue(100 == spy.get(0));

&lt;span style="color: #008000"&gt;// 篡改方法&lt;/span&gt;
when(spy.size()).thenReturn(-1);
assertEquals(-1, spy.size());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际上，mock 也可以基于具体的类来构造，这时可以指定某些方法实际调用具体类的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;除了使用 mock、spy 方法来构造模拟对象，还可以通过注解来构造，但这样的话得指定 JUnit 的 Runner 为 &lt;code&gt;org.mockito.junit.MockitoJUnitRunner&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.junit.Test;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.junit.runner.RunWith;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.Mock;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.Spy;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.junit.MockitoJUnitRunner;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.ArrayList;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.when;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.junit.Assert.assertTrue;

@RunWith(MockitoJUnitRunner.class)
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;testTester&lt;/span&gt; {

    @Mock
    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; mocked;

    @Spy
    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; spyed;

    @Test
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; test() {
        when(mocked.isEmpty()).thenReturn(&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);
        when(spyed.isEmpty()).thenReturn(&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);

        assertTrue(!mocked.isEmpty());
        assertTrue(!spyed.isEmpty());

        mocked.add(0);
        spyed.add(0);

        assertTrue(0 == mocked.size());
        assertTrue(1 == spyed.size());
    }
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="Java"></category><category term="mockito"></category><category term="单测"></category></entry><entry><title>编写漂亮的 shell 代码</title><link href="http://youngsterxyf.github.io/2018/05/16/beautiful-shell-code/" rel="alternate"></link><published>2018-05-16T00:00:00+08:00</published><updated>2018-05-16T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-05-16:/2018/05/16/beautiful-shell-code/</id><summary type="html">&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is true, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

map() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is true, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

map() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
}

reduce() {
    operator=$1
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    list=($2)
    list_len=&lt;span style="color: #a31515"&gt;${#&lt;/span&gt;list[@]&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    result=&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list_len&lt;span style="color: #a31515"&gt;}&lt;/span&gt; -gt 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        result=&lt;span style="color: #a31515"&gt;${&lt;/span&gt;list[0]&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list_len&lt;span style="color: #a31515"&gt;}&lt;/span&gt; -gt 1 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list[@]:1&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
            result=&lt;span style="color: #0000ff"&gt;$(&lt;/span&gt;&lt;span style="color: #a31515"&gt;${&lt;/span&gt;operator&lt;span style="color: #a31515"&gt;}&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;result&lt;span style="color: #a31515"&gt;}&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;&lt;span style="color: #0000ff"&gt;)&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    echo &lt;span style="color: #a31515"&gt;${&lt;/span&gt;result&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
}

filter() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
}

sum() {
    v=0
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; arg in &lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;$@&lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        v=&lt;span style="color: #0000ff"&gt;$((&lt;/span&gt;$v+&lt;span style="color: #a31515"&gt;${&lt;/span&gt;arg&lt;span style="color: #a31515"&gt;}&lt;/span&gt;&lt;span style="color: #0000ff"&gt;))&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
    echo $v
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="Bash"></category></entry><entry><title>配置 Maven 自动化构建 protobuf 代码依赖</title><link href="http://youngsterxyf.github.io/2018/05/14/maven-protobuf/" rel="alternate"></link><published>2018-05-14T00:00:00+08:00</published><updated>2018-05-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-05-14:/2018/05/14/maven-protobuf/</id><summary type="html">&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin.version&amp;gt;
    &amp;lt;maven-dependency-plugin.version&amp;gt;3.0.2&amp;lt;/maven-dependency-plugin.version …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin.version&amp;gt;
    &amp;lt;maven-dependency-plugin.version&amp;gt;3.0.2&amp;lt;/maven-dependency-plugin.version&amp;gt;
    &amp;lt;os-maven-plugin.version&amp;gt;1.5.0.Final&amp;lt;/os-maven-plugin.version&amp;gt;
    &amp;lt;protobuf.version&amp;gt;2.5.0&amp;lt;/protobuf.version&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.添加 protobuf-java 库依赖&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${protobuf.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.添加 maven 扩展：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;build&amp;gt;
    &amp;lt;extensions&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- provides os.detected.classifier (i.e. linux-x86_64, osx-x86_64) property --&amp;gt;&lt;/span&gt;
        &amp;lt;extension&amp;gt;
            &amp;lt;groupId&amp;gt;kr.motd.maven&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;os-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${os-maven-plugin.version}&amp;lt;/version&amp;gt;
        &amp;lt;/extension&amp;gt;
    &amp;lt;/extensions&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.配置构建插件：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- copy protoc binary into build directory --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${maven-dependency-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;copy-protoc&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;copy&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;artifactItems&amp;gt;
                            &amp;lt;artifactItem&amp;gt;
                                &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;protoc&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;${protobuf.version}&amp;lt;/version&amp;gt;
                                &amp;lt;classifier&amp;gt;${os.detected.classifier}&amp;lt;/classifier&amp;gt;
                                &amp;lt;type&amp;gt;exe&amp;lt;/type&amp;gt;
                                &amp;lt;overWrite&amp;gt;true&amp;lt;/overWrite&amp;gt;
                                &amp;lt;outputDirectory&amp;gt;${project.build.directory}&amp;lt;/outputDirectory&amp;gt;
                            &amp;lt;/artifactItem&amp;gt;
                        &amp;lt;/artifactItems&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- compile proto buffer files using copied protoc binary --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-antrun-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${maven-antrun-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;exec-protoc&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;target&amp;gt;
                            &amp;lt;property name=&lt;span style="color: #a31515"&gt;&amp;quot;protoc.filename&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;protoc-${protobuf.version}-${os.detected.classifier}.exe&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;property name=&lt;span style="color: #a31515"&gt;&amp;quot;protoc.filepath&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;${project.build.directory}/${protoc.filename}&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;chmod file=&lt;span style="color: #a31515"&gt;&amp;quot;${protoc.filepath}&amp;quot;&lt;/span&gt; perm=&lt;span style="color: #a31515"&gt;&amp;quot;ugo+rx&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;mkdir dir=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.output.directory}&amp;quot;&lt;/span&gt; /&amp;gt;
                            &amp;lt;path id=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths.path&amp;quot;&lt;/span&gt;&amp;gt;
                                &amp;lt;fileset dir=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.directory}&amp;quot;&lt;/span&gt;&amp;gt;
                                    &amp;lt;include name=&lt;span style="color: #a31515"&gt;&amp;quot;**/*.proto&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;/fileset&amp;gt;
                            &amp;lt;/path&amp;gt;
                            &amp;lt;pathconvert pathsep=&lt;span style="color: #a31515"&gt;&amp;quot; &amp;quot;&lt;/span&gt; property=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths&amp;quot;&lt;/span&gt; refid=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths.path&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;exec executable=&lt;span style="color: #a31515"&gt;&amp;quot;${protoc.filepath}&amp;quot;&lt;/span&gt; failonerror=&lt;span style="color: #a31515"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;-I&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.directory}&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;--java_out&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.output.directory}&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg line=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.filepaths}&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;/exec&amp;gt;
                        &amp;lt;/target&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;run&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- add generated proto buffer classes into the package --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;build-helper-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${build-helper-maven-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;add-classes&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;add-source&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;sources&amp;gt;
                            &amp;lt;source&amp;gt;${protobuf.output.directory}&amp;lt;/source&amp;gt;
                        &amp;lt;/sources&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://vlkan.com/blog/post/2015/11/27/maven-protobuf/&lt;/p&gt;
&lt;p&gt;http://www.chendan.me/2017/07/02/maven-protobuf/&lt;/p&gt;</content><category term="java"></category><category term="maven"></category><category term="protobuf"></category></entry><entry><title>《Python 编程之美》译者序</title><link href="http://youngsterxyf.github.io/2018/04/01/the-python-guide/" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-04-01:/2018/04/01/the-python-guide/</id><summary type="html">&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语言包括：Python、PHP、Go、Java、JavaScript 等。&lt;/p&gt;
&lt;p&gt;虽说编程语言各异，但我使用它们来写各种项目的代码却一直坚持两点：代码可读性和自解释性/自文档性（self-documentation）。这很大程度上应该是受到 Python 语言设计哲学的影响 - 追求简单易读易懂的代码。&lt;/p&gt;
&lt;p&gt;很多人可能会认为这两点其实是一点 - 代码可读性，但我想做点区分：代码可读性突出对代码阅读者视觉上的影响，是否存在不必要的理解干扰，比如：必要的空行、变量定义与使用之间的距离、函数体/逻辑分支是否过长、逻辑表达是否直观等等。可读性高的代码通常都非常漂亮、赏心悦目。自解释性代码则更突出语义层面，比如：变量名称/函数名称/类名是否恰当、函数/方法/API 是否单一职责、工程目录结构/包/模块拆分是否符合“高内聚低耦合”原则等等 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语言包括：Python、PHP、Go、Java、JavaScript 等。&lt;/p&gt;
&lt;p&gt;虽说编程语言各异，但我使用它们来写各种项目的代码却一直坚持两点：代码可读性和自解释性/自文档性（self-documentation）。这很大程度上应该是受到 Python 语言设计哲学的影响 - 追求简单易读易懂的代码。&lt;/p&gt;
&lt;p&gt;很多人可能会认为这两点其实是一点 - 代码可读性，但我想做点区分：代码可读性突出对代码阅读者视觉上的影响，是否存在不必要的理解干扰，比如：必要的空行、变量定义与使用之间的距离、函数体/逻辑分支是否过长、逻辑表达是否直观等等。可读性高的代码通常都非常漂亮、赏心悦目。自解释性代码则更突出语义层面，比如：变量名称/函数名称/类名是否恰当、函数/方法/API 是否单一职责、工程目录结构/包/模块拆分是否符合“高内聚低耦合”原则等等。长期追求这两点，可以极大地提升个人，特别是团队的工作效率和工作质量。&lt;/p&gt;
&lt;p&gt;本书作者 Kenneth Reitz 于 2011 年发布 Requests 这个 HTTP 请求工具库，提出“for humans”的理念，强调软件/工具库应该对人类友好易用，这一理念本质上是对 Python 哲学（特别是上述两点）的一种引申和发扬。之后 Reitz 在一些 Python大会上做技术分享，宣扬“for humans”理念，对 Python 社区产生巨大影响。我在第一次用过 Requests 库之后，便很少使用 Python 标准库中的 urllib 和 urllib2，现在标准库文档中也特别建议开发者使用 Requests。&lt;/p&gt;
&lt;p&gt;因为对“for humans”理念的认同，也因为经常使用 Requests，所以当 Reitz 在 Github 上邀请我翻译 Requests 文档中文版时，我欣然接受，和另一个 Python 开发者共同翻译了 Requests 文档的首个官方中文翻译版。这“另一个 Python 开发者”也就是本书的另一个译者。&lt;/p&gt;
&lt;p&gt;在 Reitz 发起 “The Hitchhiker's Guide to Python!” 项目（也就是本书的社区开源版）后，我一直持续跟进阅读，收获巨大。后来得知这本开源书籍正式出版，欣喜若狂，辗转咨询多人，联系到刘皎老师 ，申请了本书的翻译工作。&lt;/p&gt;
&lt;p&gt;但是，后来发现翻译的工作量远远超出预估，除了个人的一些主观原因，主要因为本书内容的广度和深度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度：本书由 Python 社区数百人共同创作而成，可以视作 Python 小百科全书。1-3章指导读者按照自己的需求选择安装配置 Python 版本/发行版、开发环境等。7-11章则针对不同的应用场景，从多个维度甄选对比了大量的 Python 库，读者可以“按图索骥”地做出自己的选择，从而节约大量的时间精力。因为译者的 Python 开发经验主要集中在 Web 开发和数据处理，对于很多应用场景下的 Python 库不太熟悉，所以翻译之前花费了大量时间来学习理解。&lt;/li&gt;
&lt;li&gt;深度：针对 Python 中手的核心需求，本书探讨了大量的最佳实践。其中4-5章通过大量示例具体地阐释了“Python 之禅”的句句箴言，如何编写高质量的 Python 代码，并精选若干高质量的知名 Python 开源项目，详细介绍如何通过阅读源码来提升编程技术水平。虽说 Python 社区几乎人人皆知“Python 之禅”，但如何落地到开发实践估计极少有人说得清楚。对照书中的实例阐释，译者几经调整推敲“Python 之禅”的译文，最终敲定的译文也不是特别令自己满意。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比原计划，本书最终延期近一年才得以翻译完成。除了歉意，我内心满是感谢：感谢邦杰中途友情加入，帮忙翻译了4-6章初稿，这三章的难度和长度都非常大；感谢编辑老师刘皎对我拖稿的次次容忍和耐心等待；感谢妻儿的理解，我对你们缺少了太多的陪伴。&lt;/p&gt;
&lt;p&gt;虽说我已尽自己所能地保证译文质量，但错误瑕疵难免，在此也请读者原谅。希望你们阅读愉快！&lt;/p&gt;
&lt;p&gt;至此，我如释重负。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;夏永锋&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;写于上海&lt;/em&gt;&lt;/p&gt;</content><category term="翻译"></category><category term="书籍"></category></entry></feed>