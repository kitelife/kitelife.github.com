<!DOCTYPE html>
<html lang="zh">
<head>

        <title>Yii源码阅读笔记 - 请求处理基本流程</title>
        <meta charset="utf-8" />
        <link href="http://youngsterxyf.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="黑 * 白 Full Atom Feed" />
        <link href="http://youngsterxyf.github.io/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="黑 * 白 Full RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../../../../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/pygment.css" />

        <script src="../../../../theme/js/libs/modernizr-2.6.2.min.js"></script>

              <script>
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-43488080-1', '黑白');
                ga('send', 'pageview');

              </script>

              <script type="text/javascript" src="http://tajs.qq.com/stats?sId=27164999" charset="UTF-8"></script>
 
</head>

<body id="index" class="home">
    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="../../../..">黑 * 白 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="../../../..">主 页</a></li>

                <li><a href="/archives.html">归 档</a></li>
                <li><a href="/tags.html">标 签</a></li>
                <li><a href="/pages/tools.html">工具集</a></li>
                <li><a href="/pages/links.html">链 接</a></li>
                <li><a href="/pages/aboutme.html">关于我</a></li>
                <li><a href="/feeds/rss.xml">RSS</a></li>

              </ul>
            </div>

<section id="content" class="body">
   <div class="row">
        <div class="columns">
            <header>
              <h2 class="entry-title">
                <a href="../../../../2014/11/04/read-yii-code-1/" rel="bookmark" title="Permalink to Yii源码阅读笔记 - 请求处理基本流程">Yii源码阅读笔记 - 请求处理基本流程</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2014-11-04T00:00:00">
                2014-11-04 Tue
              </abbr>
              <address class="vcard author">
                By <a class="url fn" href="../../../../author/youngsterxyf.html">youngsterxyf</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <p>对于Web框架，我认为其主要有三点作用：</p>
<ol>
<li>提供多人协作的基本规范</li>
<li>避免重复造轮子</li>
<li>开发者只需关注业务逻辑，脏活（如：基本的安全防范、兼容问题）Web框架都已完成并提供设计良好的API</li>
</ol>
<p>但代价是学习成本 - 为了尽可能发挥Web框架的优势，需要花一些阅读文档，甚至是框架源码（特别是文档缺乏或者文档写得垃圾的），然后经过几次项目实践，一切才能了然于胸。</p>
<p>喏，为了在工作中更好地使用、避免误用Yii框架，大致阅读了Yii框架的部分代码，然后有了这个系列的笔记。</p>
<hr />
<p>深入学习一个Web框架，首先要理解的是请求处理流程。对于PHP而言，处理流程也即包含了应用的初始化过程，如加载配置、初始化组件等。请求处理流程中最核心的应该是路由解析和分发，此外可能还有过滤器处理、事件处理等，直到请求处理进入具体的Controller和Action。响应生成、过滤等也可以关注。</p>
<hr />
<p>基于Yii框架的工程目录结构大致如下所示：</p>
<p><img alt="Yii-Project-Structure" src="/assets/uploads/pics/yii-project-structure.png" /></p>
<ul>
<li>index.php是应用的入口</li>
<li>protected目录是存放动态脚本的地方<ul>
<li>components子目录存放各种组件类</li>
<li>configs存放应用的配置文件</li>
<li>controllers存放Controller类文件</li>
<li>models存放Model类文件</li>
<li>runtime存放一些应用生成的临时文件或者缓存文件，如Smarty编译好的模板、日志文件</li>
<li>views存放View模板文件</li>
</ul>
</li>
<li>static目录存放静态文件，如CSS、JS、图片等</li>
<li>yii目录则存放Yii框架的源码</li>
</ul>
<p><code>index.php</code>文件的内容大致如下：</p>
<div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nb">defined</span><span class="p">(</span><span class="s1">&#39;APP_ENV&#39;</span><span class="p">)</span> <span class="k">or</span> <span class="nb">define</span><span class="p">(</span><span class="s1">&#39;APP_ENV&#39;</span><span class="p">,</span> <span class="s1">&#39;development&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">APP_ENV</span> <span class="o">==</span> <span class="s1">&#39;production&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">ini_set</span><span class="p">(</span><span class="s1">&#39;display_errors&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nb">error_reporting</span><span class="p">(</span><span class="k">E_ALL</span><span class="p">);</span>
    <span class="nb">define</span><span class="p">(</span><span class="s1">&#39;YII_ENABLE_ERROR_HANDLER&#39;</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="nv">$yii</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="k">__FILE__</span><span class="p">)</span> <span class="o">.</span> <span class="s1">&#39;/yii/framework/yiilite.php&#39;</span><span class="p">;</span>
    <span class="nb">defined</span><span class="p">(</span><span class="s1">&#39;YII_TRACE_LEVEL&#39;</span><span class="p">)</span> <span class="k">or</span> <span class="nb">define</span><span class="p">(</span><span class="s1">&#39;YII_TRACE_LEVEL&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">error_reporting</span><span class="p">(</span><span class="k">E_ALL</span><span class="p">);</span>
    <span class="nv">$yii</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="k">__FILE__</span><span class="p">)</span> <span class="o">.</span> <span class="s1">&#39;/yii/framework/yii.php&#39;</span><span class="p">;</span>
    <span class="nb">defined</span><span class="p">(</span><span class="s1">&#39;YII_DEBUG&#39;</span><span class="p">)</span> <span class="k">or</span> <span class="nb">define</span><span class="p">(</span><span class="s1">&#39;YII_DEBUG&#39;</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="nb">defined</span><span class="p">(</span><span class="s1">&#39;YII_TRACE_LEVEL&#39;</span><span class="p">)</span> <span class="k">or</span> <span class="nb">define</span><span class="p">(</span><span class="s1">&#39;YII_TRACE_LEVEL&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="nv">$config</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="k">__FILE__</span><span class="p">)</span> <span class="o">.</span> <span class="s1">&#39;/protected/configs/&#39;</span> <span class="o">.</span> <span class="nx">APP_ENV</span> <span class="o">.</span> <span class="s1">&#39;.php&#39;</span><span class="p">;</span>

<span class="k">require_once</span><span class="p">(</span><span class="nv">$yii</span><span class="p">);</span>
<span class="nv">$YiiApp</span> <span class="o">=</span> <span class="nx">Yii</span><span class="o">::</span><span class="na">createWebApplication</span><span class="p">(</span><span class="nv">$config</span><span class="p">);</span>
<span class="nv">$YiiApp</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">();</span>
</pre></div>


<p>根据应用所处的环境（开发环境或生产环境）配置不同的环境变量，加载不同的配置文件，然后根据配置信息创建一个Web应用对象（这个对象类似一个容器），并处理请求。</p>
<p><code>Yii::createWebApplication($config)</code>中类Yii直接继承自类YiiBase，并且没有自定义属性和方法，即调用的静态方法createWebApplication来自类YiiBase，实现如下：</p>
<div class="highlight"><pre><span class="x">public static function createWebApplication($config=null)</span>
<span class="x">{</span>
<span class="x">    return self::createApplication(&#39;CWebApplication&#39;, $config);</span>
<span class="x">}</span>
</pre></div>


<p>之所以这么实现，是因为Yii还支持控制台/命令行类型的应用实现，比如cron脚本。</p>
<p>静态方法createApplication实现如下：</p>
<div class="highlight"><pre><span class="x">public static function createApplication($class, $config=null)</span>
<span class="x">{</span>
<span class="x">    return new $class($config);</span>
<span class="x">}</span>
</pre></div>


<p>真正实例化的类CWebApplication见文件<code>yii/framework/web/CWebApplication.php</code>。</p>
<p>类CWebApplication自己也没有实现构造方法，直接继承自抽象类CApplication（见文件<code>yii/framework/base/CApplication.php</code>），其构造方法实现如下：</p>
<div class="highlight"><pre><span class="x">public function __construct($config=null)</span>
<span class="x">{</span>
<span class="x">    Yii::setApplication($this);</span>

<span class="x">    // set basePath at early as possible to avoid trouble</span>
<span class="x">    if(is_string($config))</span>
<span class="x">        $config=require($config);</span>
<span class="x">    if(isset($config[&#39;basePath&#39;]))</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;setBasePath($config[&#39;basePath&#39;]);</span>
<span class="x">        unset($config[&#39;basePath&#39;]);</span>
<span class="x">    }</span>
<span class="x">    else</span>
<span class="x">        $this-&gt;setBasePath(&#39;protected&#39;);</span>
<span class="x">    Yii::setPathOfAlias(&#39;application&#39;,$this-&gt;getBasePath());</span>
<span class="x">    Yii::setPathOfAlias(&#39;webroot&#39;,dirname($_SERVER[&#39;SCRIPT_FILENAME&#39;]));</span>
<span class="x">    if(isset($config[&#39;extensionPath&#39;]))</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;setExtensionPath($config[&#39;extensionPath&#39;]);</span>
<span class="x">        unset($config[&#39;extensionPath&#39;]);</span>
<span class="x">    }</span>
<span class="x">    else</span>
<span class="x">        Yii::setPathOfAlias(&#39;ext&#39;,$this-&gt;getBasePath().DIRECTORY_SEPARATOR.&#39;extensions&#39;);</span>
<span class="x">    if(isset($config[&#39;aliases&#39;]))</span>
<span class="x">    {</span>
<span class="x">        $this-&gt;setAliases($config[&#39;aliases&#39;]);</span>
<span class="x">        unset($config[&#39;aliases&#39;]);</span>
<span class="x">    }</span>

<span class="x">    $this-&gt;preinit();</span>

<span class="x">    $this-&gt;initSystemHandlers();</span>
<span class="x">    $this-&gt;registerCoreComponents();</span>

<span class="x">    $this-&gt;configure($config);</span>
<span class="x">    $this-&gt;attachBehaviors($this-&gt;behaviors);</span>
<span class="x">    $this-&gt;preloadComponents();</span>

<span class="x">    $this-&gt;init();</span>
<span class="x">}</span>
</pre></div>


<p><code>Yii::setApplication($this)</code>将当前类CWebApplication的实例化对象赋值给类YiiBase的私有属性<code>$_app</code>，之后通过<code>Yii::app()</code>就能取到这个对象（app方法其实是类YiiBase中定义的）。</p>
<p>构造方法根据配置信息初始化一些路径和别名相关的属性。以路径别名<code>application</code>为例，如果想将日志目录配置为<code>protected/runtime</code>，则可以指定路径为<code>application.runtime</code>，这样的好处是你可以配置<code>basePath</code>来指定动态脚本所在的目录，不一定必须是<code>protected</code>，即使你的修改了basePath，其余相对basePath的路径配置都不需要变动。</p>
<p>类CApplication又直接继承自类CModule（见文件<code>yii/framework/base/CModule.php</code>），上述构造方法中调用的方法<code>preinit</code>、<code>configure</code>、<code>preloadComponents</code>定义在类CModule中。</p>
<p><code>preinit</code>的方法体为空。这个方法调用之后主要是加载核心组件、及将配置信息存到<code>Yii::app()</code>这个容器对象中。如果需要在这些操作之前做一些初始化准备工作，则可以自定义一个类继承自类<code>CWebApplication</code>，然后实现<code>preinit</code>方法。但这样的话，index.php中创建web应用对象的方式就有所不同的了，假设自定义的类为<code>MyWebApplication</code>，index.php中在引入该类文件后：</p>
<div class="highlight"><pre><span class="x">$yiiApp = Yii::createApplication(&#39;MyWebApplication&#39;, $config);</span>
<span class="x">$yiiApp-&gt;run();</span>
</pre></div>


<p>方法<code>initSystemHandler</code>则是根据条件设置框架的异常和错误处理方法。</p>
<p>方法<code>registerCoreComponents</code>则是加载框架的核心组件，当然如果有需要可以配置同名（同名指的是key相同，Yii中每个组件都是通过一个key或者说别名来注册和引用）的自定义组件来覆盖默认的核心组件，如db、urlManager。</p>
<p>组件的注册加载细节我们会另外写一篇文章来介绍。</p>
<hr />
<p>方法<code>configure</code>定义在类<code>CModule</code>中，实现如下：</p>
<div class="highlight"><pre><span class="x">public function configure($config)</span>
<span class="x">{</span>
<span class="x">    if(is_array($config))</span>
<span class="x">    {</span>
<span class="x">        foreach($config as $key=&gt;$value)</span>
<span class="x">            $this-&gt;$key=$value;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>


<p>看起来是不是很简单？但其实没你想的那么简单呢... 思考一下如果代码中当前对象<code>$this</code>不存在属性<code>$key</code>或者名为<code>$key</code>的属性是私有的会发生什么事情？这时PHP的魔术方法<code>__set</code>就派上用场了。</p>
<p>类<code>CModule</code>直接继承自类<code>CComponent</code>。在类CComponent中定义了方法<code>__set</code>，实现如下：</p>
<div class="highlight"><pre><span class="x">public function __set($name,$value)</span>
<span class="x">{</span>
<span class="x">    $setter=&#39;set&#39;.$name;</span>
<span class="x">    if(method_exists($this,$setter))</span>
<span class="x">        return $this-&gt;$setter($value);</span>
<span class="x">    elseif(strncasecmp($name,&#39;on&#39;,2)===0 &amp;&amp; method_exists($this,$name))</span>
<span class="x">    {</span>
<span class="x">        // duplicating getEventHandlers() here for performance</span>
<span class="x">        $name=strtolower($name);</span>
<span class="x">        if(!isset($this-&gt;_e[$name]))</span>
<span class="x">            $this-&gt;_e[$name]=new CList;</span>
<span class="x">        return $this-&gt;_e[$name]-&gt;add($value);</span>
<span class="x">    }</span>
<span class="x">    elseif(is_array($this-&gt;_m))</span>
<span class="x">    {</span>
<span class="x">        foreach($this-&gt;_m as $object)</span>
<span class="x">        {</span>
<span class="x">            if($object-&gt;getEnabled() &amp;&amp; (property_exists($object,$name) || $object-&gt;canSetProperty($name)))</span>
<span class="x">                return $object-&gt;$name=$value;</span>
<span class="x">        }</span>
<span class="x">    }</span>
<span class="x">    if(method_exists($this,&#39;get&#39;.$name))</span>
<span class="x">        throw new CException(Yii::t(&#39;yii&#39;,&#39;Property &quot;{class}.{property}&quot; is read only.&#39;,</span>
<span class="x">            array(&#39;{class}&#39;=&gt;get_class($this), &#39;{property}&#39;=&gt;$name)));</span>
<span class="x">    else</span>
<span class="x">        throw new CException(Yii::t(&#39;yii&#39;,&#39;Property &quot;{class}.{property}&quot; is not defined.&#39;,</span>
<span class="x">            array(&#39;{class}&#39;=&gt;get_class($this), &#39;{property}&#39;=&gt;$name)));</span>
<span class="x">}</span>
</pre></div>


<p>PHP中对一个对象的属性进行赋值的规则如下：</p>
<ol>
<li>如果该对象有public的该属性，则直接赋值</li>
<li>否则看该对象所在继承树上是否有定义魔术方法<code>__set</code>，如果有则调用<code>__set</code>来处理赋值过程</li>
<li>如果连<code>__set</code>也没有，则为该对象生成一个public的属性，然后赋值给它</li>
</ol>
<p>类CComponent中定义的魔术方法<code>__set</code>其逻辑是：</p>
<ol>
<li>查看当前对象是否有名为<code>'set'.$key</code>的方法，如果有，则以该方法来处理赋值过程</li>
<li>否则，检查$key是否以字符串<code>on</code>开头，如果是且当前对象具有名为$key的方法，则认为这是一个事件的赋值过程，将赋值到事件列表中</li>
<li>否则，则认为这是一个行为(behavior)赋值，尝试为属性<code>_m</code>对象列表中对象的属性赋值。（貌似是这样，我也还懂<code>_m</code>的作用）</li>
</ol>
<p>以上述规则逻辑，所以类CModule中定义了很多方法名以字符串<code>set</code>或<code>get</code>开头的方法，如setComponents、getComponents、setParams、getParams等。说到这里，你是不是领会到什么了？</p>
<hr />
<p><code>$this-&gt;attachBehaviors($this-&gt;behaviors)</code>一句中当前对象的属性behaviors的访问权限为public，默认值为空数组，可以在配置文件中配置如下一项：</p>
<div class="highlight"><pre><span class="x">&#39;behaviors&#39; =&gt; array(</span>
<span class="x">    &#39;behaviorName&#39;=&gt;array(</span>
<span class="x">        &#39;class&#39;=&gt;&#39;path.to.BehaviorClass&#39;,</span>
<span class="x">        &#39;property1&#39;=&gt;&#39;value1&#39;,</span>
<span class="x">        &#39;property2&#39;=&gt;&#39;value2&#39;,</span>
<span class="x">    )</span>
<span class="x">),</span>
</pre></div>


<p>按照上述对象属性的赋值规则，该配置项会赋值给属性behaviors。</p>
<p>方法attachBehaviors对这些配置项逐个初始化然后存入属性<code>_m</code>中。</p>
<hr />
<p>方法<code>preloadComponents</code>定义在类CModule中，实现如下：</p>
<div class="highlight"><pre><span class="x">/**</span>
<span class="x"> * Loads static application components.</span>
<span class="x"> */</span>
<span class="x">protected function preloadComponents()</span>
<span class="x">{</span>
<span class="x">    foreach($this-&gt;preload as $id)</span>
<span class="x">        $this-&gt;getComponent($id);</span>
<span class="x">}</span>
</pre></div>


<p>其中属性preload访问权限为public，默认也是空数组，可以在其中配置需要预加载的组件的ID。</p>
<hr />
<p><code>$this-&gt;init()</code>一行中方法<code>init</code>定义在类CWebApplication中，实现如下：</p>
<div class="highlight"><pre><span class="x">protected function init()</span>
<span class="x">{</span>
<span class="x">    parent::init();</span>
<span class="x">    // preload &#39;request&#39; so that it has chance to respond to onBeginRequest event.</span>
<span class="x">    $this-&gt;getRequest();</span>
<span class="x">}</span>
</pre></div>


<p>其中方法<code>getRequest</code>就是预加载request组件。</p>
<hr />
<p>index.php中得到Web应用对象后继而调用其方法run，该run方法定义于类CApplication中，实现如下：</p>
<div class="highlight"><pre><span class="x">/**</span>
<span class="x"> * Runs the application.</span>
<span class="x"> * This method loads static application components. Derived classes usually overrides this</span>
<span class="x"> * method to do more application-specific tasks.</span>
<span class="x"> * Remember to call the parent implementation so that static application components are loaded.</span>
<span class="x"> */</span>
<span class="x">public function run()</span>
<span class="x">{</span>
<span class="x">    if($this-&gt;hasEventHandler(&#39;onBeginRequest&#39;))</span>
<span class="x">        $this-&gt;onBeginRequest(new CEvent($this));</span>
<span class="x">    // 这里为了处理程序主动调用exit()或者抛出异常时的情况</span>
<span class="x">    register_shutdown_function(array($this,&#39;end&#39;),0,false);</span>
<span class="x">    // 请求处理</span>
<span class="x">    $this-&gt;processRequest();</span>
<span class="x">    if($this-&gt;hasEventHandler(&#39;onEndRequest&#39;))</span>
<span class="x">        $this-&gt;onEndRequest(new CEvent($this));</span>
<span class="x">}</span>
</pre></div>


<p>其中方法processRequest定义于类CWebApplication中，实现如下：</p>
<div class="highlight"><pre><span class="x">public function processRequest()</span>
<span class="x">{</span>
<span class="x">    // 可以在配置文件里配置request组件时，提供catchAllRequest参数</span>
<span class="x">    // catchAllRequest是一个数组，第一个元素指定一个controller及一个action，其余元素是这个action的参数</span>
<span class="x">    // 如果配置了catchAllRequest，就可以用这个controller/action来处理所有的请求，当网站进入维护状态时，有其用处。</span>
<span class="x">    if(is_array($this-&gt;catchAllRequest) &amp;&amp; isset($this-&gt;catchAllRequest[0]))</span>
<span class="x">    {</span>
<span class="x">        $route=$this-&gt;catchAllRequest[0];</span>
<span class="x">        foreach(array_splice($this-&gt;catchAllRequest,1) as $name=&gt;$value)</span>
<span class="x">            $_GET[$name]=$value;</span>
<span class="x">    }</span>
<span class="x">    else</span>
<span class="x">        // 正常的路由解析</span>
<span class="x">        // 组件urlManager -&gt;parseUrl 组件request</span>
<span class="x">        $route=$this-&gt;getUrlManager()-&gt;parseUrl($this-&gt;getRequest());</span>
<span class="x">    // 根据路由执行控制器处理函数</span>
<span class="x">    $this-&gt;runController($route);</span>
<span class="x">}</span>
</pre></div>


<p>其中路由解析的过程我们也会以单独的一篇文章来分析，暂不细说。</p>
<p>方法runController的实现如下：</p>
<div class="highlight"><pre><span class="x">/**</span>
<span class="x"> * Creates the controller and performs the specified action.</span>
<span class="x"> * @param string $route the route of the current request. See {@link createController} for more details.</span>
<span class="x"> * @throws CHttpException if the controller could not be created.</span>
<span class="x"> */</span>
<span class="x">public function runController($route)</span>
<span class="x">{</span>
<span class="x">    if(($ca=$this-&gt;createController($route))!==null)</span>
<span class="x">    {</span>
<span class="x">        list($controller,$actionID)=$ca;</span>
<span class="x">        $oldController=$this-&gt;_controller;</span>
<span class="x">        $this-&gt;_controller=$controller;</span>
<span class="x">        $controller-&gt;init();</span>
<span class="x">        $controller-&gt;run($actionID);</span>
<span class="x">        $this-&gt;_controller=$oldController;</span>
<span class="x">    }</span>
<span class="x">    else</span>
<span class="x">        throw new CHttpException(404,Yii::t(&#39;yii&#39;,&#39;Unable to resolve the request &quot;{route}&quot;.&#39;,</span>
<span class="x">            array(&#39;{route}&#39;=&gt;$route===&#39;&#39;?$this-&gt;defaultController:$route)));</span>
<span class="x">}</span>
</pre></div>


<p>其中方法Controller根据$route按照一定的规则找到对应的controller类，之后调用controller的init方法和run方法。但这个调用之前和之后还恢复老的controller，这应该是因为在一个controller中可以forward到另一个controller中去，也即controller可以递归执行，所以需要保存和恢复上下文。</p>
<p>Yii中所有Controller类都必须直接或间接继承自类CController，该类的init方法实现为空，如有需要可以在子类中重写。而其run方法实现如下：</p>
<div class="highlight"><pre><span class="x">public function run($actionID)</span>
<span class="x">{</span>
<span class="x">    if(($action=$this-&gt;createAction($actionID))!==null)</span>
<span class="x">    {</span>
<span class="x">        if(($parent=$this-&gt;getModule())===null)</span>
<span class="x">            $parent=Yii::app();</span>
<span class="x">        if($parent-&gt;beforeControllerAction($this,$action))</span>
<span class="x">        {</span>
<span class="x">            $this-&gt;runActionWithFilters($action,$this-&gt;filters());</span>
<span class="x">            $parent-&gt;afterControllerAction($this,$action);</span>
<span class="x">        }</span>
<span class="x">    }</span>
<span class="x">    else</span>
<span class="x">        $this-&gt;missingAction($actionID);</span>
<span class="x">}</span>
</pre></div>


<p><code>$this-&gt;runActionWithFilters($action,$this-&gt;filters())</code>一行中，方法filters的实现仅是返回一个空数组，如果想要使用过滤器就需要在自定义的Controller类中重写该方法，过滤器的配置方法见源码中注释：</p>
<div class="highlight"><pre>* For a method-based filter (called inline filter), it is specified as &#39;FilterName[ +|- Action1, Action2, ...]&#39;,
 * where the &#39;+&#39; (&#39;-&#39;) operators describe which actions should be (should not be) applied with the filter.
 *
 * For a class-based filter, it is specified as an array like the following:
 * &lt;pre&gt;
 * array(
 *     &#39;FilterClass[ +|- Action1, Action2, ...]&#39;,
 *     &#39;name1&#39;=&gt;&#39;value1&#39;,
 *     &#39;name2&#39;=&gt;&#39;value2&#39;,
 *     ...
 * )
 * &lt;/pre&gt;
 * where the name-value pairs will be used to initialize the properties of the filter.
</pre></div>


<p>方法runActionWithFilters实现如下：</p>
<div class="highlight"><pre><span class="x">public function runActionWithFilters($action,$filters)</span>
<span class="x">{</span>
<span class="x">    if(empty($filters))</span>
<span class="x">        $this-&gt;runAction($action);</span>
<span class="x">    else</span>
<span class="x">    {</span>
<span class="x">        $priorAction=$this-&gt;_action;</span>
<span class="x">        $this-&gt;_action=$action;</span>
<span class="x">        CFilterChain::create($this,$action,$filters)-&gt;run();</span>
<span class="x">        $this-&gt;_action=$priorAction;</span>
<span class="x">    }</span>
<span class="x">}</span>
</pre></div>


<p>如果没有设置过滤器，则直接执行目标action，方法runAction的实现如下：</p>
<div class="highlight"><pre><span class="x">public function runAction($action)</span>
<span class="x">{</span>
<span class="x">    $priorAction=$this-&gt;_action;</span>
<span class="x">    $this-&gt;_action=$action;</span>
<span class="x">    if($this-&gt;beforeAction($action))</span>
<span class="x">    {</span>
<span class="x">        if($action-&gt;runWithParams($this-&gt;getActionParams())===false)</span>
<span class="x">            $this-&gt;invalidActionParams($action);</span>
<span class="x">        else</span>
<span class="x">            $this-&gt;afterAction($action);</span>
<span class="x">    }</span>
<span class="x">    $this-&gt;_action=$priorAction;</span>
<span class="x">}</span>
</pre></div>


<p>类CController中定义的beforeAction直接返回true，如果需要在目标action执行之前做一些检查过滤操作则需要在自定义的Controller类中重写beforeAction方法，该方法最后必须返回true或false。beforeAction的作用类似于简化版的过滤器。</p>
<p>beforeAction通过后，则执行目标action。由于路由配置是类正则的，URL解析出来的一些片段值（算是放在url中的请求参数）应该传入目标action，方法getActionParams即是取到这些参数值。Yii在路由解析时将这些参数值也存放到全局变量<code>$_GET</code>中，所以getActionParams直接返回了<code>$_GET</code>。</p>
<hr />
<p>如果设置了过滤器，则需要根据controller、action、filters创建一个CFilterChain对象（过程中当然会对过滤器配置进行解析），类CFilterChain的run方法实现如下：</p>
<div class="highlight"><pre><span class="x">public function run()</span>
<span class="x">{</span>
<span class="x">    if($this-&gt;offsetExists($this-&gt;filterIndex))</span>
<span class="x">    {</span>
<span class="x">        $filter=$this-&gt;itemAt($this-&gt;filterIndex++);</span>
<span class="x">        Yii::trace(&#39;Running filter &#39;.($filter instanceof CInlineFilter ? get_class($this-&gt;controller).&#39;.filter&#39;.$filter-&gt;name.&#39;()&#39;:get_class($filter).&#39;.filter()&#39;),&#39;system.web.filters.CFilterChain&#39;);</span>
<span class="x">        $filter-&gt;filter($this);</span>
<span class="x">    }</span>
<span class="x">    else</span>
<span class="x">        $this-&gt;controller-&gt;runAction($this-&gt;action);</span>
<span class="x">}</span>
</pre></div>


<p>其中<code>$this-&gt;filterIndex</code>的初始值为0，方法offsetExits定义于类CList中，逻辑就是检测是否遍历执行完所有的过滤器，如果还有，则取出一个过滤器对象，执行其filter方法，该方法的实现如下：</p>
<div class="highlight"><pre><span class="x">public function filter($filterChain)</span>
<span class="x">{</span>
<span class="x">    $method=&#39;filter&#39;.$this-&gt;name;</span>
<span class="x">    $filterChain-&gt;controller-&gt;$method($filterChain);</span>
<span class="x">}</span>
</pre></div>


<p>这个时候你应该感到疑惑 - 既然是一个过滤器链，那么循环在哪？事实上，Yii的这个地方并没有提供循环来让过滤器逐个执行，这就意味着在自定义的过滤器中，如果过滤条件通过，则需要尾递归地显式调用过滤器链的run方法，这样直到所有的过滤器都通过，才执行目标action<code>$this-&gt;controller-&gt;runAction($this-&gt;action)</code>。</p>
            </div><!-- /.entry-content -->
            <div class="comments">
              <h3>Comments</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "2014/11/04/read-yii-code-1/";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://xiayfblackwhite.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>
        </div><!-- /.twelve.columns -->
 </div><!-- /.row -->
</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="http://github.com/youngsterxyf" target="_blank">Github</a></div></li>

                <li><div class="btn twitter"><a href="https://twitter.com/youngsterxyf" target="_blank">Twitter</a></div></li>

                <li><div class="btn warning"><a href="http://weibo.com/u/1855563263" target="_blank">Weibo</a></div></li>

                <li><div class="btn douban"><a href="http://www.douban.com/people/youngster21/" target="_blank">Douban</a></div></li>



              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'xiayfblackwhite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../../../../theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="../../../../theme/js/libs/gumby.min.js"></script>
  <script src="../../../../theme/js/plugins.js"></script>
  <script src="../../../../theme/js/main.js"></script>
</body>
</html>