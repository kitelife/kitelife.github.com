<!DOCTYPE html>
<html lang="zh">
<head>

        <title>Reactor 官方文档翻译简化版</title>
        <meta charset="utf-8" />
        <link href="http://youngsterxyf.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="黑·白 Full Atom Feed" />
        <link href="http://youngsterxyf.github.io/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="黑·白 Full RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../../../../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/pygment.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/SentyZHAO/SentyZHAO.css" />

        <script src="../../../../theme/js/libs/jquery-1.9.1.min.js"></script>
        <script src="../../../../theme/js/libs/modernizr-2.6.2.min.js"></script>
            <script>
              var _hmt = _hmt || [];
              (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?5c5d8c3fe75afeff117777b9236b96ec";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
              })();
            </script>
</head>

<body id="index" class="home">
    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1 style='font-family: "SentyZHAO";'><a href="../../../..">黑·白 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>

              <ul class="columns" style='font-family: "SentyZHAO";'>
                <li><a href="../../../..">主 页</a></li>

                <li><a href="/archives.html">归 档</a></li>
                <li><a href="/pages/tech-share.html">技术分享</a></li>
                <li><a href="/pages/translation.html">技术翻译</a></li>
                <li><a href="/pages/tools.html">工具集</a></li>
                <li><a href="/pages/links.html">链 接</a></li>
                <li><a href="/pages/aboutme.html">关于我</a></li>
                <li><a href="/feeds/rss.xml">RSS</a></li>

              </ul>
            </div>

<section id="content" class="body">
   <div class="row">
        <div class="columns">
            <header>
              <h2 class="entry-title">
                <a href="../../../../2019/06/26/simplified-reactor-doc-zh/" rel="bookmark" title="Permalink to Reactor 官方文档翻译简化版">Reactor 官方文档翻译简化版</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2019-06-26T00:00:00+08:00">
                2019-06-26 三
              </abbr>
              <address class="vcard author">
                By <a class="url fn" href="../../../../author/xiayf.html">xiayf</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <p>原文：https://projectreactor.io/docs/core/release/reference/</p>
<h3>1. 开始吧</h3>
<h4>1.1 Reactor 简介</h4>
<p>Reactor 是为 JVM 准备的一个完全非阻塞的反应式编程基础组件，支持高效的需求管理（以管理“反压”的形式），直接与 Java 8 的函数式 API 集成，尤其是 <code>CompletableFuture</code>、<code>Stream</code> 以及 <code>Duration</code>，提供可组合的异步序列 API - <code>Flux</code>（适用于 N 个元素的序列）和 <code>Mono</code>（适用于 0 或 1个元素的序列）--- 并且全面地（extensively）实现了 <a href="https://www.reactive-streams.org/">反应式流（Reative Streams）</a> 规范。</p>
<p>借助 <code>reactor-netty</code> 项目，Reactor 也支持进程间的非阻塞通信，适用于微服务架构。<code>reactor-netty</code> 为 HTTP（包括 Websockets）、TCP 以及 UDP 提供支持反压的网络引擎，完全支持反应式编码解码。</p>
<h4>1.2 理解 BOM</h4>
<p>Reactor 3 开始采用 BOM （Bill of Materials，物料清单）发布模型（自 <code>reactor-core 3.0.4</code> 开始，使用 <code>Aluminium</code>（铝）版本序列），一个版本包含一组相关组件的版本，这些版本组件之间兼容性非常好，允许这些组件采用不同的版本命名方式。</p>
<p>BOM 发布模型本身也是版本化的，以一个代号后接一个修饰词来命名一个版本序列。如下是一个示例列表：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Aluminium-RELEASE
Californium-BUILD-SNAPSHOT
Aluminium-SR1
Bismuth-RELEASE
Californium-SR32
</pre></div>


<p>代号等价于常规的 <code>大版本号.小版本号</code> 形式，通常以字母升序方式取自 <a href="https://en.wikipedia.org/wiki/Periodic_table#Overview">元素周期表</a>。</p>
<p>按照时间顺序，修饰词分别为如下几个：</p>
<ul>
<li>BUILD-SNAPSHOT：为开发测试构建的版本。</li>
<li>M1 .. N：里程碑版本或者开发者预览版本。</li>
<li>RELEASE：一个代号系列中的首个 GA（General Availability 通用）发行版。</li>
<li>SR1 .. N：一个代号系列中的后续 GA 发行版 - 相当于一个补丁版本。（SR 代表 “Service Release”（服务版本））</li>
</ul>
<h4>1.3 如何获取 Reactor</h4>
<h5>1.3.1 以 Maven 管理依赖包</h5>
<p>Maven 原生支持 BOM 模型概念。首先，在你的 <code>pom.xml</code> 文件添加如下代码片段来引入 BOM：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>&lt;dependencyManagement&gt; 
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt;
            &lt;version&gt;Bismuth-RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</pre></div>


<p><em>备注：注意其中的 <code>dependencyManagement</code> 标签，添加到 <code>dependencies</code> 一节中。</em></p>
<p>如果顶部标签（<code>dependencyManagement</code>）已经存在，则只添加上面该标签的内部内容。</p>
<p>接下来，将依赖包添加到项目中，和一般依赖包一样，不过没有 <code>&lt;version&gt;</code>，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; 
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; 
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre></div>


<h5>1.3.2 以 Gradle 管理依赖包</h5>
<p>Gradle 核心并不支持 Maven BOM，不过可以借助 Spring 的 <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">gradle-dependency-management</a> 插件。</p>
<p>首先，应用插件，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>plugins <span style="border: 1px solid #FF0000">{</span>
    id <span style="color: #a31515">&quot;io.spring.dependency-management&quot;</span> <span style="color: #0000ff">version</span> <span style="color: #a31515">&quot;1.0.6.RELEASE&quot;</span>
<span style="border: 1px solid #FF0000">}</span>
</pre></div>


<p>然后使用它来引入 BOM，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>dependencyManagement <span style="border: 1px solid #FF0000">{</span>
     imports <span style="border: 1px solid #FF0000">{</span>
          mavenBom <span style="color: #a31515">&quot;io.projectreactor:reactor-bom:Bismuth-RELEASE&quot;</span>
     <span style="border: 1px solid #FF0000">}</span>
<span style="border: 1px solid #FF0000">}</span>
</pre></div>


<p>最后将依赖添加到项目中，无需指定版本号，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>dependencies <span style="border: 1px solid #FF0000">{</span>
     compile <span style="color: #a31515">&#39;io.projectreactor:reactor-core&#39;</span> 
<span style="border: 1px solid #FF0000">}</span>
</pre></div>


<h3>2. 反应式编程简介</h3>
<p>Reactor 是反应式编程范式的一个实现。反应式编程的定义归纳起来，如下所示：</p>
<blockquote>
<p>反应式编程是一个异步编程范式，关注数据流和变化的传播。这意味着通过被采用编程语言可以轻松地表达静态（比如 数组）或动态（比如 事件发射器）数据流。 --- https://en.wikipedia.org/wiki/Reactive_programming</p>
</blockquote>
<p>反应式编程方向的首个重要工作是：微软在 .NET 生态体系中创建了反应式扩展（Rx）库，然后 RxJava 在 JVM 上实现了反应式编程。时光飞逝，经 Reative Streams 的大力推进，Java 社区终于出现了反应式编程标准，该规范定义了一组接口以及 JVM 上反应式编程库之间的交互规则。Java 9 标准库已将这组接口集成到 <code>Flow</code> 类（译注：https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html）中。</p>
<p>反应式编程范式在面向对象语言中通常表现为一个观察者设计模式的扩展。你也可以将主流的反应式流模式（reactive streams pattern）和大家熟知的迭代器设计模式做对比，所有这些库中都存在对标于 <code>Iterable</code> - <code>Iterator</code> 的概念（译注：比如 发布者-消费者）。主要差别在于：迭代器是基于 pull 方式，反应式流则基于 push 方式。</p>
<p>使用迭代器是一个命令式编程的模式，即使如何访问数据（accessing values）完全是 <code>Iterable</code> 的职责，但实际上，何时访问序列中的下一个（<code>next()</code>）值取决于开发者的选择。在反应式流中，上述 <code>Iterable</code> - <code>Iterator</code> 对的等价物为 <code>Publisher</code> - <code>Subscriber</code>。不过，在出现新的数据/事件时，由 <code>Publisher</code> 通知 <code>Subscriber</code>，这个“推”特性也是实现反应式的关键之处。并且，在被推送的值上应用哪些操作是声明式表达而不是命令式表达的：程序员表达的是计算逻辑而不是描述精确的控制流。</p>
<p>除了“推”的特性，反应式流也良好地定义了如何处理错误和结束流。一个 <code>Publisher</code> 可以向它的 <code>Subscriber</code> 推送新的值（通过调用订阅者的 <code>onNext</code> 方法），也可以推送错误（调用 <code>onError</code> 方法）或结束（调用 <code>onComplete</code>方法）信号。错误和结束信号都可以终结事件序列。简而言之，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>onNext x 0..N [onError | onComplete]
</pre></div>


<p>这个方式非常灵活。这个模式支持“没有值”、“一个值”或“n个值”（包括值无限的序列，比如时钟的持续滴答事件）的各种使用场景。</p>
<p>但是，起初，我们为什么需要这样一个异步的反应式的编程库？</p>
<h4>2.1 阻塞即是资源浪费</h4>
<p>现代的软件应用，并发用户量非常巨大，即使现代硬件的处理能力一直在提升，软件的性能仍旧是一个关键问题。</p>
<p>宽泛来讲，提升一个程序的性能，有两种方式：</p>
<ul>
<li><strong>并行化</strong> 使用更多的线程和更多的硬件资源。</li>
<li>对于当前的硬件资源，<strong>寻求更高效的使用方式</strong>。</li>
</ul>
<p>通常，Java 开发者会使用阻塞性的代码编写程序，这种代码编写方式容易触及性能瓶颈，然后引入更多的线程来运行相似的阻塞性代码。但是，这种资源利用的扩展方式很快就会引发竞态（contention）和并发的问题。</p>
<p>更糟糕的是，阻塞就意味着浪费资源。如果你稍加分析，就会发现一旦程序牵涉一些等待延迟（尤其是 I/0 操作，比如等待一个数据库请求或者一个网络调用），资源就会被浪费，因为此时线程（可能是大量线程）是空闲的，等待着数据。</p>
<p>因此，并行化方式并非银弹。为了压榨出硬件的全部能力，并行化是必要的，但并行化的代码理解（reason about）起来也非常复杂，实际威力也会因为资源浪费而大打折扣。</p>
<h4>2.2 异步可以解决问题吗？</h4>
<p>前面提到的第二种方式 - 寻求更高效的使用方式 - 是资源浪费问题的一个解决方案。通过编写异步非阻塞的代码，在发生阻塞等待时，切换执行另一个活跃任务，活跃任务使用的是相同的底层资源，然后在异步处理过程结束后再切回到当前进程来执行。</p>
<p>但是我们如何编写在 JVM 上异步执行的代码？ Java 提供了两种异步编程模型：</p>
<ul>
<li><strong>回调</strong>：异步方法没有返回值，但接受一个额外的 <code>callback（回调）</code>参数（一个 lambda 表达式或匿名类），在得到异步处理结果时会调用这个回调。一个众所周知的例子是 Swing 的 <code>EventListener</code> 派生类。</li>
<li><strong>Future</strong>：这种异步方法在调用时会<em>即刻</em>返回一个 <code>Future&lt;T&gt;</code>。这个异步过程会计算出一个 <code>T</code> 类型的值，不过需要通过 <code>Future</code> 对象来访问。计算出来的值不能立即可用，可以对 <code>Future</code> 对象进行探询直到值计算出来。例如：<code>ExecutorService</code> 运行 <code>Callable&lt;T&gt;</code> 任务就是提供 <code>Future</code> 对象来获取异步结果。</li>
</ul>
<p>那么这两种技术方案就足够好了吗？在很多使用场景下并不理想，这两种方式都有局限。</p>
<p>多个回调难以组合使用，容易导致代码难以阅读和维护（就是所谓的“回调地狱”）。</p>
<p>来看一个例子：在界面上为用户显示他最喜爱的5个物件，如果用户还没有任何喜欢的物件，则给出建议物件。这个逻辑涉及3个服务（第一个服务提供物件 ID，第二个服务获取物件的详细信息，第三个服务提供建议物件的详细信息），如下所示：</p>
<p><em>回调地域的示例</em></p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>userService.getFavorites(userId, <span style="color: #0000ff">new</span> Callback&lt;List&lt;String&gt;&gt;() { <span style="color: #008000">// 1</span>
    <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> onSuccess(List&lt;String&gt; list) { <span style="color: #008000">// 2</span>
        <span style="color: #0000ff">if</span> (list.isEmpty()) { <span style="color: #008000">// 3</span>
            suggestionService.getSuggestions(<span style="color: #0000ff">new</span> Callback&lt;List&lt;Favorite&gt;&gt;() {
                <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> onSuccess(List&lt;Favorite&gt; list) { <span style="color: #008000">// 4</span>
                    UiUtils.submitOnUiThread(() -&gt; { <span style="color: #008000">// 5</span>
                        list.stream()
                            .limit(5)
                            .forEach(uiList::show); <span style="color: #008000">// 6</span>
                    })
                }

                <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> onError(Throwable error) { <span style="color: #008000">// 7</span>
                    UiUtils.errorPopup(error);
                }
            });
        } <span style="color: #0000ff">else</span> {
            list.stream() <span style="color: #008000">// 8</span>
                .limit(5)
                .forEach(favId -&gt; favoriteService.getDetails(favId, <span style="color: #008000">// 9</span>
                    <span style="color: #0000ff">new</span> Callback&lt;Favorite&gt;() {
                        <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> onSuccess(Favorite details) {
                            UiUtils.submitOnUiThread(() -&gt; uiList.show(details));
                        }

                        <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> onError(Throwable error) {
                            UiUtils.errorPopup(error);
                        }
                    }
                ));
        }
    }

    <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> onError(Throwable error) {
        UiUtils.errorPopup(error);
    }
})
</pre></div>


<ol>
<li>基于回调的服务：<code>Callback</code> 接口定义了两个方法，异步处理成功时调用其中的 <code>onSuccess</code>，异步处理发生错误时调用 <code>onError</code>。</li>
<li>第一个服务以其结果 - 喜爱物件的 ID 列表 - 调用回调方法。</li>
<li>如果列表为空，则必须转到 <code>suggestionService</code> 来处理。</li>
<li><code>suggestionService</code> 向第二个回调传递一个 <code>List&lt;Favorite&gt;</code> 列表。</li>
<li>对于 UI 渲染，必须让消费数据的代码运行在 UI 的线程中。</li>
<li>这里我们使用了 Java 8 的 <code>Stream</code> 将建议物件的数量限制为5个，然后在 UI 中渲染成一个图形化列表。</li>
<li>在每个回调层级，我们都以相同的方式处理错误：在弹出框中显示错误信息。</li>
<li>回到 喜爱物件 ID 列表的层级。如果 <code>userService</code> 服务返回一个不为空的 ID 列表，则转到 <code>favoriteService</code> 去获取带详细信息的 <code>Favorite</code> 对象。因为只需要5个喜爱物件，所以先使用流式处理将 ID 数量限制为 5 个。</li>
<li>再一次，使用一个回调。这一次我们获取到完整的 <code>Favorite</code> 对象，并在 UI 线程中将其在 UI 上渲染出来。</li>
</ol>
<p>看看有多少代码，理解起来也有点困难，其中也有一些重复的代码片段。再来看看使用 Reactor 如何来实现这段逻辑：</p>
<p><em>和回调实现方式等价的 Reactor 实现</em></p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>userService.getFavorite(userId) <span style="color: #008000">// 1</span>
            .flatMap(favoriteService::getDetails) <span style="color: #008000">// 2</span>
            .switchIfEmpty(suggestionService.getSuggestions()) <span style="color: #008000">// 3</span>
            .take(5) <span style="color: #008000">// 4</span>
            .publishOn(UiUtils.uiThreadScheduler()) <span style="color: #008000">// 5</span>
            .subscribe(uiList::show, UiUtils::errorPopup); <span style="color: #008000">// 6</span>
</pre></div>


<ol>
<li>开启一个喜爱物件 ID 的流。</li>
<li><em>异步地</em>将 ID 转换成带详细信息的 <code>Favorite</code> 对象（<code>flatMap</code>）。至此我们得到一个 <code>Favorite</code> 对象流。</li>
<li>如果 <code>Favorite</code> 流为空，则切换到备选处理方式 <code>suggestionService</code>。</li>
<li>我们只关注产出流中的前（最多）5个元素。</li>
<li>最后，在 UI 线程中处理每份数据。</li>
<li>真正触发流的处理：描述了如何处理最终的数据（显示为一个 UI 列表），以及在发生错误时如何处理（显示一个弹出框）。</li>
</ol>
<p>如果希望确保在 800ms 以内获取到喜爱物件 ID 列表，如果超时，则从缓存中获取数据，如何实现？基于回调的代码实现，这是一个复杂的任务。使用 Reactor，只需在操作链中添加一个 <code>timeout</code> 算子就能轻松搞定，如下所示：</p>
<p><em>超时回退处理的 Reactor 代码示例</em></p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>userService.getFavorites(userId)
            .timeout(Duration.ofMillis(800)) <span style="color: #008000">// 1</span>
            .onErrorResume(cacheService.cachedFavoritesFor(userId)) <span style="color: #008000">// 2</span>
            .flatMap(favoriteService::getDetails)
            .switchIfEmpty(suggestionService.getSuggestions())
            .take(5)
            .publishOn(UiUtils.uiThreadScheduler())
            .subscribe(uiList::show, UiUtils::errorPopup);
</pre></div>


<ol>
<li>如果前置处理超过 800ms 还没输出任何事件，则下发一个错误。</li>
<li>在收到错误事件时，回退到调用 <code>cacheService</code>。</li>
<li>操作链的余下部分和前一个例子类似。</li>
</ol>
<p>使用 <code>Future</code> 对象相比回调更好一点，不过组合使用起来也不太方便，尽管 Java 8 引入 <code>CompletableFuture</code> 改善了这一问题。将多个 <code>Future</code> 对象组织在一起，可行但并不容易。另外，<code>Future</code> 还有其它问题：</p>
<ul>
<li>容易碰到另一个阻塞的情况：调用 <code>Future</code> 对象的 <code>get()</code> 方法。</li>
<li>不支持惰性计算。</li>
<li>对多个值的处理和高级错误处理缺乏支持。</li>
</ul>
<p>来看看另一个例子：先获取一个 ID 列表，然后根据 ID 获取一个名字以及获取一个统计数值，再将名字和统计数值组合起来使用，这几个步骤都必须是异步的。如下示例以一组 <code>CompletableFuture</code> 来实现这个逻辑：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); <span style="color: #008000">// 1</span>

CompletableFuture&lt;List&lt;String&gt;&gt; results = ids.thenComposeAsync(l -&gt; { <span style="color: #008000">// 2</span>
    Stream&lt;CompletableFuture&lt;String&gt;&gt; zip = 
            l.stream().map(i -&gt; { <span style="color: #008000">// 3</span>
                CompletableFuture&lt;String&gt; nameTask = ifhName(i); <span style="color: #008000">// 4</span>
                CompletableFuture&lt;Integer&gt; statTask = ifhStat(i); <span style="color: #008000">// 5</span>
                <span style="color: #0000ff">return</span> nameTask.thenCombineAsync(statTask, (name, stat) -&gt; <span style="color: #a31515">&quot;Name &quot;</span> + name + <span style="color: #a31515">&quot; has stats &quot;</span> + stat); <span style="color: #008000">// 6</span>
            });
    List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList()); <span style="color: #008000">// 7</span>
    CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(<span style="color: #0000ff">new</span> CompletableFuture[combinationList.size()]);

    CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); <span style="color: #008000">// 8</span>
    <span style="color: #0000ff">return</span> allDone.thenApply(v -&gt; combinationList.stream()
                    .map(CompletableFuture::join) <span style="color: #008000">// 9</span>
                    .collect(Collectors.toList()));
});

List&lt;String&gt; results = result.join(); <span style="color: #008000">// 10</span>
assertThat(results).contains(
        <span style="color: #a31515">&quot;Name NameJoe has stats 103&quot;</span>,
        <span style="color: #a31515">&quot;Name NameBart has stats 104&quot;</span>,
        <span style="color: #a31515">&quot;Name NameHenry has stats 105&quot;</span>,
        <span style="color: #a31515">&quot;Name NameNicole has stats 106&quot;</span>,
        <span style="color: #a31515">&quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&quot;</span>);
</pre></div>


<ol>
<li>一开始获得一个 <code>Future</code> 结果 - 为后续处理提供一个 <code>id</code> 列表。</li>
<li>一旦获得 <code>id</code> 列表就可以开始进一步的异步处理。</li>
<li>逐个处理列表中的元素。</li>
<li>异步获取关联的名字。</li>
<li>异步获取关联的统计数值。</li>
<li>组合两个异步结果。</li>
<li>至此我们得到一个 <code>Future</code> 对象列表，表示所有的组合任务。</li>
<li>将 <code>Future</code> 对象数组传给 <code>CompletableFuture.allOf</code> 方法，这个方法会输出一个 <code>Future</code> 对象，当 <code>Future</code> 对象数组代表的异步任务都完成时，这个 <code>Future</code> 对象代表的异步任务也就完成了。</li>
<li>此处的特殊之处在于：在（<code>allOf</code> 返回的）<code>CompletableFuture&lt;Void&gt;</code> 对象表示的异步任务结束时，遍历 <code>Future</code> 对象列表（combinationList），使用 <code>join()</code> 方法（此次不会阻塞，因为 <code>allOf</code> 会确保所有异步任务都已完成）获取收集异步任务结果。</li>
<li>触发执行整个异步处理流水线（调用 <code>join()</code> 方法），然而等着异步处理完成并返回一个结果列表，就可以进行断言判断了。</li>
</ol>
<p>Reactor 自带了很多组合算子，可以简化这个处理过程的实现，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Flux&lt;String&gt; ids = ifhrIds(); <span style="color: #008000">// 1</span>

Flux&lt;String&gt; combinations = 
        ids.flatMap(id -&gt; { <span style="color: #008000">// 2</span>
            Mono&lt;String&gt; nameTask = ifhrName(id); <span style="color: #008000">// 3</span>
            Mono&lt;Integer&gt; statTask = ifhrStat(id); <span style="color: #008000">// 4</span>

            <span style="color: #0000ff">return</span> nameTask.zipWith(statTask, <span style="color: #008000">// 5</span>
                    (name, stat) -&gt; <span style="color: #a31515">&quot;Name &quot;</span> + name + <span style="color: #a31515">&quot; has stats &quot;</span> + stat);
        });

Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); <span style="color: #008000">// 6</span>

List&lt;String&gt; results = result.block(); <span style="color: #008000">// 7</span>
assertThat(results).containsExactly( <span style="color: #008000">// 8</span>
    <span style="color: #a31515">&quot;Name NameJoe has stats 103&quot;</span>,
    <span style="color: #a31515">&quot;Name NameBart has stats 104&quot;</span>,
    <span style="color: #a31515">&quot;Name NameHenry has stats 105&quot;</span>,
    <span style="color: #a31515">&quot;Name NameNicole has stats 106&quot;</span>,
    <span style="color: #a31515">&quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&quot;</span>
);
</pre></div>


<ol>
<li>这次，一开始我们得到一个异步提供的字符串序列（<code>ids</code>）（一个 <code>Flux&lt;String&gt;</code> 对象）。</li>
<li>对于序列中的每个元素，异步处理两次（在 <code>flatMap</code> 的 lambda 参数值中）。</li>
<li>获取关联的名字。</li>
<li>获取关联的统计值。</li>
<li>异步组合两个值</li>
<li>在异步处理的结果可用时，将它们聚合到一个 <code>List</code> 对象中。</li>
<li>在实际项目中，我们通常会继续异步处理 <code>Flux</code>，比如：异步组合使用它或者直接订阅它。最可能的是，返回这个 <code>Mono</code> 类型的 <code>result</code>。因为这里只是个测试，所以使用了 block，等待处理结束，直接返回值的聚合列表。</li>
<li>对结果进行断言判断。</li>
</ol>
<p>使用回调和 <code>Future</code> 对象的问题是类似的，反应式编程以 <code>发布者（Publisher）- 订阅者（Subscriber）</code> 解决了这些问题。 </p>
<h4>2.3 从命令式到反应式编程</h4>
<p>反应式编程库，比如 Reactor，目标是解决 JVM 上“经典”异步处理方式的弊端，同时也专注于提供以下几个方面的特性：</p>
<ul>
<li><strong>可组合性</strong> 和 <strong>代码可读性</strong></li>
<li>将数据视作一个<strong>流</strong>，并提供丰富的<strong>算子</strong>来操作流</li>
<li>在<strong>订阅（subscriber）</strong>之前不会实际做任何事情</li>
<li><strong>反压</strong> 或者说 消费者通知生产者流速过高的能力</li>
<li>与并发无关（concurrency-agnostic）的<strong>高阶（high level）</strong>抽象，<strong>适用性强（high value）</strong>（译注：并发无关是指这种抽象对于并发非并发的场景都适用）</li>
</ul>
<h3>3. Reactor 核心特性</h3>
<p>Reactor 项目的主要成果是 <code>reactor-core</code> - 一个遵循<a href="https://www.reactive-streams.org/">反应式流</a>规范并支持 Java 8 的反应式编程库。</p>
<p>Reactor 引入 2 个可组合的反应式类型（实现了 <code>Publisher</code> 接口并且提供丰富的算子）： <code>Flux</code> 和 <code>Mono</code>。一个 <code>Flux</code> 对象代表包含 0 到 N 个元素的反应式序列，<code>Mono</code> 对象代表单值或空（0或1个元素）的结果。</p>
<h4>3.1 Flux - 0-N 个值的异步序列</h4>
<p><img alt="" src="media/15617160831865.jpg"></p>
<h4>3.2 Mono - 包含 0 或 1 个值的异步结果</h4>
<p><img alt="" src="media/15617161823523.jpg"></p>
<h4>3.3 创建一个 Flux 或 Mono 并进行订阅的一些简单方法</h4>
<p><code>Flux</code> 和 <code>Mono</code> 的类中包含大量的工厂方法，上手使用 Reactor 最简单的方式是从中选择一个用起来。</p>
<p>例如，创建一个 <code>String</code> 序列，可以逐个列举出这些字符串，或者将这些字符串放到一个集合中，然后基于这个集合创建一个 Flux，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Flux&lt;<span style="border: 1px solid #FF0000"></span>String&gt; seq1 = Flux.just(<span style="color: #a31515">&quot;foo&quot;</span>, <span style="color: #a31515">&quot;bar&quot;</span>, <span style="color: #a31515">&quot;foobar&quot;</span>);

List&lt;String&gt; iterable = Arrays.asList(<span style="color: #a31515">&quot;foo&quot;</span>, <span style="color: #a31515">&quot;bar&quot;</span>, <span style="color: #a31515">&quot;foobar&quot;</span>);
Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);
</pre></div>


<p>其它一些工厂方法的使用示例如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Mono&lt;String&gt; noData = Mono.empty();
Mono&lt;String&gt; data = Mono.just(<span style="color: #a31515">&quot;foo&quot;</span>);
Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(5, 3);
</pre></div>


<p>对于订阅操作，<code>Flux</code> 和 <code>Mono</code> 借助了 Java 8 的 lambda 表达式。有大量 <code>.subscribe()</code> 的重载方法/变种方法（variants）可选选择使用，使用 lambda 表达式来实现回调的不同组合，如下所示是这些方法的签名：</p>
<p><em>Flux 中基于 lambda 表达式的订阅方法变种</em></p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>subscribe();

subscribe(Consumer&lt;? <span style="color: #0000ff">super</span> T&gt; consumer);

subscribe(Consumer&lt;? <span style="color: #0000ff">super</span> T&gt; consumer,
          Consumer&lt;? <span style="color: #0000ff">super</span> Throwable&gt; errorConsumer);

subscribe(Consumer&lt;? <span style="color: #0000ff">super</span> T&gt; consumer,
          Consumer&lt;? <span style="color: #0000ff">super</span> Throwable&gt; errorConsumer,
          Runnable completeConsumer);

subscribe(Consumer&lt;? <span style="color: #0000ff">super</span> T&gt; consumer,
          Consumer&lt;? <span style="color: #0000ff">super</span> Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? <span style="color: #0000ff">super</span> Subscription&gt; subscriptionConsumer);
</pre></div>


<blockquote>
<p>这些订阅方法都会返回一个订阅操作的引用，当不再需要更多的数据时，可以使用这个引用来取消订阅。一旦取消，数据源就应该停止产出数据，并清理使用的所有资源。这一 “取消并清理” 行为在 Reactor 中以通用的 <code>Disposable</code> 接口来表现。</p>
</blockquote>
<h5>3.3.1 lambda 表达式的替代方案：BaseSubscriber</h5>
<p><code>Flux</code> 和 <code>Mono</code> 提供了一个相比上面那么订阅方法更通用的 <code>subscribe</code> 方法，其参数是一个完整的 <code>Subscriber</code> 实例，而不是根据几个 lambda 表达式组合出一个 <code>Subscriber</code> 实例。为了方便实现这样的一个 <code>Subscriber</code>，Reactor 提供了一个名为 <code>BaseSubscriber</code> 的可扩展的抽象类。</p>
<p>下面来实现一个，我们将其命名为 <code>SampleSubscriber</code>。如下示例演示了如何将其应用到一个 <code>Flux</code> 序列上：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>SampleSubscriber&lt;Integer&gt; ss = <span style="color: #0000ff">new</span> SampleSubscriber&lt;Integer&gt;();
Flux&lt;Integer&gt; ints = Flux.range(1, 4);
<span style="color: #008000">//</span>
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println(<span style="color: #a31515">&quot;Error &quot;</span> + error),
    () -&gt; {System.out.println(<span style="color: #a31515">&quot;Done&quot;</span>);},
    s -&gt; s.request(10));
<span style="color: #008000">//</span>
ints.subscribe(ss);
</pre></div>


<p>如下示例演示了 <code>SampleSubscriber</code> 继承自 <code>BaseSubscriber</code> 的一个最简化实现：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">package</span> io.projectreactor.samples;

<span style="color: #0000ff">import</span> org.reactivestreams.Subscription;
<span style="color: #0000ff">import</span> reactor.core.publisher.BaseSubscriber;

<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> <span style="color: #2b91af">SampleSubscriber</span>&lt;T&gt; <span style="color: #0000ff">extends</span> BaseSubscriber&lt;T&gt; {

    <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> hookOnSubscribe(Subscription subscription) {
        System.out.println(<span style="color: #a31515">&quot;Subscribed&quot;</span>);
        request(1);
    }

    <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> hookOnNext(T value) {
        System.out.println(value);
        request(1);
    }
}
</pre></div>


<p><code>BaseSubscriber</code> 还提供了一个 <code>requestUnbounded()</code> 方法来切换到无限消费模式（相当于 <code>request(Long.MAX_VALUES)</code>），另外也提供了一个 <code>cancel()</code> 方法。</p>
<p>除了 <code>hookOnSubscribe</code> 和 <code>hookOnNext</code>，<code>BaseSubscriber</code> 还提供了其他钩子方法（方法体为空，提供继承重写）：<code>hookOnComplete</code>、<code>hookOnError</code>、<code>hookOnCancel</code> 以及 <code>hookFinally</code>（当事件/消息序列（流）终止时，一定会调用该方法，调用时会传入一个 <code>SignalType</code> 类型参数表示终止的类型）。</p>
<h5>3.3.2 关于反压和调整请求量的方式</h5>
<p>在 Reactor 中实现反压，是通过向上游算子发送一个 <code>请求（request）</code>来逐级传播消费者的压力，直到数据源。当前请求的总量有时又称为当前的“需求量” 或者 “待满足（pending）的请求量”。需求量的上限是 <code>Long.MAX_VALUE</code>，表示一个无限量的请求（意思是“尽快产出数据“ - 反压也就失效了）。</p>
<p>最终的订阅者在订阅之前会发出首个请求，订阅所有消息/数据最直接的方式是即刻触发一个无限量（Long.MAX_VALUE）的请求：</p>
<ul>
<li><code>subscribe()</code> 以及大部分基于 lambda 表达式的变种方法（除了那个接受 <code>Consumer&lt;Subscription&gt;</code> 类型参数的方法）</li>
<li><code>block()</code>、<code>blockFirst()</code> 和 <code>blockLast()</code></li>
<li>调用 <code>toIterable()</code> 或 <code>toStream()</code> 进行遍历</li>
</ul>
<p>对首个请求进行定制的最简单方式是以一个 <code>BaseSubscriber</code> 派生类实例来 <code>subscribe</code>，派生类重写 <code>BaseSubscriber</code> 的 <code>hookOnSubscribe</code> 方法，如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Flux.range(1, 10)
    .doOnRequest(r -&gt; System.out.println(<span style="color: #a31515">&quot;request of &quot;</span> + r))
    .subscribe(<span style="color: #0000ff">new</span> BaseSubscriber&lt;Integer&gt;() {

      @Override
      <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> hookOnNext(Integer integer) {
        System.out.println(<span style="color: #a31515">&quot;Cancelling after having received &quot;</span> + integer);
        cancel();
      }
    });
</pre></div>


<p>上面这个代码片段输出如下内容：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>request <span style="color: #0000ff">of</span> 1
Cancelling <span style="color: #0000ff">after</span> <span style="color: #0000ff">having</span> received 1
</pre></div>


<p><strong>改变下游需求量的算子</strong></p>
<p>谨记：订阅时指定的需求量，上游操作链中的每个算子都可以对其作出调整。一个典型案例是 <code>buffer(N)</code> 算子：如果它收到一个 <code>request(2)</code> 请求，它会理解为2个缓冲区的请求量。因为缓冲区需要 N 个元素才认为是满的，所以 <code>buffer</code> 算子将请求量调整成了 <code>2 x N</code>。</p>
<p>你也许也注意到某些算子存在这样的变种 - 接受一个名为 <code>prefetch</code> 的 <code>int</code> 类型参数。这是另外一类修改下游请求量的算子。这类算子（比如 <code>flatMap</code>）通常是处理内部序列（inner sequences），从每个进入的元素派生出一个 <code>Publisher</code>。</p>
<p><code>预取（prefetch）</code>是调整内部序列请求量的一个方式。如果未指定，多数这类算子会以 32 为初始需求量。</p>
<p>这类算子通常也会实现一个<strong>填补优化方案</strong>：算子一旦看到 25% 的预取请求量已完成，就会向上游再发起 25% 的请求量。这是一个启发式优化，如此这类算子就可以主动地为即将到来的请求量做好准备。</p>
<p>最后，再介绍一对直接用于调整请求量的算子：<code>limitRate</code> 和 <code>limitRequest</code>。</p>
<p><code>limitRate(N)</code> 把下游的请求量拆分成多个更小量的请求向上游传播。例如，一个 <code>100</code> 的请求传到算子 <code>limitRate(10)</code>，则会变成 10 次请求，一次请求 10，传播到上游。注意：<code>limitRate</code> 实际上以这种形式实现了前面提到的填补优化方案。</p>
<p>这个算子有一个变种，允许开发者调整预取填补量（即算子变种的 <code>lowTide</code> 参数）：<code>limitRate(highTide, lowTide)</code>。<code>lowTide</code> 参数设定为 <code>0</code> 时，会导致严格限制一次请求 <code>highTide</code> 个，而不是经填补策略进一步调整过的一次请求量。</p>
<p>此外，<code>limitRequest(N)</code> 则是限制了下游最大的需求总量。它会累加请求量直到 <code>N</code>。如果一次请求没有让需求总量超过 <code>N</code>，则这次请求会完整地传播到上游（译注：意思是如果一次请求让需求总量超过了 <code>N</code>，这次请求的请求量会被裁剪）。如果数据源发出的数据总量达到了限制的总量，<code>limitRequest</code> 则认为这个序列可以结束了，向下游发送一个 <code>onComplete</code> 信号，并取消数据源。</p>
<h4>3.4 动态地（programmatically）创建一个序列</h4>
<h5>3.4.1 同步的 <code>generate</code></h5>
<p>动态创建一个 <code>Flux</code> 最简单的方式是借助 <code>generate</code> 方法，该方法接受一个生成器函数。</p>
<p>这一方式可以实现<strong>同步的</strong>且<strong>一个接一个</strong>地下发数据，这意味着接收方（sink）是一个 <code>SynchronousSink</code>，其 <code>next()</code> 方法在一次回调方法调用中最多只能调用一次。可以在其后再调用 <code>error(Throwable)</code> 或 <code>complete()</code>，视你的需求而定。</p>
<p><code>generate</code> 方法变种的这个应该是最有用的：允许保持一个状态，在调用接收方的 <code>next</code> 方法时可以基于这个状态来决定下发什么数据。那么这个生成器函数就成了一个 <code>BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;</code> 实例，其中 <code>&lt;S&gt;</code> 即是状态对象的类型。对于初始状态，可以提供一个 <code>Supplier&lt;S&gt;</code> 来获取，这样生成器函数每轮调用都会返回一个新的状态。</p>
<p>例如，可以使用一个 <code>int</code> 实例作为状态：</p>
<p><em>基于状态的 <code>generate</code> 方法使用示例</em></p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Flux&lt;String&gt; flux = Flux.generate(
    () -&gt; 0, <span style="color: #008000">// 1</span>
    (state, sink) -&gt; {
        sink.next(<span style="color: #a31515">&quot;3 x &quot;</span> + state + <span style="color: #a31515">&quot; = &quot;</span> + 3*state); <span style="color: #008000">// 2</span>
        <span style="color: #0000ff">if</span> (state == 10) sink.complete(); <span style="color: #008000">// 3</span>
        <span style="color: #0000ff">return</span> state + 1; <span style="color: #008000">// 4</span>
    });
</pre></div>


<ol>
<li>以 0 作为初始状态。</li>
<li>基于状态（state）决定下发什么消息/数据。</li>
<li>基于状态决定何时可以停止流/序列。</li>
<li>返回一个新状态，下次调用时可以使用（除非在这次调用时已经终止序列）。</li>
</ol>
<p>也可以使用一个 <code>&lt;S&gt;</code> 类型的可变对象。比如，上面的示例可以使用一个 <code>AtomicLong</code> 实例作为状态来重写，每轮调用都会改变它的值：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::<span style="color: #0000ff">new</span>,
    (state, sink) -&gt; {
        <span style="color: #2b91af">long</span> i = state.getAndIncrement();
        sink.next(<span style="color: #a31515">&quot;3 x &quot;</span> + i + <span style="color: #a31515">&quot; = &quot;</span> + 3*i);
        <span style="color: #0000ff">if</span> (i == 10) sink.complete();
        <span style="color: #0000ff">return</span> state;
    });
</pre></div>


<blockquote>
<p>如果状态对象在序列终止时需要清理一些资源，则应该使用 <code>generate(Supplier&lt;S&gt;, BiFunction, Consumer&lt;S&gt;)</code> 变种方法来清理最后的状态实例。</p>
</blockquote>
<p>如下示例使用的 <code>generate</code> 方法接受一个 <code>Consumer</code> 类型参数：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::<span style="color: #0000ff">new</span>,
    (state, sink) -&gt; {
        <span style="color: #2b91af">long</span> i = state.getAndIncrement();
        sink.next(<span style="color: #a31515">&quot;3 x &quot;</span> + i + <span style="color: #a31515">&quot; = &quot;</span> + 3*i);
        <span style="color: #0000ff">if</span> (i == 10) sink.complete();
        <span style="color: #0000ff">return</span> state;
    }, (state) -&gt; System.out.println(<span style="color: #a31515">&quot;state: &quot;</span> + state));
</pre></div>


<h5>3.4.2 异步多线程的 <code>create</code></h5>
<p><code>create</code> 是动态创建一个 <code>Flux</code> 的更高级的方式，适用于每轮下发多个数据，甚至是从多个线程中下发数据。</p>
<p>这个方法会向回调方法传入一个 <code>FluxSink</code> 实例参数，在回调方法体中可以调用这个参数的 <code>next</code>、<code>error</code> 和 <code>complete</code> 方法。与 <code>generate</code> 不同，它没有基于状态的变种方法。另外，回调方法中，可以多线程地触发事件（trigger multi-threaded events）。</p>
<blockquote>
<p><code>create</code> 非常适用于将一个已有的 API （比如：一个基于监听器的异步 API）桥接到反应式上下文中。</p>
<p><code>create</code> 并不会自动并行化执行你的代码，也不会让处理过程自动变成异步的，即使它可以配合异步 API 使用。如果在 <code>create</code> 的 lambda 表达式中发生阻塞，就会存在死锁或者其它副作用的风险。即使借助 <code>subscribeOn</code>，也要当心 <code>create</code> lambda 表达式中长时间的阻塞（比如无限循环调用 <code>sink.next(t)</code>）锁住流水线处理： （译注：异步的）数据请求可能根本得不到执行，因为（译注：线程池只有一个线程）同一个线程一直被无限循环占用着。使用 <code>subscribeOn(Scheduler, false)</code> 变种方法：<code>requestOnSeparateThread = false</code> 将使用 <code>Scheduler</code> 的线程来执行 <code>create</code> 方法的回调，在原始的线程中执行 <code>request</code>，从而让数据仍然可以流动起来。（译注：此处逻辑有点绕，也可能是因为 subscribeOn 方法本身语义就不太直观）。</p>
</blockquote>
<p>假设我们要使用一个基于监听器的 API，它按块处理数据，提供两类事件：（1）来了一块数据，（2）处理可以结束了（终止事件），如下 <code>MyEventListener</code> 接口定义所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #0000ff">interface</span> <span style="color: #2b91af">MyEventListener</span>&lt;T&gt; {
    <span style="color: #2b91af">void</span> onDataChunk(List&lt;T&gt; chunk);
    <span style="color: #2b91af">void</span> processComplete();
}
</pre></div>


<p>我们使用 <code>create</code> 将这个 API 桥接到一个 <code>Flux&lt;T&gt;</code> 实例上：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span>Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myEventProcessor.register(  <span style="color: #008000">// 4</span>
        <span style="color: #0000ff">new</span> MyEventListener&lt;String&gt;() { <span style="color: #008000">// 1</span>
            <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> onDataChunk(List&lt;String&gt; chunk) {
                <span style="color: #0000ff">for</span>(String s : chunk) {
                    sink.next(s); <span style="color: #008000">// 2</span>
                }
            }

            <span style="color: #0000ff">public</span> <span style="color: #2b91af">void</span> processComplete() {
                sink.complete(); <span style="color: #008000">// 3</span>
            }
        }
    );
});
</pre></div>


<ol>
<li>桥接到 <code>MyEventListener</code> API</li>
<li>数据块中每个元素都成了 <code>Flux</code> 中的元素。</li>
<li><code>processComplete</code> 事件转换成了 <code>onComplete</code> 事件。</li>
<li>所有这些逻辑都是在 <code>myEventProcessor</code> 执行时异步完成的。</li>
</ol>
<p>此外，因为 <code>create</code> 可以桥接异步 API，并管理反压，通过指定一个 <code>OverflowStrategy</code> 策略，可以调整如何智能地处理反压：</p>
<ul>
<li><code>IGNORE</code> 完全忽略下游的反压请求。这一策略在下游的队列满时（when queues get full downstream）会导致 <code>IllegalStateException</code> 异常抛出。</li>
<li><code>ERROR</code> 在下游处理不过来时会下发（onError）一个 <code>IllegalStateException</code> 异常消息。</li>
<li><code>DROP</code> 如果下游还没准备好接收当前事件，则直接丢弃。</li>
<li><code>BUFFER</code> （默认策略）如果下游处理不过来，则将所有事件放入缓冲区。（缓冲区大小无限制，所以可能会导致内存溢出<code>OutOfMemoryError</code>）</li>
</ul>
<blockquote>
<p><code>Mono</code> 也有一个 <code>create</code> 生成器方法。Mono 的 create 方法传入回调的 <code>MonoSink</code> 参数不允许下发多个消息，在第一个消息之后它会丢弃所有的消息。</p>
</blockquote>
<h5>3.4.3 异步单线程的 <code>push</code></h5>
<h4>3.5 多线程 和 调度器 （Threading and Schedulers）</h4>
<h5>3.5.1 <code>publishOn</code> 方法</h5>
<h5>3.5.2 <code>subscribeOn</code> 方法</h5>
<h3>4. 测试</h3>
<h3>5. 调试 Reactor</h3>
<h3>6. 高级特性和概念</h3>
            </div><!-- /.entry-content -->
            <div class="comments">
              <h3>欢迎评论</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "2019/06/26/simplified-reactor-doc-zh/";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://xiayfblackwhite.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>
        </div><!-- /.twelve.columns -->
 </div><!-- /.row -->
</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">


        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="http://github.com/youngsterxyf" target="_blank">Github</a></div></li>

                <li><div class="btn twitter"><a href="https://twitter.com/youngsterxyf" target="_blank">Twitter</a></div></li>

                <li><div class="btn warning"><a href="http://weibo.com/u/1855563263" target="_blank">Weibo</a></div></li>

                <li><div class="btn douban"><a href="http://www.douban.com/people/youngster21/" target="_blank">Douban</a></div></li>



              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'xiayfblackwhite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../../../../theme/js/libs/gumby.min.js"></script>
  <script src="../../../../theme/js/plugins.js"></script>
  <script src="../../../../theme/js/main.js"></script>
  <link rel="stylesheet" type="text/css" href="../../../../theme/emoji/css/basic/emojify.min.css" />
  <script src="../../../../theme/emoji/js/emojify.min.js"></script>
  <script>
    emojify.setConfig({
        img_dir : '../../../../theme/emoji/images/basic'
    });
    emojify.run();
</script>
</body>
</html>