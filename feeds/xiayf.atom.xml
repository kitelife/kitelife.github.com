<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>有趣的技术 - xiayf</title><link href="http://youngsterxyf.github.io/" rel="alternate"></link><link href="http://youngsterxyf.github.io/feeds/xiayf.atom.xml" rel="self"></link><id>http://youngsterxyf.github.io/</id><updated>2020-07-14T00:00:00+08:00</updated><entry><title>Disruptor 等待策略引发的 CPU 负载异常问题</title><link href="http://youngsterxyf.github.io/2020/07/14/disruptor-waitstrategy-cpu-busy/" rel="alternate"></link><published>2020-07-14T00:00:00+08:00</published><updated>2020-07-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2020-07-14:/2020/07/14/disruptor-waitstrategy-cpu-busy/</id><summary type="html">&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;工作中，我负责的系统是一个数据流处理服务 - 以流水线（pipeline）的形式分多级异步处理：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/ONwUsrlhLmIq8BW.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其中的 队列 实际使用的是 &lt;a href="https://github.com/LMAX-Exchange/disruptor"&gt;Disruptor&lt;/a&gt;，多生产者单消费者模式：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ThreadFactory factory = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ThreadFactoryBuilder().setNameFormat(name).setDaemon(&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;).build();
Disruptor&amp;lt;Event&amp;lt;T&amp;gt;&amp;gt;  disruptor = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Disruptor&amp;lt;&amp;gt;(Event&amp;lt;T&amp;gt;::&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;, bufferSize, factory, ProducerType.MULTI, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SleepingWaitStrategy());
disruptor.handleEventsWith((Event&amp;lt;T&amp;gt; event, &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; sequence, &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; endOfBatch) -&amp;gt; {
    consumer.accept(event.value, endOfBatch);
    event …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;工作中，我负责的系统是一个数据流处理服务 - 以流水线（pipeline）的形式分多级异步处理：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/ONwUsrlhLmIq8BW.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其中的 队列 实际使用的是 &lt;a href="https://github.com/LMAX-Exchange/disruptor"&gt;Disruptor&lt;/a&gt;，多生产者单消费者模式：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ThreadFactory factory = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ThreadFactoryBuilder().setNameFormat(name).setDaemon(&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;).build();
Disruptor&amp;lt;Event&amp;lt;T&amp;gt;&amp;gt;  disruptor = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Disruptor&amp;lt;&amp;gt;(Event&amp;lt;T&amp;gt;::&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;, bufferSize, factory, ProducerType.MULTI, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SleepingWaitStrategy());
disruptor.handleEventsWith((Event&amp;lt;T&amp;gt; event, &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; sequence, &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; endOfBatch) -&amp;gt; {
    consumer.accept(event.value, endOfBatch);
    event.value = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;服务运行在 k8s 集群上，每个容器节点上可能会运行多个 pipeline，也即意味着单个节点上会存在多个 disruptor 实例。&lt;/p&gt;
&lt;h2&gt;现象&lt;/h2&gt;
&lt;p&gt;近期突然收到测试环境很多节点（生产环境也有少量节点）的 CPU 使用率告警 - CPU 使用率持续 5 分钟以上超过 90%，如下其中一个任务节点的 CPU 使用率监控图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/XJVsiMI3b9m5dlB.jpg"&gt;
&lt;img alt="" src="https://i.loli.net/2020/07/14/2YwPQAqaICr879x.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpu.busy = cpu.system + cpu.user + 软/硬中断&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意其中 &lt;code&gt;cpu.system&lt;/code&gt; 比 &lt;code&gt;cpu.user&lt;/code&gt; 高不少，&lt;code&gt;cpu.busy&lt;/code&gt; 又比 &lt;code&gt;cpu.system&lt;/code&gt; 高不少。也即 CPU 时间片资源主要消耗在 内核态 和中断逻辑上（对于这些任务而言 &lt;code&gt;cpu.user&lt;/code&gt; 指标也是异常的）。&lt;/p&gt;
&lt;p&gt;这些节点运行的任务，几乎没有数据需要处理，也就是说几乎是空跑的。从线程数量监控以及 jstack 输出的堆栈跟踪信息，也未发现明显异常。&lt;/p&gt;
&lt;h2&gt;原因排查&lt;/h2&gt;
&lt;p&gt;将测试环境的任务在本地环境运行起来，并基于 &lt;a href="https://www.lightbend.com/blog/profiling-jvm-applications"&gt;How to profile JVM applications&lt;/a&gt; 一文中提到的火焰图工具，产出对应 JVM 应用的火焰图：
&lt;img alt="" src="https://i.loli.net/2020/07/14/zQMWsBeKbuZLamN.jpg"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以大致看出其中 &lt;code&gt;com/lmax/disruptor/SleepingWaitStrategy:::waitFor&lt;/code&gt; / &lt;code&gt;jdk/internal/misc/Unsafe:::park&lt;/code&gt; 比较可疑，在调用栈中耗时最长。&lt;/p&gt;
&lt;p&gt;从项目源码和 jstack 输出的堆栈跟踪信息可以看到，测试任务中大致涉及 18个 disruptor 实例，均使用 &lt;code&gt;SleepingWaitStrategy&lt;/code&gt; 等待策略，该策略的 &lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/SleepingWaitStrategy.java#L56"&gt;waitFor&lt;/a&gt; 方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; waitFor(&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; sequence, Sequence cursor, &lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Sequence dependentSequence, &lt;span style="color: #0000ff"&gt;final&lt;/span&gt; SequenceBarrier barrier) &lt;span style="color: #0000ff"&gt;throws&lt;/span&gt; AlertException {
    &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; availableSequence;
    &lt;span style="color: #008000"&gt;// 默认 200&lt;/span&gt;
    &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; counter = retries;

    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; ((availableSequence = dependentSequence.get()) &amp;lt; sequence) {
      counter = applyWaitMethod(barrier, counter);
    }

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; availableSequence;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;waitFor 方法中核心调用了 &lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/SleepingWaitStrategy.java#L76"&gt;applyWaitMethod&lt;/a&gt; ：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; applyWaitMethod(&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; SequenceBarrier barrier, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; counter) &lt;span style="color: #0000ff"&gt;throws&lt;/span&gt; AlertException {
    barrier.checkAlert();

    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (counter &amp;gt; 100)
    {
        --counter;
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (counter &amp;gt; 0)
    {
        --counter;
        Thread.yield();
    }
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
    {
        &lt;span style="color: #008000"&gt;// sleepTimeNs 默认 100&lt;/span&gt;
        &lt;span style="color: #008000"&gt;// 间接调用  jdk/internal/misc/Unsafe:::park 方法&lt;/span&gt;
        LockSupport.parkNanos(sleepTimeNs);
    }

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; counter;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html#parkNanos-long-"&gt;LockSupport.parkNanos&lt;/a&gt; 方法的作用简单而言即让当前线程睡眠 sleepTimeNs 纳秒。&lt;/p&gt;
&lt;p&gt;Disruptor 作为一个任务队列，自带一个线程池，线程池的线程工厂即构造方法传入的 factory，线程数量等于 &lt;a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/dsl/Disruptor.java#L165"&gt;disruptor.handleEventsWith&lt;/a&gt; 调用时传入的回调方法数量，handleEventsWith 的参数数量不定（&lt;code&gt;public final EventHandlerGroup&amp;lt;T&amp;gt; handleEventsWith(final EventHandler&amp;lt;? super T&amp;gt;... handlers)&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;18个 Disruptor 实例，每个实例有一个消费者线程，消费者线程不断检查队列中是否有新的 &lt;code&gt;Event&amp;lt;T&amp;gt;&lt;/code&gt; 任务需要处理，如果有，则调用 EventHandler 回调方法进行处理，否则睡眠 sleepTimeNs 纳秒。&lt;/p&gt;
&lt;p&gt;到此，结合监控指标，可以大致猜测：由于 sleepTimeNs 较小，导致多个线程的状态不断在 &lt;code&gt;运行&lt;/code&gt;、&lt;code&gt;睡眠&lt;/code&gt;、&lt;code&gt;等待调度&lt;/code&gt; 之间切换，线程上下文切换非常频繁。&lt;/p&gt;
&lt;p&gt;围绕 LockSupport.parkNanos 编写一个测试程序，来复现这个问题：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.Executors;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.concurrent.locks.LockSupport;

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Test&lt;/span&gt; {

  &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; main(String[] args) &lt;span style="color: #0000ff"&gt;throws&lt;/span&gt; InterruptedException {
    ExecutorService tp = Executors.newFixedThreadPool(18);
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; idx = 0; idx &amp;lt; 18; idx++) {
      tp.submit(() -&amp;gt; {
        &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;true&lt;/span&gt;) {
          LockSupport.parkNanos(100);
        }
      });
    }
    CountDownLatch wg = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CountDownLatch(1);
    wg.await();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 3.2 GHz 6-Core Intel Core i7 配置 macOS 系统中，这个测试程序可以稳定地将 CPU 使用率控制在 700%+，如下 &lt;code&gt;top -pid [测试程序的进程 id]&lt;/code&gt; 命令的输出：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/14/Z6jixvuWY1yTnL4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其中 CSW 为线程上下文切换的次数。&lt;/p&gt;
&lt;p&gt;既然问题原因在于多个线程频繁睡眠导致，那么解决方案也比较简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用更大的值来替换 sleepTimeNs 默认值：&lt;code&gt;new Disruptor&amp;lt;&amp;gt;(Event&amp;lt;T&amp;gt;::new, bufferSize, factory, ProducerType.MULTI, new SleepingWaitStrategy(200, 1000 * 1000 / 10)); // 0.1 ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用其他等待策略（WaitStrategy），比如：&lt;code&gt;com.lmax.disruptor.BlockingWaitStrategy&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过解决方案也有微小的负作用 - 部分新任务/&lt;code&gt;Event&amp;lt;T&amp;gt;&lt;/code&gt;实例的处理时延会增大，但在我们的数据流处理场景下，这点时延增大对业务完全没有影响。&lt;/p&gt;
&lt;p&gt;不过，这个问题应该是一直存在，为什么近期才收到告警，为什么以前从监控上未发现？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么近期才收到告警？因为这个监控告警是近期公司监控平台才统一配置的&lt;/li&gt;
&lt;li&gt;为什么以前从监控上未发现？因为公司切换了新的监控平台，老的监控平台没有 cpu.busy 这个指标，而这些没什么数据要处理的任务长时间不需要开发维护，也就未得到及时关注。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;扩展资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;上下文切换耗时多少？&lt;a href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html"&gt;How long does it take to make a context switch?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LockSupport.parkNanos(100)&lt;/code&gt; 真的就是睡眠 100 纳秒吗？&lt;a href="https://hazelcast.com/blog/locksupport-parknanos-under-the-hood-and-the-curious-case-of-parking/"&gt;LockSupport.parkNanos() Under the Hood and the Curious Case of Parking&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="其他"></category><category term="问题排查"></category><category term="Java"></category><category term="Disruptor"></category></entry><entry><title>如何剖析 JVM 应用（译）</title><link href="http://youngsterxyf.github.io/2020/07/13/how-to-profile-jvm-applications/" rel="alternate"></link><published>2020-07-13T00:00:00+08:00</published><updated>2020-07-13T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2020-07-13:/2020/07/13/how-to-profile-jvm-applications/</id><summary type="html">&lt;p&gt;原文链接：&lt;a href="https://www.lightbend.com/blog/profiling-jvm-applications"&gt;How to profile JVM applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hi 大家好。工具团队（tooling team）近期的一个关注点是改进 sbt 贡献流程（ improvement of the contribution process to sbt）。我们一直在思考的另一个事情是 sbt 的性能。为一举解决这两件事情，我调研了 Jason Zaugg、Johannes Rudolph 这些人如何剖析 JVM 应用，这篇文章即是调研结果。&lt;/p&gt;
&lt;p&gt;这里论述的技术应该可以应用于Java 和 Scala，也基本与你使用的工具无关。&lt;/p&gt;
&lt;h2&gt;火焰图（使用 async-profiler 生成）&lt;/h2&gt;
&lt;p&gt;剖析 JVM 应用的方式有多种，但新晋热门是Netflix 高级性能架构师（Senior Performance Architect …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文链接：&lt;a href="https://www.lightbend.com/blog/profiling-jvm-applications"&gt;How to profile JVM applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hi 大家好。工具团队（tooling team）近期的一个关注点是改进 sbt 贡献流程（ improvement of the contribution process to sbt）。我们一直在思考的另一个事情是 sbt 的性能。为一举解决这两件事情，我调研了 Jason Zaugg、Johannes Rudolph 这些人如何剖析 JVM 应用，这篇文章即是调研结果。&lt;/p&gt;
&lt;p&gt;这里论述的技术应该可以应用于Java 和 Scala，也基本与你使用的工具无关。&lt;/p&gt;
&lt;h2&gt;火焰图（使用 async-profiler 生成）&lt;/h2&gt;
&lt;p&gt;剖析 JVM 应用的方式有多种，但新晋热门是Netflix 高级性能架构师（Senior Performance Architect）Brendan Gregg 发明的&lt;strong&gt;火焰图&lt;/strong&gt;。开发者先收集堆栈踪迹抽样数据（stack trace samples），然后将其处理成一张交互式的 svg 图。若要快速了解火焰图，可阅读如下链接资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=ugRrFdda_JQ"&gt;Using FlameGraphs To Illuminate The JVM by Nitsan Wakart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=D53T1Ejig1Q"&gt;USENIX ATC ’17: Visualizing Performance with Flame Graphs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我推荐的第一个火焰图工具是  Andrei Pangin 发起的 async-profiler，在 macOS 和 Linux 操作系统环境下均可使用，上手使用也更简单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载安装器 &lt;a href="https://github.com/jvm-profiling-tools/async-profiler/releases/tag/v1.2"&gt;async-profiler 1.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;假设你的系统中存在一个命令查找路径 &lt;code&gt;$HOME/bin&lt;/code&gt;，在 &lt;code&gt;$HOME/bin&lt;/code&gt; 目录下创建符号链接指向 &lt;code&gt;build/&lt;/code&gt; 和 &lt;code&gt;profiler.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ln -s ~/App/async-profiler/profiler.sh $HOME/bin/profiler.sh
ln -s ~/App/async-profiler/build $HOME/bin/build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来，关闭所有 Java 应用，以及任何可能影响剖析过程的东西，比如 Slack，然后在终端程序（terminal）中运行你的应用。对于我而言，则是尝试剖析 &lt;code&gt;sbt&lt;/code&gt; 的初始化加载过程：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sbt exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在另一个终端中，运行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ jps
92746 sbt-launch.jar
92780 Jps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由此我们知道应用的进程 ID。对于我而言，目标进程 ID 是 &lt;code&gt;92746&lt;/code&gt;。在应用运行的同时，运行如下命令：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;$&lt;/span&gt; profiler.sh -d 60 &amp;lt;process id&amp;gt;
Started [cpu] profiling
&lt;span style="color: #008000"&gt;--- Execution profile ---&lt;/span&gt;
Total samples:         31602
Non-Java:              3239 (10.25%)
GC active:             46 (0.15%)
&lt;span style="color: #0000ff"&gt;Unknown&lt;/span&gt; (native)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;      14667 (46.41%)
&lt;span style="color: #0000ff"&gt;Not&lt;/span&gt; walkable (native)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt; 3 (0.01%)
&lt;span style="color: #0000ff"&gt;Unknown&lt;/span&gt; (Java)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;        433 (1.37%)
&lt;span style="color: #0000ff"&gt;Not&lt;/span&gt; walkable (Java)&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;   8 (0.03%)
Thread &lt;span style="color: #0000ff"&gt;exit&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;           1 (0.00%)
Deopt:                 9 (0.03%)

Frame buffer &lt;span style="color: #0000ff"&gt;usage&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;:&lt;/span&gt;    55.658%

Total: 1932000000 (6.11%)  samples: 1932
  [ 0] java.lang.ClassLoader&lt;span style="border: 1px solid #FF0000"&gt;$&lt;/span&gt;NativeLibrary.&lt;span style="color: #0000ff"&gt;load&lt;/span&gt;
  [ 1] java.lang.ClassLoader.loadLibrary0
  [ 2] java.lang.ClassLoader.loadLibrary
  [ 3] java.lang.Runtime.loadLibrary0
  [ 4] java.lang.&lt;span style="color: #0000ff"&gt;System&lt;/span&gt;.loadLibrary
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令会输出一大堆有用的堆栈跟踪信息（stacktraces），为将这些信息可视化为一张火焰图，运行如下命令：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;profiler.sh -d 60 -f /tmp/flamegraph.svg &amp;lt;process id&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令最后应该会产出文件 &lt;code&gt;/tmp/flamegraph.svg&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flamegraph" src="https://i.loli.net/2020/07/13/dZVkB9xq2Gy6NfA.png"&gt;&lt;/p&gt;
&lt;p&gt;你自己来体验一下 &lt;a href="https://downloads.lightbend.com/website/blog/2019/flamegraph.svg?_ga=2.187105832.1642569835.1594378538-197429397.1594378538"&gt;flamegraph.svg&lt;/a&gt; 输出的信息。&lt;/p&gt;
&lt;h2&gt;火焰图（使用 perf-map-agent 生成）&lt;/h2&gt;
&lt;p&gt;虽然 async-profiler 上手使用很简单，但火焰图真正有趣之处在于可以混合展现 JVM 堆栈追踪和原生代码（native code）堆栈跟踪信息，让开发者可以看到 CPU 实际消耗在程序的何处。Lightbend 公司的 Johannes Rudolph 为此写了一个工具 - &lt;a href="https://github.com/jvm-profiling-tools/perf-map-agent"&gt;perf-map-agent&lt;/a&gt;。该工具在 macOS 环境下会使用 &lt;code&gt;dtrace&lt;/code&gt;，在 Linux 环境下会使用 &lt;code&gt;perf&lt;/code&gt;。如果你想确认瓶颈是否出现在原生代码中，这个工具会特别有用。&lt;/p&gt;
&lt;p&gt;我们先要编译 &lt;a href="https://github.com/jvm-profiling-tools/perf-map-agent"&gt;perf-map-agent&lt;/a&gt;。对于 macOS 环境，在运行 &lt;code&gt;cmake .&lt;/code&gt; 之前需要先设置 &lt;code&gt;JAVA_HOME&lt;/code&gt; 环境变量：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cd work
$ git clone https://github.com/brendangregg/FlameGraph.git

$ git clone https://github.com/jvm-profiling-tools/perf-map-agent.git
$ cd perf-map-agent
$ export JAVA_HOME=&lt;span style="color: #0000ff"&gt;$(&lt;/span&gt;/usr/libexec/java_home&lt;span style="color: #0000ff"&gt;)&lt;/span&gt;
$ cmake .
-- The C compiler identification is AppleClang 9.0.0.9000039
-- The CXX compiler identification is AppleClang 9.0.0.9000039
...
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在一个新的终端中，带 &lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt; 标记参数运行 sbt：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sbt -J-Dsbt.launcher.standby=20s -J-XX:+PreserveFramePointer exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在另一个终端中运行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ cd quicktest/
$ export JAVA_HOME=&lt;span style="color: #0000ff"&gt;$(&lt;/span&gt;/usr/libexec/java_home&lt;span style="color: #0000ff"&gt;)&lt;/span&gt;
$ export FLAMEGRAPH_DIR=$HOME/work/FlameGraph
$ jps
94592 Jps
94549 sbt-launch.jar
$ $HOME/work/perf-map-agent/bin/dtrace-java-flames 94549
dtrace: system integrity protection is on, some features will not be available

dtrace: description &lt;span style="color: #a31515"&gt;&amp;#39;profile-99 &amp;#39;&lt;/span&gt; matched 2 probes
Flame graph SVG written to DTRACE_FLAME_OUTPUT=&lt;span style="color: #a31515"&gt;&amp;#39;/Users/xxx/work/quicktest/flamegraph-94549.svg&amp;#39;&lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;理论上这样会产出更全面的火焰图，不过对于 &lt;code&gt;sbt exit&lt;/code&gt;，产出的火焰图看起来可能有点凌乱。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flamegraph-2" src="https://i.loli.net/2020/07/13/s9BbWAnluTPwE3J.png"&gt;&lt;/p&gt;
&lt;p&gt;如果 sbt 操作已经经过即时编译器优化（the operations are already JITed），或者操作比较特殊（the operation is more specific），那么火焰图的效果会更好。为了得到效果更好的火焰图，我们可以将相同的操作多重复几次：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sbt -J-Dsbt.launcher.standby=20s -J-XX:+PreserveFramePointer reload reload reload reload exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以产出程序的稳定态火焰图，逐步放大火焰图，就可以找到执行的热点路径。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flamegraph-3" src="https://i.loli.net/2020/07/13/93YyjxR5ATS1Dnq.png"&gt;&lt;/p&gt;
&lt;h2&gt;Flamescope&lt;/h2&gt;
&lt;p&gt;Netflix 公司近期发布了一个新的火焰图可视化工具 - &lt;a href="https://medium.com/netflix-techblog/netflix-flamescope-a57ca19d47bb"&gt;Flamescope&lt;/a&gt;，可以将火焰图过滤限制在一个特定的时间范围内。&lt;/p&gt;
&lt;p&gt;&lt;img alt="FlameScope" src="https://i.loli.net/2020/07/13/djm2hkvC98irQu7.png"&gt;&lt;/p&gt;
&lt;p&gt;Martin Spier 和 Brendan Gregg 为研究扰动以及其他时间相关的问题（perturbations and other time-based issues）而开发了这个工具。常规的火焰图是聚合了所有堆栈追踪抽样数据，如果系统中发生了一个短时小故障，就会被深埋于其他追踪信息中，这个工具就是为了解决这个问题。&lt;/p&gt;
&lt;h2&gt;JMH (sbt-jmh)&lt;/h2&gt;
&lt;p&gt;因为 JIT 存在预热等特点，增大了基准测试的困难。JMH 会将相同的测试运行多次，消除 JIT 预热等特点造成的影响，从而更准确地测量代码的性能。&lt;/p&gt;
&lt;p&gt;对于 sbt 用户而言，Lightbend 公司 Konrad Malawski 编写的 &lt;a href="https://github.com/ktoso/sbt-jmh"&gt;sbt-jmh&lt;/a&gt; 进一步简化了 JMH 测试。并且它也集成了 async-profiler。&lt;/p&gt;
&lt;h2&gt;VisualVM&lt;/h2&gt;
&lt;p&gt;我也想提一下传统的 JVM 剖析工具。因为 &lt;a href="https://visualvm.github.io/"&gt;VisualVM&lt;/a&gt; 开源了，所以就来说说它。&lt;/p&gt;
&lt;p&gt;1、先打开 VisualVM
2、在一个终端中启动 sbt
3、从 VisualVM 界面的 Local 应用目录下应该可以看到 &lt;code&gt;xsbt.boot.Boot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/13/EB7vsuo1HjaTtQw.jpg"&gt;&lt;/p&gt;
&lt;p&gt;4、打开它，选择 抽样功能（sampler） 或 剖析功能（profiler），在你想要开始的时间点点击 CPU 按钮&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/07/13/aoiIDfMKw9pjY4Z.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如果你对 &lt;a href="https://www.yourkit.com/"&gt;YourKit&lt;/a&gt; 比较熟悉，也可以使用它，用法比较相似。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;火焰图对堆栈跟踪抽样数据进行可视化，方便识别应用代码中的热点路径。也有助于确认代码变更是否实际影响了应用性能。&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Java"></category><category term="工具"></category><category term="问题排查"></category></entry><entry><title>博客构建环境准备</title><link href="http://youngsterxyf.github.io/2020/06/14/blog-build-env/" rel="alternate"></link><published>2020-06-14T00:00:00+08:00</published><updated>2020-06-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2020-06-14:/2020/06/14/blog-build-env/</id><summary type="html">&lt;p&gt;好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;1、Python 虚拟环境&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;virtualenv -p python3 ~/.py3
source ~/.py3/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2、安装 Python 依赖包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pip install pelican[Markdown]   &lt;span style="color: #008000"&gt;# 可能需要先安装 pip：easy_install pip&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、安装主题包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git clone https://github.com/youngsterxyf/my-pelican-themes.git ~/github/youngsterxyf/my-pelican-themes
pelican-themes -i ~/github/youngsterxyf/my-pelican-themes/my-gum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4、构建&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;另，更新艺术字体或字集：&lt;/p&gt;
&lt;p&gt;(1 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;1、Python 虚拟环境&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;virtualenv -p python3 ~/.py3
source ~/.py3/bin/activate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2、安装 Python 依赖包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pip install pelican[Markdown]   &lt;span style="color: #008000"&gt;# 可能需要先安装 pip：easy_install pip&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、安装主题包&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git clone https://github.com/youngsterxyf/my-pelican-themes.git ~/github/youngsterxyf/my-pelican-themes
pelican-themes -i ~/github/youngsterxyf/my-pelican-themes/my-gum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4、构建&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;另，更新艺术字体或字集：&lt;/p&gt;
&lt;p&gt;(1) 下载 fontmin-app：https://github.com/ecomfe/fontmin-app&lt;/p&gt;
&lt;p&gt;(2) 导入字体 SentyZHAO（汉仪新蒂赵孟頫体）：https://github.com/youngsterxyf/blog-content/blob/master/new-blog/SentyZHAO.ttf&lt;/p&gt;
&lt;p&gt;&lt;img alt="fontmin" src="https://i.loli.net/2020/06/14/Xn8b9kZDIfWoLmp.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另，华戈行书字体见：http://www.foundertype.com/index.php/FontInfo/index/id/5350&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(3) 生成字体样式，并拷贝更新到目标主题包目录中：https://github.com/youngsterxyf/my-pelican-themes/tree/master/my-gum/static&lt;/p&gt;
&lt;p&gt;(4) 更新主题包：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pelican-themes -r my-gum
pelican-themes -i ~/github/youngsterxyf/my-pelican-themes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(5) 重新构建生成博客&lt;/p&gt;</content><category term="其他"></category></entry><entry><title>读文笔记：Kafka 官方设计文档</title><link href="http://youngsterxyf.github.io/2019/10/13/reading-kafka-design/" rel="alternate"></link><published>2019-10-13T00:00:00+08:00</published><updated>2019-10-13T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-10-13:/2019/10/13/reading-kafka-design/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://kafka.apache.org/documentation/#design"&gt;http://kafka.apache.org/documentation/#design&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;数据持久化&lt;/h2&gt;
&lt;h4&gt;不用惧怕文件系统&lt;/h4&gt;
&lt;p&gt;磁盘的读写速度，取决于如何读写。对于线性读写方式，操作系统做了充分的优化：提前读 - 预取若干数据块，滞后写 - 将小的逻辑写操作合并成一个大的物理写操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://queue.acm.org/detail.cfm?id=1563874"&gt;研究&lt;/a&gt;表明：&lt;a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg"&gt;顺序读写磁盘（sequential disk access）的速度有些时候比随机访问内存还要快&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现代操作系统激进地尽可能将空闲内存用作磁盘缓存。所有磁盘读写都经过操作系统提供的统一缓存。这个特性没法轻易关闭，除非直接 I/O （direct I/O），因此，如果程序在用户进程中进行数据缓存，缓存的数据通常也是和操作系统页缓存重复的，缓存两遍，没啥意义，也浪费内存。&lt;/p&gt;
&lt;p&gt;而且，Kafka 是构建在 JVM 之上的，了解 Java 内存使用方式的人应该都知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象的内存开销非常高，通常是实际数据大小的2倍（甚至更多 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://kafka.apache.org/documentation/#design"&gt;http://kafka.apache.org/documentation/#design&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;数据持久化&lt;/h2&gt;
&lt;h4&gt;不用惧怕文件系统&lt;/h4&gt;
&lt;p&gt;磁盘的读写速度，取决于如何读写。对于线性读写方式，操作系统做了充分的优化：提前读 - 预取若干数据块，滞后写 - 将小的逻辑写操作合并成一个大的物理写操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://queue.acm.org/detail.cfm?id=1563874"&gt;研究&lt;/a&gt;表明：&lt;a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg"&gt;顺序读写磁盘（sequential disk access）的速度有些时候比随机访问内存还要快&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现代操作系统激进地尽可能将空闲内存用作磁盘缓存。所有磁盘读写都经过操作系统提供的统一缓存。这个特性没法轻易关闭，除非直接 I/O （direct I/O），因此，如果程序在用户进程中进行数据缓存，缓存的数据通常也是和操作系统页缓存重复的，缓存两遍，没啥意义，也浪费内存。&lt;/p&gt;
&lt;p&gt;而且，Kafka 是构建在 JVM 之上的，了解 Java 内存使用方式的人应该都知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象的内存开销非常高，通常是实际数据大小的2倍（甚至更多）&lt;/li&gt;
&lt;li&gt;随着堆上数据量增大，Java 的 GC 表现也会更糟糕&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，使用文件系统并依赖于操作系统内存页缓存，优于在程序中维护一块内存缓存或其它结构。至少操作系统内存页缓存的可用内存翻倍了。另外，如果使用紧凑的字节结构来缓存数据，相比使用对象，可用内存可能还会翻倍。在 32GB 内存的机器上这么搞，缓存可用到 20-30GB，还不会对 GC 造成了什么坏影响。并且，即使服务重启，这块缓存空间也是热的（除非机器重启），用户进程内的内存缓存在服务重启后得重建（10GB的数据缓存可能需要10分钟左右）。&lt;/p&gt;
&lt;p&gt;这样也可以简化代码逻辑，因为缓存和文件系统之间的一致性由操作系统来保证了。&lt;/p&gt;
&lt;p&gt;这样一分析，设计就简单了：我们反其道而行之，所有数据都直接写到文件系统上持久化日志文件中，不需要在程序中使用内存缓存，也不必确保将数据刷到磁盘。这实际意味着数据转移到了内核的内存页缓存。&lt;/p&gt;
&lt;h4&gt;常量时间就能搞定&lt;/h4&gt;
&lt;p&gt;B 树的 O(log N) 时间复杂度，对于磁盘操作来说，并不能等同于常量时间复杂度。&lt;/p&gt;
&lt;p&gt;Kafka 采用日志文件方式，确保读写操作的时间复杂度是 O(1)。&lt;/p&gt;
&lt;p&gt;Kafka 不会在消息一被消费就立即删除，而是保留一段时间，这样对于消费者来说也更灵活一些。&lt;/p&gt;
&lt;h2&gt;效率&lt;/h2&gt;
&lt;p&gt;对于 Kafka 这类系统而言，即使像前述那样消除了糟糕的磁盘访问模式，也会遇到两个导致数据效率低的问题：&lt;strong&gt;过多的小 I/O 操作&lt;/strong&gt;，以及&lt;strong&gt;过多的字节拷贝&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;小 I/O 问题在客户端与服务端之间，以及服务端内部的数据持久化操作中都会发生。对此，Kafka 协议建立在 “消息集” （即一批消息）的抽象之上，这样网络请求读写的是一批一批的消息，减少了网络往返的时间开销（注：消息处理的实时性会相对差一点）。服务端也是一次将一批消息写到日志文件中，消费者也按序一次获取一批消息。这一简单的优化可以将吞吐能力提升几个数量级。&lt;/p&gt;
&lt;p&gt;对于过多的字节拷贝问题，在消息量大的时候，影响比较明显。Kafka 采用了一种标准化的二进制消息格式，producer、broker、consumer 都使用这种格式，这样数据块在传输期间不需要变动。&lt;/p&gt;
&lt;p&gt;broker 维护的消息日志只是一个目录下的一堆文件，文件内容是按序写入的消息集，消息集的数据格式同于 producer、consumer 使用的。共用一种数据格式方便了一个重要的操作优化：持久化日志块的网络传输。对于从内存页缓存（pagecache）到网络套接字（socket）的数据传输操作，现代 UNIX 操作系统提供了一种高度优化的代码执行路径。Linux 中使用 &lt;a href="http://man7.org/linux/man-pages/man2/sendfile.2.html"&gt;sendfile 系统调用&lt;/a&gt; 可以利用这个优化。&lt;/p&gt;
&lt;p&gt;要理解 sendfile 的收益，需要先理解从文件到套接字传输数据的常规代码执行路径：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作系统从磁盘将数据读到内核空间的内存页缓存（pagecache）&lt;/li&gt;
&lt;li&gt;应用程序从内核空间减数据读到用户空间缓冲区&lt;/li&gt;
&lt;li&gt;应用程序将数据从用户空间缓冲区读到内核空间的套接字缓冲区&lt;/li&gt;
&lt;li&gt;操作系统将数据从套接字缓冲区读到 NIC 缓冲区，网卡从 NIC 缓冲区读取数据通过网络发出去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一代码执行路径，涉及 4 次数据拷贝和 2 次系统调用，很显然是低效的。使用 sendfile，可以避免内核空间和用户空间之间一些不必要的数据拷贝，操作系统可以直接将数据从内存页缓存发送到网络。&lt;/p&gt;
&lt;p&gt;进一步了解 sendfile 以及 Java 平台如何支持零拷贝，可以阅读&lt;a href="https://developer.ibm.com/articles/j-zerocopy/"&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;生产者（The Producer）&lt;/h2&gt;
&lt;h4&gt;负载均衡&lt;/h4&gt;
&lt;p&gt;消息应该发到哪个分区（partition）由客户端根据哈希算法（或者随机）决定，并且消息是直接由 producer 发到目标分区的 leader broker，没有任何中间路由层。&lt;/p&gt;
&lt;p&gt;所有 Kafka 节点都可以响应元数据请求 - 告知客户端（producer 或 consumer）哪些服务节点还存活以及某个 topic 的各个分区 leader 分别是哪个节点（疑惑：如果某个分区 leader 节点挂掉之后，客户端如何获知？何时可以获知？）&lt;/p&gt;
&lt;h2&gt;消息交付语义&lt;/h2&gt;
&lt;p&gt;producer 和 consumer 之间的消息交付语义，分 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最多消费一次 - 消息可能会丢失，但不会被重复消费&lt;/li&gt;
&lt;li&gt;最少消费一次 - 消息不会丢，但可能被重复消费&lt;/li&gt;
&lt;li&gt;仅消费一次 - 每个消息都会被消费且仅消费一次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个问题可以分成两个阶段的问题：&lt;strong&gt;producer 向 broker 发布一个消息时的持久性保证&lt;/strong&gt; 以及 &lt;strong&gt;consumer 消费一个消息时的语义保证&lt;/strong&gt; （the durability guarantees for publishing a message and the guarantees when consuming a message）。&lt;/p&gt;
&lt;p&gt;producer 向 Kafka 集群发消息时，会提供一个请求参数 &lt;code&gt;acks&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;acks=0：表示 producer 不需要等分区 leader broker 返回任何响应，将消息存入套接字缓冲区（socket buffer）就当做消息已经发送成功。所以可靠性是没有保证的。&lt;/li&gt;
&lt;li&gt;acks=1：表示 分区 leader broker 将消息写入自己的本地日志文件，就向 producer 响应成功，不必等待分区副本 broker 同步好消息。&lt;/li&gt;
&lt;li&gt;acks=-1 或 acks=all：表示 分区 leader broker 需要等待所有同步副本 broker 同步好消息并响应成功，才向 producer 响应成功&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第 2 种情况，如果分区 leader broker 挂掉/不存活，则副本未来得及同步的消息会丢失。&lt;/p&gt;
&lt;p&gt;第 3 种情况，只要有同步副本正常同步消息，那么即使 leader 挂了也不会丢数据。&lt;/p&gt;
&lt;p&gt;如果 leader 被系统判定为不存活，则会从（同步）副本中选举一个新的 leader，那么 Kafka 如何判定一个节点是否存活？存活判定依赖 2 个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点必须维持与 Zookeeper 的 session 连接（通过 Zookeeper 的心跳机制）&lt;/li&gt;
&lt;li&gt;如果是一个从节点（follower），则必须不断从 leader 节点同步消息数据，且同步进度没有落后太多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 producer 在发送消息的过程中发生网络问题，它没法判定分区 leader 是否收到消息。0.11.0.0 版本之前，producer 只能重发消息，别无他法，因此只能提供“最少消费一次的”交付语义。0.11.0.0 版本之后，Kafka producer 支持一个幂等交付功能选项，可以确保消息重发不会导致 Kafka 的消息日志中出现重复的条目：broker 为每个 producer 分配一个 ID，然后基于消息序号来去重。&lt;/p&gt;
&lt;p&gt;也是从 0.11.0.0 版本开始，Producer 支持以类事务的语义向多个 topic 分区发送消息：要么所有消息都发送成功，要么都不成功。这个能力主要用于实现 Kafka topic 之间的仅处理一次语义。&lt;/p&gt;
&lt;p&gt;从 consumer 角度来看，同一个分区的所有副本，日志数据相同，消费进度也一样。consumer 可以控制自己对分区日志数据的消费位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 consumer 读取消息后，先向 kafka 提交消费位置，再处理消息；如果该 consumer 挂掉或重启，会可能导致丢消息，从而只能满足“最多处理一次”交付语义。&lt;/li&gt;
&lt;li&gt;如果 consumer 读取消息后，是先处理，再提交消费位置；如果该 consumer 挂掉或重启，则可能导致重复消费消息，从而只能满足“最少处理一次”交付语义。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何实现“仅处理一次”语义？借助 Producer 的事务能力。&lt;/p&gt;
&lt;h2&gt;复制&lt;/h2&gt;
&lt;p&gt;复制的粒度/单元是 topic 分区。Kafka 集群中，每个分区都有一个 leader broker 节点，0个或多个从节点（follower）。分区读写都是由 leader broker 处理。&lt;/p&gt;
&lt;p&gt;如同一个普通的 consumer，从节点从 leader broker 拉取（pull）消息，然后写到自己的消息日志文件中。让从节点以 pull 的方式获取 leader 的消息数据，好处在于批量读写。&lt;/p&gt;
&lt;p&gt;对于 follower 节点而言，“是否存活”的实际含义是“是否顺利地从 leader 同步消息”，leader 节点会追踪“同步中”节点集（ISRs）。如果一个 follower 挂掉了/卡住了/同步落后太多了，则将其从这个 ISRs 中移除。follow 是否卡住或者同步落后太多，依据 &lt;code&gt;replica.lag.time.max.ms&lt;/code&gt; 配置参数判定。&lt;/p&gt;
&lt;p&gt;将某消息写到某个分区，如果该分区所有同步中副本都已经将该消息写到自己的消息日志文件中，则可以认为该消息的写操作已提交（committed），也就是真正的写成功。&lt;/p&gt;
&lt;p&gt;只有写提交的消息才会分发给 consumer。&lt;/p&gt;
&lt;p&gt;producer 可以选择是否等待消息写操作提交，在延迟（latency）和持久性（durability）之间权衡。&lt;/p&gt;
&lt;p&gt;Kafka 集群在某分区的 leader 节点挂掉之后，会快速进行失败转移（a short fail-over period），选举出新的分区 leader 节点，可用性不会受到影响。但如果发生网络分区（network partitions）问题，则无法保证可用性。CAP - C（Consistency）：一致性，A（Availability）：可用性，P（Partition Tolerance）：分区容错性 - 放弃了 分区容错性。&lt;/p&gt;
&lt;h4&gt;日志数据复制：仲裁成员集（Quorums）、同步中副本集（ISRs）和状态机&lt;/h4&gt;
&lt;p&gt;（备注：这一节我理解得还不太透彻。）&lt;/p&gt;
&lt;p&gt;一类常见的分布式系统是主从模式的，由主节点决定状态变化的顺序（the order of a series of values）。从节点通过日志复制（replicated log）方式同步状态数据。对于提交决策（commit decision）和选主（leader election），通常是基于多数人投票的机制。假设副本个数（注：个人理解包含主节点）为 2f+1，那么只有当 f+1 个副本写入成功，主节点才会将这个写操作标记为已提交（committed）。当主节点挂掉之后，基于 f 个状态最新的副本节点，可以选举出新的主节点，且状态不会有任何丢失。&lt;/p&gt;
&lt;p&gt;多数人投票方式，有一个优点：延迟取决于速度快的节点，而不是慢的。缺点是：对于实际的生产系统，抗风险能力还不够，而且不够灵活，不能让使用者做权衡。&lt;/p&gt;
&lt;p&gt;Kafka 选择仲裁成员集（quorum set）的方式与此不同，而不是基于多数人投票，而是动态维护一组同步中副本（ISR），这些副本与主节点保持同步。只有这组副本中的成员才有资格当选为主节点。ISR 集发生变化时会持久化到 Zookeeper 上。&lt;/p&gt;
&lt;p&gt;基于 ISR 模型，如果 topic 分区有 f+1 个副本，则可以容忍 f 个节点挂掉，也不会丢失任何已提交的消息。&lt;/p&gt;
&lt;p&gt;与 Kafka ISR 模型实际实现最相近的学术论文是微软的 &lt;a href="http://research.microsoft.com/apps/pubs/default.aspx?id=66814"&gt;PacificA&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;可用性和持久性保证&lt;/h4&gt;
&lt;p&gt;注意：producer 发送消息时设定 &lt;code&gt;acks=all&lt;/code&gt; 并不是要求所有的副本都确认写入成功，而是在当前同步中副本（ISR）都确认写入成功时，分区 leader 就向 producer 响应成功。例如：某个 topic 被设置为 2 个副本，然后其中一个副本节点挂掉，此时要求 &lt;code&gt;acks=all&lt;/code&gt; 的写操作也会成功。如果剩下的副本节点也挂了，那么就会丢消息啦。&lt;/p&gt;
&lt;p&gt;为了方便用户在 可用性 和 持久性 之间权衡，Kafka 提供两个 topic 级别的配置，用于 持久性 比 可用性 重要的情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://kafka.apache.org/documentation/#design_uncleanleader"&gt;禁用脏 leader 选举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;指定一个最小 ISR 集大小（&lt;code&gt;min.insync.replicas&lt;/code&gt; 参数设置）：只有当 ISR 集大小大于设定的最小值，分区 [leader] 才会接受消息写入。这个设置只有当 producer 使用 &lt;code&gt;acks=all&lt;/code&gt; 时才会生效。（注：在我们生产环境中，分区副本数通常申请为 3（包含 leader），那么 &lt;code&gt;min.insync.replicas&lt;/code&gt; 应该设定为 2，但默认是 1。使用 1，那么当分区只有一个副本（即 leader），producer 也能写入成功，但如果这个副本又挂了，就会丢数据。）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;副本管理&lt;/h4&gt;
&lt;p&gt;一个 Kafka 集群上一般会有多个 topic，每个 topic 又有多个 partition，为了节点之间负载均衡，通常以&lt;strong&gt;循环（round-robin）方式&lt;/strong&gt;在所有节点上分布 partition 和 分区 leader 角色。&lt;/p&gt;
&lt;p&gt;另外，在分区 leader 节点之后重新选出 leader 之前，存在一段不可用的时间窗口，为了缩短这个时间窗口，Kafka 会从所有 broker 中选择一个作为“控制器（controller）”，这个控制器会检测 broker 级别的问题（failures），在发现某个 broker 挂掉之后，负责为受影响的分区指定新的 leader，而不是每个分区自己负责重新选主，这样的选主过程更轻量更快。如果控制器节点挂了，还存活的 broker 中的一个会成为新的控制器。&lt;/p&gt;
&lt;h2&gt;消费者消费进度跟踪&lt;/h2&gt;
&lt;p&gt;Kafka 为每个消费组（consumer group）指定一个 broker 来存储目标 topic 各个分区的消费进度（offsets），这个 broker 称为 &lt;strong&gt;组协调器（group coordinator）&lt;/strong&gt;。这个消费组中的任一消费者实例都应该将消费进度提交到这个组协调器，或者从这个组协调器获取启动之前上次的消费进度。Kafka 基于消费组的名称为消费组分配协调器。消费者可以向任一 broker 发送 FindCoordinatorRequest 请求来查找自己的协调器，并从 FindCoordinatorResponse 响应中获取协调器的详细信息。&lt;/p&gt;
&lt;p&gt;在组协调器接收到一个 OffsetCommitRequest 请求后，会将请求数据写到一个特殊的&lt;a href="http://kafka.apache.org/documentation/#compaction"&gt;经压实的（compacted）&lt;/a&gt; Kafka topic - &lt;em&gt;__consumer_offsets&lt;/em&gt;。在目标分区的所有副本都确认收到了，协调器才会向消费者发送进度提交成功的响应。这个 topic 的消息日志数据会定期进行压实（compact），因为只需要为每个分区维护最新的消费进度。协调器也会在内存中缓存消费进度，方便快速响应消费进度查询请求。&lt;/p&gt;
&lt;p&gt;注：如果消费者/消费组特别多（例如：我们广告引擎服务，读取正排消息 topic，一个机器实例就是一个 consumer group，数量在几百到几千不等），那么组协调器的压力会比较大，那么确保组协调器的角色均匀分配到集群的所有 broker，比较关键。另外，&lt;em&gt;__consumer_offsets&lt;/em&gt; 这个 topic 的分区数量不能太少，最好和 broker 数量相同或者整数倍数量。&lt;/p&gt;</content><category term="其他"></category><category term="文章"></category><category term="笔记"></category><category term="经典"></category><category term="Kafka"></category><category term="进行中"></category></entry><entry><title>读文笔记：Photon - Fault-tolerant and Scalable Joining of Continuous Data Streams</title><link href="http://youngsterxyf.github.io/2019/10/10/reading-photon/" rel="alternate"></link><published>2019-10-10T00:00:00+08:00</published><updated>2019-10-10T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-10-10:/2019/10/10/reading-photon/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41318.pdf"&gt;Photon: Fault-tolerant and Scalable Joining of Continuous Data Streams&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Photon 是谷歌广告系统中用于 join 广告曝光日志流和点击日志流的一套系统。&lt;/p&gt;
&lt;p&gt;数据流 join 为什么没用 flink 这类通用的流式处理框架？&lt;/p&gt;
&lt;p&gt;数据流 join，特别是广告数据流 join，技术上难在哪里？&lt;/p&gt;
&lt;p&gt;任一条流都可能乱序或延迟，广告点击涉及计费的问题，计费不能多算广告主的钱，也要尽可能避免漏计费，降低广告收入损失。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;该系统在谷歌生产环境中每分钟处理百万级的事件，端到端延迟小于 10 秒（注：对于广告实时竞价的广告主而言，这个延迟的长短很重要）。&lt;/p&gt;
&lt;p&gt;广告曝光、点击整体流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户搜索某个关键词时，谷歌的服务器会返回广告和搜索结果。广告服务器会将广告 query 和结果数据作为日志发送到多个日志数据中心（multiple logs-datacenters），最终持久化存储在 GFS 上。每次 query …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41318.pdf"&gt;Photon: Fault-tolerant and Scalable Joining of Continuous Data Streams&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Photon 是谷歌广告系统中用于 join 广告曝光日志流和点击日志流的一套系统。&lt;/p&gt;
&lt;p&gt;数据流 join 为什么没用 flink 这类通用的流式处理框架？&lt;/p&gt;
&lt;p&gt;数据流 join，特别是广告数据流 join，技术上难在哪里？&lt;/p&gt;
&lt;p&gt;任一条流都可能乱序或延迟，广告点击涉及计费的问题，计费不能多算广告主的钱，也要尽可能避免漏计费，降低广告收入损失。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;该系统在谷歌生产环境中每分钟处理百万级的事件，端到端延迟小于 10 秒（注：对于广告实时竞价的广告主而言，这个延迟的长短很重要）。&lt;/p&gt;
&lt;p&gt;广告曝光、点击整体流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户搜索某个关键词时，谷歌的服务器会返回广告和搜索结果。广告服务器会将广告 query 和结果数据作为日志发送到多个日志数据中心（multiple logs-datacenters），最终持久化存储在 GFS 上。每次 query 都会被赋予一个唯一性 ID &lt;em&gt;query_id&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;对于搜索结果中的广告，用户可能会点击。广告点击会触发一次请求，谷歌的后端服务器将请求重定向到广告主的网站。在重定向之前，谷歌服务器会将点击事件记录到日志中，发送到多个日志数据中心。点击事件日志中包含广告曝光的 query_id，点击事件也会被赋予一个唯一性 ID &lt;em&gt;click_id&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计费是在点击之后，但计费所需要的广告出价等信息是在曝光请求中记录的，出于数据敏感性、带宽、请求处理延迟等多方面的考量，计费相关的信息并不会返回到用户客户端，也就是说点击请求中不会包含计费直接相关的信息，需要将 点击日志 和 曝光日志 做一次 join，得到一条完整的上下文日志，才方便做后续计费等处理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/EDOy6VKxeJUcgAW.jpg"&gt;&lt;/p&gt;
&lt;p&gt;论文中提了到该系统解决了几个技术挑战点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仅处理一次语义（exactly-once semantics）：实际上达到的是 最多处理一次语义 （At most once），也就是绝对不能多算钱，然后尽可能避免少算钱&lt;/li&gt;
&lt;li&gt;自动化的跨数据中心容错：也就是多数据中心部署，如果有一个数据中心不可用（比如 网络问题），也不会影响系统正常处理数据&lt;/li&gt;
&lt;li&gt;横向扩展性高：也就是加机器就能应对消息量增长&lt;/li&gt;
&lt;li&gt;低时延&lt;/li&gt;
&lt;li&gt;流乱序&lt;/li&gt;
&lt;li&gt;主流延迟（delayed primary stream）：这里说的”主流“是曝光日志流&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在我看来，该系统的亮点主要在前 3 点，后边细说。&lt;/p&gt;
&lt;p&gt;为解决 1、2 挑战点，系统引入一个服务模块：IdRegistry，这个服务的功能：提供点击事件 id（&lt;em&gt;click_id&lt;/em&gt;） 的存储和查询，如果某个 click_id 可以从 IdRegistry 中查到，则表示该点击事件已经处理过了，不要再次处理。&lt;/p&gt;
&lt;p&gt;并且，多数据中心都部署一套 Photon，但 IdRegistry 共享一个，多套 Photon 系统的输入相同，那么 IdRegistry 除了提供去重的功能，还提供了负载均衡的功能。正常情况下，假设 N 个数据中心，每个数据中心 Photon join 产出的日志数据量为总量的 1/N。&lt;/p&gt;
&lt;p&gt;当某个数据中心的 Photon 不可用时，相当于其负载动态地重新分配到其它数据中心，虽然总体能力上降低了，但只要处理能力有冗余，就不会影响正常处理。&lt;/p&gt;
&lt;p&gt;那么很明显，IdRegistry 很可能成为系统的短板；另外，曝光/点击的唯一性 ID 如何生成？如果由一个中心服务来提供唯一性 ID 的生成，那么这个服务也会成为系统的短板。&lt;/p&gt;
&lt;p&gt;所以，系统没有选择一个中心服务来生成唯一性 id，而是将 id 设计为包含3个部分：&lt;em&gt;ServerIP&lt;/em&gt;、&lt;em&gt;ProcessID&lt;/em&gt;、&lt;em&gt;Timestamp&lt;/em&gt;。由于日志文件中行之间大致是按照时间戳有序的，所以 id 中包含时间戳的一个额外好处是：根据 id 即可大致定位日志内容。另外，还有一个和横向扩展性相关的好处，后边细说。&lt;/p&gt;
&lt;p&gt;IdRegistry 的角色至关重要，所以将其实现为一个基于 Paxos 协议的分布式系统，根据 CAP 原则，可用性（此处是指&lt;strong&gt;吞吐能力&lt;/strong&gt;）受限。解决方案是：&lt;/p&gt;
&lt;p&gt;1、提高单机处理能力：服务端攒批处理，尽可能减少网络往返次数导致的等待（特别是：由于 IdRegistry 是跨地域分布式，部署上节点之间最大延迟是 100ms 左右）&lt;/p&gt;
&lt;p&gt;2、分片（Sharding）：根据 click_id 进行分片，但如果是固定分片，那么随着以后业务量增大，不好扩展。Photon 使用了一种基于时间段动态分片方案，这个方案基于 click_id 自带时间戳。大致逻辑是：使用一个配置，内容大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/VRlgr2CoD8zw7Mm.jpg"&gt;&lt;/p&gt;
&lt;p&gt;对于每个 click 日志，先根据 click_id 中的时间戳，判断分片数，并计算对应的分片 id。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/JMWyQvrDZCaAEdH.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;系统的模块关系图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/zghk6oVaqZ5uEs3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Photon 的 Dispatcher 模块并没有以 Kafka 这种消息队列作为输入，而是直接监听文件系统中的日志文件变更，这一点有点奇怪，不是特别理解。&lt;/p&gt;
&lt;p&gt;Joiner 负责实际的 join 工作，由于 3、4 都比较耗时，所以为了尽可能减少 Joiner 的工作量，Dispatcher 将点击事件日志发送给 Joiner，会先到 IdRegistry 中查一下该事件是否已被处理过，从而起到过滤作用。因多数据中心部署，实际过滤比为：$ \frac{N-1}{N} $。&lt;/p&gt;
&lt;p&gt;为了确保 Joiner 高可用，Joiner 是无状态的，向 Dispatcher 提供 RPC 接口，Joiner 内部有限流，以保证不会因为单个 Joiner 负载过大，导致处理时延增大。Dispatcher 调用 Joiner 失败后会重试，重试使用的是指数退避算法。但处理失败的点击事件，是另外存储在 GFS 上，应该是由另外的线程来负责重试，不会影响正常的事件处理。&lt;/p&gt;
&lt;p&gt;当 Joiner 收到一个点击事件的处理请求时，会根据点击日志数据中的 &lt;em&gt;query_id&lt;/em&gt; 从 EventStore 查询曝光日志详情，但因为曝光日志数据流可能会有延迟，所以可能会查不到，查不到且发现 click_id 中的时间戳早于某个阈值（比如是 N天前的一个事件），Joiner 会将该 click_id 标记为不可 join，然后向 Dispatcher 返回成功；如果 click_id 中的时间戳不早于阈值，则向 Dispatcher 返回失败，由 Dispatcher 来重试。&lt;/p&gt;
&lt;p&gt;为了确保不会多计费，Joiner 在将 join 结果写入 Joined Click Logs 之前，会向 IdRegistry 注册 click_id。&lt;/p&gt;
&lt;p&gt;假设注册实际上已成功，但因网络原因或 RPC 调用超时 Joiner 未收到成功响应，此时怎么办？Joiner 向 IdRegistry 注册 click_id 时，会附带一个额外的 唯一性 token，也包含3个部分：Joiner 服务器地址、进程 ID、时间戳，IdRegistry 会把这个唯一性 token 作为值存储下来，所以对于这种情况，Joiner 可以重复发注册请求，如果 IdRegistry 根据 token 发现已注册成功的 click_id 和当前收到的 click_id 来自同一个 Joiner，则也会返回注册成功。&lt;/p&gt;
&lt;p&gt;假设注册成功，合并结果写入异常，异常分为 2 种，需要解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写入之前，Joiner 节点宕机或重启&lt;/li&gt;
&lt;li&gt;合并结果实际写入成功，但因为网络原因，Joiner 未收到响应&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为尽可能减少因某个 Joiner 节点硬件异常导致的 join 结果丢失，IdRegistry 对于单个 Joiner 的请求有限流，这个限流会间接导致 Joiner 对 Dispatcher 限流。&lt;/p&gt;
&lt;p&gt;为了进一步减少因为上面2种异常情况以及其它异常导致的 Join 结果丢失，Photon 还提供一个校验系统：获取原始点击事件日志，如果该日志 click_id 在 IdRegistry 中存在，但合并结果中不存在，则根据 IdRegistry 存储的对应 click_id 的 token，判断对应的 Joiner 是否存活，如果存活，则交于该 Joiner 重新处理，如果对应的 Joiner 已不存在，则从 IdRegistry 中删除该 click_id 记录，然后交于任一 Joiner 来处理，都一样。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;EventStore 获取原始的曝光日志，向 Joiner 提供查询接口，返回原始的曝光日志内容。&lt;/p&gt;
&lt;p&gt;基于时间局部性，EventStore 内部分 2 层，第一层为 CacheEventStore - 一个类似 Memcached 的 KV 内存映射，K 是 query_id，V 是曝光日志内容，基于一致性哈希算法根据 query_id 进行分片，缓存几分钟最新的曝光日志数据，可以命中 90% 左右的查询请求。&lt;/p&gt;
&lt;p&gt;如果 CacheEventStore 查询 miss，则交于第二层 LogsEventStore 来处理。LogsEventStore 对 query_id 和 曝光日志所在的日志文件及目标起始行（因为日志文件数据大致按时间戳有序，根据 query_id 中的时间戳大致可以知道查询的起始行）建立索引（实际存储在 BigTable 中），查询时，先根据 query_id，查到目标日志文件和起始行，然后从日志文件中读取原始曝光日志内容。&lt;/p&gt;</content><category term="其他"></category><category term="论文"></category><category term="笔记"></category></entry><entry><title>读文笔记：日志 - 每个软件工程师都应该了解的实时数据统一抽象</title><link href="http://youngsterxyf.github.io/2019/10/10/reading-the-log/" rel="alternate"></link><published>2019-10-10T00:00:00+08:00</published><updated>2019-10-10T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-10-10:/2019/10/10/reading-the-log/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话概括，这篇文章细说了 Kafka 的本质原理、解决的问题、适用性等。&lt;/p&gt;
&lt;p&gt;Kafka 本质上是提供日志数据流。&lt;/p&gt;
&lt;p&gt;日志是客观世界的事件记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A log is perhaps the simplest possible storage abstraction. It is an append-only, totally-ordered sequence of records ordered by time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志数据的特点是：只增不改，自带时间戳，数据存储的先后顺序即（大致）是实际发生的时间先后顺序。&lt;/p&gt;
&lt;p&gt;数据库可以基于日志来还原历史操作行为 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话概括，这篇文章细说了 Kafka 的本质原理、解决的问题、适用性等。&lt;/p&gt;
&lt;p&gt;Kafka 本质上是提供日志数据流。&lt;/p&gt;
&lt;p&gt;日志是客观世界的事件记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A log is perhaps the simplest possible storage abstraction. It is an append-only, totally-ordered sequence of records ordered by time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志数据的特点是：只增不改，自带时间戳，数据存储的先后顺序即（大致）是实际发生的时间先后顺序。&lt;/p&gt;
&lt;p&gt;数据库可以基于日志来还原历史操作行为，并最终生成最新状态，主从同步就是这么干的。&lt;/p&gt;
&lt;p&gt;对于分布式系统而言，日志可以解决 2 个问题：按序改变状态和分发数据（ordering changes and distributing data）。&lt;/p&gt;
&lt;p&gt;状态机复制原则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If two identical, deterministic processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分布式系统中各个节点可以依据日志来同步状态，达到（最终）一致性。并且，可以依据节点处理到哪行日志即可确定/表达该节点的状态。&lt;/p&gt;
&lt;p&gt;（日志）事件流（events）和数据表（tables）是一体两面（a facinating duality）：数据表的变更操作即是一个日志事件流，基于日志事件流可以生成数据表，并将其状态不断更新到最新，数据表的状态是日志事件流的在某个时间点的切面。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;events -&amp;gt; table -&amp;gt; events = events &amp;lt;-&amp;gt; table&lt;/p&gt;
&lt;p&gt;The magic of the log is that if it is a complete log of changes, it holds not only the contents of the final version of the table, but also allows recreating all other versions that might have existed. It is, effectively, a sort of backup of every previous state of the table.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码版本控制系统（比如 git）也是基于日志实现的分布式系统，一次 commit 相当于一次日志记录。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于互联网/金融等行业的公司来说，数据是重要资产，如何尽可能发挥数据的潜在价值为公司增收，至关重要。因为管理、技术上的原因，公司通常分多个业务部门，各业务部门提供若干服务，各个服务都会产出数据，这些数据很可能需要跨部门跨服务流通，流通的速度越快，周期越短，收益越大。&lt;/p&gt;
&lt;p&gt;以前，数据的处理方式主要是批处理，并不是因为没有流处理的技术，而是数据流通的基础设施跟不上，没做到持续的数据流。&lt;strong&gt;（注：这个说法，我个人只部分认同，很多时候，批处理的时延和收益可以满足大部分需求，实时流处理的边际效益可能并不明显）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流式处理是批处理的泛化形式（stream processing is a generalization of batch processing, and, given the prevalence of real-time data, a very important generalization）。&lt;/p&gt;
&lt;p&gt;为了避免因数据流通导致各个服务之间的直接耦合，新增一个统一的数据通道中间服务，各个服务只管对数据通道进行写入或读出，不用关心数据是哪个服务写入的，或者哪些服务在消费/使用自己产出的数据。&lt;strong&gt;（解耦）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，消费者消费数据的速率可能不一样，也可能会经历异常重启等情况，让消费者来控制速率，并且多个消费者之间不会相互干扰，会更好。&lt;/p&gt;
&lt;p&gt;基于数据流通的需求和日志的理念，Linkedin 设计开发了 Kafka。&lt;/p&gt;
&lt;p&gt;因为日志数据量可能会很大，日志数据本质上是有序串行的，如果支持数据分片，分片之间并行消费，分片内日志数据全局有序，数据流通的吞吐能力就可以无限扩展。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;基于 Kafka 这类数据管道，服务之间可以实现多级串联。（注：我们现在做的服务就是这么干）&lt;/p&gt;
&lt;p&gt;这种分布式系统架构中，至少涉及 producer（生产者）、broker（中间人）、consumer（消费者）三个角色，角色之间在某些工作上如何分工也是值得思考的：&lt;/p&gt;
&lt;p&gt;生产者产生的数据应该是什么样的？ - 统一格式/编码、方便解析&lt;/p&gt;
&lt;p&gt;中间人（kafka）需要解决什么问题？- 对于单个生产者写入的数据，保证按写入顺序有序地分发给消费者；解决数据高可用，高吞吐能力；支持回溯/重复消费（因此数据需要保留指定时间长度），从而消费者出问题后可以从头消费数据恢复状态。因为支持很多消费者消费同一个数据流，所以平均下来，Kafka 服务的成本会比较低。&lt;/p&gt;
&lt;p&gt;消费者按各自的需求进行数据转换存储。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于实现高吞吐能力，除了分片，Kakfa 还充分利用了攒批处理：生产者可以批量发送，中间人将数据攒批写入磁盘日志文件 等等。&lt;/p&gt;
&lt;p&gt;此外，由于涉及大量的磁盘文件和网络之间数据读写，Kafka 还充分利用操作系统内核的零拷贝传输能力。&lt;/p&gt;</content><category term="其他"></category><category term="论文"></category><category term="笔记"></category></entry><entry><title>Lucene 查询解析器语法（译）</title><link href="http://youngsterxyf.github.io/2019/09/04/lucene-query-parser-syntax/" rel="alternate"></link><published>2019-09-04T00:00:00+08:00</published><updated>2019-09-04T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-09-04:/2019/09/04/lucene-query-parser-syntax/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description"&gt;Query Parser Syntax&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（一个词法分析器，使用 JavaCC 将一个字符串翻译成一个 Lucene 查询）提供一种功能丰富的查询语言。&lt;/p&gt;
&lt;p&gt;一般来说，查询解析器支持的语法在不同发布版本之间可能会有变化。当前这个文档页面描述的是当前这个发布版本的语法。如果你正在使用一个不同版本的 Lucene，请参考该版本自带的 docs/queryparsersyntax.html 文档。&lt;/p&gt;
&lt;p&gt;在选择使用这个查询解析器之前，请考虑以下 3 点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你准备以编程的方式生成一个查询字符串，然后使用查询解析器来解析它。那么，你应该认真考虑一下是否应该直接使用查询 API 来构建查询。换句话说，查询解析器专门用于人类输入的文本，而不是程序生成的文本。&lt;/li&gt;
&lt;li&gt;不可分词（untokenized）的域（译者注：抱歉，此处没太理解）最好直接添加到查询中，而不是通过查询解析器来解析。如果一个域的值是通过应用自动生成的，那么应该为这个域自动生成查询子句 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description"&gt;Query Parser Syntax&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（一个词法分析器，使用 JavaCC 将一个字符串翻译成一个 Lucene 查询）提供一种功能丰富的查询语言。&lt;/p&gt;
&lt;p&gt;一般来说，查询解析器支持的语法在不同发布版本之间可能会有变化。当前这个文档页面描述的是当前这个发布版本的语法。如果你正在使用一个不同版本的 Lucene，请参考该版本自带的 docs/queryparsersyntax.html 文档。&lt;/p&gt;
&lt;p&gt;在选择使用这个查询解析器之前，请考虑以下 3 点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你准备以编程的方式生成一个查询字符串，然后使用查询解析器来解析它。那么，你应该认真考虑一下是否应该直接使用查询 API 来构建查询。换句话说，查询解析器专门用于人类输入的文本，而不是程序生成的文本。&lt;/li&gt;
&lt;li&gt;不可分词（untokenized）的域（译者注：抱歉，此处没太理解）最好直接添加到查询中，而不是通过查询解析器来解析。如果一个域的值是通过应用自动生成的，那么应该为这个域自动生成查询子句。分析器（查询解析器所使用的）是专门用于将人类输入的文本转换成一些词（terms），那么程序自动生成的值，也应该由程序自动添加到查询中。&lt;/li&gt;
&lt;li&gt;从查询形式来看，如果域的值是普通文本，则应该使用查询解析器。所有其它值类型，比如：日期范围、关键词等等，最好通过查询 API 直接添加。如果一个域的值仅限于一个有限的集合（可以通过一个下拉菜单指定），则不应该添加到查询字符串（后续会被解析）中，而是应该作为一个 TermQuery 子句添加到查询中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;词（Terms）&lt;/h2&gt;
&lt;p&gt;一个查询语句可以拆解成 词（terms） 和 操作符（operators）。词又分为两种：单个词（single Terms）和短语（Phrases）。&lt;/p&gt;
&lt;p&gt;单个词是指 ”test“ 或 ”Hello“ 这类单词。&lt;/p&gt;
&lt;p&gt;短语是指以双引号包围起来的一组单词，比如：”hello dolly“。&lt;/p&gt;
&lt;p&gt;多个词（Multiple terms）可以使用布尔操作符组合在一起，实现一个更加复杂的查询（如下文所示）。&lt;/p&gt;
&lt;p&gt;备注：用于创建索引的解析器也会用于解析查询字符串中的词和短语。因此，选择合适的解析器很重要，否则解析器可能会被查询字符串中的词干扰（译者注：这句应该是指英文解析器可能无法对中文进行正确分词的问题）。&lt;/p&gt;
&lt;h2&gt;域（Fields）&lt;/h2&gt;
&lt;p&gt;Lucene 支持分多个字段/域的数据。搜索时，可以指定一个域，也可以使用默认域。域的名称以及默认域与具体实现相关。&lt;/p&gt;
&lt;p&gt;输入域的名称，后跟一个冒号（:），以及目标搜索词，即可对任意一个域进行搜索。&lt;/p&gt;
&lt;p&gt;举例来说，假设一个 Lucene 索引包含 2 个域：title 和 text，text 是默认域。若想查找标题为 ”The Right Way“ 且文本内容包含 ”don't go this way“ 的文档，可以输入：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;title:&amp;quot;The Right Way&amp;quot; AND text:go&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;title:&amp;quot;The Right Way&amp;quot; AND go&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为 text 是默认域，所以域的标志可以省略。&lt;/p&gt;
&lt;p&gt;注意：指定的域仅对紧跟其后的词生效，因此，如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;title:The Right Way
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将对 title 域仅查找 ”The“，并对默认域（当前这个例子中是指 text 域）查找 ”Right“ 和 ”Way“。&lt;/p&gt;
&lt;h2&gt;词修饰语（Term Modifiers）&lt;/h2&gt;
&lt;p&gt;Lucene 支持修饰查询词（modifying query terms）来提供多种搜索方式。&lt;/p&gt;
&lt;h3&gt;通配符搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持对单个词(single terms)（不是短语查询 phrase queries）进行单个字符和多个字符的通配搜索。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;?&lt;/code&gt; 符号进行单个字符的通配搜索。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;*&lt;/code&gt; 符号进行多个字符的通配搜索。&lt;/p&gt;
&lt;p&gt;单字符通配搜索用于查找替换单个字符即可匹配的词。举例来说，若要搜索 ”text“ 或 ”test“，可以如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;te?t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;多字符通配搜索用于查找替换0个或多个字符即可匹配的词。举例来说，若要搜索 ”test“、”tests“ 或 ”tester“，可以如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;test*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以对词的中间部分进行通配搜索：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;te*t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;备注：不可以将 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; 符号用作一次搜索的首个字符。&lt;/p&gt;
&lt;h3&gt;正则表达式搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持正则表达式搜索，匹配斜杠（&lt;code&gt;/&lt;/code&gt;） 之间的模式。正则表达式的语法在不同的发布版本之间可能会有差异，目前支持的语法在 &lt;a href="http://lucene.apache.org/core/8_2_0/core/org/apache/lucene/util/automaton/RegExp.html?is-external=true"&gt;RegExp&lt;/a&gt; 类文档中有说明。举例来说，查找包含 ”moat“ 或 ”boat“ 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/[mb]oat/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;模糊搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持基于 Damerau-Levenshtein 编辑距离的模糊搜索。在单个词的最后添加波浪符（~）即可进行模糊搜索。举例来说，使用模糊搜索查找拼写上近似 ”roam“ 的词：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;roam~&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个查询语句会找到 foam 和 roams 这类词。&lt;/p&gt;
&lt;p&gt;模糊搜索可以通过一个额外（可选）的参数来指定允许的最大编辑次数。这个参数值界于 0 和 2 之间，例如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;roam~1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果未指定该参数，则默认使用 2 个编辑距离。&lt;/p&gt;
&lt;p&gt;以前，这里还允许使用浮点数。现在这个语法已被考虑弃用，将于 Lucene 5.0 中移除。&lt;/p&gt;
&lt;h3&gt;邻近搜索&lt;/h3&gt;
&lt;p&gt;Lucene 支持查找指定距离的邻近词。在短语的最后添加拨浪符（~）即可进行邻近搜索。举例来说，在文档中搜索 ”apache“ 和 ”jakarta“ 相距 10 个词的模式：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;quot;jakarta apache&amp;quot;~10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;范围搜索&lt;/h3&gt;
&lt;p&gt;范围查询可以要求域的值在范围查询语句指定的上下界之间。范围查询对于上下界可以包含也可以不包含。排序按照字典序进行。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;mod_date:[20020101 TO 20030101]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个查询语句会查找 mod_date 域的值在 20020101 和 20030101 （包含上下界） 之间的文档。注意：范围查询并不是仅适用于日期域，也可以对非日期的域进行范围查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;title:{Aida TO Carmen}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个查询语句会查找到 title 域的值在 Aida 和 Carmen （不包含上下界）之间的所有文档。&lt;/p&gt;
&lt;p&gt;包含上下界的范围查询使用方括号来表示。不包含上下界的范围查询使用大括号来表示。&lt;/p&gt;
&lt;h3&gt;词加权（Boosting a term）&lt;/h3&gt;
&lt;p&gt;Lucene 会基于文档中找到的词对匹配到的文档提供相关性级别（译者疑问：基于向量余弦来计算相关性？）。可以在目标搜索词之后紧接一个脱字符 “^”，后跟一个加权系数（一个数字）来提升该搜索词的相关性权重。加权系统越高，查询命中的文档与该词的相关性越强。&lt;/p&gt;
&lt;p&gt;加权操作允许对词进行加权控制文档的相关性。例如，假设你正在搜索：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;jakarta apache&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后希望搜索结果和词 ”jakarta“ 更相关一些，则可以使用 ”^“ 符号后跟一个加权系数对这个词进行加权，即如下这样查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;jakarta^4 apache&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这会使得查找到的文档和词 ”jakarta“ 看起来更相关一些。也可以对短语进行加权，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;quot;jakarta apache&amp;quot;^4 &amp;quot;Apache Lucene&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认，加权系数是 1。加权系统可以小于 1（比如：0.2），但必须大于 0。&lt;/p&gt;
&lt;h2&gt;布尔操作符&lt;/h2&gt;
&lt;p&gt;布尔操作符允许使用逻辑操作符组合多个词。Lucene 支持的布尔操作符包含 &lt;code&gt;AND&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;OR&lt;/code&gt;、&lt;code&gt;NOT&lt;/code&gt; 及 &lt;code&gt;-&lt;/code&gt;（备注：布尔操作符必须全部是大写字母）。&lt;/p&gt;
&lt;h3&gt;OR&lt;/h3&gt;
&lt;p&gt;“OR” 操作符是默认的连接操作符。这意味着如果两个词之间没有布尔操作符，则使用 “OR” 操作符。OR 操作符链接两个词，并匹配包含其中任意一个词的文档。这相当于集合的并集操作。“||” 符合可用于替代单词 “OR”。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索包含 “jakarta apache” 或仅是 “jakarta” 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;quot;jakarta apache&amp;quot; jakarta&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;quot;jakarta apache&amp;quot; OR jakarta&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;AND&lt;/h3&gt;
&lt;p&gt;"AND" 操作符会匹配文本内容中同时存在两个词（因为 AND 是二元操作符）的文档。这相当于集合的交集操作。“&amp;amp;&amp;amp;” 符号可用于替代单词 “AND”。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索包含 “jakarta apache” 和 “Apache Lucene” 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;quot;jakarta apache&amp;quot; AND “Apache Lucene”&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;+&lt;/h3&gt;
&lt;p&gt;“+”（必需）操作符要求文档的某个域中包含 “+” 符号之后的词。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索（必须）包含 “jakarta” 以及可能包含 “lucene”（包不包含都可以）的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;+jakarta lucene&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;NOT&lt;/h3&gt;
&lt;p&gt;若文档包含”NOT“之后的词，”NOT“ 操作会排查该文档。这相当于集合的差集操作。”!“ 符号可用于替代单词 ”NOT“。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句搜索包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档”：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;quot;jakarta apache&amp;quot; NOT &amp;quot;Apache Lucene&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;备注：“NOT” 操作符不可以用于单个词。例如，如下搜索不会返回任何结果：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;NOT &amp;quot;jakarta apache&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;-&lt;/h3&gt;
&lt;p&gt;如果文档包含”-“符号之后的词，那么”-“（禁止）操作符会排除这些文档。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来查询包含 ”jakarta apache“ 但不包含 ”Apache Lucene“ 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;quot;jakarta apache&amp;quot; -&amp;quot;Apache Lucene&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;分组&lt;/h2&gt;
&lt;p&gt;Lucene 支持使用圆括号对子句进行分组，构成子查询。如果你想控制一个查询语句的布尔逻辑，这对非常有用。&lt;/p&gt;
&lt;p&gt;比如，使用如下查询语句来搜索包含 “jakarta” 或 “apache”，以及 “website” 的文档：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;(jakarta OR apache) AND website&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如此就消除了任何困惑，确保你想表达是：必须存在 ”website“，以及可能存在词 ”jakarta“ 或 ”apache“。&lt;/p&gt;
&lt;h2&gt;域分组&lt;/h2&gt;
&lt;p&gt;Lucene 支持使用圆括号对单个域的多个子句进行分组。&lt;/p&gt;
&lt;p&gt;例如，若想搜索一个 title 中既包含单词“return”且包含短语“pink panther”，可以使用如下查询：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;title:(+return +&amp;quot;pink panther&amp;quot;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;特殊字符转义&lt;/h2&gt;
&lt;p&gt;Lucene 支持对查询语法使用的特殊字符进行转移。目前这些特殊字符如下列表所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;+ - &amp;amp;&amp;amp; || ! ( ) { } [ ] ^ &amp;quot; ~ * ? : \ /&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在特殊字符之前加 &lt;code&gt;\&lt;/code&gt; 来转义。例如，使用如下查询语句来搜索 &lt;code&gt;(1+1):2&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;\(1\+1\)\:2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Lucene"></category><category term="ElasticSearch"></category><category term="Kibana"></category></entry><entry><title>一个 Python 小项目的小结</title><link href="http://youngsterxyf.github.io/2019/08/14/a-python-project-summary/" rel="alternate"></link><published>2019-08-14T00:00:00+08:00</published><updated>2019-08-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-08-14:/2019/08/14/a-python-project-summary/</id><summary type="html">&lt;p&gt;前段时间临时接手一个 Python 小项目，这个项目实现的类似一个管控平台，其中核心功能是为算法同学提供机器学习模型训练任务的全流程管理，平台后端基于 Flask 框架实现，前端基于 Ant Design Pro 实现。&lt;/p&gt;
&lt;p&gt;代码稍微有些乱，所以做了部分代码的重构，在此做点经验小结。&lt;/p&gt;
&lt;h3&gt;1、并行化或异步化&lt;/h3&gt;
&lt;p&gt;部分请求处理逻辑，由于比较耗时，故使用线程池来加速，或者使用独立线程异步处理，或者先存储一个中间状态，由后台定时任务来完成实际的处理工作。对于异步处理结果，前端通过轮询来获取。&lt;/p&gt;
&lt;p&gt;线程池的使用，主要使用 map 方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool

input_list = [...]
pool: Pool = Pool(len(input_list))
pool.map(func, input_list)
pool.close()
pool.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;独立线程异步处理 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前段时间临时接手一个 Python 小项目，这个项目实现的类似一个管控平台，其中核心功能是为算法同学提供机器学习模型训练任务的全流程管理，平台后端基于 Flask 框架实现，前端基于 Ant Design Pro 实现。&lt;/p&gt;
&lt;p&gt;代码稍微有些乱，所以做了部分代码的重构，在此做点经验小结。&lt;/p&gt;
&lt;h3&gt;1、并行化或异步化&lt;/h3&gt;
&lt;p&gt;部分请求处理逻辑，由于比较耗时，故使用线程池来加速，或者使用独立线程异步处理，或者先存储一个中间状态，由后台定时任务来完成实际的处理工作。对于异步处理结果，前端通过轮询来获取。&lt;/p&gt;
&lt;p&gt;线程池的使用，主要使用 map 方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool

input_list = [...]
pool: Pool = Pool(len(input_list))
pool.map(func, input_list)
pool.close()
pool.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;独立线程异步处理：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; multiprocessing

p = multiprocessing.Process(target=func, args=(...))
p.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定时任务，基于 apscheduler 库实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; apscheduler.schedulers.background &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; BackgroundScheduler

scheduler = BackgroundScheduler()

scheduler.add_join(func, &lt;span style="color: #a31515"&gt;&amp;#39;interval&amp;#39;&lt;/span&gt;, seconds=1)

scheduler.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为对于 Python 应用，通常会使用 gunicorn 这种 WSGI HTTP 服务器以多进程启动多个应用实例，提升请求吞吐能力。但是对于定时任务我们希望只有一个实例，对此，如果使用 gunicorn，可以基于它的 preload 机制来实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# wsgi.py&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; app

&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; __name__ == &lt;span style="color: #a31515"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;# 注意其中的 --preload 参数&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;gunicorn --workers=4 --preload --log-level=info --access-logfile=access.log -b 0.0.0.0:8080 wsgi:app&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;preload 机制简单来说，就是 import app 类所在的模块及其依赖的各个模块（import 过程中会执行其中的语句），然后 fork 出多个进程，每个进程都执行 app.run()。&lt;/p&gt;
&lt;h4&gt;2、实现一些通用方案对异常进行捕获或重试&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; exception_try(times: int = 3, sleep_then_try_seconds=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; decorator(f):
        &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; wrapper(*args, **kwargs):
            count = 0
            exception = &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; count &amp;lt; times:
                &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
                    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; f(*args, **kwargs)
                &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; Exception &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
                    exception = e
                    count += 1
                    logging.exception(&lt;span style="color: #a31515"&gt;&amp;quot;Try {} times&amp;quot;&lt;/span&gt;.format(count))
                    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (sleep_then_try_seconds &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;) &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; count &amp;lt; times:
                        time.sleep(sleep_then_try_seconds)
            &lt;span style="color: #0000ff"&gt;raise&lt;/span&gt; exception
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; wrapper
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; decorator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;@exception_try(times=3, sleep_then_try_seconds=0.5)
&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; connect(self):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; pymysql.connect(host=self.host, user=self.user, password=self.password, db=self.db, charset=self.charset)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个装饰器方法用于实现异常重试，并且可以指定重试的时间间隔，实际使用下来效果较好。而且也不会因为 &lt;code&gt;try...except&lt;/code&gt; 导致大块代码缩进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确保数据库连接关闭（其它类似资源也可以这样实现）&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; with_db(db: Connection, exception_callback=&lt;span style="color: #0000ff"&gt;None&lt;/span&gt;):
    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; decorator(f):
        &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; db_context(*a, **kw):
            &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; f(db, *a, **kw)
            &lt;span style="color: #0000ff"&gt;except&lt;/span&gt; Exception &lt;span style="color: #0000ff"&gt;as&lt;/span&gt; e:
                logging.exception(str(e))
                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; exception_callback &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;:
                    exception_callback(e)
            &lt;span style="color: #0000ff"&gt;finally&lt;/span&gt;:
                &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;:
                    db.close()
                &lt;span style="color: #0000ff"&gt;except&lt;/span&gt;:
                    &lt;span style="color: #0000ff"&gt;pass&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; db_context

    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; decorator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 将 conf.db.connect() 对象作为 delete_task_from_job_queue 的第一个参数注入，task_id 这个参数以不定参数的方式传入 delete_task_from_job_queue&lt;/span&gt;
with_db(conf.db.connect())(delete_task_from_job_queue)(task_id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个装饰器方法用于确保数据库连接在异常发生也能正常关闭，防止资源泄露。&lt;/p&gt;
&lt;h4&gt;3、循环等待或超时&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;TimeoutCondition&lt;/span&gt;(object):

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self, condition_func, timeout_seconds):
        self.condition = condition_func
        self.timeout = timeout_seconds
        self.begin = &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;
        self.timeout_false = &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;
        self.cond_true = &lt;span style="color: #0000ff"&gt;True&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __bool__(self):
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; self.begin &lt;span style="color: #0000ff"&gt;is&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;:
            self.begin = timeit.default_timer()
        self.cond_true = self.condition()
        self.timeout_false = self.timeout &amp;lt;= 0 &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; (timeit.default_timer() - self.begin) &amp;lt; self.timeout
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; self.cond_true &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; self.timeout_false

    &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; is_timeout(self):
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; self.cond_true &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; self.timeout_false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cond = TimeoutCondition(&lt;span style="color: #0000ff"&gt;lambda&lt;/span&gt; : len(service_list) == 0, 5)
&lt;span style="color: #0000ff"&gt;while&lt;/span&gt; cond:
    time.sleep(1)
    service_list = get_service_list()
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; cond.is_timeout():
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;TimeoutCondition&lt;/code&gt; 用于实现循环等待某个条件满足，但为了避免死循环，所以加一个超时条件判断。实例化参数第一个是原始的条件判断 lambda 语句，第二个是一个超时设置。另外，借助魔术方法 &lt;code&gt;__bool__&lt;/code&gt;，让 TimeoutCondtion 的实例用起来像是一个布尔变量，调用 &lt;code&gt;is_timeout()&lt;/code&gt; 方法可以区分循环等待退出是因为原始条件满足，还是超时退出的。&lt;/p&gt;
&lt;h4&gt;4、按部署环境配置应用的行为&lt;/h4&gt;
&lt;p&gt;应用在不同的环境（开发、测试、生产）中应该允许加载不同的配置，配置不同的行为。&lt;/p&gt;
&lt;p&gt;当前应用处于什么环境，可以通过环境变量来配置，应用初始化时最先检测当前处于什么环境，之后的初始化流程就可以依据环境配置来加载配置，定制应用行为。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# conf/__init__.py&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;AppConfig&lt;/span&gt;(object):
    app_env = os.getenv(&lt;span style="color: #a31515"&gt;&amp;#39;APP_ENV&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;development&amp;#39;&lt;/span&gt;)
    is_prod = app_env == &lt;span style="color: #a31515"&gt;&amp;#39;production&amp;#39;&lt;/span&gt;
    is_dev = app_env == &lt;span style="color: #a31515"&gt;&amp;#39;development&amp;#39;&lt;/span&gt;
    is_testing = app_env == &lt;span style="color: #a31515"&gt;&amp;#39;testing&amp;#39;&lt;/span&gt;

    &lt;span style="color: #008000"&gt;# 其余应用配置项&lt;/span&gt;
    ...

conf = AppConfig()


&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; _load_config_by_env(env: str):
    &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    不同环境加载不同的配置文件&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    配置目录结构：&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    conf/&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        __init__.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        development.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        production.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;        testing.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    module = importlib.import_module(&lt;span style="color: #a31515"&gt;&amp;#39;conf.{}&amp;#39;&lt;/span&gt;.format(env))
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; hasattr(module, &lt;span style="color: #a31515"&gt;&amp;#39;Config&amp;#39;&lt;/span&gt;):
        logging.warning(&lt;span style="color: #a31515"&gt;&amp;#39;Not find {} config&amp;#39;&lt;/span&gt;.format(env))
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; name, value &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; getattr(module, &lt;span style="color: #a31515"&gt;&amp;#39;Config&amp;#39;&lt;/span&gt;).__dict__.items():
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; name.startswith(&lt;span style="color: #a31515"&gt;&amp;#39;__&amp;#39;&lt;/span&gt;):
            &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;
        conf.__dict__[name] = value
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# 根据环境配置日志级别&lt;/span&gt;
log_level = logging.INFO &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; conf.is_prod &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; logging.DEBUG
logging.basicConfig(format=consts.LOG_FORMAT, level=log_level)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;5、方便排查问题的日志输出&lt;/h4&gt;
&lt;p&gt;日志是问题排查的主要信息来源，所以日志记录得好不好，很关键。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;# https://github.com/python/cpython/blob/3.7/Lib/logging/__init__.py#L457&lt;/span&gt;
&lt;span style="color: #008000"&gt;# 日志时间 - 日志级别 - 代码文件路径 - 行号 - 进程 ID - 线程名称 - 日志内容&lt;/span&gt;
LOG_FORMAT = &lt;span style="color: #a31515"&gt;&amp;#39;%(asctime)-15s - %(levelname)s - %(pathname)s - %(lineno)d - %(process)d - %(threadName)s - %(message)s&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;6、API 规范与异常提示&lt;/h4&gt;
&lt;p&gt;为了统一前端 API 响应处理，有必要对 API 响应体的结构指定标准。以我个人的习惯，所有从应用代码中返回的响应，HTTP 状态码都应该是 200，具体当前 API 请求成功还是失败，如果失败，失败的原因是什么都应该包含在响应体中，响应体大致的结构为：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{
    &amp;quot;code&amp;quot;: &lt;span style="border: 1px solid #FF0000"&gt;...&lt;/span&gt;,
    &amp;quot;msg&amp;quot;: &lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;,
    &amp;quot;data&amp;quot;: &lt;span style="border: 1px solid #FF0000"&gt;...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;code 表示请求处理失败时，data 字段可选，code 表示请求处理成功时，msg 字段可选。&lt;/p&gt;
&lt;p&gt;前端配合对响应体进行统一检测和提示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; { notification } from &lt;span style="color: #a31515"&gt;&amp;#39;antd&amp;#39;&lt;/span&gt;;

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; defaultHTTPCodeHandler(response) {
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (response.status &amp;gt;= 400) {
    &lt;span style="color: #008000"&gt;// 注意 clone&lt;/span&gt;
    response.clone().text().then(respBody =&amp;gt; {
      notification.error({message: &lt;span style="color: #a31515"&gt;&amp;#39;API 异常响应&amp;#39;&lt;/span&gt;, description: &lt;span style="color: #a31515"&gt;`${&lt;/span&gt;response.status&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;respBody&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;, duration: &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;});
      console.log(&lt;span style="color: #a31515"&gt;`${&lt;/span&gt;response.status&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;respBody&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;);
    });
  }
}

&lt;span style="color: #0000ff"&gt;function&lt;/span&gt; defaultMsgCodeHandler(response) {
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (response.status === 200) {
    &lt;span style="color: #008000"&gt;// 注意 clone&lt;/span&gt;
    response.clone().json().then(jsonBody =&amp;gt; {
      &lt;span style="color: #008000"&gt;// 0、200、10000 都属于成功响应&lt;/span&gt;
      &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (jsonBody !== &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; &amp;amp;&amp;amp; jsonBody.code !== &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; &amp;amp;&amp;amp; jsonBody.code !== 0 &amp;amp;&amp;amp; jsonBody.code !== 200 &amp;amp;&amp;amp; jsonBody.code != 10000) {
        notification.error({message: &lt;span style="color: #a31515"&gt;&amp;#39;请求失败&amp;#39;&lt;/span&gt;, description: &lt;span style="color: #a31515"&gt;`${&lt;/span&gt;jsonBody.code&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;jsonBody.msg&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;, duration: &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;});
        console.log(&lt;span style="color: #a31515"&gt;`${&lt;/span&gt;jsonBody.code&lt;span style="color: #a31515"&gt;}, ${&lt;/span&gt;jsonBody.msg&lt;span style="color: #a31515"&gt;}`&lt;/span&gt;);
      }
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并且统一封装发起请求的逻辑：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;export&lt;/span&gt; &lt;span style="color: #0000ff"&gt;function&lt;/span&gt; corsFetch(url, init, httpCodeCallback, msgCodeCallback) {
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; host = myHost();
  &lt;span style="color: #0000ff"&gt;let&lt;/span&gt; urlPrefix = host;
  &lt;span style="color: #008000"&gt;// 自带 host，则不额外补充 host 前缀&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (url.startsWith(&lt;span style="color: #a31515"&gt;&amp;quot;http://&amp;quot;&lt;/span&gt;) || url.startsWith(&lt;span style="color: #a31515"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;)) {
    urlPrefix = &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
  }
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; httpCodeHandler = httpCodeCallback === &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; ? defaultHTTPCodeHandler : httpCodeCallback;
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; msgCodeHandler = msgCodeCallback === &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt; ? defaultMsgCodeHandler : msgCodeCallback;
  &lt;span style="color: #008000"&gt;// 对于线上环境或者测试环境，不跨域&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (host === PROD_ENV_HOST || host === TEST_ENV_HOST) {
    &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; promise = fetch(urlPrefix + url, init);
    promise.then((response) =&amp;gt; httpCodeHandler(response));
    promise.then((response) =&amp;gt; msgCodeHandler(response));
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; promise;
  }
  &lt;span style="color: #008000"&gt;// 对于本地测试环境，跨域访问预发环境 API 数据，方便测试&lt;/span&gt;
  &lt;span style="color: #0000ff"&gt;let&lt;/span&gt; corsInit = {
    credentials: &lt;span style="color: #a31515"&gt;&amp;#39;include&amp;#39;&lt;/span&gt;,
    mode: &lt;span style="color: #a31515"&gt;&amp;#39;cors&amp;#39;&lt;/span&gt;,
    redirect: &lt;span style="color: #a31515"&gt;&amp;#39;follow&amp;#39;&lt;/span&gt;,
  };
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (init !== &lt;span style="color: #0000ff"&gt;undefined&lt;/span&gt;) {
    corsInit = { ...corsInit, ...init };
  }
  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (urlPrefix !== &lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&lt;/span&gt;) {
    urlPrefix = TEST_ENV_HOST;
  }
  &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; promise = fetch(urlPrefix + url, corsInit);
  promise.then((response) =&amp;gt; httpCodeHandler(response));
  promise.then((response) =&amp;gt; msgCodeHandler(response));
  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; promise;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中为了方便本地开发测试，允许本地开发环境跨域访问测试环境（最好不要直接跨越访问生产环境），并且自动区分，corsFetch 调用方无感知。&lt;/p&gt;</content><category term="其他"></category><category term="总结"></category><category term="Python"></category></entry><entry><title>Reactor 官方文档翻译简化版</title><link href="http://youngsterxyf.github.io/2019/06/26/simplified-reactor-doc-zh/" rel="alternate"></link><published>2019-06-26T00:00:00+08:00</published><updated>2019-06-26T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-06-26:/2019/06/26/simplified-reactor-doc-zh/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://projectreactor.io/docs/core/release/reference/"&gt;Reactor 3 Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. 起步&lt;/h3&gt;
&lt;h4&gt;1.1 Reactor 简介&lt;/h4&gt;
&lt;p&gt;Reactor 是为 JVM 准备的一个完全非阻塞的反应式编程基础组件，支持高效的需求管理（以管理“反压”的形式），直接与 Java 8 的函数式 API 集成，尤其是 &lt;code&gt;CompletableFuture&lt;/code&gt;、&lt;code&gt;Stream&lt;/code&gt; 以及 &lt;code&gt;Duration&lt;/code&gt;，提供可组合的异步序列 API - &lt;code&gt;Flux&lt;/code&gt;（适用于 N 个元素的序列）和 &lt;code&gt;Mono&lt;/code&gt;（适用于 0 或 1个元素的序列）--- 并且全面地（extensively）实现了 &lt;a href="https://www.reactive-streams.org/"&gt;反应式流（Reative Streams）&lt;/a&gt; 规范。&lt;/p&gt;
&lt;p&gt;借助 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://projectreactor.io/docs/core/release/reference/"&gt;Reactor 3 Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. 起步&lt;/h3&gt;
&lt;h4&gt;1.1 Reactor 简介&lt;/h4&gt;
&lt;p&gt;Reactor 是为 JVM 准备的一个完全非阻塞的反应式编程基础组件，支持高效的需求管理（以管理“反压”的形式），直接与 Java 8 的函数式 API 集成，尤其是 &lt;code&gt;CompletableFuture&lt;/code&gt;、&lt;code&gt;Stream&lt;/code&gt; 以及 &lt;code&gt;Duration&lt;/code&gt;，提供可组合的异步序列 API - &lt;code&gt;Flux&lt;/code&gt;（适用于 N 个元素的序列）和 &lt;code&gt;Mono&lt;/code&gt;（适用于 0 或 1个元素的序列）--- 并且全面地（extensively）实现了 &lt;a href="https://www.reactive-streams.org/"&gt;反应式流（Reative Streams）&lt;/a&gt; 规范。&lt;/p&gt;
&lt;p&gt;借助 &lt;code&gt;reactor-netty&lt;/code&gt; 项目，Reactor 也支持进程间的非阻塞通信，适用于微服务架构。&lt;code&gt;reactor-netty&lt;/code&gt; 为 HTTP（包括 Websockets）、TCP 以及 UDP 提供支持反压的网络引擎，完全支持反应式编码解码。&lt;/p&gt;
&lt;h4&gt;1.2 理解 BOM&lt;/h4&gt;
&lt;p&gt;Reactor 3 开始采用 BOM （Bill of Materials，物料清单）发布模型（自 &lt;code&gt;reactor-core 3.0.4&lt;/code&gt; 开始，使用 &lt;code&gt;Aluminium&lt;/code&gt;（铝）版本序列），一个版本包含一组相关组件的版本，这些版本组件之间兼容性非常好，允许这些组件采用不同的版本命名方式。&lt;/p&gt;
&lt;p&gt;BOM 发布模型本身也是版本化的，以一个代号后接一个修饰词来命名一个版本序列。如下是一个示例列表：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;Aluminium-RELEASE&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;Californium-BUILD-SNAPSHOT&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;Aluminium-SR1&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;Bismuth-RELEASE&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;Californium-SR32&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代号等价于常规的 &lt;code&gt;大版本号.小版本号&lt;/code&gt; 形式，通常以字母升序方式取自 &lt;a href="https://en.wikipedia.org/wiki/Periodic_table#Overview"&gt;元素周期表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;按照时间顺序，修饰词分别为如下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUILD-SNAPSHOT：为开发测试构建的版本。&lt;/li&gt;
&lt;li&gt;M1 .. N：里程碑版本或者开发者预览版本。&lt;/li&gt;
&lt;li&gt;RELEASE：一个代号系列中的首个 GA（General Availability 通用）发行版。&lt;/li&gt;
&lt;li&gt;SR1 .. N：一个代号系列中的后续 GA 发行版 - 相当于一个补丁版本。（SR 代表 “Service Release”（服务版本））&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3 如何获取 Reactor&lt;/h4&gt;
&lt;h5&gt;1.3.1 以 Maven 管理依赖包&lt;/h5&gt;
&lt;p&gt;Maven 原生支持 BOM 模型概念。首先，在你的 &lt;code&gt;pom.xml&lt;/code&gt; 文件添加如下代码片段来引入 BOM：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt; 
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;reactor-bom&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;Bismuth-RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;备注：注意其中的 &lt;code&gt;dependencyManagement&lt;/code&gt; 标签，添加到 &lt;code&gt;dependencies&lt;/code&gt; 一节中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果顶部标签（&lt;code&gt;dependencyManagement&lt;/code&gt;）已经存在，则只添加上面该标签的内部内容。&lt;/p&gt;
&lt;p&gt;接下来，将依赖包添加到项目中，和一般依赖包一样，不过没有 &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;reactor-core&amp;lt;/artifactId&amp;gt; 
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;reactor-test&amp;lt;/artifactId&amp;gt; 
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;1.3.2 以 Gradle 管理依赖包&lt;/h5&gt;
&lt;p&gt;Gradle 核心并不支持 Maven BOM，不过可以借助 Spring 的 &lt;a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"&gt;gradle-dependency-management&lt;/a&gt; 插件。&lt;/p&gt;
&lt;p&gt;首先，应用插件，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;plugins {&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;    id &amp;quot;io.spring.dependency-management&amp;quot; version &amp;quot;1.0.6.RELEASE&amp;quot;&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后使用它来引入 BOM，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;dependencyManagement {&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;     imports {&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;          mavenBom &amp;quot;io.projectreactor:reactor-bom:Bismuth-RELEASE&amp;quot;&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;     }&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后将依赖添加到项目中，无需指定版本号，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;dependencies {&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;     compile &amp;#39;io.projectreactor:reactor-core&amp;#39; &lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 反应式编程简介&lt;/h3&gt;
&lt;p&gt;Reactor 是反应式编程范式的一个实现。反应式编程的定义归纳起来，如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反应式编程是一个异步编程范式，关注数据流和变化的传播。这意味着通过被采用编程语言可以轻松地表达静态（比如 数组）或动态（比如 事件发射器）数据流。 --- https://en.wikipedia.org/wiki/Reactive_programming&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反应式编程方向的首个重要工作是：微软在 .NET 生态体系中创建了反应式扩展（Rx）库，然后 RxJava 在 JVM 上实现了反应式编程。时光飞逝，经 Reative Streams 的大力推进，Java 社区终于出现了反应式编程标准，该规范定义了一组接口以及 JVM 上反应式编程库之间的交互规则。Java 9 标准库已将这组接口集成到 &lt;code&gt;Flow&lt;/code&gt; 类（译注：见&lt;a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html"&gt;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html&lt;/a&gt;）中。&lt;/p&gt;
&lt;p&gt;反应式编程范式在面向对象语言中通常表现为一个观察者设计模式的扩展。你也可以将主流的反应式流模式（reactive streams pattern）和大家熟知的迭代器设计模式做对比，所有这些库中都存在对标于 &lt;code&gt;Iterable&lt;/code&gt; - &lt;code&gt;Iterator&lt;/code&gt; 的概念（译注：比如 发布者-消费者）。主要差别在于：迭代器是基于 pull 方式，反应式流则基于 push 方式。&lt;/p&gt;
&lt;p&gt;使用迭代器是一个命令式编程的模式，即使如何访问数据（accessing values）完全是 &lt;code&gt;Iterable&lt;/code&gt; 的职责，但实际上，何时访问序列中的下一个（&lt;code&gt;next()&lt;/code&gt;）值取决于开发者的选择。在反应式流中，上述 &lt;code&gt;Iterable&lt;/code&gt; - &lt;code&gt;Iterator&lt;/code&gt; 对的等价物为 &lt;code&gt;Publisher&lt;/code&gt; - &lt;code&gt;Subscriber&lt;/code&gt;。不过，在出现新的数据/事件时，由 &lt;code&gt;Publisher&lt;/code&gt; 通知 &lt;code&gt;Subscriber&lt;/code&gt;，这个“推”特性也是实现反应式的关键之处。并且，在被推送的值上应用哪些操作是声明式表达而不是命令式表达的：程序员表达的是计算逻辑而不是描述精确的控制流。&lt;/p&gt;
&lt;p&gt;除了“推”的特性，反应式流也良好地定义了如何处理错误和结束流。一个 &lt;code&gt;Publisher&lt;/code&gt; 可以向它的 &lt;code&gt;Subscriber&lt;/code&gt; 推送新的值（通过调用订阅者的 &lt;code&gt;onNext&lt;/code&gt; 方法），也可以推送错误（调用 &lt;code&gt;onError&lt;/code&gt; 方法）或结束（调用 &lt;code&gt;onComplete&lt;/code&gt;方法）信号。错误和结束信号都可以终结事件序列。简而言之，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;onNext x 0..N [onError | onComplete]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个方式非常灵活。这个模式支持“没有值”、“一个值”或“n个值”（包括值无限的序列，比如时钟的持续滴答事件）的各种使用场景。&lt;/p&gt;
&lt;p&gt;但是，起初，我们为什么需要这样一个异步的反应式的编程库？&lt;/p&gt;
&lt;h4&gt;2.1 阻塞即是资源浪费&lt;/h4&gt;
&lt;p&gt;现代的软件应用，并发用户量非常巨大，即使现代硬件的处理能力一直在提升，软件的性能仍旧是一个关键问题。&lt;/p&gt;
&lt;p&gt;宽泛来讲，提升一个程序的性能，有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;并行化&lt;/strong&gt; 使用更多的线程和更多的硬件资源。&lt;/li&gt;
&lt;li&gt;对于当前的硬件资源，&lt;strong&gt;寻求更高效的使用方式&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，Java 开发者会使用阻塞性的代码编写程序，这种代码编写方式容易触及性能瓶颈，然后引入更多的线程来运行相似的阻塞性代码。但是，这种资源利用的扩展方式很快就会引发竞态（contention）和并发的问题。&lt;/p&gt;
&lt;p&gt;更糟糕的是，阻塞就意味着浪费资源。如果你稍加分析，就会发现一旦程序牵涉一些等待延迟（尤其是 I/0 操作，比如等待一个数据库请求或者一个网络调用），资源就会被浪费，因为此时线程（可能是大量线程）是空闲的，等待着数据。&lt;/p&gt;
&lt;p&gt;因此，并行化方式并非银弹。为了压榨出硬件的全部能力，并行化是必要的，但并行化的代码理解（reason about）起来也非常复杂，实际威力也会因为资源浪费而大打折扣。&lt;/p&gt;
&lt;h4&gt;2.2 异步可以解决问题吗？&lt;/h4&gt;
&lt;p&gt;前面提到的第二种方式 - 寻求更高效的使用方式 - 是资源浪费问题的一个解决方案。通过编写异步非阻塞的代码，在发生阻塞等待时，切换执行另一个活跃任务，活跃任务使用的是相同的底层资源，然后在异步处理过程结束后再切回到当前进程来执行。&lt;/p&gt;
&lt;p&gt;但是我们如何编写在 JVM 上异步执行的代码？ Java 提供了两种异步编程模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回调&lt;/strong&gt;：异步方法没有返回值，但接受一个额外的 &lt;code&gt;callback（回调）&lt;/code&gt;参数（一个 lambda 表达式或匿名类），在得到异步处理结果时会调用这个回调。一个众所周知的例子是 Swing 的 &lt;code&gt;EventListener&lt;/code&gt; 派生类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Future&lt;/strong&gt;：这种异步方法在调用时会&lt;em&gt;即刻&lt;/em&gt;返回一个 &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;。这个异步过程会计算出一个 &lt;code&gt;T&lt;/code&gt; 类型的值，不过需要通过 &lt;code&gt;Future&lt;/code&gt; 对象来访问。计算出来的值不能立即可用，可以对 &lt;code&gt;Future&lt;/code&gt; 对象进行探询直到值计算出来。例如：&lt;code&gt;ExecutorService&lt;/code&gt; 运行 &lt;code&gt;Callable&amp;lt;T&amp;gt;&lt;/code&gt; 任务就是提供 &lt;code&gt;Future&lt;/code&gt; 对象来获取异步结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这两种技术方案就足够好了吗？在很多使用场景下并不理想，这两种方式都有局限。&lt;/p&gt;
&lt;p&gt;多个回调难以组合使用，容易导致代码难以阅读和维护（就是所谓的“回调地狱”）。&lt;/p&gt;
&lt;p&gt;来看一个例子：在界面上为用户显示他最喜爱的5个物件，如果用户还没有任何喜欢的物件，则给出建议物件。这个逻辑涉及3个服务（第一个服务提供物件 ID，第二个服务获取物件的详细信息，第三个服务提供建议物件的详细信息），如下所示：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;回调地域的示例&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userService.getFavorites(userId, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Callback&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;() { &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onSuccess(List&amp;lt;String&amp;gt; list) { &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (list.isEmpty()) { &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            suggestionService.getSuggestions(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Callback&amp;lt;List&amp;lt;Favorite&amp;gt;&amp;gt;() {
                &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onSuccess(List&amp;lt;Favorite&amp;gt; list) { &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
                    UiUtils.submitOnUiThread(() -&amp;gt; { &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
                        list.stream()
                            .limit(5)
                            .forEach(uiList::show); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;
                    })
                }

                &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onError(Throwable error) { &lt;span style="color: #008000"&gt;// 7&lt;/span&gt;
                    UiUtils.errorPopup(error);
                }
            });
        } &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; {
            list.stream() &lt;span style="color: #008000"&gt;// 8&lt;/span&gt;
                .limit(5)
                .forEach(favId -&amp;gt; favoriteService.getDetails(favId, &lt;span style="color: #008000"&gt;// 9&lt;/span&gt;
                    &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Callback&amp;lt;Favorite&amp;gt;() {
                        &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onSuccess(Favorite details) {
                            UiUtils.submitOnUiThread(() -&amp;gt; uiList.show(details));
                        }

                        &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onError(Throwable error) {
                            UiUtils.errorPopup(error);
                        }
                    }
                ));
        }
    }

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onError(Throwable error) {
        UiUtils.errorPopup(error);
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;基于回调的服务：&lt;code&gt;Callback&lt;/code&gt; 接口定义了两个方法，异步处理成功时调用其中的 &lt;code&gt;onSuccess&lt;/code&gt;，异步处理发生错误时调用 &lt;code&gt;onError&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第一个服务以其结果 - 喜爱物件的 ID 列表 - 调用回调方法。&lt;/li&gt;
&lt;li&gt;如果列表为空，则必须转到 &lt;code&gt;suggestionService&lt;/code&gt; 来处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;suggestionService&lt;/code&gt; 向第二个回调传递一个 &lt;code&gt;List&amp;lt;Favorite&amp;gt;&lt;/code&gt; 列表。&lt;/li&gt;
&lt;li&gt;对于 UI 渲染，必须让消费数据的代码运行在 UI 的线程中。&lt;/li&gt;
&lt;li&gt;这里我们使用了 Java 8 的 &lt;code&gt;Stream&lt;/code&gt; 将建议物件的数量限制为5个，然后在 UI 中渲染成一个图形化列表。&lt;/li&gt;
&lt;li&gt;在每个回调层级，我们都以相同的方式处理错误：在弹出框中显示错误信息。&lt;/li&gt;
&lt;li&gt;回到 喜爱物件 ID 列表的层级。如果 &lt;code&gt;userService&lt;/code&gt; 服务返回一个不为空的 ID 列表，则转到 &lt;code&gt;favoriteService&lt;/code&gt; 去获取带详细信息的 &lt;code&gt;Favorite&lt;/code&gt; 对象。因为只需要5个喜爱物件，所以先使用流式处理将 ID 数量限制为 5 个。&lt;/li&gt;
&lt;li&gt;再一次，使用一个回调。这一次我们获取到完整的 &lt;code&gt;Favorite&lt;/code&gt; 对象，并在 UI 线程中将其在 UI 上渲染出来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看看有多少代码，理解起来也有点困难，其中也有一些重复的代码片段。再来看看使用 Reactor 如何来实现这段逻辑：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;和回调实现方式等价的 Reactor 实现&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userService.getFavorite(userId) &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
            .flatMap(favoriteService::getDetails) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
            .switchIfEmpty(suggestionService.getSuggestions()) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            .take(5) &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
            .publishOn(UiUtils.uiThreadScheduler()) &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
            .subscribe(uiList::show, UiUtils::errorPopup); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;开启一个喜爱物件 ID 的流。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;异步地&lt;/em&gt;将 ID 转换成带详细信息的 &lt;code&gt;Favorite&lt;/code&gt; 对象（&lt;code&gt;flatMap&lt;/code&gt;）。至此我们得到一个 &lt;code&gt;Favorite&lt;/code&gt; 对象流。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;Favorite&lt;/code&gt; 流为空，则切换到备选处理方式 &lt;code&gt;suggestionService&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;我们只关注产出流中的前（最多）5个元素。&lt;/li&gt;
&lt;li&gt;最后，在 UI 线程中处理每份数据。&lt;/li&gt;
&lt;li&gt;真正触发流的处理：描述了如何处理最终的数据（显示为一个 UI 列表），以及在发生错误时如何处理（显示一个弹出框）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果希望确保在 800ms 以内获取到喜爱物件 ID 列表，如果超时，则从缓存中获取数据，如何实现？基于回调的代码实现，这是一个复杂的任务。使用 Reactor，只需在操作链中添加一个 &lt;code&gt;timeout&lt;/code&gt; 算子就能轻松搞定，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;超时回退处理的 Reactor 代码示例&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;userService.getFavorites(userId)
            .timeout(Duration.ofMillis(800)) &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
            .onErrorResume(cacheService.cachedFavoritesFor(userId)) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
            .flatMap(favoriteService::getDetails)
            .switchIfEmpty(suggestionService.getSuggestions())
            .take(5)
            .publishOn(UiUtils.uiThreadScheduler())
            .subscribe(uiList::show, UiUtils::errorPopup);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;如果前置处理超过 800ms 还没输出任何事件，则下发一个错误。&lt;/li&gt;
&lt;li&gt;在收到错误事件时，回退到调用 &lt;code&gt;cacheService&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;操作链的余下部分和前一个例子类似。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;Future&lt;/code&gt; 对象相比回调更好一点，不过组合使用起来也不太方便，尽管 Java 8 引入 &lt;code&gt;CompletableFuture&lt;/code&gt; 改善了这一问题。将多个 &lt;code&gt;Future&lt;/code&gt; 对象组织在一起，可行但并不容易。另外，&lt;code&gt;Future&lt;/code&gt; 还有其它问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易碰到另一个阻塞的情况：调用 &lt;code&gt;Future&lt;/code&gt; 对象的 &lt;code&gt;get()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;不支持惰性计算。&lt;/li&gt;
&lt;li&gt;对多个值的处理和高级错误处理缺乏支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看看另一个例子：先获取一个 ID 列表，然后根据 ID 获取一个名字以及获取一个统计数值，再将名字和统计数值组合起来使用，这几个步骤都必须是异步的。如下示例以一组 &lt;code&gt;CompletableFuture&lt;/code&gt; 来实现这个逻辑：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CompletableFuture&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; ids = ifhIds(); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

CompletableFuture&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; results = ids.thenComposeAsync(l -&amp;gt; { &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
    Stream&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; zip = 
            l.stream().map(i -&amp;gt; { &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
                CompletableFuture&amp;lt;String&amp;gt; nameTask = ifhName(i); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
                CompletableFuture&amp;lt;Integer&amp;gt; statTask = ifhStat(i); &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; nameTask.thenCombineAsync(statTask, (name, stat) -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;Name &amp;quot;&lt;/span&gt; + name + &lt;span style="color: #a31515"&gt;&amp;quot; has stats &amp;quot;&lt;/span&gt; + stat); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;
            });
    List&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; combinationList = zip.collect(Collectors.toList()); &lt;span style="color: #008000"&gt;// 7&lt;/span&gt;
    CompletableFuture&amp;lt;String&amp;gt;[] combinationArray = combinationList.toArray(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; CompletableFuture[combinationList.size()]);

    CompletableFuture&amp;lt;Void&amp;gt; allDone = CompletableFuture.allOf(combinationArray); &lt;span style="color: #008000"&gt;// 8&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; allDone.thenApply(v -&amp;gt; combinationList.stream()
                    .map(CompletableFuture::join) &lt;span style="color: #008000"&gt;// 9&lt;/span&gt;
                    .collect(Collectors.toList()));
});

List&amp;lt;String&amp;gt; results = result.join(); &lt;span style="color: #008000"&gt;// 10&lt;/span&gt;
assertThat(results).contains(
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameJoe has stats 103&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameBart has stats 104&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameHenry has stats 105&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameNicole has stats 106&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #a31515"&gt;&amp;quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;一开始获得一个 &lt;code&gt;Future&lt;/code&gt; 结果 - 为后续处理提供一个 &lt;code&gt;id&lt;/code&gt; 列表。&lt;/li&gt;
&lt;li&gt;一旦获得 &lt;code&gt;id&lt;/code&gt; 列表就可以开始进一步的异步处理。&lt;/li&gt;
&lt;li&gt;逐个处理列表中的元素。&lt;/li&gt;
&lt;li&gt;异步获取关联的名字。&lt;/li&gt;
&lt;li&gt;异步获取关联的统计数值。&lt;/li&gt;
&lt;li&gt;组合两个异步结果。&lt;/li&gt;
&lt;li&gt;至此我们得到一个 &lt;code&gt;Future&lt;/code&gt; 对象列表，表示所有的组合任务。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;Future&lt;/code&gt; 对象数组传给 &lt;code&gt;CompletableFuture.allOf&lt;/code&gt; 方法，这个方法会输出一个 &lt;code&gt;Future&lt;/code&gt; 对象，当 &lt;code&gt;Future&lt;/code&gt; 对象数组代表的异步任务都完成时，这个 &lt;code&gt;Future&lt;/code&gt; 对象代表的异步任务也就完成了。&lt;/li&gt;
&lt;li&gt;此处的特殊之处在于：在（&lt;code&gt;allOf&lt;/code&gt; 返回的）&lt;code&gt;CompletableFuture&amp;lt;Void&amp;gt;&lt;/code&gt; 对象表示的异步任务结束时，遍历 &lt;code&gt;Future&lt;/code&gt; 对象列表（combinationList），使用 &lt;code&gt;join()&lt;/code&gt; 方法（此次不会阻塞，因为 &lt;code&gt;allOf&lt;/code&gt; 会确保所有异步任务都已完成）获取收集异步任务结果。&lt;/li&gt;
&lt;li&gt;触发执行整个异步处理流水线（调用 &lt;code&gt;join()&lt;/code&gt; 方法），然而等着异步处理完成并返回一个结果列表，就可以进行断言判断了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Reactor 自带了很多组合算子，可以简化这个处理过程的实现，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; ids = ifhrIds(); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

Flux&amp;lt;String&amp;gt; combinations = 
        ids.flatMap(id -&amp;gt; { &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
            Mono&amp;lt;String&amp;gt; nameTask = ifhrName(id); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            Mono&amp;lt;Integer&amp;gt; statTask = ifhrStat(id); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;

            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; nameTask.zipWith(statTask, &lt;span style="color: #008000"&gt;// 5&lt;/span&gt;
                    (name, stat) -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;Name &amp;quot;&lt;/span&gt; + name + &lt;span style="color: #a31515"&gt;&amp;quot; has stats &amp;quot;&lt;/span&gt; + stat);
        });

Mono&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = combinations.collectList(); &lt;span style="color: #008000"&gt;// 6&lt;/span&gt;

List&amp;lt;String&amp;gt; results = result.block(); &lt;span style="color: #008000"&gt;// 7&lt;/span&gt;
assertThat(results).containsExactly( &lt;span style="color: #008000"&gt;// 8&lt;/span&gt;
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameJoe has stats 103&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameBart has stats 104&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameHenry has stats 105&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameNicole has stats 106&amp;quot;&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;&amp;quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&amp;quot;&lt;/span&gt;
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;这次，一开始我们得到一个异步提供的字符串序列（&lt;code&gt;ids&lt;/code&gt;）（一个 &lt;code&gt;Flux&amp;lt;String&amp;gt;&lt;/code&gt; 对象）。&lt;/li&gt;
&lt;li&gt;对于序列中的每个元素，异步处理两次（在 &lt;code&gt;flatMap&lt;/code&gt; 的 lambda 参数值中）。&lt;/li&gt;
&lt;li&gt;获取关联的名字。&lt;/li&gt;
&lt;li&gt;获取关联的统计值。&lt;/li&gt;
&lt;li&gt;异步组合两个值&lt;/li&gt;
&lt;li&gt;在异步处理的结果可用时，将它们聚合到一个 &lt;code&gt;List&lt;/code&gt; 对象中。&lt;/li&gt;
&lt;li&gt;在实际项目中，我们通常会继续异步处理 &lt;code&gt;Flux&lt;/code&gt;，比如：异步组合使用它或者直接订阅它。最可能的是，返回这个 &lt;code&gt;Mono&lt;/code&gt; 类型的 &lt;code&gt;result&lt;/code&gt;。因为这里只是个测试，所以使用了 block，等待处理结束，直接返回值的聚合列表。&lt;/li&gt;
&lt;li&gt;对结果进行断言判断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用回调和 &lt;code&gt;Future&lt;/code&gt; 对象的问题是类似的，反应式编程以 &lt;code&gt;发布者（Publisher）- 订阅者（Subscriber）&lt;/code&gt; 解决了这些问题。 &lt;/p&gt;
&lt;h4&gt;2.3 从命令式到反应式编程&lt;/h4&gt;
&lt;p&gt;反应式编程库，比如 Reactor，目标是解决 JVM 上“经典”异步处理方式的弊端，同时也专注于提供以下几个方面的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可组合性&lt;/strong&gt; 和 &lt;strong&gt;代码可读性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将数据视作一个&lt;strong&gt;流&lt;/strong&gt;，并提供丰富的&lt;strong&gt;算子&lt;/strong&gt;来操作流&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;订阅（subscriber）&lt;/strong&gt;之前不会实际做任何事情&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反压&lt;/strong&gt; 或者说 消费者通知生产者流速过高的能力&lt;/li&gt;
&lt;li&gt;与并发无关（concurrency-agnostic）的&lt;strong&gt;高阶（high level）&lt;/strong&gt;抽象，&lt;strong&gt;适用性强（high value）&lt;/strong&gt;（译注：并发无关是指这种抽象对于并发非并发的场景都适用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. Reactor 核心特性&lt;/h3&gt;
&lt;p&gt;Reactor 项目的主要成果是 &lt;code&gt;reactor-core&lt;/code&gt; - 一个遵循&lt;a href="https://www.reactive-streams.org/"&gt;反应式流&lt;/a&gt;规范并支持 Java 8 的反应式编程库。&lt;/p&gt;
&lt;p&gt;Reactor 引入 2 个可组合的反应式类型（实现了 &lt;code&gt;Publisher&lt;/code&gt; 接口并且提供丰富的算子）： &lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt;。一个 &lt;code&gt;Flux&lt;/code&gt; 对象代表包含 0 到 N 个元素的反应式序列，&lt;code&gt;Mono&lt;/code&gt; 对象代表单值或空（0或1个元素）的结果。&lt;/p&gt;
&lt;h4&gt;3.1 Flux - 0-N 个值的异步序列&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/oKMX4rTvUViZRHj.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;3.2 Mono - 包含 0 或 1 个值的异步结果&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="https://i.loli.net/2020/06/14/8WxGgH9UkcQwuX4.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;3.3 创建一个 Flux 或 Mono 并进行订阅的一些简单方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 的类中包含大量的工厂方法，上手使用 Reactor 最简单的方式是从中选择一个用起来。&lt;/p&gt;
&lt;p&gt;例如，创建一个 &lt;code&gt;String&lt;/code&gt; 序列，可以逐个列举出这些字符串，或者将这些字符串放到一个集合中，然后基于这个集合创建一个 Flux，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;&lt;span style="border: 1px solid #FF0000"&gt;&lt;/span&gt;String&amp;gt; seq1 = Flux.just(&lt;span style="color: #a31515"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;);

List&amp;lt;String&amp;gt; iterable = Arrays.asList(&lt;span style="color: #a31515"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;);
Flux&amp;lt;String&amp;gt; seq2 = Flux.fromIterable(iterable);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其它一些工厂方法的使用示例如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Mono&amp;lt;String&amp;gt; noData = Mono.empty();
Mono&amp;lt;String&amp;gt; data = Mono.just(&lt;span style="color: #a31515"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;);
Flux&amp;lt;Integer&amp;gt; numbersFromFiveToSeven = Flux.range(5, 3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于订阅操作，&lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 借助了 Java 8 的 lambda 表达式。有大量 &lt;code&gt;.subscribe()&lt;/code&gt; 的重载方法/变种方法（variants）可选选择使用，使用 lambda 表达式来实现回调的不同组合，如下所示是这些方法的签名：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Flux 中基于 lambda 表达式的订阅方法变种&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;subscribe();

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer);

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Throwable&amp;gt; errorConsumer);

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Throwable&amp;gt; errorConsumer,
          Runnable completeConsumer);

subscribe(Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; T&amp;gt; consumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Throwable&amp;gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&amp;lt;? &lt;span style="color: #0000ff"&gt;super&lt;/span&gt; Subscription&amp;gt; subscriptionConsumer);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;这些订阅方法都会返回一个订阅操作的引用，当不再需要更多的数据时，可以使用这个引用来取消订阅。一旦取消，数据源就应该停止产出数据，并清理使用的所有资源。这一 “取消并清理” 行为在 Reactor 中以通用的 &lt;code&gt;Disposable&lt;/code&gt; 接口来表现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;3.3.1 lambda 表达式的替代方案：BaseSubscriber&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 提供了一个相比上面那么订阅方法更通用的 &lt;code&gt;subscribe&lt;/code&gt; 方法，其参数是一个完整的 &lt;code&gt;Subscriber&lt;/code&gt; 实例，而不是根据几个 lambda 表达式组合出一个 &lt;code&gt;Subscriber&lt;/code&gt; 实例。为了方便实现这样的一个 &lt;code&gt;Subscriber&lt;/code&gt;，Reactor 提供了一个名为 &lt;code&gt;BaseSubscriber&lt;/code&gt; 的可扩展的抽象类。&lt;/p&gt;
&lt;p&gt;下面来实现一个，我们将其命名为 &lt;code&gt;SampleSubscriber&lt;/code&gt;。如下示例演示了如何将其应用到一个 &lt;code&gt;Flux&lt;/code&gt; 序列上：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;SampleSubscriber&amp;lt;Integer&amp;gt; ss = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SampleSubscriber&amp;lt;Integer&amp;gt;();
Flux&amp;lt;Integer&amp;gt; ints = Flux.range(1, 4);
&lt;span style="color: #008000"&gt;//&lt;/span&gt;
ints.subscribe(i -&amp;gt; System.out.println(i),
    error -&amp;gt; System.err.println(&lt;span style="color: #a31515"&gt;&amp;quot;Error &amp;quot;&lt;/span&gt; + error),
    () -&amp;gt; {System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;Done&amp;quot;&lt;/span&gt;);},
    s -&amp;gt; s.request(10));
&lt;span style="color: #008000"&gt;//&lt;/span&gt;
ints.subscribe(ss);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如下示例演示了 &lt;code&gt;SampleSubscriber&lt;/code&gt; 继承自 &lt;code&gt;BaseSubscriber&lt;/code&gt; 的一个最简化实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;package&lt;/span&gt; io.projectreactor.samples;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.reactivestreams.Subscription;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; reactor.core.publisher.BaseSubscriber;

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;SampleSubscriber&lt;/span&gt;&amp;lt;T&amp;gt; &lt;span style="color: #0000ff"&gt;extends&lt;/span&gt; BaseSubscriber&amp;lt;T&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnSubscribe(Subscription subscription) {
        System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;Subscribed&amp;quot;&lt;/span&gt;);
        request(1);
    }

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnNext(T value) {
        System.out.println(value);
        request(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;BaseSubscriber&lt;/code&gt; 还提供了一个 &lt;code&gt;requestUnbounded()&lt;/code&gt; 方法来切换到无限消费模式（相当于 &lt;code&gt;request(Long.MAX_VALUES)&lt;/code&gt;），另外也提供了一个 &lt;code&gt;cancel()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;hookOnSubscribe&lt;/code&gt; 和 &lt;code&gt;hookOnNext&lt;/code&gt;，&lt;code&gt;BaseSubscriber&lt;/code&gt; 还提供了其他钩子方法（方法体为空，提供继承重写）：&lt;code&gt;hookOnComplete&lt;/code&gt;、&lt;code&gt;hookOnError&lt;/code&gt;、&lt;code&gt;hookOnCancel&lt;/code&gt; 以及 &lt;code&gt;hookFinally&lt;/code&gt;（当事件/消息序列（流）终止时，一定会调用该方法，调用时会传入一个 &lt;code&gt;SignalType&lt;/code&gt; 类型参数表示终止的类型）。&lt;/p&gt;
&lt;h5&gt;3.3.2 关于反压和调整请求量的方式&lt;/h5&gt;
&lt;p&gt;在 Reactor 中实现反压，是通过向上游算子发送一个 &lt;code&gt;请求（request）&lt;/code&gt;来逐级传播消费者的压力，直到数据源。当前请求的总量有时又称为当前的“需求量” 或者 “待满足（pending）的请求量”。需求量的上限是 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;，表示一个无限量的请求（意思是“尽快产出数据“ - 反压也就失效了）。&lt;/p&gt;
&lt;p&gt;最终的订阅者在订阅之前会发出首个请求，订阅所有消息/数据最直接的方式是即刻触发一个无限量（Long.MAX_VALUE）的请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;subscribe()&lt;/code&gt; 以及大部分基于 lambda 表达式的变种方法（除了那个接受 &lt;code&gt;Consumer&amp;lt;Subscription&amp;gt;&lt;/code&gt; 类型参数的方法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;block()&lt;/code&gt;、&lt;code&gt;blockFirst()&lt;/code&gt; 和 &lt;code&gt;blockLast()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;toIterable()&lt;/code&gt; 或 &lt;code&gt;toStream()&lt;/code&gt; 进行遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对首个请求进行定制的最简单方式是以一个 &lt;code&gt;BaseSubscriber&lt;/code&gt; 派生类实例来 &lt;code&gt;subscribe&lt;/code&gt;，派生类重写 &lt;code&gt;BaseSubscriber&lt;/code&gt; 的 &lt;code&gt;hookOnSubscribe&lt;/code&gt; 方法，如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.range(1, 10)
    .doOnRequest(r -&amp;gt; System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;request of &amp;quot;&lt;/span&gt; + r))
    .subscribe(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; BaseSubscriber&amp;lt;Integer&amp;gt;() {

      @Override
      &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; hookOnNext(Integer integer) {
        System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;Cancelling after having received &amp;quot;&lt;/span&gt; + integer);
        cancel();
      }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面这个代码片段输出如下内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;request of 1&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;Cancelling after having received 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;改变下游需求量的算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谨记：订阅时指定的需求量，上游操作链中的每个算子都可以对其作出调整。一个典型案例是 &lt;code&gt;buffer(N)&lt;/code&gt; 算子：如果它收到一个 &lt;code&gt;request(2)&lt;/code&gt; 请求，它会理解为2个缓冲区的请求量。因为缓冲区需要 N 个元素才认为是满的，所以 &lt;code&gt;buffer&lt;/code&gt; 算子将请求量调整成了 &lt;code&gt;2 x N&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你也许也注意到某些算子存在这样的变种 - 接受一个名为 &lt;code&gt;prefetch&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 类型参数。这是另外一类修改下游请求量的算子。这类算子（比如 &lt;code&gt;flatMap&lt;/code&gt;）通常是处理内部序列（inner sequences），从每个进入的元素派生出一个 &lt;code&gt;Publisher&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;预取（prefetch）&lt;/code&gt;是调整内部序列请求量的一个方式。如果未指定，多数这类算子会以 32 为初始需求量。&lt;/p&gt;
&lt;p&gt;这类算子通常也会实现一个&lt;strong&gt;填补优化方案&lt;/strong&gt;：算子一旦看到 25% 的预取请求量已完成，就会向上游再发起 25% 的请求量。这是一个启发式优化，如此这类算子就可以主动地为即将到来的请求量做好准备。&lt;/p&gt;
&lt;p&gt;最后，再介绍一对直接用于调整请求量的算子：&lt;code&gt;limitRate&lt;/code&gt; 和 &lt;code&gt;limitRequest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;limitRate(N)&lt;/code&gt; 把下游的请求量拆分成多个更小量的请求向上游传播。例如，一个 &lt;code&gt;100&lt;/code&gt; 的请求传到算子 &lt;code&gt;limitRate(10)&lt;/code&gt;，则会变成 10 次请求，一次请求 10，传播到上游。注意：&lt;code&gt;limitRate&lt;/code&gt; 实际上以这种形式实现了前面提到的填补优化方案。&lt;/p&gt;
&lt;p&gt;这个算子有一个变种，允许开发者调整预取填补量（即算子变种的 &lt;code&gt;lowTide&lt;/code&gt; 参数）：&lt;code&gt;limitRate(highTide, lowTide)&lt;/code&gt;。&lt;code&gt;lowTide&lt;/code&gt; 参数设定为 &lt;code&gt;0&lt;/code&gt; 时，会导致严格限制一次请求 &lt;code&gt;highTide&lt;/code&gt; 个，而不是经填补策略进一步调整过的一次请求量。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;limitRequest(N)&lt;/code&gt; 则是限制了下游最大的需求总量。它会累加请求量直到 &lt;code&gt;N&lt;/code&gt;。如果一次请求没有让需求总量超过 &lt;code&gt;N&lt;/code&gt;，则这次请求会完整地传播到上游（译注：意思是如果一次请求让需求总量超过了 &lt;code&gt;N&lt;/code&gt;，这次请求的请求量会被裁剪）。如果数据源发出的数据总量达到了限制的总量，&lt;code&gt;limitRequest&lt;/code&gt; 则认为这个序列可以结束了，向下游发送一个 &lt;code&gt;onComplete&lt;/code&gt; 信号，并取消数据源。&lt;/p&gt;
&lt;h4&gt;3.4 动态地（programmatically）创建一个序列&lt;/h4&gt;
&lt;h5&gt;3.4.1 同步的 generate&lt;/h5&gt;
&lt;p&gt;动态创建一个 &lt;code&gt;Flux&lt;/code&gt; 最简单的方式是借助 &lt;code&gt;generate&lt;/code&gt; 方法，该方法接受一个生成器函数。&lt;/p&gt;
&lt;p&gt;这一方式可以实现&lt;strong&gt;同步的&lt;/strong&gt;且&lt;strong&gt;一个接一个&lt;/strong&gt;地下发数据，这意味着接收方（sink）是一个 &lt;code&gt;SynchronousSink&lt;/code&gt;，其 &lt;code&gt;next()&lt;/code&gt; 方法在一次回调方法调用中最多只能调用一次。可以在其后再调用 &lt;code&gt;error(Throwable)&lt;/code&gt; 或 &lt;code&gt;complete()&lt;/code&gt;，视你的需求而定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;generate&lt;/code&gt; 方法变种的这个应该是最有用的：允许保持一个状态，在调用接收方的 &lt;code&gt;next&lt;/code&gt; 方法时可以基于这个状态来决定下发什么数据。那么这个生成器函数就成了一个 &lt;code&gt;BiFunction&amp;lt;S, SynchronousSink&amp;lt;T&amp;gt;, S&amp;gt;&lt;/code&gt; 实例，其中 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 即是状态对象的类型。对于初始状态，可以提供一个 &lt;code&gt;Supplier&amp;lt;S&amp;gt;&lt;/code&gt; 来获取，这样生成器函数每轮调用都会返回一个新的状态。&lt;/p&gt;
&lt;p&gt;例如，可以使用一个 &lt;code&gt;int&lt;/code&gt; 实例作为状态：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;基于状态的 &lt;code&gt;generate&lt;/code&gt; 方法使用示例&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; flux = Flux.generate(
    () -&amp;gt; 0, &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
    (state, sink) -&amp;gt; {
        sink.next(&lt;span style="color: #a31515"&gt;&amp;quot;3 x &amp;quot;&lt;/span&gt; + state + &lt;span style="color: #a31515"&gt;&amp;quot; = &amp;quot;&lt;/span&gt; + 3*state); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (state == 10) sink.complete(); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; state + 1; &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;以 0 作为初始状态。&lt;/li&gt;
&lt;li&gt;基于状态（state）决定下发什么消息/数据。&lt;/li&gt;
&lt;li&gt;基于状态决定何时可以停止流/序列。&lt;/li&gt;
&lt;li&gt;返回一个新状态，下次调用时可以使用（除非在这次调用时已经终止序列）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以使用一个 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 类型的可变对象。比如，上面的示例可以使用一个 &lt;code&gt;AtomicLong&lt;/code&gt; 实例作为状态来重写，每轮调用都会改变它的值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; flux = Flux.generate(
    AtomicLong::&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;,
    (state, sink) -&amp;gt; {
        &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; i = state.getAndIncrement();
        sink.next(&lt;span style="color: #a31515"&gt;&amp;quot;3 x &amp;quot;&lt;/span&gt; + i + &lt;span style="color: #a31515"&gt;&amp;quot; = &amp;quot;&lt;/span&gt; + 3*i);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (i == 10) sink.complete();
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; state;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;如果状态对象在序列终止时需要清理一些资源，则应该使用 &lt;code&gt;generate(Supplier&amp;lt;S&amp;gt;, BiFunction, Consumer&amp;lt;S&amp;gt;)&lt;/code&gt; 变种方法来清理最后的状态实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下示例使用的 &lt;code&gt;generate&lt;/code&gt; 方法接受一个 &lt;code&gt;Consumer&lt;/code&gt; 类型参数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; flux = Flux.generate(
    AtomicLong::&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;,
    (state, sink) -&amp;gt; {
        &lt;span style="color: #2b91af"&gt;long&lt;/span&gt; i = state.getAndIncrement();
        sink.next(&lt;span style="color: #a31515"&gt;&amp;quot;3 x &amp;quot;&lt;/span&gt; + i + &lt;span style="color: #a31515"&gt;&amp;quot; = &amp;quot;&lt;/span&gt; + 3*i);
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (i == 10) sink.complete();
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; state;
    }, (state) -&amp;gt; System.out.println(&lt;span style="color: #a31515"&gt;&amp;quot;state: &amp;quot;&lt;/span&gt; + state));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;3.4.2 异步多线程的 create&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;create&lt;/code&gt; 是动态创建一个 &lt;code&gt;Flux&lt;/code&gt; 的更高级的方式，适用于每轮下发多个数据，甚至是从多个线程中下发数据。&lt;/p&gt;
&lt;p&gt;这个方法会向回调方法传入一个 &lt;code&gt;FluxSink&lt;/code&gt; 实例参数，在回调方法体中可以调用这个参数的 &lt;code&gt;next&lt;/code&gt;、&lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;complete&lt;/code&gt; 方法。与 &lt;code&gt;generate&lt;/code&gt; 不同，它没有基于状态的变种方法。另外，回调方法中，可以多线程地触发事件（trigger multi-threaded events）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;create&lt;/code&gt; 非常适用于将一个已有的 API （比如：一个基于监听器的异步 API）桥接到反应式上下文中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;create&lt;/code&gt; 并不会自动并行化执行你的代码，也不会让处理过程自动变成异步的，即使它可以配合异步 API 使用。如果在 &lt;code&gt;create&lt;/code&gt; 的 lambda 表达式中发生阻塞，就会存在死锁或者其它副作用的风险。即使借助 &lt;code&gt;subscribeOn&lt;/code&gt;，也要当心 &lt;code&gt;create&lt;/code&gt; lambda 表达式中长时间的阻塞（比如无限循环调用 &lt;code&gt;sink.next(t)&lt;/code&gt;）锁住流水线处理： （译注：异步的）数据请求可能根本得不到执行，因为（译注：线程池只有一个线程）同一个线程一直被无限循环占用着。使用 &lt;code&gt;subscribeOn(Scheduler, false)&lt;/code&gt; 变种方法：&lt;code&gt;requestOnSeparateThread = false&lt;/code&gt; 将使用 &lt;code&gt;Scheduler&lt;/code&gt; 的线程来执行 &lt;code&gt;create&lt;/code&gt; 方法的回调，在原始的线程中执行 &lt;code&gt;request&lt;/code&gt;，从而让数据仍然可以流动起来。（译注：此处逻辑有点绕，也可能是因为 subscribeOn 方法本身语义就不太直观）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们要使用一个基于监听器的 API，它按块处理数据，提供两类事件：（1）来了一块数据，（2）处理可以结束了（终止事件），如下 &lt;code&gt;MyEventListener&lt;/code&gt; 接口定义所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;MyEventListener&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onDataChunk(List&amp;lt;T&amp;gt; chunk);
    &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processComplete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们使用 &lt;code&gt;create&lt;/code&gt; 将这个 API 桥接到一个 &lt;code&gt;Flux&amp;lt;T&amp;gt;&lt;/code&gt; 实例上：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; bridge = Flux.create(sink -&amp;gt; {
    myEventProcessor.register(  &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MyEventListener&amp;lt;String&amp;gt;() { &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onDataChunk(List&amp;lt;String&amp;gt; chunk) {
                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(String s : chunk) {
                    sink.next(s); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
                }
            }

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processComplete() {
                sink.complete(); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            }
        }
    );
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;桥接到 &lt;code&gt;MyEventListener&lt;/code&gt; API&lt;/li&gt;
&lt;li&gt;数据块中每个元素都成了 &lt;code&gt;Flux&lt;/code&gt; 中的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;processComplete&lt;/code&gt; 事件转换成了 &lt;code&gt;onComplete&lt;/code&gt; 事件。&lt;/li&gt;
&lt;li&gt;所有这些逻辑都是在 &lt;code&gt;myEventProcessor&lt;/code&gt; 执行时异步完成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外，因为 &lt;code&gt;create&lt;/code&gt; 可以桥接异步 API，并管理反压，通过指定一个 &lt;code&gt;OverflowStrategy&lt;/code&gt; 策略，可以调整如何智能地处理反压：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IGNORE&lt;/code&gt; 完全忽略下游的反压请求。这一策略在下游的队列满时（when queues get full downstream）会导致 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常抛出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ERROR&lt;/code&gt; 在下游处理不过来时会下发（onError）一个 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常消息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DROP&lt;/code&gt; 如果下游还没准备好接收当前事件，则直接丢弃。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BUFFER&lt;/code&gt; （默认策略）如果下游处理不过来，则将所有事件放入缓冲区。（缓冲区大小无限制，所以可能会导致内存溢出&lt;code&gt;OutOfMemoryError&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Mono&lt;/code&gt; 也有一个 &lt;code&gt;create&lt;/code&gt; 生成器方法。Mono 的 create 方法传入回调的 &lt;code&gt;MonoSink&lt;/code&gt; 参数不允许下发多个消息，在第一个消息之后它会丢弃所有的消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;3.4.3 异步单线程的 push&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;push&lt;/code&gt; 的功能介于 &lt;code&gt;generate&lt;/code&gt; 和 &lt;code&gt;create&lt;/code&gt; 之间，适用于处理来自单个生产者的事件。&lt;code&gt;push&lt;/code&gt; 也可以是异步的，也可以使用 &lt;code&gt;create&lt;/code&gt; 支持的超限策略来管理反压，然而，同时（at a time）只能有一个生产线程调用 &lt;code&gt;next&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; bridge = Flux.push(sink -&amp;gt; {
    myEventProcessor.register(
        &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SingleThreadEventListener&amp;lt;String&amp;gt;() { &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onDataChunk(List&amp;lt;String&amp;gt; chunk) {
                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (String s: chunk) {
                    sink.next(&lt;span style="border: 1px solid #FF0000"&gt;&lt;/span&gt;s); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
                }
            }

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processComplete() {
                sink.complete(); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
            }

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; processError(Throwable e) {
                sink.error(e); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;
            }
        }
    );
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;桥接到 &lt;code&gt;SingleThreadEventListener&lt;/code&gt; 的 API。&lt;/li&gt;
&lt;li&gt;在单个监听器线程中使用 &lt;code&gt;next&lt;/code&gt; 向下游（sink - 接收方）推送事件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;complete&lt;/code&gt; 事件也是由同一个监听器线程发出的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;error&lt;/code&gt; 事件也是由同一个监听器线程发出的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;推/拉 混合模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多数 Reactor 算子，比如 &lt;code&gt;create&lt;/code&gt;，都遵从 &lt;strong&gt;推/拉（push/pull）&lt;/strong&gt; 混合模型。这意味着尽管大部分的处理过程都是异步的（暗指“推”的方式），也存在小部分逻辑是 &lt;em&gt;拉（pull）&lt;/em&gt;方式：数据请求。&lt;/p&gt;
&lt;p&gt;消费者从数据源&lt;em&gt;拉取&lt;/em&gt;数据，意指：数据源在消费者首次请求后才会发出数据，然后只有要数据就会推送给消费者，不过数据量不会超过消费者请求的量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;push()&lt;/code&gt; 和 &lt;code&gt;create()&lt;/code&gt; 都可以配置（set up）一个 &lt;code&gt;onRequest&lt;/code&gt; 事件消费者来管理请求量，并且确保仅当存在已发起的请求，数据才会推送给下游。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux&amp;lt;String&amp;gt; bridge = Flux.create(sink -&amp;gt; {
    myMessageProcessor.register(
        &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MyMessageListener&amp;lt;String&amp;gt;() {

            &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; onMessage(List&amp;lt;String&amp;gt; messages) {
                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (String s: messages) {
                    sink.next(s); &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
                }
            }
        }
    );
    sink.onRequest(n -&amp;gt; {
        List&amp;lt;String&amp;gt; messages = myMessageProcessor.getHistory(n); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (String s: messages) {
            sink.next(s); &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
        }
    });    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;译者注：上面这个示例有点问题，实际并不存在这样一个 create 方法，并且 sink.onRequest 实际代表一个无限量（n = Long.MAX_VALUE）的请求。&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在请求发起后，拉取消息。&lt;/li&gt;
&lt;li&gt;如果即刻有消息了，则推送给下游。&lt;/li&gt;
&lt;li&gt;后续异步到达的消息也会推送给下游。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;3.5 多线程 和 调度器 （Threading and Schedulers）&lt;/h4&gt;
&lt;p&gt;Reactor，与 RxJava 类似，可以认为是&lt;strong&gt;并发无关的&lt;/strong&gt;，也就是说，Reactor 并不强制使用并发（a concurrency
 model），而是，让开发者按需决定是否使用并发。然而，Reactor 也提供一些功能方便开启并发。&lt;/p&gt;
&lt;p&gt;获取到一个 &lt;code&gt;Flux&lt;/code&gt; 或 &lt;code&gt;Mono&lt;/code&gt; 处理流，并不意味着它在一个专用（dedicated）的线程（&lt;code&gt;Thread&lt;/code&gt;） 中运行。相反，多数算子也是运行在前一个算子运行的线程中。除非特意指定，首个（topmost）算子（数据源）就运行在执行 &lt;code&gt;subscribe()&lt;/code&gt; 方法调用的线程中。如下示例在一个新建线程中运行一个 &lt;code&gt;Mono&lt;/code&gt; 处理流。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; main(String[] args) {
    &lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Mono&amp;lt;String&amp;gt; mono = Mono.just(&lt;span style="color: #a31515"&gt;&amp;quot;Hello &amp;quot;&lt;/span&gt;); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

    &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Thread(() -&amp;gt; mono
        .map(msg -&amp;gt; msg + &lt;span style="color: #a31515"&gt;&amp;quot;thread &amp;quot;&lt;/span&gt;)
        .subscribe(v -&amp;gt; &lt;span style="color: #008000"&gt;// 2 &lt;/span&gt;
            System.out.println(v + Thread.currentThread().getName()) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
        )
    ).join();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Mono&amp;lt;String&amp;gt;&lt;/code&gt; 是在主（&lt;code&gt;main&lt;/code&gt;）线程中装配的（assembled）。&lt;/li&gt;
&lt;li&gt;然而， 订阅操作发生在 &lt;code&gt;Thread-0&lt;/code&gt; 线程中。&lt;/li&gt;
&lt;li&gt;因而，&lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;onNext&lt;/code&gt; 的回调（译注：&lt;code&gt;onNext&lt;/code&gt; 的回调即 subscribe 方法传入的 lambda 表达式）实际上也是在 &lt;code&gt;Thread-0&lt;/code&gt; 上执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述的代码会输出如下内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;hello thread Thread-0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Reactor 中，运行模型以及实际的运行过程发生在什么地方由使用什么 &lt;code&gt;Scheduler&lt;/code&gt; 决定。&lt;a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; 类似于 &lt;code&gt;ExecutorService&lt;/code&gt;，负有调度职责，但具备一个专用的抽象，功能更强大，充当一个时钟的角色，可用的实现更多。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"&gt;&lt;code&gt;Schedulers&lt;/code&gt;&lt;/a&gt; 类提供了一些静态方法来访问这些运行上下文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前线程（&lt;code&gt;Schedulers.immediate()&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;单个可复用的线程（&lt;code&gt;Schedulers.single()&lt;/code&gt;）。注意：这个方法会为所有调用方（译注：调用 Schedulers.single()）复用同一个线程，指导 &lt;code&gt;Scheduler&lt;/code&gt; 销毁（disposed）。如果期望每次调用返回一个专用线程，则应该使用 &lt;code&gt;Schedulers.newSingle()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;一个弹性的线程池（&lt;code&gt;Schedulers.elastic()&lt;/code&gt;）。这个 Scheduler 会按需创建新的工作者线程池（worker pool），并复用空闲的工作者线程池。如果工作者线程池空闲时间太长（默认 60s）则会被销毁。对于 I/O 阻塞工作而言这是一个好选择。&lt;code&gt;Schedulers.elastic()&lt;/code&gt; 可以简便地为阻塞处理过程提供独立的线程（its own thread），这样阻塞操作就不会占用（tie up）其他资源。详情请参考 &lt;a href="https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking"&gt;如何包装一个同步阻塞的调用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;固定数量工作者的（译注：我暂时的理解 - 工作者（worker）也是一个线程池）一个池，专门为并行处理工作做过调优（Schedulers.parallel()）。它会创建和 CPU 核心数量相同的工作者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，也可以使用 &lt;code&gt;Schedulers.fromExecutorService(ExecutorService)&lt;/code&gt; 基于已有的 ExecutorService 创建一个 Scheduler。（也可以基于一个 Executor 来创建，但不建议这么干（译注：因为 Executor 不能销毁释放））&lt;/p&gt;
&lt;p&gt;也可以使用 &lt;strong&gt;newXXX&lt;/strong&gt; 这类方法创建各种调度器（scheduler）类型的全新实例。例如，使用 &lt;code&gt;Schedulers.newElastic(yourScheduleName)&lt;/code&gt; 创建一个名为 &lt;code&gt;yourScheduleName&lt;/code&gt; 的全新的弹性调度器（elastic scheduler）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;elastic&lt;/code&gt; 调度器用于兼容处理不可避免的历史遗留的阻塞性代码，但 &lt;code&gt;single&lt;/code&gt; 和 &lt;code&gt;parallel&lt;/code&gt; 调度器不行，因而，如果在 &lt;code&gt;single&lt;/code&gt; 或 &lt;code&gt;parallel&lt;/code&gt; 调度器上使用 Reactor 的阻塞性 API（&lt;code&gt;block()&lt;/code&gt;、&lt;code&gt;blockFirst()&lt;/code&gt;、&lt;code&gt;blockLast()&lt;/code&gt;，或者进行 &lt;code&gt;toIterable()&lt;/code&gt; 或 &lt;code&gt;toStream()&lt;/code&gt; 迭代），会导致抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;如果自定义调度器所创建的线程实例实现了 &lt;code&gt;NonBlocking&lt;/code&gt; 标记性接口（marker interface），那么这个调度器也可以被标记为”仅适用于非阻塞性使用（non blocking only）“。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;某些算子默认会从 &lt;code&gt;Schedulers&lt;/code&gt; 选择一个特定的调度器来使用（通常也支持选择其他的）。例如，调用工厂方法 &lt;code&gt;Flux.interval(Duration.ofMills(300))&lt;/code&gt; 会生成一个 &lt;code&gt;Flux&amp;lt;Long&amp;gt;&lt;/code&gt; 实例 - 每 300 ms 输出一个滴答事件。这个方法底层实现默认使用 &lt;code&gt;Schedulers.parallel()&lt;/code&gt;。如下代码行演示了如何将调度器修改成类似于 &lt;code&gt;Schedulers.single()&lt;/code&gt; 的调度器新实例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.interval(Duration.ofMillis(300), Schedulers.newSingle(&lt;span style="color: #a31515"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Reactor 提供了两种方式来切换反应式链中的执行上下文（或者说 &lt;code&gt;调度器&lt;/code&gt;）：&lt;code&gt;publishOn&lt;/code&gt; 和 &lt;code&gt;subscribeOn&lt;/code&gt;。两者都是接受一个 &lt;code&gt;Scheduler&lt;/code&gt; 类型参数并将执行上下文切换到这个调度器。不过，链中 &lt;code&gt;publishOn&lt;/code&gt; 所处的位置很关键，而 &lt;code&gt;subscribeOn&lt;/code&gt; 处于哪个位置都无所谓。要理解这个差别的原因，得先理解 &lt;a href="https://projectreactor.io/docs/core/release/reference/#reactive.subscribe"&gt;订阅之前实际什么都没有发生&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Reactor，串接算子，就是将很多 &lt;code&gt;Flux&lt;/code&gt; 和 &lt;code&gt;Mono&lt;/code&gt; 的实现一个套一个，逐层封装。一旦订阅，就创建了一个 &lt;code&gt;Subscriber&lt;/code&gt; 对象链，沿链回溯即可找到第一个发布者。这些实现细节是隐藏在接口背后，开发者可见的是最外层的那个 &lt;code&gt;Flux&lt;/code&gt;（或 &lt;code&gt;Mono&lt;/code&gt;）以及 &lt;code&gt;Subscription&lt;/code&gt;（译注：Reactor 中 Subscription 是一个接口类型，是 &lt;code&gt;Subscriber&lt;/code&gt; 接口中 &lt;code&gt;onSubscribe&lt;/code&gt; 方法参数的类型 - &lt;code&gt;public void onSubscribe(Subscription s)&lt;/code&gt;，用于向生产者请求数据 或者 取消订阅），但这些算子特定的链中消费者是幕后功臣。&lt;/p&gt;
&lt;p&gt;有了上面这些认知，现在我们可以进一步了解 &lt;code&gt;publishOn&lt;/code&gt; 和 &lt;code&gt;subscribeOn&lt;/code&gt; 这两个算子：&lt;/p&gt;
&lt;h5&gt;3.5.1 publishOn 方法&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;publishOn&lt;/code&gt; 和其他算子的用法一样，用在订阅链的中间环节，接收来自上游的信号，然后向下游重放这些信号，不过下发事件回调（&lt;code&gt;onEvent&lt;/code&gt;、&lt;code&gt;onError&lt;/code&gt;、&lt;code&gt;onComplete&lt;/code&gt;）是在关联 &lt;code&gt;Scheduler&lt;/code&gt; 的一个工作者上执行的。因此，这个算子会影响后续算子在哪执行（直到订阅链上又串接了另一个 &lt;code&gt;publishOn&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将执行上下文切换到 &lt;code&gt;Scheduler&lt;/code&gt; 选择的一个线程上&lt;/li&gt;
&lt;li&gt;根据规范（as per the specification），&lt;code&gt;onNext&lt;/code&gt; 是按时序依次调用下发事件的，所以是占用一个线程（译注：这句不太理解，onNext happen in sequence, so this uses up a single thread）&lt;/li&gt;
&lt;li&gt;除非算子工作在一个特定的 &lt;code&gt;Scheduler&lt;/code&gt; 上（译注：某些算子的内部实现决定了这一点），&lt;code&gt;publishOn&lt;/code&gt; 之后的算子都是在同一个线程上执行&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Scheduler s = Schedulers.newParallel(&lt;span style="color: #a31515"&gt;&amp;quot;parallel-scheduler&amp;quot;&lt;/span&gt;, 4); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Flux&amp;lt;String&amp;gt; flux = Flux
    .range(1, 2)
    .map(i -&amp;gt; 10 + i) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
    .publishOn(s) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
    .map(i -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;value &amp;quot;&lt;/span&gt; + i); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Thread(() -&amp;gt; flux.subscribe(System.out::println));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;创建一个新的 &lt;code&gt;Scheduler&lt;/code&gt;，内含 4 个线程&lt;/li&gt;
&lt;li&gt;第一个 &lt;code&gt;map&lt;/code&gt; 运行在 &amp;lt;第5步&amp;gt; 的匿名线程上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;publishOn&lt;/code&gt; 将整个序列的后续处理切换到从 &amp;lt;第1步&amp;gt; 选出的线程上&lt;/li&gt;
&lt;li&gt;第二个 &lt;code&gt;map&lt;/code&gt; 运行在上面说的从 &amp;lt;第1步&amp;gt; 选出的线程上&lt;/li&gt;
&lt;li&gt;这个匿名线程是 &lt;em&gt;订阅&lt;/em&gt; 操作发生的地方。打印语句发生在 &lt;code&gt;publishOn&lt;/code&gt; 切换的最新执行上下文上&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;3.5.2 subscribeOn 方法&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;subscribeOn&lt;/code&gt; 在构造反向链时应用于订阅处理过程（译注：所谓构造反向链时，是指调用 subscribe 方法时）。因此，无论你将 &lt;code&gt;subscribeOn&lt;/code&gt; 放在算子链的何处，&lt;strong&gt;它始终会影响源头下发数据的执行上下文&lt;/strong&gt;。然而，这并不会影响 &lt;code&gt;publishOn&lt;/code&gt; 之后算子调用的行为，它们仍然会切换到 &lt;code&gt;publishOn&lt;/code&gt; 指定的执行上下文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从订阅操作发生时整个算子链所在的线程切换到新的线程&lt;/li&gt;
&lt;li&gt;从指定 &lt;code&gt;Scheduler&lt;/code&gt; 中选择一个线程&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;只有链中最早的 &lt;code&gt;subscribeOn&lt;/code&gt; 调用会发生实际作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Scheduler s = Schedulers.newParallel(&lt;span style="color: #a31515"&gt;&amp;quot;parallel-scheduler&amp;quot;&lt;/span&gt;, 4); &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;final&lt;/span&gt; Flux&amp;lt;String&amp;gt; flux = Flux
    .range(1, 2)
    .map(i -&amp;gt; 10 + i) &lt;span style="color: #008000"&gt;// 2&lt;/span&gt;
    .subscribeOn(s) &lt;span style="color: #008000"&gt;// 3&lt;/span&gt;
    .map(i -&amp;gt; &lt;span style="color: #a31515"&gt;&amp;quot;value &amp;quot;&lt;/span&gt; + i); &lt;span style="color: #008000"&gt;// 4&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Thread(() -&amp;gt; flux.subscribe(System.out::println)); &lt;span style="color: #008000"&gt;// 5 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;创建一个新的 &lt;code&gt;Scheduler&lt;/code&gt;，内含 4 个线程&lt;/li&gt;
&lt;li&gt;第一个 &lt;code&gt;map&lt;/code&gt; 运行在这 4 个线程中的某个线程上&lt;/li&gt;
&lt;li&gt;...因为 &lt;code&gt;subscribeOn&lt;/code&gt; 将整个序列处理链从订阅操作发生时的执行上下文（第5步）切换到了新的上下文&lt;/li&gt;
&lt;li&gt;第二个 &lt;code&gt;map&lt;/code&gt; 和第一个 &lt;code&gt;map&lt;/code&gt; 运行在同一个线程上&lt;/li&gt;
&lt;li&gt;这个匿名线程是 &lt;em&gt;订阅操作&lt;/em&gt; 一开始发生的地方的，但是 &lt;code&gt;subscribeOn&lt;/code&gt; 即刻将上下文切换到调度器4个线程中的一个上&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;4. 高级特性和概念&lt;/h3&gt;
&lt;h4&gt;4.1 使用 ConnectableFlux 将消息广播到多个订阅者&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;以后有空再翻译&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;4.2 3种分批处理方式&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;以后有空再翻译&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;4.3 使用 ParallelFlux 并行化处理&lt;/h4&gt;
&lt;p&gt;如今多核架构已是下里巴人，相应地，轻松实现并行化工作的工具手段很关键。Reactor 提供了一个特殊类型 - &lt;code&gt;ParallelFlux&lt;/code&gt; - 帮助实现并行化处理。&lt;code&gt;ParallelFlux&lt;/code&gt; 提供的算子是为并行化工作优化过的。&lt;/p&gt;
&lt;p&gt;对任意 &lt;code&gt;Flux&lt;/code&gt; 实例调用 &lt;code&gt;parallel()&lt;/code&gt;算子就能得到一个 &lt;code&gt;ParallelFlux&lt;/code&gt; 实例。这个方法本身并不能实现并行化工作，而是将工作负载拆分到多个“轨道”（默认“轨道”数量等于 CPU 核数）&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;为了告知产出的 ParallelFlux 实例每个“轨道”在哪执行（以及如何并行执行“轨道”），则必须使用 &lt;code&gt;runOn(Scheduler)&lt;/code&gt;。注意：对于并行工作，推荐使用一个专用调度器 - &lt;code&gt;Schedulers.parallel()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对比如下两个示例，第一个示例的代码如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.range(1, 10)
    .parallel(2) &lt;span style="color: #008000"&gt;// 1&lt;/span&gt;
    .subscribe(i -&amp;gt; System.out.println(Thread.currentThread().getName() + &lt;span style="color: #a31515"&gt;&amp;quot; -&amp;gt; &amp;quot;&lt;/span&gt; + i));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;这里强制指定了“轨道”数量，而不依赖于 CPU 核数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二个示例的代码如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Flux.range(1, 10)
    .parallel(2)
    .runOn(Schedulers.parallel())
    .subscribe(i -&amp;gt; System.out.println(Thread.currentThread().getName() + &lt;span style="color: #a31515"&gt;&amp;quot; -&amp;gt; &amp;quot;&lt;/span&gt; + i));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一个示例输出如下内容：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 1&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 2&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 3&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 4&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 5&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 6&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 7&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 8&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 9&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;main -&amp;gt; 10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二个示例正确地在两个线程上实现了并行化，输入如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;parallel-1 -&amp;gt; 1&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-2 -&amp;gt; 2&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-1 -&amp;gt; 3&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-2 -&amp;gt; 4&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-1 -&amp;gt; 5&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-2 -&amp;gt; 6&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-1 -&amp;gt; 7&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-1 -&amp;gt; 9&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-2 -&amp;gt; 8&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;parallel-2 -&amp;gt; 10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果数据序列&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;已经在并行化处理，而你又想将其转回一个 “常规的” &lt;code&gt;Flux&lt;/code&gt; 实例，然后串行执行算子链余下的部分，则可以使用 &lt;code&gt;ParallelFlux&lt;/code&gt; 的 &lt;code&gt;sequential()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;注意：如果直接使用一个 &lt;code&gt;Subscriber&lt;/code&gt; 类型参数而不是 lambda 表达式来调用 &lt;code&gt;subscribe&lt;/code&gt; 方法，那么内部实现会隐式地调用 &lt;code&gt;sequential()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;由此也要注意：&lt;code&gt;subscribe(Subscriber&amp;lt;T&amp;gt;)&lt;/code&gt; 会合并所有数据“轨道”，而 &lt;code&gt;subscribe(Consumer&amp;lt;T&amp;gt;)&lt;/code&gt; 是运行所有的数据“轨道”。如果以 lambda 表达式调用 &lt;code&gt;subscribe&lt;/code&gt; 方法，那么每个 lambda 表达式都会被复制成多个实例（数量等于“轨道”数量）去执行&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3"&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;译注：这里的“轨道”其实不太直白。在实现上，&lt;code&gt;ParallelFlux&lt;/code&gt; 会将最后 &lt;code&gt;subscribe&lt;/code&gt; 的 onNext 回调按并行度（默认等于 CPU 核数 N）复制成 N 个，那么最终调用 ParallelFlux 的 N 个 Subscriber，从 ParallelFlux 实例到一个 Subscriber 的数据流路径可以理解为一个“轨道”，ParallelFlux 在接收到上游消息后按照 round-robin 方式选择一个 Subscriber 调用其 &lt;code&gt;onNext&lt;/code&gt; 下发消息，但 &lt;code&gt;onNext&lt;/code&gt; 是运行在什么线程上，是由 runOn 算子决定的，如果不使用 runOn 算子，那么所有 Subscriber 的 &lt;code&gt;onNext&lt;/code&gt; 方法调用都是同步运行在主线程上的。&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;译注：原文中用了多个词来表达相近的意思：sequence（序列）、stream（流）、flow（流），阅读时可以相互替代理解。此外，还有 event（事件）、data（数据）、message（消息），在当前上下文中，可以看成是等价的。&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;译注：这话写得真蠢。详细解释见脚注 1。&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Reactor"></category><category term="Reactive"></category></entry><entry><title>Java System.getProperty VS. System.getenv（译）</title><link href="http://youngsterxyf.github.io/2019/06/25/java-prop-env/" rel="alternate"></link><published>2019-06-25T00:00:00+08:00</published><updated>2019-06-25T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-06-25:/2019/06/25/java-prop-env/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://www.baeldung.com/java-system-get-property-vs-system-getenv"&gt;Java System.getProperty vs System.getenv&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1、简介&lt;/h2&gt;
&lt;p&gt;Java 应用代码中会自动引入 &lt;code&gt;java.lang&lt;/code&gt; 包。这个包包含很多常用的类，包括 &lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;java.lang.System&lt;/code&gt; 类是一个 final 类，这意味着开发者无法继承它，其所有方法都是静态的（static）。&lt;/p&gt;
&lt;p&gt;System 类中有两个方法，分别来&lt;strong&gt;读取系统属性（system properties）和环境变量（environment variables）&lt;/strong&gt;，下面我们来看看这两者的区别。&lt;/p&gt;
&lt;h2&gt;2、使用 System.getProperty()&lt;/h2&gt;
&lt;p&gt;Java 平台使用一个 &lt;code&gt;Properties&lt;/code&gt; 对象来提供&lt;strong&gt;本地系统相关的信息和配置 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;原文：&lt;a href="https://www.baeldung.com/java-system-get-property-vs-system-getenv"&gt;Java System.getProperty vs System.getenv&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1、简介&lt;/h2&gt;
&lt;p&gt;Java 应用代码中会自动引入 &lt;code&gt;java.lang&lt;/code&gt; 包。这个包包含很多常用的类，包括 &lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;java.lang.System&lt;/code&gt; 类是一个 final 类，这意味着开发者无法继承它，其所有方法都是静态的（static）。&lt;/p&gt;
&lt;p&gt;System 类中有两个方法，分别来&lt;strong&gt;读取系统属性（system properties）和环境变量（environment variables）&lt;/strong&gt;，下面我们来看看这两者的区别。&lt;/p&gt;
&lt;h2&gt;2、使用 System.getProperty()&lt;/h2&gt;
&lt;p&gt;Java 平台使用一个 &lt;code&gt;Properties&lt;/code&gt; 对象来提供&lt;strong&gt;本地系统相关的信息和配置&lt;/strong&gt;，我们称之为 &lt;strong&gt;系统属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;系统属性包括当前用户、当前 Java 运行时版本 以及 文件路径分隔符诸如此类的信息。&lt;/p&gt;
&lt;p&gt;如下代码中，我们使用 &lt;code&gt;System.getProperty("log_dir")&lt;/code&gt; 来读取 &lt;em&gt;log_dir&lt;/em&gt; 属性值。我们也会使用默认值参数，这样如果属性不存在，&lt;code&gt;getProperty&lt;/code&gt; 则返回 &lt;em&gt;/tmp/log&lt;/em&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;String log_dir = System.getProperty(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;/tmp/log&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果希望在运行时变更系统属性，则可以使用 &lt;code&gt;System.setProperty&lt;/code&gt; 方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;System.setProperty(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;/tmp/log&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以以如下格式使用命令行参数向应用传递指定属性或配置值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;java -jar jarName -DpropertyName=value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比如 将 app.jar 的 foo 属性值设置为 bar：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="border: 1px solid #FF0000"&gt;java -jar app -Dfoo=&amp;quot;bar&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;System.getProperty 返回的一定是一个字符串。&lt;/p&gt;
&lt;h2&gt;3、使用 System.getenv()&lt;/h2&gt;
&lt;p&gt;环境变量是类似 Properties 的一些 键/值 对。许多操作系统都提供环境变量的方式向应用传递配置信息。&lt;/p&gt;
&lt;p&gt;设置环境变量的方式，各操作系统之间有所不同。例如，Windows 中，我们使用控制面板中的系统工具（System Utility）应用来设置，而 Unix 系统则使用 shell 脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个进程时，该进程默认会从其父进程继承一个克隆的上下文环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下代码片段演示：使用一个 lambda 表达式来输出所有环境变量。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;System.getenv().forEach((k, v) -&amp;gt; {
    System.out.println(k + &lt;span style="color: #a31515"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + v);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;getenv() 返回一个只读的 &lt;code&gt;Map&lt;/code&gt;&lt;/strong&gt;。尝试向该映射中添加值，会抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;可以使用变量名称作为参数调用 &lt;code&gt;getenv&lt;/code&gt; 来获取单个变量值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;String log_dir = System.getenv(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此外，我们可以在应用中创建一个新进程，并向其上下文环境中添加新的环境变量。&lt;/p&gt;
&lt;p&gt;Java 中，我们使用 &lt;code&gt;ProcessBuilder&lt;/code&gt; 类来创建新进程，该类有一个名为 &lt;code&gt;environment&lt;/code&gt; 的方法，此方法返回一个 &lt;code&gt;Map&lt;/code&gt;，不过这个映射不是只读的，这样就可以向其添加新元素：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ProcessBuilder pb = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ProcessBuilder(args);
Map&amp;lt;String, String&amp;gt; env = pb.environment();
env.put(&lt;span style="color: #a31515"&gt;&amp;quot;log_dir&amp;quot;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;/tmp/log&amp;quot;&lt;/span&gt;);
Process process = pb.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;4、区别&lt;/h2&gt;
&lt;p&gt;这两者本质上都是提供 字符串类型 键值 信息的映射，区别在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们可以在运行时变更 系统属性（Properties），但是 环境变量（Environment Variables）仅是操作系统环境变量的一个不可变拷贝。&lt;/li&gt;
&lt;li&gt;仅 Java 平台包含这个 系统属性 特性，而 环境变量 则是操作系统层面提供，全局可用的 - 运行在同一个机器上的所有应用都可以访问。&lt;/li&gt;
&lt;li&gt;系统属性 在打包应用时就必须存在&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;，而 环境变量 则任意时刻都可以在操作系统中创建。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;5、总结一下&lt;/h2&gt;
&lt;p&gt;虽然这两者在概念上比较相似，但是 系统属性 和 环境变量 的应用方式差别很大。&lt;/p&gt;
&lt;p&gt;二选一通常考量的是生效范围。使用 环境变量，同一个应用可以部署到多个机器上运行不同的实例，并在操作系统级别或者在 AWS / Azure 云平台控制台中进行配置，以免更新配置时还得重新构建应用（&lt;strong&gt;译注：其实使用 系统属性 也可以实现这个效果，比如在 shell 脚本中获取系统环境变量，然后作为系统属性通过 Java 命令行参数传递给应用&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getProperty&lt;/code&gt; 方法名称是驼峰风格，但 &lt;code&gt;getenv&lt;/code&gt; 不是，谨记！&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;原文是这么写的，但我认为这句话有问题。系统属性明明可以在应用运行时通过命令行参数指定，也可以将属性文件打包到应用包中，在运行时加载（通过 &lt;code&gt;System.getProperties().load&lt;/code&gt; 方法）。&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="其他"></category><category term="翻译"></category><category term="Java"></category></entry><entry><title>Java 单测伴侣 - mockito</title><link href="http://youngsterxyf.github.io/2019/06/17/mockito/" rel="alternate"></link><published>2019-06-17T00:00:00+08:00</published><updated>2019-06-17T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2019-06-17:/2019/06/17/mockito/</id><summary type="html">&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码还挺难的，挺花时间，其中最麻烦的是待测代码可能会访问外部资源（比如数据库、HTTP API），如果不能方便地进模拟访问这些外部资源，那么测试起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;但，对于复杂逻辑，如果不经过严格测试，发布到生产环境，又有些不放心，没底气，或者在代码重构时，如果没有覆盖全面的测试，很难评估代码变动带来的影响。&lt;/p&gt;
&lt;p&gt;直到遇到 &lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt;，我才觉得是时候认真写写测试代码了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt; 提供两种对象模拟方式：&lt;strong&gt;mock&lt;/strong&gt; 和 &lt;strong&gt;spy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，mock 模拟的对象是一个完全假的对象，只是具备指定类型的接口，以 &lt;code&gt;java.util.List&lt;/code&gt; 为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.mock;

List mockedList = mock(List.class);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码还挺难的，挺花时间，其中最麻烦的是待测代码可能会访问外部资源（比如数据库、HTTP API），如果不能方便地进模拟访问这些外部资源，那么测试起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;但，对于复杂逻辑，如果不经过严格测试，发布到生产环境，又有些不放心，没底气，或者在代码重构时，如果没有覆盖全面的测试，很难评估代码变动带来的影响。&lt;/p&gt;
&lt;p&gt;直到遇到 &lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt;，我才觉得是时候认真写写测试代码了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt; 提供两种对象模拟方式：&lt;strong&gt;mock&lt;/strong&gt; 和 &lt;strong&gt;spy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，mock 模拟的对象是一个完全假的对象，只是具备指定类型的接口，以 &lt;code&gt;java.util.List&lt;/code&gt; 为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.mock;

List mockedList = mock(List.class);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然 List 是一个 interface，也可以模拟出一个对象实例，这个 mockedList 对象具备 List 接口定义的所有方法，但所有方法都不具备实际的行为操作，对于有返回值的方法，则默认返回方法返回类型的默认值，没有返回值的方法，则纯粹是一个空方法。比如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// mockedList 并不会真的把 1 存下来&lt;/span&gt;
mockedList.add(1);
&lt;span style="color: #008000"&gt;// 所以，size() 返回默认值，输出 0&lt;/span&gt;
System.out.println(mockedList.size());
&lt;span style="color: #008000"&gt;// 输出 null&lt;/span&gt;
System.out.println(mockedList.get(0));
&lt;span style="color: #008000"&gt;// 输出 null&lt;/span&gt;
System.out.println(mockedList.get(1));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于模拟出来的对象，可以任意指定其方法的返回值，比如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.when;

&lt;span style="color: #008000"&gt;// 调用 size() 方法时，返回 10&lt;/span&gt;
when(mockedList.size()).willReturn(10);
when(mockedList.get(0)).willReturn(&lt;span style="color: #a31515"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;);
when(mockedList.get(1)).thenReturn(&lt;span style="color: #a31515"&gt;&amp;quot;您好！&amp;quot;&lt;/span&gt;);

&lt;span style="color: #008000"&gt;// 输出 10&lt;/span&gt;
System.out.println(mockedList.size());
&lt;span style="color: #008000"&gt;// 输出 Hello World!&lt;/span&gt;
System.out.println(mockedList.get(0));
&lt;span style="color: #008000"&gt;// 输出 您好！&lt;/span&gt;
System.out.println(mockedList.get(1));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然我们写测试代码时，并不会使用 System.out.println，然后看输出，而是使用&lt;strong&gt;断言&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.junit.Assert.assertEquals;

assertEquals(10, mockedList.size());
assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;Hello World!&amp;quot;&lt;/span&gt;, mockedList.get(0));
assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;您好！&amp;quot;&lt;/span&gt;, mockedList.get(1));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;断言方法非常多，不仅仅只是 assertEquals。&lt;/p&gt;
&lt;p&gt;对于同一个方法，可以模拟多次调用返回不同的值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 会覆盖之前 mock 的行为：when(mockedList.size()).willReturn(10);&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 或者这么写：when(mockedList.size()).willReturn(0, -1, 10);&lt;/span&gt;
when(mockedList.size()).thenReturn(0).thenReturn(-1).thenReturn(10);
assertEquals(0, mockedList.size());
assertEquals(-1, mockedList.size());
assertEquals(10, mockedList.size());
&lt;span style="color: #008000"&gt;// 第 3 次之后的 mockedList.size() 调用都返回 10&lt;/span&gt;
assertEquals(10, mockedList.size());

Iterator iterator = mock(Iterator.class);
&lt;span style="color: #008000"&gt;// 或者这么写：when(iterator.next()).thenReturn(0, 1, 10, 1000);&lt;/span&gt;
when(iterator.next()).thenReturn(0).thenReturn(1).thenReturn(10).thenReturn(1000);
assertEquals(0, iterator.next());
assertEquals(1, iterator.next());
assertEquals(10, iterator.next());
assertEquals(1000, iterator.next());
&lt;span style="color: #008000"&gt;// 第 4 次之后的 iterator.next() 调用都返回 1000&lt;/span&gt;
assertEquals(1000, iterator.next());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还可以模拟异常抛出：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;List mockedList = mock(List.class);

when(mockedList.get(-1000)).thenThrow(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; RuntimeException(&lt;span style="color: #a31515"&gt;&amp;quot;参数异常！&amp;quot;&lt;/span&gt;));
&lt;span style="color: #0000ff"&gt;try&lt;/span&gt; {
    mockedList.get(-1000);
} &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt; (Exception e) {
    assertTrue(e &lt;span style="color: #0000ff"&gt;instanceof&lt;/span&gt; RuntimeException);
    assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;参数异常！&amp;quot;&lt;/span&gt;, e.getMessage());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以基于复杂的逻辑来构造返回值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.invocation.InvocationOnMock;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.stubbing.Answer;

List&amp;lt;Integer&amp;gt; mockedList = mock(List.class);
when(mockedList.get(anyInt())).thenAnswer(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; EchoAnswer());

assertTrue(1 == mockedList.get(1));
assertTrue(10 == mockedList.get(10));

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;EchoAnswer&lt;/span&gt; &lt;span style="color: #0000ff"&gt;implements&lt;/span&gt; Answer&amp;lt;Integer&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; Integer answer(InvocationOnMock var) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; var.getArgument(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了 &lt;code&gt;when(...).thenReturn(...)&lt;/code&gt; 风格的测试模拟方式，还有 BDD（Behavior Driven Development 行为驱动开发）风格的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.BDDMockito.given;

&lt;span style="color: #008000"&gt;// given&lt;/span&gt;
given(mockedList.get(0)).willReturn(100);
&lt;span style="color: #008000"&gt;// when&lt;/span&gt;
&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; v = (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;) mockedList.get(0);
&lt;span style="color: #008000"&gt;// then&lt;/span&gt;
assertEquals(100, v);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果方法没有返回值，或者其它奇葩的需求，则没法使用 when.thenReturn / willReturn 这样的模拟方法，可以使用 &lt;code&gt;doReturn(...).when(...)...&lt;/code&gt;：
&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.doThrow;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.doReturn;

ArrayList mockedList = mock(ArrayList.class);
&lt;span style="color: #008000"&gt;// clear 方法无返回值&lt;/span&gt;
doThrow(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; RuntimeException(&lt;span style="color: #a31515"&gt;&amp;quot;清除失败&amp;quot;&lt;/span&gt;)).when(mockedList).clear();

&lt;span style="color: #0000ff"&gt;try&lt;/span&gt; {
    mockedList.clear();
} &lt;span style="color: #0000ff"&gt;catch&lt;/span&gt; (Exception e) {
    assertTrue(e &lt;span style="color: #0000ff"&gt;instanceof&lt;/span&gt; RuntimeException);
    assertEquals(&lt;span style="color: #a31515"&gt;&amp;quot;清除失败&amp;quot;&lt;/span&gt;, e.getMessage());
}

&lt;span style="color: #008000"&gt;// 没有意义，因为没法使用 断言 来验证，实际运行时会抛异常&lt;/span&gt;
doReturn(10).when(mockedList).clear();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从示例代码可以看出，&lt;code&gt;doReturn(...).when(...)....&lt;/code&gt; 不会做类型校验，mockedList.clear() 返回值类型为 void，但我们模拟让其返回 10；所以，正常情况应该尽可能使用 &lt;code&gt;when(...).thenReturn(...)&lt;/code&gt; 或 &lt;code&gt;given(...).willReturn(...)&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;前述代码示例中，模拟方法的参数都做了硬编码，实际情况通常都不是这么测试，而是模拟方法的参数符合一定的要求即可，比如：在某个范围之内、符合类型的任何值：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.anyInt;

&lt;span style="color: #008000"&gt;/*&lt;/span&gt;
&lt;span style="color: #008000"&gt;以任何 int 类型的参数调用 mockedList.get 方法，都返回 100&lt;/span&gt;

&lt;span style="color: #008000"&gt;如果写成 when(mockedList.get(0)).thenReturn(100)，则只有以 0 为参数调用 mockedList.get 方法，才会返回100，其他参数值，返回的都是默认值 0&lt;/span&gt;
&lt;span style="color: #008000"&gt;*/&lt;/span&gt;
when(mockedList.get(anyInt())).thenReturn(100);

assertEquals(100, mockedList.get(0));
assertEquals(100, mockedList.get(1000));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可用的参数匹配器，见 org.mockito.ArgumentMatchers 类的静态方法列表，也可以自己实现 ArgumentMatcher 接口：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;package&lt;/span&gt; org.mockito;

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;ArgumentMatcher&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; matches(T var1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.ArgumentMatcher;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.intThat;

when(mockedList.get(intThat(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; LimitedInt()))).thenReturn(10);

assertEquals(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, mockedList.get(-1));
assertEquals(10, mockedList.get(1));
assertEquals(10, mockedList.get(99));
assertEquals(&lt;span style="color: #0000ff"&gt;null&lt;/span&gt;, mockedList.get(100));

&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;LimitedInt&lt;/span&gt; &lt;span style="color: #0000ff"&gt;implements&lt;/span&gt; ArgumentMatcher&amp;lt;Integer&amp;gt; {

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;boolean&lt;/span&gt; matches(Integer var) {
        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;var&lt;/span&gt; &lt;span style="border: 1px solid #FF0000"&gt;&amp;gt; 0 &amp;amp;&amp;amp; &lt;/span&gt;var &amp;lt; 100;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果被模拟的方法包含多个参数，那么这些参数要么全部使用匹配器，要么全部不使用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;模拟某些类（A）的方法，通常会将 mock 出来的对象注入到依赖该类实例的其他类（B）中，来替代真实的依赖，这种方式的目的是为了测试类 B 的行为是否符合预期。&lt;/p&gt;
&lt;p&gt;另一个测试需求是，测试某个类 A' 在某个上下文环境中的行为是否符合预期，比如： A' 的某个方法是否被调用过、调用过几次、调用参数是否符合预期、几个方法之间的调用次序是否符合预期、方法调用耗时是否符合预期等等。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.verify;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.times;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.never;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.verifyZeroInteractions;

List mocked = mock(List.class);

Caller caller = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Caller();
caller.setList(mocked);

&lt;span style="color: #008000"&gt;// 调用 0 次&lt;/span&gt;
caller.run(0);
&lt;span style="color: #008000"&gt;// 验证是否从来没调用过 mocked.size()&lt;/span&gt;
verify(mocked, never()).size();
&lt;span style="color: #008000"&gt;// 验证 没有和 mocked 产生过任何交互&lt;/span&gt;
&lt;span style="color: #008000"&gt;// 因为 Caller.run 中调用了 list.isEmpty()，实际产生了交互，所以这行测试会失败&lt;/span&gt;
verifyZeroInteractions(mocked);

&lt;span style="color: #008000"&gt;// 调用 10 次&lt;/span&gt;
caller.run(10);
&lt;span style="color: #008000"&gt;// 验证是否调用 mocked.size() 10 次&lt;/span&gt;
verify(mocked, times(10)).size();

&lt;span style="color: #008000"&gt;// 再调用一次&lt;/span&gt;
caller.run(1);
&lt;span style="color: #008000"&gt;// 所以是 11 次了&lt;/span&gt;
verify(mocked, times(11)).size();

@Data
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Caller&lt;/span&gt; {
    List list;

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; run(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; count) {
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; idx=0; idx &amp;lt; count; idx++) {
            list.size();
        }
        &lt;span style="color: #008000"&gt;//&lt;/span&gt;
        list.isEmpty();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;List mocked = mock(List.class);

mocked.add(1);
mocked.add(2);

verify(mocked).add(1);

&lt;span style="color: #008000"&gt;// 是否有其他交互没有验证过？因为 mocked 还调用过 mocked.add(2)，所以这句测试会失败&lt;/span&gt;
verifyNoMoreInteractions(mocked);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.InOrder;

&lt;span style="color: #008000"&gt;// 也可以验证调用次序&lt;/span&gt;
List mocked1 = mock(List.class);
List mocked2 = mock(List.class);

mocked1.size();
mocked1.isEmpty();
mocked2.isEmpty();

&lt;span style="color: #008000"&gt;// 会记录 mocked1、mocked2 中方法的调用/交互次序，要求：与 mocked1 的交互先于 mocked2&lt;/span&gt;
InOrder inOrder = inOrder(mocked1, mocked2);
&lt;span style="color: #008000"&gt;// mocked1、mocked2 的交互顺序必须和 inOrder.verify 之间的顺序一致&lt;/span&gt;
inOrder.verify(mocked1).size();
inOrder.verify(mocked1).isEmpty();
inOrder.verify(mocked2).isEmpty();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;也可以验证某个方法被调用时所使用的参数是否符合预期：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.ArgumentCaptor;

List mockedlist = mock(List.class);

Caller caller = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Caller();
caller.setList(mockedlist);
caller.run();

&lt;span style="color: #008000"&gt;// 捕获 mockedList.add 的调用参数&lt;/span&gt;
ArgumentCaptor&amp;lt;Integer&amp;gt; argumentCaptor = ArgumentCaptor.forClass(Integer.class);
verify(mockedlist).add(argumentCaptor.capture());
assertTrue(100 == argumentCaptor.getValue());

@Data
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Caller&lt;/span&gt; {
    List list;

    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; run() {
        list.add(100);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;前面的内容都是以 mock 为例，我们再来说说 spy，与 mock 的区别：&lt;/p&gt;
&lt;p&gt;mock 出来的对象是一个完全假的对象，但 spy 通常是基于一个具体的类或类实例，对其篡改某些方法，对于被篡改方法之外的方法，其行为都和调用真实对象的方法一样，不过并没有调用真实对象的方法，也不会对真实对象产生影响：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #008000"&gt;// 基于一个实际的类实例&lt;/span&gt;
List&amp;lt;Integer&amp;gt; realList = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(10);
List&amp;lt;Integer&amp;gt; spy = spy(realList);

spy.add(1);

&lt;span style="color: #008000"&gt;// 被窃听的对象并没有发生变化&lt;/span&gt;
assertEquals(0, realList.size());
&lt;span style="color: #008000"&gt;// 间谍对象确实将 1 存了下来&lt;/span&gt;
assertEquals(1, spy.size());
&lt;span style="color: #008000"&gt;// 这句会抛出 java.lang.IndexOutOfBoundsException，因为 realList 还是为空&lt;/span&gt;
assertTrue(1 == realList.get(0));
assertTrue(1 == spy.get(0));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以基于一个具体的类来构造 spy，但这样无法使用带参数的构造方法，也无法指定类型参数：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; = spy(ArrayList.class);
assertEquals(0, spy.size());
spy.add(100);
assertEquals(1, spy.size());
assertTrue(100 == spy.get(0));

&lt;span style="color: #008000"&gt;// 篡改方法&lt;/span&gt;
when(spy.size()).thenReturn(-1);
assertEquals(-1, spy.size());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际上，mock 也可以基于具体的类来构造，这时可以指定某些方法实际调用具体类的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;除了使用 mock、spy 方法来构造模拟对象，还可以通过注解来构造，但这样的话得指定 JUnit 的 Runner 为 &lt;code&gt;org.mockito.junit.MockitoJUnitRunner&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.junit.Test;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.junit.runner.RunWith;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.Mock;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.Spy;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; org.mockito.junit.MockitoJUnitRunner;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.ArrayList;
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.when;
&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.junit.Assert.assertTrue;

@RunWith(MockitoJUnitRunner.class)
&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;testTester&lt;/span&gt; {

    @Mock
    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; mocked;

    @Spy
    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; spyed;

    @Test
    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #2b91af"&gt;void&lt;/span&gt; test() {
        when(mocked.isEmpty()).thenReturn(&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);
        when(spyed.isEmpty()).thenReturn(&lt;span style="color: #0000ff"&gt;false&lt;/span&gt;);

        assertTrue(!mocked.isEmpty());
        assertTrue(!spyed.isEmpty());

        mocked.add(0);
        spyed.add(0);

        assertTrue(0 == mocked.size());
        assertTrue(1 == spyed.size());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Java"></category><category term="mockito"></category><category term="单测"></category></entry><entry><title>编写漂亮的 shell 代码</title><link href="http://youngsterxyf.github.io/2018/05/16/beautiful-shell-code/" rel="alternate"></link><published>2018-05-16T00:00:00+08:00</published><updated>2018-05-16T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-05-16:/2018/05/16/beautiful-shell-code/</id><summary type="html">&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is true, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

map() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is true, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

map() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
}

reduce() {
    operator=$1
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    list=($2)
    list_len=&lt;span style="color: #a31515"&gt;${#&lt;/span&gt;list[@]&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    result=&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list_len&lt;span style="color: #a31515"&gt;}&lt;/span&gt; -gt 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        result=&lt;span style="color: #a31515"&gt;${&lt;/span&gt;list[0]&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    &lt;span style="color: #008000"&gt;#&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list_len&lt;span style="color: #a31515"&gt;}&lt;/span&gt; -gt 1 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in &lt;span style="color: #a31515"&gt;${&lt;/span&gt;list[@]:1&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
            result=&lt;span style="color: #0000ff"&gt;$(&lt;/span&gt;&lt;span style="color: #a31515"&gt;${&lt;/span&gt;operator&lt;span style="color: #a31515"&gt;}&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;result&lt;span style="color: #a31515"&gt;}&lt;/span&gt; &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;&lt;span style="color: #0000ff"&gt;)&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    echo &lt;span style="color: #a31515"&gt;${&lt;/span&gt;result&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
}

filter() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
        &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
            echo &lt;span style="color: #a31515"&gt;${&lt;/span&gt;item&lt;span style="color: #a31515"&gt;}&lt;/span&gt;
        &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
}

sum() {
    v=0
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; arg in &lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;$@&lt;span style="color: #a31515"&gt;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        v=&lt;span style="color: #0000ff"&gt;$((&lt;/span&gt;$v+&lt;span style="color: #a31515"&gt;${&lt;/span&gt;arg&lt;span style="color: #a31515"&gt;}&lt;/span&gt;&lt;span style="color: #0000ff"&gt;))&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;done&lt;/span&gt;
    echo $v
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="其他"></category><category term="Bash"></category></entry><entry><title>配置 Maven 自动化构建 protobuf 代码依赖</title><link href="http://youngsterxyf.github.io/2018/05/14/maven-protobuf/" rel="alternate"></link><published>2018-05-14T00:00:00+08:00</published><updated>2018-05-14T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-05-14:/2018/05/14/maven-protobuf/</id><summary type="html">&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin.version&amp;gt;
    &amp;lt;maven-dependency-plugin.version&amp;gt;3.0.2&amp;lt;/maven-dependency-plugin.version …&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin.version&amp;gt;
    &amp;lt;maven-dependency-plugin.version&amp;gt;3.0.2&amp;lt;/maven-dependency-plugin.version&amp;gt;
    &amp;lt;os-maven-plugin.version&amp;gt;1.5.0.Final&amp;lt;/os-maven-plugin.version&amp;gt;
    &amp;lt;protobuf.version&amp;gt;2.5.0&amp;lt;/protobuf.version&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.添加 protobuf-java 库依赖&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${protobuf.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.添加 maven 扩展：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;extensions&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- provides os.detected.classifier (i.e. linux-x86_64, osx-x86_64) property --&amp;gt;&lt;/span&gt;
        &amp;lt;extension&amp;gt;
            &amp;lt;groupId&amp;gt;kr.motd.maven&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;os-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${os-maven-plugin.version}&amp;lt;/version&amp;gt;
        &amp;lt;/extension&amp;gt;
    &amp;lt;/extensions&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.配置构建插件：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- copy protoc binary into build directory --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${maven-dependency-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;copy-protoc&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;copy&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;artifactItems&amp;gt;
                            &amp;lt;artifactItem&amp;gt;
                                &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;protoc&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;${protobuf.version}&amp;lt;/version&amp;gt;
                                &amp;lt;classifier&amp;gt;${os.detected.classifier}&amp;lt;/classifier&amp;gt;
                                &amp;lt;type&amp;gt;exe&amp;lt;/type&amp;gt;
                                &amp;lt;overWrite&amp;gt;true&amp;lt;/overWrite&amp;gt;
                                &amp;lt;outputDirectory&amp;gt;${project.build.directory}&amp;lt;/outputDirectory&amp;gt;
                            &amp;lt;/artifactItem&amp;gt;
                        &amp;lt;/artifactItems&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- compile proto buffer files using copied protoc binary --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-antrun-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${maven-antrun-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;exec-protoc&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;target&amp;gt;
                            &amp;lt;property name=&lt;span style="color: #a31515"&gt;&amp;quot;protoc.filename&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;protoc-${protobuf.version}-${os.detected.classifier}.exe&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;property name=&lt;span style="color: #a31515"&gt;&amp;quot;protoc.filepath&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;${project.build.directory}/${protoc.filename}&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;chmod file=&lt;span style="color: #a31515"&gt;&amp;quot;${protoc.filepath}&amp;quot;&lt;/span&gt; perm=&lt;span style="color: #a31515"&gt;&amp;quot;ugo+rx&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;mkdir dir=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.output.directory}&amp;quot;&lt;/span&gt; /&amp;gt;
                            &amp;lt;path id=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths.path&amp;quot;&lt;/span&gt;&amp;gt;
                                &amp;lt;fileset dir=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.directory}&amp;quot;&lt;/span&gt;&amp;gt;
                                    &amp;lt;include name=&lt;span style="color: #a31515"&gt;&amp;quot;**/*.proto&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;/fileset&amp;gt;
                            &amp;lt;/path&amp;gt;
                            &amp;lt;pathconvert pathsep=&lt;span style="color: #a31515"&gt;&amp;quot; &amp;quot;&lt;/span&gt; property=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths&amp;quot;&lt;/span&gt; refid=&lt;span style="color: #a31515"&gt;&amp;quot;protobuf.input.filepaths.path&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;exec executable=&lt;span style="color: #a31515"&gt;&amp;quot;${protoc.filepath}&amp;quot;&lt;/span&gt; failonerror=&lt;span style="color: #a31515"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;-I&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.directory}&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;--java_out&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg value=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.output.directory}&amp;quot;&lt;/span&gt;/&amp;gt;
                                &amp;lt;arg line=&lt;span style="color: #a31515"&gt;&amp;quot;${protobuf.input.filepaths}&amp;quot;&lt;/span&gt;/&amp;gt;
                            &amp;lt;/exec&amp;gt;
                        &amp;lt;/target&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;run&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &lt;span style="color: #008000"&gt;&amp;lt;!-- add generated proto buffer classes into the package --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;build-helper-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${build-helper-maven-plugin.version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;add-classes&amp;lt;/id&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;add-source&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;configuration&amp;gt;
                        &amp;lt;sources&amp;gt;
                            &amp;lt;source&amp;gt;${protobuf.output.directory}&amp;lt;/source&amp;gt;
                        &amp;lt;/sources&amp;gt;
                    &amp;lt;/configuration&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://vlkan.com/blog/post/2015/11/27/maven-protobuf/&lt;/p&gt;
&lt;p&gt;http://www.chendan.me/2017/07/02/maven-protobuf/&lt;/p&gt;</content><category term="其他"></category><category term="java"></category><category term="maven"></category><category term="protobuf"></category></entry><entry><title>《Python 编程之美》译者序</title><link href="http://youngsterxyf.github.io/2018/04/01/the-python-guide/" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>xiayf</name></author><id>tag:youngsterxyf.github.io,2018-04-01:/2018/04/01/the-python-guide/</id><summary type="html">&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语言包括：Python、PHP、Go、Java、JavaScript 等。&lt;/p&gt;
&lt;p&gt;虽说编程语言各异，但我使用它们来写各种项目的代码却一直坚持两点：代码可读性和自解释性/自文档性（self-documentation）。这很大程度上应该是受到 Python 语言设计哲学的影响 - 追求简单易读易懂的代码。&lt;/p&gt;
&lt;p&gt;很多人可能会认为这两点其实是一点 - 代码可读性，但我想做点区分：代码可读性突出对代码阅读者视觉上的影响，是否存在不必要的理解干扰，比如：必要的空行、变量定义与使用之间的距离、函数体/逻辑分支是否过长、逻辑表达是否直观等等。可读性高的代码通常都非常漂亮、赏心悦目。自解释性代码则更突出语义层面，比如：变量名称/函数名称/类名是否恰当、函数/方法/API 是否单一职责、工程目录结构/包/模块拆分是否符合“高内聚低耦合”原则等等 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语言包括：Python、PHP、Go、Java、JavaScript 等。&lt;/p&gt;
&lt;p&gt;虽说编程语言各异，但我使用它们来写各种项目的代码却一直坚持两点：代码可读性和自解释性/自文档性（self-documentation）。这很大程度上应该是受到 Python 语言设计哲学的影响 - 追求简单易读易懂的代码。&lt;/p&gt;
&lt;p&gt;很多人可能会认为这两点其实是一点 - 代码可读性，但我想做点区分：代码可读性突出对代码阅读者视觉上的影响，是否存在不必要的理解干扰，比如：必要的空行、变量定义与使用之间的距离、函数体/逻辑分支是否过长、逻辑表达是否直观等等。可读性高的代码通常都非常漂亮、赏心悦目。自解释性代码则更突出语义层面，比如：变量名称/函数名称/类名是否恰当、函数/方法/API 是否单一职责、工程目录结构/包/模块拆分是否符合“高内聚低耦合”原则等等。长期追求这两点，可以极大地提升个人，特别是团队的工作效率和工作质量。&lt;/p&gt;
&lt;p&gt;本书作者 Kenneth Reitz 于 2011 年发布 Requests 这个 HTTP 请求工具库，提出“for humans”的理念，强调软件/工具库应该对人类友好易用，这一理念本质上是对 Python 哲学（特别是上述两点）的一种引申和发扬。之后 Reitz 在一些 Python大会上做技术分享，宣扬“for humans”理念，对 Python 社区产生巨大影响。我在第一次用过 Requests 库之后，便很少使用 Python 标准库中的 urllib 和 urllib2，现在标准库文档中也特别建议开发者使用 Requests。&lt;/p&gt;
&lt;p&gt;因为对“for humans”理念的认同，也因为经常使用 Requests，所以当 Reitz 在 Github 上邀请我翻译 Requests 文档中文版时，我欣然接受，和另一个 Python 开发者共同翻译了 Requests 文档的首个官方中文翻译版。这“另一个 Python 开发者”也就是本书的另一个译者。&lt;/p&gt;
&lt;p&gt;在 Reitz 发起 “The Hitchhiker's Guide to Python!” 项目（也就是本书的社区开源版）后，我一直持续跟进阅读，收获巨大。后来得知这本开源书籍正式出版，欣喜若狂，辗转咨询多人，联系到刘皎老师 ，申请了本书的翻译工作。&lt;/p&gt;
&lt;p&gt;但是，后来发现翻译的工作量远远超出预估，除了个人的一些主观原因，主要因为本书内容的广度和深度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度：本书由 Python 社区数百人共同创作而成，可以视作 Python 小百科全书。1-3章指导读者按照自己的需求选择安装配置 Python 版本/发行版、开发环境等。7-11章则针对不同的应用场景，从多个维度甄选对比了大量的 Python 库，读者可以“按图索骥”地做出自己的选择，从而节约大量的时间精力。因为译者的 Python 开发经验主要集中在 Web 开发和数据处理，对于很多应用场景下的 Python 库不太熟悉，所以翻译之前花费了大量时间来学习理解。&lt;/li&gt;
&lt;li&gt;深度：针对 Python 中手的核心需求，本书探讨了大量的最佳实践。其中4-5章通过大量示例具体地阐释了“Python 之禅”的句句箴言，如何编写高质量的 Python 代码，并精选若干高质量的知名 Python 开源项目，详细介绍如何通过阅读源码来提升编程技术水平。虽说 Python 社区几乎人人皆知“Python 之禅”，但如何落地到开发实践估计极少有人说得清楚。对照书中的实例阐释，译者几经调整推敲“Python 之禅”的译文，最终敲定的译文也不是特别令自己满意。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比原计划，本书最终延期近一年才得以翻译完成。除了歉意，我内心满是感谢：感谢邦杰中途友情加入，帮忙翻译了4-6章初稿，这三章的难度和长度都非常大；感谢编辑老师刘皎对我拖稿的次次容忍和耐心等待；感谢妻儿的理解，我对你们缺少了太多的陪伴。&lt;/p&gt;
&lt;p&gt;虽说我已尽自己所能地保证译文质量，但错误瑕疵难免，在此也请读者原谅。希望你们阅读愉快！&lt;/p&gt;
&lt;p&gt;至此，我如释重负。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;夏永锋&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;写于上海&lt;/em&gt;&lt;/p&gt;</content><category term="其他"></category><category term="翻译"></category><category term="书籍"></category></entry></feed>