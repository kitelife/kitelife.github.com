<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>黑 * 白</title><link href="http://youngsterxyf.github.io/" rel="alternate"></link><link href="http://youngsterxyf.github.io/feeds/youngsterxyf.atom.xml" rel="self"></link><id>http://youngsterxyf.github.io/</id><updated>2015-05-20T00:00:00+08:00</updated><entry><title>Go并发编程基础（译）</title><link href="http://youngsterxyf.github.io/2015/05/20/fundamentals-of-concurrent-programming/" rel="alternate"></link><updated>2015-05-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-05-20:2015/05/20/fundamentals-of-concurrent-programming/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/"&gt;Fundamentals of concurrent programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是一篇并发编程方面的入门文章，以&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;编写示例代码，内容涵盖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行期并发线程（goroutines）&lt;/li&gt;
&lt;li&gt;基本的同步技术（管道和锁）&lt;/li&gt;
&lt;li&gt;Go语言中基本的并发模式&lt;/li&gt;
&lt;li&gt;死锁和数据竞争&lt;/li&gt;
&lt;li&gt;并行计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在开始阅读本文之前，你应该知道如何编写简单的Go程序。如果你熟悉的是C/C++、Java或Python之类的语言，那么 &lt;a href="http://tour.golang.org/welcome/1"&gt;Go语言之旅&lt;/a&gt; 能提供所有必要的背景知识。也许你还有兴趣读一读 &lt;a href="http://code.google.com/p/go-wiki/wiki/GoForCPPProgrammers"&gt;为C++程序员准备的Go语言教程&lt;/a&gt; 或 &lt;a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/"&gt;为Java程序员准备的Go语言教程&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;1. 运行期线程&lt;/h4&gt;
&lt;p&gt;Go允许使用&lt;code&gt;go&lt;/code&gt;语句开启一个新的运行期线程，即 &lt;a href="http://golang.org/ref/spec#Go_statements"&gt;goroutine&lt;/a&gt;，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。&lt;/p&gt;
&lt;p&gt;Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。&lt;/p&gt;
&lt;p&gt;下面所示程序会输出“Hello from main goroutine”。也可能会输出“Hello from another goroutine”，具体依赖于两个goroutine哪个先结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello from another goroutine&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello from main goroutine&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;// 至此，程序运行结束，&lt;/span&gt;
    &lt;span class="c1"&gt;// 所有活跃的goroutine被杀死&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/goroutine1.go"&gt;goroutine1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来的这个程序，多数情况下，会输出“Hello from main goroutine”和“Hello from another goroutine”，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello from another goroutine&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello from main goroutine&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// 等待1秒，等另一个goroutine结束&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/goroutine2.go"&gt;goroutine2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 函数Publish在给定时间过期后打印text字符串到标准输出&lt;/span&gt;
&lt;span class="c1"&gt;// 该函数并不会阻塞而是立即返回&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;text&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;BREAKING NEWS:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt; &lt;span class="c1"&gt;// 注意这里的括号。必须调用匿名函数&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish1.go"&gt;publish1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可能会这样使用&lt;code&gt;Publish&lt;/code&gt;函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;Publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A goroutine starts a new thread of execution.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Let’s hope the news will published before I leave.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;// 等待发布新闻&lt;/span&gt;
    &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Ten seconds later: I’m leaving now.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish1.go"&gt;publish1.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ go run publish1.go
Let’s hope the news will published before I leave.
BREAKING NEWS: A goroutine starts a new thread of execution.
Ten seconds later: I’m leaving now.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 - 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。&lt;/p&gt;
&lt;h4&gt;2. 管道（channel）&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Sushi conveyor belt" src="http://www.nada.kth.se/~snilsson/concurrency/sushi-conveyor-belt.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/spec#Channel_types"&gt;管道&lt;/a&gt;是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;code&gt;&amp;lt;-&lt;/code&gt;用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="nx"&gt;Sushi&lt;/span&gt;      &lt;span class="c1"&gt;// 可用来发送和接收Sushi类型的值&lt;/span&gt;
&lt;span class="kd"&gt;chan&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt;  &lt;span class="c1"&gt;// 仅可用来发送float64类型的值&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;      &lt;span class="c1"&gt;// 仅可用来接收int类型的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;管道是引用类型，基于make函数来分配。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;ic&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;// 不带缓冲的int类型管道&lt;/span&gt;
&lt;span class="nx"&gt;wc&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// 带缓冲的Work类型指针管道&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果压迫通过管道发送一个值，则将&lt;code&gt;&amp;lt;-&lt;/code&gt;作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;ic&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;     &lt;span class="c1"&gt;// 往管道发送3&lt;/span&gt;
&lt;span class="nx"&gt;work&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;wc&lt;/span&gt;    &lt;span class="c1"&gt;// 从管道接收一个指向Work类型值的指针&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可能接收之前会一直阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭管道（Close）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/spec#Close"&gt;close&lt;/a&gt; 函数标志着不会再往某个管道发送值。在调用&lt;code&gt;close&lt;/code&gt;之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello!&amp;quot;&lt;/span&gt;
    &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}()&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;// 输出字符串&amp;quot;Hello!&amp;quot;&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;// 输出零值 - 空字符串&amp;quot;&amp;quot;，不会阻塞&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;// 再次打印输出空字符串&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;       &lt;span class="c1"&gt;// 变量v的值为空字符串&amp;quot;&amp;quot;，变量ok的值为false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个带有&lt;code&gt;range&lt;/code&gt;子句的&lt;code&gt;for&lt;/code&gt;语句会依次读取发往管道的值，直到该管道关闭：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="nx"&gt;Sushi&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Producer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Consumed&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Producer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="nx"&gt;Sushi&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="nx"&gt;Sushi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;Sushi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;海老握り&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Ebi nigiri&lt;/span&gt;
        &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;Sushi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;鮪とろ握り&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Toro nigiri&lt;/span&gt;
        &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/sushi.go"&gt;sushi.go&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;3. 同步&lt;/h4&gt;
&lt;p&gt;下一个示例中，我们让&lt;code&gt;Publish&lt;/code&gt;函数返回一个管道 - 用于在发布text变量值时广播一条消息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 在给定时间过期时，Publish函数会打印text变量值到标准输出&lt;/span&gt;
&lt;span class="c1"&gt;// 在text变量值发布后，该函数会关闭管道wait&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;text&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;BREAKING NEWS:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;// 广播 - 一个关闭的管道都会发送一个零值&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish2.go"&gt;publish2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：我们使用了一个空结构体的管道：&lt;code&gt;struct{}&lt;/code&gt;。这明确地指明该管道仅用于发信号，而不是传递数据。&lt;/p&gt;
&lt;p&gt;我们可能会这样使用这个函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;wait&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;Publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Channels let goroutines communicate.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Waiting for the news...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The news is out, time to leave.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/publish2.go"&gt;publish2.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ go run publish2.go
Waiting for the news...
BREAKING NEWS: Channels let goroutines communicate.
The news is out, time to leave.
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4. 死锁&lt;/h4&gt;
&lt;p&gt;&lt;img alt="traffic jam" src="http://www.nada.kth.se/~snilsson/concurrency/traffic-jam.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;现在我们在&lt;code&gt;Publish&lt;/code&gt;函数中引入一个bug：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;text&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;BREAKING NEWS:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;// 译注：注意这里将close函数调用注释掉了&lt;/span&gt;
        &lt;span class="c1"&gt;//close(ch)&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时&lt;code&gt;Publish&lt;/code&gt;函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;wait&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;Publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Channels let goroutines communicate.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Waiting for the news...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;// 译注：注意下面这一句&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The news is out, time to leave.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;死锁是线程之间相互等待，其中任何一个都无法向前运行的情形。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Waiting for the news...
BREAKING NEWS: Channels let goroutines communicate.
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
    .../goroutineStop.go:11 +0xf6

goroutine 2 [syscall]:
created by runtime.main
    .../go/src/pkg/runtime/proc.c:225

goroutine 4 [timer goroutine (idle)]:
created by addtimer
    .../go/src/pkg/runtime/ztime_linux_amd64.c:73
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。&lt;/p&gt;
&lt;h4&gt;5. 数据竞争（data race）&lt;/h4&gt;
&lt;p&gt;死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当两个线程并发地访问同一个变量，并且其中至少一个访问是写操作时，数据竞争就发生了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;race&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;wait&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// 译注：注意下面这一行&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="c1"&gt;// 一次访问: 读, 递增, 写&lt;/span&gt;
        &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="c1"&gt;// 译注：注意下面这一行&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="c1"&gt;// 另一次冲突的访问&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 输出：未指定&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go"&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码中的两个goroutine（假设命名为&lt;code&gt;g1&lt;/code&gt;和&lt;code&gt;g2&lt;/code&gt;）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g1&lt;/code&gt; 从 &lt;code&gt;n&lt;/code&gt; 中获取值0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g2&lt;/code&gt; 从 &lt;code&gt;n&lt;/code&gt; 中获取值0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g1&lt;/code&gt; 将值从0增大到1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g1&lt;/code&gt; 将1写到 &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g2&lt;/code&gt; 将值从0增大到1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g2&lt;/code&gt; 将1写到 &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;程序输出 n 的值，当前为1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mid action" src="http://www.nada.kth.se/~snilsson/concurrency/mid-action.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（&lt;a href="http://golang.org/pkg/sync/"&gt;sync&lt;/a&gt;和&lt;a href="http://golang.org/pkg/sync/atomic/"&gt;sync/atomic&lt;/a&gt;包中还有更低层次的机制可供使用，但本文中不做讨论）。&lt;/p&gt;
&lt;p&gt;Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;sharingIsCaring&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;// 仅为一个goroutine可见的局部变量.&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
        &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="c1"&gt;// 数据从一个goroutine离开...&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;   &lt;span class="c1"&gt;// ...然后安全到达另一个goroutine.&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 输出: 2&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go"&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上代码中的管道肩负双重责任 - 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/mem"&gt;Go语言内存模型&lt;/a&gt; - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。&lt;/p&gt;
&lt;h4&gt;6. 互斥锁&lt;/h4&gt;
&lt;p&gt;&lt;img alt="lock" src="http://www.nada.kth.se/~snilsson/concurrency/lock.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - &lt;a href="http://golang.org/pkg/sync/#Mutex"&gt;sync.Mutex&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。&lt;/p&gt;
&lt;p&gt;因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，&lt;code&gt;AtomicInt&lt;/code&gt;，用于存储一个整型值。任意数量的goroutine都能通过&lt;code&gt;Add&lt;/code&gt;和&lt;code&gt;Value&lt;/code&gt;方法安全地访问这个数值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// AtomicInt是一个并发数据结构，持有一个整数值&lt;/span&gt;
&lt;span class="c1"&gt;// 该数据结构的零值为0&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;AtomicInt&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;mu&lt;/span&gt; &lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Mutex&lt;/span&gt; &lt;span class="c1"&gt;// 锁，一次仅能被一个goroutine持有。&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt;  &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Add方法作为一个原子操作将n加到AtomicInt&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;AtomicInt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;mu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// 等待锁释放，然后持有它&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;mu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Unlock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// 释放锁&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Value方法返回a的值&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;AtomicInt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;mu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;mu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Unlock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;lockItUp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;wait&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="nx"&gt;AtomicInt&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 一个访问&lt;/span&gt;
        &lt;span class="nb"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 另一个并发访问&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;wait&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;// 输出: 2&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/datarace.go"&gt;datarace.go&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;7. 检测数据竞争&lt;/h4&gt;
&lt;p&gt;竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出&lt;code&gt;55555&lt;/code&gt;。尝试一下，也许你会得到一个不同的结果。（&lt;a href="http://golang.org/pkg/sync/#WaitGroup"&gt;sync.WaitGroup&lt;/a&gt;是Go语言标准库的一部分；用于等待一组goroutine结束运行。）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;race&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;wg&lt;/span&gt; &lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WaitGroup&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;// 译注：注意下面这行代码中的i++&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// 注意下一行代码会输出什么？为什么？&lt;/span&gt;
            &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 6个goroutine共享变量i&lt;/span&gt;
            &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// 等待所有（5个）goroutine运行结束&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go"&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于输出&lt;code&gt;55555&lt;/code&gt;，一个貌似合理的解释是：执行&lt;code&gt;i++&lt;/code&gt;的goroutine在其他goroutine执行打印语句之前就完成了5次&lt;code&gt;i++&lt;/code&gt;操作。实际上变量&lt;code&gt;i&lt;/code&gt;更新后的值为其他goroutine所见纯属巧合。&lt;/p&gt;
&lt;p&gt;一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;correct&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;wg&lt;/span&gt; &lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WaitGroup&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 使用局部变量&lt;/span&gt;
            &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;}(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go"&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次代码就对了，程序会输出期望的结果，如：&lt;code&gt;24031&lt;/code&gt;。注意：goroutine之间的运行顺序是不确定的。&lt;/p&gt;
&lt;p&gt;仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;alsoCorrect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;wg&lt;/span&gt; &lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WaitGroup&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="c1"&gt;// 为每个闭包创建一个独有的变量&lt;/span&gt;
        &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/raceClosure.go"&gt;raceClosure.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据竞争自动检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的&lt;a href="http://tip.golang.org/doc/articles/race_detector.html"&gt;数据竞争检测器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个工具用起来也很简单：只要在使用&lt;code&gt;go&lt;/code&gt;命令时加上&lt;code&gt;-race&lt;/code&gt;标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ go run -race raceClosure.go
Race:
==================
WARNING: DATA RACE
Read by goroutine 2:
  main.func·001()
      ../raceClosure.go:22 +0x65

Previous write by goroutine 0:
  main.race()
      ../raceClosure.go:20 +0x19b
  main.main()
      ../raceClosure.go:10 +0x29
  runtime.main()
      ../go/src/pkg/runtime/proc.c:248 +0x91

Goroutine 2 (running) created at:
  main.race()
      ../raceClosure.go:24 +0x18b
  main.main()
      ../raceClosure.go:10 +0x29
  runtime.main()
      ../go/src/pkg/runtime/proc.c:248 +0x91

==================
55555
Correct:
01234
Also correct:
01324
Found 1 data race(s)
exit status 66
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。&lt;/p&gt;
&lt;p&gt;注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导）&lt;/p&gt;
&lt;h4&gt;8. Select语句&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://golang.org/ref/spec#Select_statements"&gt;select语句&lt;/a&gt;是Go语言并发工具集中的最后一个工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。&lt;/p&gt;
&lt;p&gt;以下是一个玩具示例，演示&lt;code&gt;select&lt;/code&gt;语句如何用于实现一个随机数生成器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// RandomBits函数 返回一个管道，用于产生一个比特随机序列&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;RandomBits&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;// 注意：分支没有对应的处理语句&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;ch&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/randBits.go"&gt;randBits.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;news&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;NewsAgency&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;news&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;After&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Minute&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Time out: no news in one minute.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数 &lt;a href="http://golang.org/pkg/time/#After"&gt;time.After&lt;/a&gt; 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。&lt;/p&gt;
&lt;h4&gt;9. 综合所有示例&lt;/h4&gt;
&lt;p&gt;&lt;img alt="couples" src="http://www.nada.kth.se/~snilsson/concurrency/couples.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。&lt;/p&gt;
&lt;p&gt;这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;people&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Anna&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Cody&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Dave&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Eva&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;match&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 为一个未匹配的发送操作提供空间&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WaitGroup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;people&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;people&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;Seek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;match&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;match&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;No one received %s’s message.\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;// 没有待处理的发送操作&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait group&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Seek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;match&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;wg&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WaitGroup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;peer&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;match&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s sent a message to %s.\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;peer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;match&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;// 等待某个goroutine接收我的消息&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/matching.go"&gt;matching.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ go run matching.go
Cody sent a message to Bob.
Anna sent a message to Eva.
No one received Dave’s message.
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;10. 并行计算&lt;/h4&gt;
&lt;p&gt;&lt;img alt="CPUs" src="http://www.nada.kth.se/~snilsson/concurrency/cpus.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。&lt;/p&gt;
&lt;p&gt;将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的）&lt;/li&gt;
&lt;li&gt;尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。&lt;/li&gt;
&lt;li&gt;数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Vector&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;float64&lt;/span&gt;

&lt;span class="c1"&gt;// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k&lt;/span&gt;
&lt;span class="c1"&gt;// 先决条件：len(u) &amp;gt; 0, len(v) &amp;gt; 0&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Convolve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="nx"&gt;Vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="nx"&gt;Vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Vector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 函数mul 返回 Σ u[i]*v[j], i + j = k.&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="nx"&gt;Vector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;res&lt;/span&gt; &lt;span class="kt"&gt;float64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;res&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 &lt;code&gt;Convolve&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Convolve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="nx"&gt;Vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="nx"&gt;Vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Vector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;// 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元&lt;/span&gt;
    &lt;span class="nx"&gt;size&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nx"&gt;wg&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WaitGroup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;size&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 整型溢出后 i &amp;lt; 0&lt;/span&gt;
        &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;size&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 整型溢出后 j &amp;lt; 0&lt;/span&gt;
            &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// 这些goroutine共享内存，但是只读&lt;/span&gt;
        &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;u&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;}(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/src/convolution.go"&gt;convolution.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;numcpu&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;runtime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NumCPU&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;runtime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;GOMAXPROCS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;numcpu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 尝试使用所有可用的CPU&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="翻译"></category><category term="Golang"></category></entry><entry><title>Yii源码阅读笔记 - 自定义类自动加载</title><link href="http://youngsterxyf.github.io/2015/04/10/read-yii-code-9/" rel="alternate"></link><updated>2015-04-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-04-10:2015/04/10/read-yii-code-9/</id><summary type="html">&lt;p&gt;前两天突然发现：之前的阅读笔记对于Yii应用中如何自动加载自定义类的问题没有解释。这里的自定义类是指非Yii框架本身的类。&lt;/p&gt;
&lt;p&gt;关于组件类的配置加载已在 &lt;a href="http://blog.xiayf.cn/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt; 一文中做了较为详细的说明，
所以这里不再涉及。&lt;/p&gt;
&lt;p&gt;本文主要解释以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Yii框架是如何找到请求对应的自定义控制器类？&lt;/li&gt;
&lt;li&gt;在自定义控制器类中使用其他类（如Model类、或其他任意目录下文件中定义的类）时，Yii框架是如何自动加载的？&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;在 &lt;a href="http://blog.xiayf.cn/2014/11/20/read-yii-code-7/"&gt;Yii源码阅读笔记 - 应用模块化&lt;/a&gt; 一文中介绍类 &lt;code&gt;CWebApplication&lt;/code&gt; 中的方法 &lt;code&gt;createController&lt;/code&gt; ，
该方法根据目标路由找到对应的控制器类文件并加载，方法中有行代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;$basePath=$owner-&amp;gt;getControllerPath();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的 &lt;code&gt;getControllerPath&lt;/code&gt; 会返回当前应用或模块下的控制器类的存放目录，对应应用级与模块级，其实现有两处，其一是在类 &lt;code&gt;CWebApplication&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @return string the directory that contains the controller classes. Defaults to &amp;#39;protected/controllers&amp;#39;.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function getControllerPath()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_controllerPath!==null)&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_controllerPath;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_controllerPath=$this-&amp;gt;getBasePath().DIRECTORY_SEPARATOR.&amp;#39;controllers&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另一处是在类 &lt;code&gt;CWebModule&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @return string the directory that contains the controller classes. Defaults to &amp;#39;moduleDir/controllers&amp;#39; where&lt;/span&gt;
&lt;span class="x"&gt; * moduleDir is the directory containing the module class.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function getControllerPath()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_controllerPath!==null)&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_controllerPath;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_controllerPath=$this-&amp;gt;getBasePath().DIRECTORY_SEPARATOR.&amp;#39;controllers&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这两处实现的逻辑是一样的：如果属性 &lt;code&gt;_controllerPath&lt;/code&gt; 未赋值，则&lt;strong&gt;默认&lt;/strong&gt;以应用或模块目录下的&lt;strong&gt;controllers&lt;/strong&gt;子目录作为自定义控制器类的存放目录。&lt;/p&gt;
&lt;p&gt;如果不想以该路径作为自定义控制器类的存放目录，那么就得为 &lt;code&gt;_controllerPath&lt;/code&gt; 赋值 - 与 &lt;code&gt;getControllerPath&lt;/code&gt; 对应的有方法 &lt;code&gt;setControllerPath&lt;/code&gt; （同样有两处定义，实现一样）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @param string $value the directory that contains the controller classes.&lt;/span&gt;
&lt;span class="x"&gt; * @throws CException if the directory is invalid&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function setControllerPath($value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(($this-&amp;gt;_controllerPath=realpath($value))===false || !is_dir($this-&amp;gt;_controllerPath))&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The controller path &amp;quot;{path}&amp;quot; is not a valid directory.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{path}&amp;#39;=&amp;gt;$value)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从 &lt;code&gt;getControllerPath&lt;/code&gt; 和 &lt;code&gt;setControllerPath&lt;/code&gt; 的命名上就能知道这两个方法是分别由魔术方法 &lt;code&gt;__get&lt;/code&gt; 和 &lt;code&gt;__set&lt;/code&gt; 间接调用的。由 &lt;a href="http://blog.xiayf.cn/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt; 一文内容可知，配置初始化的时候会调用类 &lt;code&gt;CModule&lt;/code&gt; 的方法 &lt;code&gt;configure&lt;/code&gt; ，该方法中又会触发魔术方法 &lt;code&gt;__set&lt;/code&gt; 。这也就意味着可以在应用配置中添加 &lt;code&gt;controllerPath&lt;/code&gt; 一项来声明自定义控制器类的存放目录。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;那么当自定义控制类中使用Model类或者其他辅助类时，Yii是如何自动加载的呢？&lt;/p&gt;
&lt;p&gt;以 &lt;strong&gt;在控制器类中IndexController调用Model类UserModel的getUserInfo方法获取用户信息&lt;/strong&gt; 为例，Yii是怎么找到并加载UserModel类文件的呢？&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://blog.xiayf.cn/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt; 一文的最后提到 - 类文件yii/framework/YiiBase.php的倒数第二行代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;spl_autoload_register(array(&amp;#39;YiiBase&amp;#39;,&amp;#39;autoload&amp;#39;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在应用初始化时，类文件 &lt;code&gt;Yii.php&lt;/code&gt; 中会require类文件 &lt;code&gt;YiiBase.php&lt;/code&gt;，从而会执行该句代码，将YiiBase类的方法autoload注册到 &lt;code&gt;SPL __autoload&lt;/code&gt; 函数队列中。&lt;/p&gt;
&lt;p&gt;而类 YiiBase 的 autoload 方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Class autoload loader.&lt;/span&gt;
&lt;span class="x"&gt; * This method is provided to be invoked within an __autoload() magic method.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $className class name&lt;/span&gt;
&lt;span class="x"&gt; * @return boolean whether the class has been loaded successfully&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public static function autoload($className)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // use include so that the error PHP file may appear&lt;/span&gt;
&lt;span class="x"&gt;    // 先在 $classMap 中查找&lt;/span&gt;
&lt;span class="x"&gt;    if(isset(self::$classMap[$className]))&lt;/span&gt;
&lt;span class="x"&gt;        include(self::$classMap[$className]);&lt;/span&gt;
&lt;span class="x"&gt;    // 在 $_coreClasses 中查找&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset(self::$_coreClasses[$className]))&lt;/span&gt;
&lt;span class="x"&gt;        include(YII_PATH.self::$_coreClasses[$className]);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 如果 $className 不带 命名空间&lt;/span&gt;
&lt;span class="x"&gt;        // include class file relying on include_path&lt;/span&gt;
&lt;span class="x"&gt;        if(strpos($className,&amp;#39;\\&amp;#39;)===false)  // class without namespace&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(self::$enableIncludePath===false)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                foreach(self::$_includePaths as $path)&lt;/span&gt;
&lt;span class="x"&gt;                {&lt;/span&gt;
&lt;span class="x"&gt;                    $classFile=$path.DIRECTORY_SEPARATOR.$className.&amp;#39;.php&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;                    if(is_file($classFile))&lt;/span&gt;
&lt;span class="x"&gt;                    {&lt;/span&gt;
&lt;span class="x"&gt;                        include($classFile);&lt;/span&gt;
&lt;span class="x"&gt;                        if(YII_DEBUG &amp;amp;&amp;amp; basename(realpath($classFile))!==$className.&amp;#39;.php&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;                            throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Class name &amp;quot;{class}&amp;quot; does not match class file &amp;quot;{file}&amp;quot;.&amp;#39;, array(&lt;/span&gt;
&lt;span class="x"&gt;                                &amp;#39;{class}&amp;#39;=&amp;gt;$className,&lt;/span&gt;
&lt;span class="x"&gt;                                &amp;#39;{file}&amp;#39;=&amp;gt;$classFile,&lt;/span&gt;
&lt;span class="x"&gt;                            )));&lt;/span&gt;
&lt;span class="x"&gt;                        break;&lt;/span&gt;
&lt;span class="x"&gt;                    }&lt;/span&gt;
&lt;span class="x"&gt;                }&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                include($className.&amp;#39;.php&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // $className 带 命名空间&lt;/span&gt;
&lt;span class="x"&gt;        else  // class name with namespace in PHP 5.3&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $namespace=str_replace(&amp;#39;\\&amp;#39;,&amp;#39;.&amp;#39;,ltrim($className,&amp;#39;\\&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;            if(($path=self::getPathOfAlias($namespace))!==false)&lt;/span&gt;
&lt;span class="x"&gt;                include($path.&amp;#39;.php&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                return false;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        return class_exists($className,false) || interface_exists($className,false);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    return true;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码中涉及的 &lt;code&gt;self::$_coreClasses&lt;/code&gt; 属性定义于类 YiiBase，其中罗列了Yii框架核心类的名称与相对路径。&lt;/p&gt;
&lt;p&gt;属性 &lt;code&gt;self::$_classMap&lt;/code&gt; ，默认是一个空数组，在类 YiiBase 的静态方法 import 中根据条件可能被赋予元素；属性 &lt;code&gt;self::$_includePaths&lt;/code&gt; 也是如此，只不过默认未赋值。静态方法 &lt;code&gt;import&lt;/code&gt; 实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public static function import($alias,$forceInclude=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(isset(self::$_imports[$alias]))  // previously imported&lt;/span&gt;
&lt;span class="x"&gt;        return self::$_imports[$alias];&lt;/span&gt;

&lt;span class="x"&gt;    if(class_exists($alias,false) || interface_exists($alias,false))&lt;/span&gt;
&lt;span class="x"&gt;        return self::$_imports[$alias]=$alias;&lt;/span&gt;

&lt;span class="x"&gt;    // 带 命名空间&lt;/span&gt;
&lt;span class="x"&gt;    if(($pos=strrpos($alias,&amp;#39;\\&amp;#39;))!==false) // a class name in PHP 5.3 namespace format&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $namespace=str_replace(&amp;#39;\\&amp;#39;,&amp;#39;.&amp;#39;,ltrim(substr($alias,0,$pos),&amp;#39;\\&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;        if(($path=self::getPathOfAlias($namespace))!==false)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $classFile=$path.DIRECTORY_SEPARATOR.substr($alias,$pos+1).&amp;#39;.php&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;            // 默认为false的哦&lt;/span&gt;
&lt;span class="x"&gt;            if($forceInclude)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                if(is_file($classFile))&lt;/span&gt;
&lt;span class="x"&gt;                    require($classFile);&lt;/span&gt;
&lt;span class="x"&gt;                else&lt;/span&gt;
&lt;span class="x"&gt;                    throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing PHP file and the file is readable.&amp;#39;,array(&amp;#39;{alias}&amp;#39;=&amp;gt;$alias)));&lt;/span&gt;
&lt;span class="x"&gt;                self::$_imports[$alias]=$alias;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                self::$classMap[$alias]=$classFile;&lt;/span&gt;
&lt;span class="x"&gt;            return $alias;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            // try to autoload the class with an autoloader&lt;/span&gt;
&lt;span class="x"&gt;            if (class_exists($alias,true))&lt;/span&gt;
&lt;span class="x"&gt;                return self::$_imports[$alias]=$alias;&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing directory or file.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                    array(&amp;#39;{alias}&amp;#39;=&amp;gt;$namespace)));&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    // 从后往前第一个 . 的位置&lt;/span&gt;
&lt;span class="x"&gt;    if(($pos=strrpos($alias,&amp;#39;.&amp;#39;))===false)  // a simple class name&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($forceInclude &amp;amp;&amp;amp; self::autoload($alias))&lt;/span&gt;
&lt;span class="x"&gt;            self::$_imports[$alias]=$alias;&lt;/span&gt;
&lt;span class="x"&gt;        return $alias;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    // 取类名部分&lt;/span&gt;
&lt;span class="x"&gt;    $className=(string)substr($alias,$pos+1);&lt;/span&gt;
&lt;span class="x"&gt;    // 如果类名为 * 则表示非类文件，而是目录&lt;/span&gt;
&lt;span class="x"&gt;    $isClass=$className!==&amp;#39;*&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    if($isClass &amp;amp;&amp;amp; (class_exists($className,false) || interface_exists($className,false)))&lt;/span&gt;
&lt;span class="x"&gt;        return self::$_imports[$alias]=$className;&lt;/span&gt;

&lt;span class="x"&gt;    if(($path=self::getPathOfAlias($alias))!==false)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 类文件&lt;/span&gt;
&lt;span class="x"&gt;        if($isClass)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if($forceInclude)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                if(is_file($path.&amp;#39;.php&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;                    require($path.&amp;#39;.php&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;                else&lt;/span&gt;
&lt;span class="x"&gt;                    throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing PHP file and the file is readable.&amp;#39;,array(&amp;#39;{alias}&amp;#39;=&amp;gt;$alias)));&lt;/span&gt;
&lt;span class="x"&gt;                self::$_imports[$alias]=$className;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                self::$classMap[$className]=$path.&amp;#39;.php&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;            return $className;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 目录&lt;/span&gt;
&lt;span class="x"&gt;        else  // a directory&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(self::$_includePaths===null)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                self::$_includePaths=array_unique(explode(PATH_SEPARATOR,get_include_path()));&lt;/span&gt;
&lt;span class="x"&gt;                if(($pos=array_search(&amp;#39;.&amp;#39;,self::$_includePaths,true))!==false)&lt;/span&gt;
&lt;span class="x"&gt;                    unset(self::$_includePaths[$pos]);&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;

&lt;span class="x"&gt;            array_unshift(self::$_includePaths,$path);&lt;/span&gt;

&lt;span class="x"&gt;            if(self::$enableIncludePath &amp;amp;&amp;amp; set_include_path(&amp;#39;.&amp;#39;.PATH_SEPARATOR.implode(PATH_SEPARATOR,self::$_includePaths))===false)&lt;/span&gt;
&lt;span class="x"&gt;                self::$enableIncludePath=false;&lt;/span&gt;

&lt;span class="x"&gt;            return self::$_imports[$alias]=$path;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Alias &amp;quot;{alias}&amp;quot; is invalid. Make sure it points to an existing directory or file.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{alias}&amp;#39;=&amp;gt;$alias)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;静态方法import在类CModule（CWebApplication类间接继承自该类）的方法 &lt;code&gt;setImport&lt;/code&gt; 中会被调用（当然还有其他地方也会调用import方法）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Sets the aliases that are used in the module.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $aliases list of aliases to be imported&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function setImport($aliases)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    foreach($aliases as $alias)&lt;/span&gt;
&lt;span class="x"&gt;        Yii::import($alias);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看到前缀为&lt;code&gt;set&lt;/code&gt;，就知道魔术方法 &lt;code&gt;__set&lt;/code&gt; 能间接调用该方法，如前所述，可以为应用提供名为 &lt;strong&gt;import&lt;/strong&gt; 的配置项。例如目前我们项目中有import配置项如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;#39;import&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;application.models.*&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;application.components.*&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;表示业务逻辑的代码（如自定义控制器类）中会使用到应用的子目录models和components下的类文件，需要Yii（准确地说是YiiBase类autoload方法）帮忙自动查找加载。
这样也就能任意组织项目的目录结构（&lt;strong&gt;当然不要太任性！&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;import配置项的值是一个路径别名数组，路径别名中的application表示应用的根目录，默认为与index.php同一级的protected目录，也可以通过配置项basePath来指定。对于basePath配置项，在类CApplication的构造方法 &lt;code&gt;__contruct&lt;/code&gt; 中有如下相关代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;if(isset($config[&amp;#39;basePath&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;setBasePath($config[&amp;#39;basePath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;    unset($config[&amp;#39;basePath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;else&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;setBasePath(&amp;#39;protected&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;Yii::setPathOfAlias(&amp;#39;application&amp;#39;,$this-&amp;gt;getBasePath());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中方法 &lt;code&gt;setPathAlias&lt;/code&gt; 的实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public static function setPathOfAlias($alias,$path)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(empty($path))&lt;/span&gt;
&lt;span class="x"&gt;        unset(self::$_aliases[$alias]);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        self::$_aliases[$alias]=rtrim($path,&amp;#39;\\/&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;除了通过import配置项指定autoload的查找路径，从类YiiBase的autoload方法实现可以看到，对于PHP 5.3以上版本，可以使用命名空间的方式来自动查找类，命名空间字符串会被替换成路径别名，所以命名空间字符串应以 &lt;code&gt;application\&lt;/code&gt; 开始，如应这样 &lt;code&gt;application\models\UserModel&lt;/code&gt; 来引用models目录下的UserModel类文件，除非额外通过 &lt;code&gt;Yii::setPathOfAlias&lt;/code&gt;为models路径指定别名。&lt;/p&gt;
&lt;p&gt;另外，类YiiBase中提供了一个静态方法 &lt;code&gt;registerAutoloader&lt;/code&gt; ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Registers a new class autoloader.&lt;/span&gt;
&lt;span class="x"&gt; * The new autoloader will be placed before {@link autoload} and after&lt;/span&gt;
&lt;span class="x"&gt; * any other existing autoloaders.&lt;/span&gt;
&lt;span class="x"&gt; * @param callback $callback a valid PHP callback (function name or array($className,$methodName)).&lt;/span&gt;
&lt;span class="x"&gt; * @param boolean $append whether to append the new autoloader after the default Yii autoloader.&lt;/span&gt;
&lt;span class="x"&gt; * Be careful using this option as it will disable {@link enableIncludePath autoloading via include path}&lt;/span&gt;
&lt;span class="x"&gt; * when set to true. After this the Yii autoloader can not rely on loading classes via simple include anymore&lt;/span&gt;
&lt;span class="x"&gt; * and you have to {@link import} all classes explicitly.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public static function registerAutoloader($callback, $append=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($append)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        self::$enableIncludePath=false;&lt;/span&gt;
&lt;span class="x"&gt;        spl_autoload_register($callback);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        spl_autoload_unregister(array(&amp;#39;YiiBase&amp;#39;,&amp;#39;autoload&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;        spl_autoload_register($callback);&lt;/span&gt;
&lt;span class="x"&gt;        spl_autoload_register(array(&amp;#39;YiiBase&amp;#39;,&amp;#39;autoload&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可通过该静态方法针对项目的目录结构添加一个自定义的自动查找加载方式。&lt;/p&gt;
&lt;h4&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/zh/function.spl-autoload-register.php"&gt;PHP手册 - spl_autoload_register&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Slim源码阅读笔记</title><link href="http://youngsterxyf.github.io/2015/03/22/read-slim/" rel="alternate"></link><updated>2015-03-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-03-22:2015/03/22/read-slim/</id><summary type="html">&lt;p&gt;以前读过 &lt;a href="http://www.phptherightway.com/"&gt;PHP - The Right Way&lt;/a&gt; 一文，
还翻译过其中的 &lt;a href="http://www.phptherightway.com/pages/The-Basics.html"&gt;The Baiscs&lt;/a&gt; 一节
(译文见 &lt;a href="http://blog.xiayf.cn/2013/03/08/php-basics/"&gt;这里&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;前两周读了 &lt;a href="http://www.amazon.cn/Modern-PHP-Lockhart-Josh/dp/1491905018/ref=sr_1_1?ie=UTF8&amp;amp;qid=1427031708&amp;amp;sr=8-1&amp;amp;keywords=Modern+PHP"&gt;Modern PHP - New Features and Good Practices&lt;/a&gt; 一书
（读书笔记见&lt;a href="http://blog.xiayf.cn/2015/03/12/read-modern-php/"&gt;这里&lt;/a&gt;），
甚是不错。&lt;/p&gt;
&lt;p&gt;这篇文档和这本书的作者都是&lt;a href="https://github.com/codeguy"&gt;Josh Lockhart&lt;/a&gt;，
他写了一个Web框架&lt;a href="http://www.slimframework.com/"&gt;Slim&lt;/a&gt;，文档与书籍内容的精华都体现在这个框架中，
所以个人觉得这个框架值得一读。&lt;/p&gt;
&lt;p&gt;Slim的设计与实现都非常精简易懂，其对请求的主处理流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="slim-process" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/slim.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中的核心概念包括：IoC容器、中间件、路由匹配等。&lt;/p&gt;
&lt;h4&gt;IoC容器&lt;/h4&gt;
&lt;p&gt;IoC，为Inversion of Control的缩写，中文翻译为“控制反转” - 是一种解决组件间依赖关系、配置和生命周期的设计模式，其最常见的实现方式为：依赖注入（DI）-
当系统/应用需要使用某个依赖组件时，容器根据配置信息构建一个组件对象返回给系统/应用。&lt;/p&gt;
&lt;p&gt;对于Web框架来说，基于Ioc容器可以将框架的功能拆解成多个组件，按需配置调用。&lt;/p&gt;
&lt;p&gt;Slim的IoC容器类为：&lt;code&gt;\Slim\Helper\Set&lt;/code&gt;，以单例request为例，当调用request对象时&lt;code&gt;$app-&amp;gt;request&lt;/code&gt;，先触发Slim类的魔术方法&lt;code&gt;__get&lt;/code&gt;，其实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __get($name)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;container-&amp;gt;get($name);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而容器类Set的get方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Get data value with key&lt;/span&gt;
&lt;span class="x"&gt; * @param  string $key     The data key&lt;/span&gt;
&lt;span class="x"&gt; * @param  mixed  $default The value to return if data key does not exist&lt;/span&gt;
&lt;span class="x"&gt; * @return mixed           The data value, or the default value&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function get($key, $default = null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if ($this-&amp;gt;has($key)) {&lt;/span&gt;
&lt;span class="x"&gt;        $isInvokable = is_object($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]) &amp;amp;&amp;amp; method_exists($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)], &amp;#39;__invoke&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;        // 注意这里的$this，在初始化组件时，将当前容器对象作为参数传入&lt;/span&gt;
&lt;span class="x"&gt;        // 从这里可以看到，容器里可以存放普通的配置信息（如settings），也可以存放组件配置&lt;/span&gt;
&lt;span class="x"&gt;        return $isInvokable ? $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]($this) : $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)];&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    return $default;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们再来看看单例组件的实现，以request为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;// 注册单例组件request&lt;/span&gt;
&lt;span class="x"&gt;$this-&amp;gt;container-&amp;gt;singleton(&amp;#39;request&amp;#39;, function ($c) {&lt;/span&gt;
&lt;span class="x"&gt;    // request组件的实例化依赖于environment组件，&lt;/span&gt;
&lt;span class="x"&gt;    // 而environment组件包含了$_SERVER以及进程标准输入的数据&lt;/span&gt;
&lt;span class="x"&gt;    return new \Slim\Http\Request($c[&amp;#39;environment&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;singleton&lt;/code&gt;方法的实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Ensure a value or object will remain globally unique&lt;/span&gt;
&lt;span class="x"&gt; * @param  string   $key   The value or object name&lt;/span&gt;
&lt;span class="x"&gt; * @param  \Closure $value The closure that defines the object&lt;/span&gt;
&lt;span class="x"&gt; * @return mixed&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function singleton($key, $value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;set($key, function ($c) use ($value) {&lt;/span&gt;
&lt;span class="x"&gt;        // 静态对象&lt;/span&gt;
&lt;span class="x"&gt;        static $object;&lt;/span&gt;

&lt;span class="x"&gt;        if (null === $object) {&lt;/span&gt;
&lt;span class="x"&gt;            $object = $value($c);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;

&lt;span class="x"&gt;        return $object;&lt;/span&gt;
&lt;span class="x"&gt;    });&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;中间件&lt;/h4&gt;
&lt;p&gt;Slim中的中间件分两种：应用级中间件、路由级中间件。&lt;/p&gt;
&lt;p&gt;应用中间件基于Rack协议实现，可以在应用对象调用之前或之后检查、分析、或修改应用环境变量、请求对象、响应对象。&lt;/p&gt;
&lt;p&gt;每个中间件类都继承自抽象类Middleware，且需要实现其抽象方法call。所有注册的中间件组成一个中间件栈，其结构类似于一个洋葱，先注册的中间件在里层，后注册的在外层，最里层的是应用对象自身，请求从外到里逐层进行处理，任何一层都可以根据条件直接响应请求或递归调用往里一层/下一个中间件。&lt;/p&gt;
&lt;p&gt;以中间件SessionCookie与MethodOverride为例，其call方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;// 中间件SessionCookie&lt;/span&gt;
&lt;span class="x"&gt;public function call()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 加载session数据&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;loadSession();&lt;/span&gt;
&lt;span class="x"&gt;    // 调用下一个中间件&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;next-&amp;gt;call();&lt;/span&gt;
&lt;span class="x"&gt;    // 保存session数据&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;saveSession();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;// 中间件MethodOverride&lt;/span&gt;
&lt;span class="x"&gt;public function call()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $env = $this-&amp;gt;app-&amp;gt;environment();&lt;/span&gt;
&lt;span class="x"&gt;    if (isset($env[&amp;#39;HTTP_X_HTTP_METHOD_OVERRIDE&amp;#39;])) {&lt;/span&gt;
&lt;span class="x"&gt;        // Header commonly used by Backbone.js and others&lt;/span&gt;
&lt;span class="x"&gt;        $env[&amp;#39;slim.method_override.original_method&amp;#39;] = $env[&amp;#39;REQUEST_METHOD&amp;#39;];&lt;/span&gt;
&lt;span class="x"&gt;        $env[&amp;#39;REQUEST_METHOD&amp;#39;] = strtoupper($env[&amp;#39;HTTP_X_HTTP_METHOD_OVERRIDE&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;    } elseif (isset($env[&amp;#39;REQUEST_METHOD&amp;#39;]) &amp;amp;&amp;amp; $env[&amp;#39;REQUEST_METHOD&amp;#39;] === &amp;#39;POST&amp;#39;) {&lt;/span&gt;
&lt;span class="x"&gt;        // HTML Form Override&lt;/span&gt;
&lt;span class="x"&gt;        $req = new \Slim\Http\Request($env);&lt;/span&gt;
&lt;span class="x"&gt;        // $this-&amp;gt;settings[&amp;#39;key&amp;#39;] 默认为_METHOD&lt;/span&gt;
&lt;span class="x"&gt;        $method = $req-&amp;gt;post($this-&amp;gt;settings[&amp;#39;key&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;        if ($method) {&lt;/span&gt;
&lt;span class="x"&gt;            $env[&amp;#39;slim.method_override.original_method&amp;#39;] = $env[&amp;#39;REQUEST_METHOD&amp;#39;];&lt;/span&gt;
&lt;span class="x"&gt;            $env[&amp;#39;REQUEST_METHOD&amp;#39;] = strtoupper($method);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 调用下一个中间件&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;next-&amp;gt;call();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;路由级中间件可以是任何可被调用的东西（&lt;code&gt;is_callable&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;）。在相关路由的回调触发之前，会逐个调用绑定到这个路由的所有路由级中间件，代码实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;// 路由类Route的dispatch方法：&lt;/span&gt;
&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Dispatch route&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * This method invokes the route object&amp;#39;s callable. If middleware is&lt;/span&gt;
&lt;span class="x"&gt; * registered for the route, each callable middleware is invoked in&lt;/span&gt;
&lt;span class="x"&gt; * the order specified.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * @return bool&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function dispatch()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 逐个调用绑定的路由级中间件，以当前路由对象作为参数传入&lt;/span&gt;
&lt;span class="x"&gt;    foreach ($this-&amp;gt;middleware as $mw) {&lt;/span&gt;
&lt;span class="x"&gt;        call_user_func_array($mw, array($this));&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    // 调用路由回调，并将通过路由模式从URL中正则匹配到的参数传入回调&lt;/span&gt;
&lt;span class="x"&gt;    $return = call_user_func_array($this-&amp;gt;getCallable(), array_values($this-&amp;gt;getParams()));&lt;/span&gt;
&lt;span class="x"&gt;    return ($return === false) ? false : true;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;路由匹配&lt;/h4&gt;
&lt;p&gt;先来看看Slim应用对象的call方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Call&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * This method finds and iterates all route objects that match the current request URI.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function call()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    try {&lt;/span&gt;
&lt;span class="x"&gt;        if (isset($this-&amp;gt;environment[&amp;#39;slim.flash&amp;#39;])) {&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;view()-&amp;gt;setData(&amp;#39;flash&amp;#39;, $this-&amp;gt;environment[&amp;#39;slim.flash&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;applyHook(&amp;#39;slim.before&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        ob_start();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;applyHook(&amp;#39;slim.before.router&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        $dispatched = false;&lt;/span&gt;
&lt;span class="x"&gt;        // 路由匹配&lt;/span&gt;
&lt;span class="x"&gt;        $matchedRoutes = $this-&amp;gt;router-&amp;gt;getMatchedRoutes($this-&amp;gt;request-&amp;gt;getMethod(), $this-&amp;gt;request-&amp;gt;getResourceUri());&lt;/span&gt;
&lt;span class="x"&gt;        // 逐个路由分发执行&lt;/span&gt;
&lt;span class="x"&gt;        foreach ($matchedRoutes as $route) {&lt;/span&gt;
&lt;span class="x"&gt;            try {&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;applyHook(&amp;#39;slim.before.dispatch&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;                $dispatched = $route-&amp;gt;dispatch();&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;applyHook(&amp;#39;slim.after.dispatch&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;                if ($dispatched) {&lt;/span&gt;
&lt;span class="x"&gt;                    break;&lt;/span&gt;
&lt;span class="x"&gt;                }&lt;/span&gt;
&lt;span class="x"&gt;            } catch (\Slim\Exception\Pass $e) {&lt;/span&gt;
&lt;span class="x"&gt;                continue;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 当路由的回调抛出非Pass异常时，则会响应404&lt;/span&gt;
&lt;span class="x"&gt;        // 这貌似不好吧？&lt;/span&gt;
&lt;span class="x"&gt;        if (!$dispatched) {&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;notFound();&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;applyHook(&amp;#39;slim.after.router&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;stop();&lt;/span&gt;
&lt;span class="x"&gt;    } catch (\Slim\Exception\Stop $e) {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;response()-&amp;gt;write(ob_get_clean());&lt;/span&gt;
&lt;span class="x"&gt;    } catch (\Exception $e) {&lt;/span&gt;
&lt;span class="x"&gt;        if ($this-&amp;gt;config(&amp;#39;debug&amp;#39;)) {&lt;/span&gt;
&lt;span class="x"&gt;            throw $e;&lt;/span&gt;
&lt;span class="x"&gt;        } else {&lt;/span&gt;
&lt;span class="x"&gt;            try {&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;response()-&amp;gt;write(ob_get_clean());&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;error($e);&lt;/span&gt;
&lt;span class="x"&gt;            } catch (\Slim\Exception\Stop $e) {&lt;/span&gt;
&lt;span class="x"&gt;                // Do nothing&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中用于路由匹配的Router类的getMatchedRoutes方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Return route objects that match the given HTTP method and URI&lt;/span&gt;
&lt;span class="x"&gt; * @param  string               $httpMethod   The HTTP method to match against&lt;/span&gt;
&lt;span class="x"&gt; * @param  string               $resourceUri  The resource URI to match against&lt;/span&gt;
&lt;span class="x"&gt; * @param  bool                 $reload       Should matching routes be re-parsed?&lt;/span&gt;
&lt;span class="x"&gt; * @return array[\Slim\Route]&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function getMatchedRoutes($httpMethod, $resourceUri, $reload = false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if ($reload || is_null($this-&amp;gt;matchedRoutes)) {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;matchedRoutes = array();&lt;/span&gt;
&lt;span class="x"&gt;        foreach ($this-&amp;gt;routes as $route) {&lt;/span&gt;
&lt;span class="x"&gt;            // 如果当前请求的HTTP方法不被当前route支持且不是ANY，则跳过&lt;/span&gt;
&lt;span class="x"&gt;            if (!$route-&amp;gt;supportsHttpMethod($httpMethod) &amp;amp;&amp;amp; !$route-&amp;gt;supportsHttpMethod(&amp;quot;ANY&amp;quot;)) {&lt;/span&gt;
&lt;span class="x"&gt;                continue;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;

&lt;span class="x"&gt;            // 否则继续匹配环境变量PATH_INFO&lt;/span&gt;
&lt;span class="x"&gt;            if ($route-&amp;gt;matches($resourceUri)) {&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;matchedRoutes[] = $route;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    return $this-&amp;gt;matchedRoutes;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中用于PATH_INFO匹配的Route类的matches方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Matches URI?&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * Parse this route&amp;#39;s pattern, and then compare it to an HTTP resource URI&lt;/span&gt;
&lt;span class="x"&gt; * This method was modeled after the techniques demonstrated by Dan Sosedoff at:&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * http://blog.sosedoff.com/2009/09/20/rails-like-php-url-router/&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * @param  string $resourceUri A Request URI&lt;/span&gt;
&lt;span class="x"&gt; * @return bool&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function matches($resourceUri)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    //Convert URL params into regex patterns, construct a regex for this route, init params&lt;/span&gt;
&lt;span class="x"&gt;    // preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换&lt;/span&gt;
&lt;span class="x"&gt;    $patternAsRegex = preg_replace_callback(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;#:([\w]+)\+?#&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        array($this, &amp;#39;matchesCallback&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;        // 括号中的部分表示可选&lt;/span&gt;
&lt;span class="x"&gt;        // 如：/archive(/:year(/:month(/:day)))&lt;/span&gt;
&lt;span class="x"&gt;        str_replace(&amp;#39;)&amp;#39;, &amp;#39;)?&amp;#39;, (string)$this-&amp;gt;pattern)&lt;/span&gt;
&lt;span class="x"&gt;    );&lt;/span&gt;
&lt;span class="x"&gt;    // 即使pattern最后有斜杠/，对于URL来说也是可选的&lt;/span&gt;
&lt;span class="x"&gt;    if (substr($this-&amp;gt;pattern, -1) === &amp;#39;/&amp;#39;) {&lt;/span&gt;
&lt;span class="x"&gt;        $patternAsRegex .= &amp;#39;?&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    $regex = &amp;#39;#^&amp;#39; . $patternAsRegex . &amp;#39;$#&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    // 大小写不敏感&lt;/span&gt;
&lt;span class="x"&gt;    if ($this-&amp;gt;caseSensitive === false) {&lt;/span&gt;
&lt;span class="x"&gt;        $regex .= &amp;#39;i&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    //Cache URL params&amp;#39; names and values if this route matches the current HTTP request&lt;/span&gt;
&lt;span class="x"&gt;    // 正则匹配&lt;/span&gt;
&lt;span class="x"&gt;    if (!preg_match($regex, $resourceUri, $paramValues)) {&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    foreach ($this-&amp;gt;paramNames as $name) {&lt;/span&gt;
&lt;span class="x"&gt;        if (isset($paramValues[$name])) {&lt;/span&gt;
&lt;span class="x"&gt;            if (isset($this-&amp;gt;paramNamesPath[$name])) {&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;params[$name] = explode(&amp;#39;/&amp;#39;, urldecode($paramValues[$name]));&lt;/span&gt;
&lt;span class="x"&gt;            } else {&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;params[$name] = urldecode($paramValues[$name]);&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    return true;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中正则搜索替换的回调方法matchesCallback的实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Convert a URL parameter (e.g. &amp;quot;:id&amp;quot;, &amp;quot;:id+&amp;quot;) into a regular expression&lt;/span&gt;
&lt;span class="x"&gt; * @param  array $m URL parameters&lt;/span&gt;
&lt;span class="x"&gt; * @return string       Regular expression for URL parameter&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function matchesCallback($m)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;paramNames[] = $m[1];&lt;/span&gt;
&lt;span class="x"&gt;    if (isset($this-&amp;gt;conditions[$m[1]])) {&lt;/span&gt;
&lt;span class="x"&gt;        return &amp;#39;(?P&amp;lt;&amp;#39; . $m[1] . &amp;#39;&amp;gt;&amp;#39; . $this-&amp;gt;conditions[$m[1]] . &amp;#39;)&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    if (substr($m[0], -1) === &amp;#39;+&amp;#39;) {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;paramNamesPath[$m[1]] = 1;&lt;/span&gt;

&lt;span class="x"&gt;        return &amp;#39;(?P&amp;lt;&amp;#39; . $m[1] . &amp;#39;&amp;gt;.+)&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    return &amp;#39;(?P&amp;lt;&amp;#39; . $m[1] . &amp;#39;&amp;gt;[^/]+)&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h4&gt;实践&lt;/h4&gt;
&lt;p&gt;上周，基于Slim框架开发了一个RSS聚合小应用，见&lt;a href="https://github.com/youngsterxyf/feed-world"&gt;这里&lt;/a&gt;。前端也尝试使用了Vue.js。&lt;/p&gt;</summary><category term="PHP"></category><category term="slim"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>读书笔记：Modern PHP - New Features and Good Practices</title><link href="http://youngsterxyf.github.io/2015/03/12/read-modern-php/" rel="alternate"></link><updated>2015-03-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-03-12:2015/03/12/read-modern-php/</id><summary type="html">&lt;p&gt;&lt;img alt="modern-php" src="/assets/uploads/pics/modern-php.png" /&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/modern-php.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;推荐阅读！&lt;/p&gt;</summary><category term="笔记"></category><category term="PHP"></category></entry><entry><title>Yii源码阅读笔记 - 日志组件</title><link href="http://youngsterxyf.github.io/2015/03/09/read-yii-code-8/" rel="alternate"></link><updated>2015-03-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-03-09:2015/03/09/read-yii-code-8/</id><summary type="html">&lt;h3&gt;使用&lt;/h3&gt;
&lt;p&gt;Yii框架为开发者提供两个静态方法进行日志记录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;Yii::log($message, $level, $category);&lt;/span&gt;
&lt;span class="x"&gt;Yii::trace($message, $category);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两者的区别在于后者依赖于应用开启调试模式，即定义常量YII_DEBUG：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;defined(&amp;#39;YII_DEBUG&amp;#39;) or define(&amp;#39;YII_DEBUG&amp;#39;, true);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yii::log方法的调用需要指定message的level和category。category是格式为“xxx.yyy.zzz”的路径别名字符串，比如日志是在yii/framework/web/CController类中记录的，那么category为“system.web.CController”。level应为以下几种之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trace：Yii::trace方法即是使用的这个level。用于跟踪执行流&lt;/li&gt;
&lt;li&gt;info：记录通用信息日志&lt;/li&gt;
&lt;li&gt;profile：用于性能分析&lt;/li&gt;
&lt;li&gt;warning：用于记录警告日志&lt;/li&gt;
&lt;li&gt;error：用于记录重大错误日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要想日志真的输出到文件、邮件、web页面等地方，还得为应用添加如下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;array(&lt;/span&gt;
&lt;span class="x"&gt;    ......&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;preload&amp;#39;=&amp;gt;array(&amp;#39;log&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;components&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        ......&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;log&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CLogRouter&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;routes&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;                array(&lt;/span&gt;
&lt;span class="x"&gt;                    &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CFileLogRoute&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                    &amp;#39;levels&amp;#39;=&amp;gt;&amp;#39;trace, info&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                    &amp;#39;categories&amp;#39;=&amp;gt;&amp;#39;system.*&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                ),&lt;/span&gt;
&lt;span class="x"&gt;                array(&lt;/span&gt;
&lt;span class="x"&gt;                    &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CEmailLogRoute&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                    &amp;#39;levels&amp;#39;=&amp;gt;&amp;#39;error, warning&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                    &amp;#39;emails&amp;#39;=&amp;gt;&amp;#39;admin@example.com&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                ),&lt;/span&gt;
&lt;span class="x"&gt;            ),&lt;/span&gt;
&lt;span class="x"&gt;        ),&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注册使用名为log的组件，组件对应的类为CLogRouter（见类文件yii/framework/logging/CLogRouter.php），并且需要为组件提供参数routes，
从目录yii/framework/logging可以看到可使用的日志输出目标路由有：&lt;code&gt;CDbLogRoute&lt;/code&gt;（将日志记录到数据库中）、&lt;code&gt;CEmailLogRoute&lt;/code&gt;（将日志发送到邮箱）、&lt;code&gt;CFileLogRoute&lt;/code&gt;（记录到文件中）、&lt;code&gt;CWebLogRoute&lt;/code&gt;（将日志显示在对应的网页中）、&lt;code&gt;CProfileLogRoute&lt;/code&gt;，其中CProfileLogRoute直接继承自CWebLogRoute，其他路由类都直接继承自CLogRoute类。&lt;/p&gt;
&lt;p&gt;至于为什么需要对log组件进行preload，即预先实例化，后边再说。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;先来看看Yii::log和Yii::trace的实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Writes a trace message.&lt;/span&gt;
&lt;span class="x"&gt; * This method will only log a message when the application is in debug mode.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $msg message to be logged&lt;/span&gt;
&lt;span class="x"&gt; * @param string $category category of the message&lt;/span&gt;
&lt;span class="x"&gt; * @see log&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public static function trace($msg,$category=&amp;#39;application&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 得先定义常量YII_DEBUG为true&lt;/span&gt;
&lt;span class="x"&gt;    if(YII_DEBUG)&lt;/span&gt;
&lt;span class="x"&gt;        // CLogger::LEVEL_TRACE&lt;/span&gt;
&lt;span class="x"&gt;        self::log($msg,CLogger::LEVEL_TRACE,$category);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Logs a message.&lt;/span&gt;
&lt;span class="x"&gt; * Messages logged by this method may be retrieved via {@link CLogger::getLogs}&lt;/span&gt;
&lt;span class="x"&gt; * and may be recorded in different media, such as file, email, database, using&lt;/span&gt;
&lt;span class="x"&gt; * {@link CLogRouter}.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $msg message to be logged&lt;/span&gt;
&lt;span class="x"&gt; * @param string $level level of the message (e.g. &amp;#39;trace&amp;#39;, &amp;#39;warning&amp;#39;, &amp;#39;error&amp;#39;). It is case-insensitive.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $category category of the message (e.g. &amp;#39;system.web&amp;#39;). It is case-insensitive.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public static function log($msg,$level=CLogger::LEVEL_INFO,$category=&amp;#39;application&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(self::$_logger===null)&lt;/span&gt;
&lt;span class="x"&gt;        self::$_logger=new CLogger;&lt;/span&gt;
&lt;span class="x"&gt;    // 注意这里的常量YII_TRACE_LEVEL，如果想日志中含有对应文件名、对应行，那么应该定义YII_TRACE_LEVEL大于0，&lt;/span&gt;
&lt;span class="x"&gt;    // 这个常量的意思应该是日志追踪的深度&lt;/span&gt;
&lt;span class="x"&gt;    if(YII_DEBUG &amp;amp;&amp;amp; YII_TRACE_LEVEL&amp;gt;0 &amp;amp;&amp;amp; $level!==CLogger::LEVEL_PROFILE)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $traces=debug_backtrace();&lt;/span&gt;
&lt;span class="x"&gt;        $count=0;&lt;/span&gt;
&lt;span class="x"&gt;        foreach($traces as $trace)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(isset($trace[&amp;#39;file&amp;#39;],$trace[&amp;#39;line&amp;#39;]) &amp;amp;&amp;amp; strpos($trace[&amp;#39;file&amp;#39;],YII_PATH)!==0)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                $msg.=&amp;quot;\nin &amp;quot;.$trace[&amp;#39;file&amp;#39;].&amp;#39; (&amp;#39;.$trace[&amp;#39;line&amp;#39;].&amp;#39;)&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;                if(++$count&amp;gt;=YII_TRACE_LEVEL)&lt;/span&gt;
&lt;span class="x"&gt;                    break;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 调用的是CLogger类的log方法&lt;/span&gt;
&lt;span class="x"&gt;    self::$_logger-&amp;gt;log($msg,$level,$category);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CLogger类的log方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Logs a message.&lt;/span&gt;
&lt;span class="x"&gt; * Messages logged by this method may be retrieved back via {@link getLogs}.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $message message to be logged&lt;/span&gt;
&lt;span class="x"&gt; * @param string $level level of the message (e.g. &amp;#39;Trace&amp;#39;, &amp;#39;Warning&amp;#39;, &amp;#39;Error&amp;#39;). It is case-insensitive.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $category category of the message (e.g. &amp;#39;system.web&amp;#39;). It is case-insensitive.&lt;/span&gt;
&lt;span class="x"&gt; * @see getLogs&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function log($message,$level=&amp;#39;info&amp;#39;,$category=&amp;#39;application&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_logs[]=array($message,$level,$category,microtime(true));&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_logCount++;&lt;/span&gt;
&lt;span class="x"&gt;    // autoFlush的默认值为10000，即只有当日志的条数达到10000（或请求处理结束时），才会flush到输出，否则一直将日志存放在内存中&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;autoFlush&amp;gt;0 &amp;amp;&amp;amp; $this-&amp;gt;_logCount&amp;gt;=$this-&amp;gt;autoFlush &amp;amp;&amp;amp; !$this-&amp;gt;_processing)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_processing=true;&lt;/span&gt;
&lt;span class="x"&gt;        // autoDump默认为false&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;flush($this-&amp;gt;autoDump);&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_processing=false;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CLogger类的flush方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Removes all recorded messages from the memory.&lt;/span&gt;
&lt;span class="x"&gt; * This method will raise an {@link onFlush} event.&lt;/span&gt;
&lt;span class="x"&gt; * The attached event handlers can process the log messages before they are removed.&lt;/span&gt;
&lt;span class="x"&gt; * @param boolean $dumpLogs whether to process the logs immediately as they are passed to log route&lt;/span&gt;
&lt;span class="x"&gt; * @since 1.1.0&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function flush($dumpLogs=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 事件对象中会带有当前的CLogger对象，作为事件的发送者&lt;/span&gt;
&lt;span class="x"&gt;    // 但在类CLogRouter的方法collectLogs和processLogs中并没有使用这个CLogger对象，&lt;/span&gt;
&lt;span class="x"&gt;    // 而是通过Yii::getLogger()来得到同一个CLogger对象，为什么不直接使用呢？&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;onFlush(new CEvent($this, array(&amp;#39;dumpLogs&amp;#39;=&amp;gt;$dumpLogs)));&lt;/span&gt;
&lt;span class="x"&gt;    // 清空重置&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_logs=array();&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_logCount=0;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Raises an &amp;lt;code&amp;gt;onFlush&amp;lt;/code&amp;gt; event.&lt;/span&gt;
&lt;span class="x"&gt; * @param CEvent $event the event parameter&lt;/span&gt;
&lt;span class="x"&gt; * @since 1.1.0&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function onFlush($event)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 抛出onFlush事件&lt;/span&gt;
&lt;span class="x"&gt;    // raiseEvent方法定义在CComponent类中，CLogger类继承自CComponent类&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;raiseEvent(&amp;#39;onFlush&amp;#39;, $event);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CComponent类的raiseEvent方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Raises an event.&lt;/span&gt;
&lt;span class="x"&gt; * This method represents the happening of an event. It invokes&lt;/span&gt;
&lt;span class="x"&gt; * all attached handlers for the event.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $name the event name&lt;/span&gt;
&lt;span class="x"&gt; * @param CEvent $event the event parameter&lt;/span&gt;
&lt;span class="x"&gt; * @throws CException if the event is undefined or an event handler is invalid.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function raiseEvent($name,$event)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $name=strtolower($name);&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($this-&amp;gt;_e[$name]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 逐个执行与事件$name绑定的$handler&lt;/span&gt;
&lt;span class="x"&gt;        foreach($this-&amp;gt;_e[$name] as $handler)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(is_string($handler))&lt;/span&gt;
&lt;span class="x"&gt;                // 会将事件对象(CEvent对象)传到$handler中&lt;/span&gt;
&lt;span class="x"&gt;                call_user_func($handler,$event);&lt;/span&gt;
&lt;span class="x"&gt;            elseif(is_callable($handler,true))&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                if(is_array($handler))&lt;/span&gt;
&lt;span class="x"&gt;                {&lt;/span&gt;
&lt;span class="x"&gt;                    // an array: 0 - object, 1 - method name&lt;/span&gt;
&lt;span class="x"&gt;                    list($object,$method)=$handler;&lt;/span&gt;
&lt;span class="x"&gt;                    if(is_string($object))  // static method call&lt;/span&gt;
&lt;span class="x"&gt;                        call_user_func($handler,$event);&lt;/span&gt;
&lt;span class="x"&gt;                    elseif(method_exists($object,$method))&lt;/span&gt;
&lt;span class="x"&gt;                        $object-&amp;gt;$method($event);&lt;/span&gt;
&lt;span class="x"&gt;                    else&lt;/span&gt;
&lt;span class="x"&gt;                        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is attached with an invalid handler &amp;quot;{handler}&amp;quot;.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name, &amp;#39;{handler}&amp;#39;=&amp;gt;$handler[1])));&lt;/span&gt;
&lt;span class="x"&gt;                }&lt;/span&gt;
&lt;span class="x"&gt;                else // PHP 5.3: anonymous function&lt;/span&gt;
&lt;span class="x"&gt;                    call_user_func($handler,$event);&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is attached with an invalid handler &amp;quot;{handler}&amp;quot;.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                    array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name, &amp;#39;{handler}&amp;#39;=&amp;gt;gettype($handler))));&lt;/span&gt;
&lt;span class="x"&gt;            // stop further handling if param.handled is set true&lt;/span&gt;
&lt;span class="x"&gt;            if(($event instanceof CEvent) &amp;amp;&amp;amp; $event-&amp;gt;handled)&lt;/span&gt;
&lt;span class="x"&gt;                return;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    elseif(YII_DEBUG &amp;amp;&amp;amp; !$this-&amp;gt;hasEvent($name))&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is not defined.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看到这里，你可能会很奇怪怎么都没看到真正记录日志的代码呢？在与事件绑定的各个$handler里呢，这也是log组件的routes参数配置成数组的原因，$handle就是该数组中对应类的实例化对象的日志记录方法。&lt;/p&gt;
&lt;p&gt;那么这些$handle是在哪里绑定事件的呢？&lt;/p&gt;
&lt;p&gt;既然log组件对应的是CLogRouter类，那么来看看其实现。&lt;/p&gt;
&lt;p&gt;类CLogRouter继承自类CApplicationComponent。根据&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;一文，可知组件初始化时实例化对象会调用init方法来完成一些初始化操作，类CLogRouter的init方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Initializes this application component.&lt;/span&gt;
&lt;span class="x"&gt; * This method is required by the IApplicationComponent interface.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function init()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    parent::init();&lt;/span&gt;
&lt;span class="x"&gt;    // 实例化配置的routes参数中指定的日志路由类列表&lt;/span&gt;
&lt;span class="x"&gt;    foreach($this-&amp;gt;_routes as $name=&amp;gt;$route)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $route=Yii::createComponent($route);&lt;/span&gt;
&lt;span class="x"&gt;        $route-&amp;gt;init();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_routes[$name]=$route;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 将当前对象的collectLogs方法绑定到事件onFlush&lt;/span&gt;
&lt;span class="x"&gt;    Yii::getLogger()-&amp;gt;attachEventHandler(&amp;#39;onFlush&amp;#39;,array($this,&amp;#39;collectLogs&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;    // 将当前对象的processLogs方法绑定到事件onEndRequest（表示请求处理结束？）&lt;/span&gt;
&lt;span class="x"&gt;    Yii::app()-&amp;gt;attachEventHandler(&amp;#39;onEndRequest&amp;#39;,array($this,&amp;#39;processLogs&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而类CLogRouter的方法collectLogs和processLogs实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Collects log messages from a logger.&lt;/span&gt;
&lt;span class="x"&gt; * This method is an event handler to the {@link CLogger::onFlush} event.&lt;/span&gt;
&lt;span class="x"&gt; * @param CEvent $event event parameter&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function collectLogs($event)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $logger=Yii::getLogger();&lt;/span&gt;
&lt;span class="x"&gt;    $dumpLogs=isset($event-&amp;gt;params[&amp;#39;dumpLogs&amp;#39;]) &amp;amp;&amp;amp; $event-&amp;gt;params[&amp;#39;dumpLogs&amp;#39;];&lt;/span&gt;
&lt;span class="x"&gt;    // 遍历所有日志路由对象，执行其方法collectLogs&lt;/span&gt;
&lt;span class="x"&gt;    foreach($this-&amp;gt;_routes as $route)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 属性enabled默认值为true&lt;/span&gt;
&lt;span class="x"&gt;        if($route-&amp;gt;enabled)&lt;/span&gt;
&lt;span class="x"&gt;            // $dumpLogs默认为false，由事件对象传过来&lt;/span&gt;
&lt;span class="x"&gt;            $route-&amp;gt;collectLogs($logger,$dumpLogs);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Collects and processes log messages from a logger.&lt;/span&gt;
&lt;span class="x"&gt; * This method is an event handler to the {@link CApplication::onEndRequest} event.&lt;/span&gt;
&lt;span class="x"&gt; * @param CEvent $event event parameter&lt;/span&gt;
&lt;span class="x"&gt; * @since 1.1.0&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function processLogs($event)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $logger=Yii::getLogger();&lt;/span&gt;
&lt;span class="x"&gt;    // 遍历所有日志路由对象，执行其方法collectLogs&lt;/span&gt;
&lt;span class="x"&gt;    foreach($this-&amp;gt;_routes as $route)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($route-&amp;gt;enabled)&lt;/span&gt;
&lt;span class="x"&gt;            // 注意这里参数$dumpLogs参数值始终为true&lt;/span&gt;
&lt;span class="x"&gt;            $route-&amp;gt;collectLogs($logger,true);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以类CWebLogRoute为例来看看日志路由类的方法collectLogs，该方法定义于类CLogRoute中，实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Retrieves filtered log messages from logger for further processing.&lt;/span&gt;
&lt;span class="x"&gt; * @param CLogger $logger logger instance&lt;/span&gt;
&lt;span class="x"&gt; * @param boolean $processLogs whether to process the logs after they are collected from the logger&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;// 事件onFlush触发时，传入的$processLogs参数值默认为false，事件onEndRequest触发时为true&lt;/span&gt;
&lt;span class="x"&gt;public function collectLogs($logger, $processLogs=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 从类CLogger实例化对象的_logs属性值中过滤得到目标日志记录&lt;/span&gt;
&lt;span class="x"&gt;    $logs=$logger-&amp;gt;getLogs($this-&amp;gt;levels,$this-&amp;gt;categories,$this-&amp;gt;except);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;logs=empty($this-&amp;gt;logs) ? $logs : array_merge($this-&amp;gt;logs,$logs);&lt;/span&gt;
&lt;span class="x"&gt;    if($processLogs &amp;amp;&amp;amp; !empty($this-&amp;gt;logs))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;filter!==null)&lt;/span&gt;
&lt;span class="x"&gt;            Yii::createComponent($this-&amp;gt;filter)-&amp;gt;filter($this-&amp;gt;logs);&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;logs!==array())&lt;/span&gt;
&lt;span class="x"&gt;            // 调用实际route的processLogs方法&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;processLogs($this-&amp;gt;logs);&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;logs=array();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而类CWebLogRoute的processLogs方法实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Displays the log messages.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $logs list of log messages&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function processLogs($logs)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;render(&amp;#39;log&amp;#39;,$logs);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Renders the view.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $view the view name (file name without extension). The file is assumed to be located under framework/data/views.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $data data to be passed to the view&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function render($view,$data)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $app=Yii::app();&lt;/span&gt;
&lt;span class="x"&gt;    $isAjax=$app-&amp;gt;getRequest()-&amp;gt;getIsAjaxRequest();&lt;/span&gt;
&lt;span class="x"&gt;    $isFlash=$app-&amp;gt;getRequest()-&amp;gt;getIsFlashRequest();&lt;/span&gt;

&lt;span class="x"&gt;    // 用firebug来显示日志信息的话？&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;showInFireBug)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // do not output anything for ajax and/or flash requests if needed&lt;/span&gt;
&lt;span class="x"&gt;        if($isAjax &amp;amp;&amp;amp; $this-&amp;gt;ignoreAjaxInFireBug || $isFlash &amp;amp;&amp;amp; $this-&amp;gt;ignoreFlashInFireBug)&lt;/span&gt;
&lt;span class="x"&gt;            return;&lt;/span&gt;
&lt;span class="x"&gt;        $view.=&amp;#39;-firebug&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;        if(($userAgent=$app-&amp;gt;getRequest()-&amp;gt;getUserAgent())!==null &amp;amp;&amp;amp; preg_match(&amp;#39;/msie [5-9]/i&amp;#39;,$userAgent))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            echo &amp;#39;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;            echo file_get_contents(dirname(__FILE__).&amp;#39;/../vendors/console-normalizer/normalizeconsole.min.js&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;            echo &amp;quot;&amp;lt;/script&amp;gt;\n&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    elseif(!($app instanceof CWebApplication) || $isAjax || $isFlash)&lt;/span&gt;
&lt;span class="x"&gt;        return;&lt;/span&gt;

&lt;span class="x"&gt;    // 渲染yii/framework/views/log.php（log-firebug.php），将结果放在实际请求页面内容的下面&lt;/span&gt;
&lt;span class="x"&gt;    $viewFile=YII_PATH.DIRECTORY_SEPARATOR.&amp;#39;views&amp;#39;.DIRECTORY_SEPARATOR.$view.&amp;#39;.php&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    include($app-&amp;gt;findLocalizedFile($viewFile,&amp;#39;en&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述代码可以知道日志路由类是将日志信息按照一定格式显示在实际请求页面内容的下方。&lt;/p&gt;
&lt;p&gt;再来看看方法init中调用的两个attachEventHandler，它们的定义是同一个，定义在类CComponent中（类CLogger直接继承自类CComponent），实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function attachEventHandler($name,$handler)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 将事件处理器$handler加到处理器列表中，在事件发生时会逐个处理器触发执行&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;getEventHandlers($name)-&amp;gt;add($handler);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中方法EventHandlers的实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Returns the list of attached event handlers for an event.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $name the event name&lt;/span&gt;
&lt;span class="x"&gt; * @return CList list of attached event handlers for the event&lt;/span&gt;
&lt;span class="x"&gt; * @throws CException if the event is not defined&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function getEventHandlers($name)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;hasEvent($name))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $name=strtolower($name);&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($this-&amp;gt;_e[$name]))&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_e[$name]=new CList;&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_e[$name];&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Event &amp;quot;{class}.{event}&amp;quot; is not defined.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{event}&amp;#39;=&amp;gt;$name)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述分析可以知道所谓事件系统，其实就是将处理函数/对象方法放到与事件ID对应的一个列表中，然后在事件触发时，逐个调用执行这些函数/对象方法。&lt;/p&gt;
&lt;p&gt;Yii框架基于事件系统，可以做到同时将日志信息写到多个目标输出中。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;回到之前提到的那个问题：为什么需要对log组件进行preload？&lt;/p&gt;
&lt;p&gt;这是因为：对于日志组件的使用并不是通过&lt;code&gt;Yii::app()-&amp;gt;db&lt;/code&gt;这种形式来调用的（如果基于这种形式，那么就可以在首次调用时再做组件实例化，以实现组件延迟加载），而是通过触发事件来间接调用，但这就需要在事件触发之间将相关的处理函数/对象方法绑定到事件，这个绑定操作又是在日志log组件的init方法中执行的，一般组件类实例化时才会调用其init方法，所以需要对log组件进行预加载。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.yiiframework.com/doc/guide/1.1/en/topics.logging"&gt;Yii - topics - Logging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>又是一年</title><link href="http://youngsterxyf.github.io/2015/01/03/the-2014-is-gone/" rel="alternate"></link><updated>2015-01-03T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2015-01-03:2015/01/03/the-2014-is-gone/</id><summary type="html">&lt;p&gt;又是一年，依照惯例，得写一篇总结和计划。当然计划更多的只是一种自我鼓励，现实总是一次又一次地证明“计划赶不上变化”。&lt;/p&gt;
&lt;p&gt;我的2014，可能用三个关键词就能概括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结婚&lt;/li&gt;
&lt;li&gt;换工作&lt;/li&gt;
&lt;li&gt;众成技术聚乐部&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;结婚&lt;/h4&gt;
&lt;p&gt;继13年领证，14年把婚礼也办了。由于两家离得远，婚礼也就分两次办。之间还补拍了婚纱照。虽然于我这些流程显得有点折腾，但重要的是大家都是很开心，也不希望老婆以后会有丁点遗憾。&lt;/p&gt;
&lt;p&gt;希望以后的日子总能努力让老婆开心幸福。&lt;/p&gt;
&lt;h4&gt;换工作&lt;/h4&gt;
&lt;p&gt;工作的时间并不长，本没想这么快换工作，何况我还是一个挺念旧的人。但还是那句话“计划赶不上变化”，不得已主动离职跳槽。&lt;/p&gt;
&lt;p&gt;对于目前的工作还比较满意，能做些自己喜欢做的事情，工作氛围也还不错。&lt;/p&gt;
&lt;p&gt;对于自己的要求就是踏踏实实做工作搞技术，不急不躁。&lt;/p&gt;
&lt;h4&gt;&lt;a href="http://happytechgroup.github.io/"&gt;众成技术聚乐部&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;参加过各种大大小小的会议，总觉得水太多，但如果始终自己一个人蒙头研究技术，也有可能落得个“闭门造车”、“目光短浅”的下场，技术的“理”也是越辩越明，所以找了三五同学朋友搞起自己的技术沙龙，
名为“众成技术聚乐部”，之所以为“众成”，是希望&lt;strong&gt;众人成就众人&lt;/strong&gt;，大家相互成就，之所以为“聚乐部”而不是“俱乐部”，是认为大家一起讨论分享技术应该是一件乐呵的事情，不要搞得那么严肃苦逼。&lt;/p&gt;
&lt;p&gt;聚乐部至今已搞了5次聚会，一个月一次，从我个人的角度来看，效果不错，虽然很多地方还有待改进。感谢所有成员的付出！&lt;/p&gt;
&lt;h4&gt;其他&lt;/h4&gt;
&lt;p&gt;技术上，相比上一年，有了些许进步 - 借着“众成”的技术分享，简单阅读了leveldb（Go语言版）的源码、Memcached源码等；为了把工作做得更好，又仔细地阅读了Yii框架源码，并写了&lt;a href="http://youngsterxyf.github.io/tag/yii.html"&gt;系列文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在写博客一事上，2014年我也不算太偷懒，共写了26篇，虽然文章质量不咋地，远远未达到自己的要求，但一切贵在坚持，不是么？&lt;/p&gt;
&lt;p&gt;阅读方面，书目如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;淘宝技术这十年 （3星，成为大牛也是要看机遇的）&lt;/li&gt;
&lt;li&gt;Web容量规划的艺术 （4星）&lt;/li&gt;
&lt;li&gt;世界是数字的 （5星，计算机科普）&lt;/li&gt;
&lt;li&gt;三体（三册）（1、2册5星，第3册4星）&lt;/li&gt;
&lt;li&gt;20个月赚130亿 - YouTube创始人陈士骏自传 （4星，好吧，这翻译的书名真俗气，但其实是本挺不错的书）&lt;/li&gt;
&lt;li&gt;PHP精粹-编写高效PHP代码 （3星，仔细阅读了前半部分，快速浏览了后半部分）&lt;/li&gt;
&lt;li&gt;MacTalk - 人生元编程 (3星，电子书，大致过了一遍）&lt;/li&gt;
&lt;li&gt;编写高质量代码：改进Python程序的91个建议 （4星，需再读一遍）&lt;/li&gt;
&lt;li&gt;文明之光（两册，5星，有态度的浓缩的世界文明史）&lt;/li&gt;
&lt;li&gt;了不起的Node.js（2星，浏览了一遍）&lt;/li&gt;
&lt;li&gt;Pro Git （4星，Git资料中的No.1）&lt;/li&gt;
&lt;li&gt;演讲之禅：一位技术演讲家的自白 （4星，每个技术人都应该多演讲，所以推荐每个技术人都读一下这本书）&lt;/li&gt;
&lt;li&gt;高性能PHP应用开发 （3星）&lt;/li&gt;
&lt;li&gt;翻译漫谈：怎样翻译更地道 （4星，未读完）&lt;/li&gt;
&lt;li&gt;最璀璨的银河：刘慈欣经典作品集 （4星，读完三体，意犹未尽，故找来大刘的中短篇集读读）&lt;/li&gt;
&lt;li&gt;数据之巅 （5星，数据思维，有点震撼到我，推荐，需再读一遍）&lt;/li&gt;
&lt;li&gt;大型网站技术架构:核心原理与案例分析 (4星，虽然没什么新东西，但系统地科普了Web架构方面的东西，还是值得一读的)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从书目可以看出，技术相关的还是缺乏深度和专注。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;2015 ...&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;做好工作，多思考，多做实在的事情&lt;/li&gt;
&lt;li&gt;继续搞好众成技术聚乐部&lt;/li&gt;
&lt;li&gt;坚持写博客，向深度发展&lt;/li&gt;
&lt;li&gt;选择一两个优秀开源项目，读源码、写博客、做分享，旨在提高系统设计能力和编码能力&lt;/li&gt;
&lt;li&gt;读有想法、有深度的书&lt;/li&gt;
&lt;li&gt;考驾照 （别笑，哈哈）&lt;/li&gt;
&lt;li&gt;以讲师的身份参加一次技术会议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;（额，“计划”本不该多说，但貌似还是说多了点...）&lt;/em&gt;&lt;/p&gt;</summary><category term="总结"></category></entry><entry><title>Cordova/Phonegap应用构建环境搭建</title><link href="http://youngsterxyf.github.io/2014/12/31/setup-cordova-env/" rel="alternate"></link><updated>2014-12-31T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-12-31:2014/12/31/setup-cordova-env/</id><summary type="html">&lt;p&gt;混合（Hybrid）移动开发将Web开发与原生开发优势互补，之后应该是一个不错的方向。Phonegap是混合移动开发的一个方案，
开发者可以使用标准的Web技术进行开发，然后使用Phonegap打包成原生APP，也可以为Phonegap开发插件来扩展APP功能。
Cordova是Apache的顶级项目，起于Adobe贡献给Apache基金会的Phonegap源码，之后Phonegap官方貌似则专注于提供Phonegap应用的云构建服务。
Phonegap官网提供的文档与Apache Cordova文档是相同的，所以从技术上可以将Phonegap与Cordova视为同一个东西。&lt;/p&gt;
&lt;p&gt;虽然Phonegap官方提供免费的开放（public）应用以及一个私有应用构建服务。但对于应用调试或插件开发来说，
使用云构建服务上传源码下载APP还是挺耗时间的，不太方便，所以搭建本地的应用构建环境是必要的。&lt;/p&gt;
&lt;p&gt;依据Cordova文档的&lt;a href="http://cordova.apache.org/docs/en/4.0.0/guide_cli_index.md.html#The%20Command-Line%20Interface"&gt;The Command-Line Interface&lt;/a&gt;
部分，针对Android应用，在Ubuntu上搭建Cordova应用构建环境的步骤如下所示：&lt;/p&gt;
&lt;h4&gt;1. 安装Node.js和git客户端&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;a href="http://nodejs.org/download/"&gt;NodeJS官网&lt;/a&gt;下载Linux二进制压缩包，解压缩后将bin路径加入PATH环境变量，即可从命令行执行node、npm命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 安装Cordova：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo npm install -g cordova&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. 下载JDK：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install default-jdk default-jre&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4. 安装Android SDK：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从Android官网的&lt;a href="http://developer.android.com/sdk/installing/index.html"&gt;这里&lt;/a&gt;下载Android Studio或独立的SDK工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果下载Android Studio，解压缩后执行&lt;code&gt;bin/android.sh&lt;/code&gt;，Android Studio启动时需要从Google的服务器上获取一些SDK相关的文件，
由于GFW的原因，无法成功获取，也就无法顺利启动。Android Studio网络代理设置的方法（参考&lt;a href="http://stackoverflow.com/questions/27683678/android-studio-component-installation-not-working-in-proxy-security-server?lq=1"&gt;这里&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;在Android Studio首次启动后，可以在HOME目录下找到文件&lt;code&gt;~/.AndroidStudio/config/options/other.xml&lt;/code&gt;，在该文件中，可以找到如下几行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;option name=&amp;quot;PROXY_TYPE_IS_SOCKS&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;USE_HTTP_PROXY&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;USE_PROXY_PAC&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_HOST&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_PORT&amp;quot; value=&amp;quot;80&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_AUTHENTICATION&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_LOGIN&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;PROXY_PASSWORD_CRYPT&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
&amp;lt;option name=&amp;quot;KEEP_PROXY_PASSWORD&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果使用HTTP协议的代理，则将“USE_HTTP_PROXY”一项的value改为“true”，“PROXY_HOST”、“PROXY_PORT”的value分别设置为代理的域名和端口，
如果代理需要身份认证，则将“PROXY_AUTHENTICATION”的value改为“true”，并设置“PROXY_LOGIN”、“PROXY_PASSWORD_CRYPT”两项。&lt;/p&gt;
&lt;p&gt;重启Android Studio即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果下载独立的SDK工具，假设解压缩后的路径为&lt;code&gt;~/Android&lt;/code&gt;，则添加环境变量&lt;code&gt;ANDROID_HOME=~/Android&lt;/code&gt;，并将子目录tools加入PATH环境变量。&lt;/p&gt;
&lt;p&gt;执行命令 &lt;code&gt;android&lt;/code&gt; 打开Android SDK管理器，与Android Studio一样，也需要设置网络代理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开菜单项“Tools -&amp;gt; Options”，填入“HTTP Proxy Server”、“HTTP Proxy Port”两项的值，重新启动Android SDK管理器即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;由于当前Cordora构建Android应用依赖于Android API 19，即Android 4.4.2，所以需要在“Android Studio”或“Android SDK管理器”
下载“Android API 19”相关的依赖包。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：下载速度很慢，请耐心等待...&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;5. 安装ant&lt;/h4&gt;
&lt;p&gt;当前Cordora构建Android应用也依赖于ant。从&lt;a href="https://www.apache.org/dist/ant/binaries/"&gt;Apache Ant&lt;/a&gt;官网下载二进制包，
解压缩后，将子目录bin加入PATH环境变量。&lt;/p&gt;
&lt;h4&gt;6. 测试&lt;/h4&gt;
&lt;p&gt;依次执行以下命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cordova create hello com.example.hello HelloWorld&lt;/code&gt;，该命令会在当前目录下创建hello子目录；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd hello&lt;/code&gt;，进入该示例工程目录；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cordova platform add android&lt;/code&gt;，为该工程添加Android平台支持；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cordova build android&lt;/code&gt;，将该工程构建成原生Android应用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cordova emulate android&lt;/code&gt;，打开Android模拟器运行示例应用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模拟器启动后如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="cordova-demo" src="/assets/uploads/pics/cordova_demo.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最终生成的apk文件在&lt;code&gt;hello/platforms/android/ant-build/&lt;/code&gt;路径下，默认名为“CordovaApp-debug.apk”。&lt;/p&gt;
&lt;p&gt;对于Cordora项目来说，源码目录即项目的www子目录。&lt;/p&gt;</summary><category term="笔记"></category><category term="Cordova"></category><category term="Phonegap"></category></entry><entry><title>读书笔记：演讲之禅-一个技术演讲家的自白</title><link href="http://youngsterxyf.github.io/2014/12/15/read-confessions-of-a-public-speaker/" rel="alternate"></link><updated>2014-12-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-12-15:2014/12/15/read-confessions-of-a-public-speaker/</id><summary type="html">&lt;p&gt;大大小小的技术会议参加过不少，关于演讲，从一个听众的角度也有一些心得；随着技术积累能力提升，也希望能够在一些正式场合做技术演讲。年轻的技术人应该学会经营自己，show出你自己。&lt;/p&gt;
&lt;p&gt;我并不是一个擅长表达的人，虽然私底下在朋友技术圈内做过一些技术分享，但对于正式场合的技术演讲却没什么经验。&lt;/p&gt;
&lt;p&gt;演讲是个经验活，但总归有一些可事先准备、能够提高成功概率的方法和注意事项吧？所以找来《演讲之禅-一个技术演讲家的自白》一书，看看是否能从别人的经验中学到点什么。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;毋庸置疑，这本书非常实在，值得一读。根据该书内容以及自己的一些想法，按照时间顺序整理出技术演讲相关的注意事项：&lt;/p&gt;
&lt;h4&gt;演讲前&lt;/h4&gt;
&lt;p&gt;一个成功的演讲毫无疑问是需要提前准备的，这里的“准备”不仅仅是准备幻灯片这么简单。&lt;/p&gt;
&lt;p&gt;首先，你需要搞清楚-举办方对会议或者活动的定位，与定位直接相关的即是听众-是哪些人，他们想知道什么，需要听到什么，根据这个定位来选择主题；
与主题相关的是你需要考虑自身是否有能力驾驭这个主题-待分享的技术你是否真的懂？这方面经验是否足够？不要试图分享那些自己还一知半解的技术点，否则就注定是在给自己挖坑！&lt;/p&gt;
&lt;p&gt;从听众情况和自身情况两方面来选择主题，另外还得根据演讲的时间来调整主题的范围大小。从小老师就告诉我们作文题目得小而具体，立意要新。个人认为对于演讲的题目也应如此。&lt;/p&gt;
&lt;p&gt;在确定演讲的具体题目后，个人建议可以先篇文章，在文章中将演讲题目相关的问题细节都搞清楚讲清楚，然后根据文章内容确定要分享内容中哪些方面（通常由于时间限制很难面面俱到，所以要有所选择），
定下演讲的提纲，即明确了演讲的整个大致的思路，这个“思路”决定了听众是否容易理解你演讲的内容、在演讲过程中是否能够一气呵成顺畅发挥，接下来就可以制作幻灯片了。&lt;/p&gt;
&lt;p&gt;对于幻灯片，应该每页都言简意赅，生动多图。在出现一个新的部分前最好再出现一下大纲，向听众明确“现在讲到哪了”、“接下来要讲的内容处于整个演讲的哪个位置”，避免听众迷失。&lt;/p&gt;
&lt;p&gt;不要想着把幻灯片一次性完美地做完，和文章、代码一样，优秀的幻灯片都是修改出来的。在做完幻灯片的初稿后，就可以开始演练 - 想象着站在演讲台上的场景，在心里对着幻灯片进行表述，
当然如果有人愿意做听众陪你演练那是再好不过了。演练过程中要注意：每页幻灯片的位置是否合适？其上的内容是否恰到好处？是否有助于自然地表述？如何紧凑自然地进行幻灯片之间的衔接？
这个过程通常伴随着对幻灯片的不断修改（通常删除的多增加的少），演练的最终效果应达到不看幻灯片也能清楚演讲大纲，看到一页幻灯片就能知道下一页幻灯片的内容。&lt;/p&gt;
&lt;p&gt;上面提到内容的准备要注意演讲的时间限制，练习过程要确保最终演讲所需时间不超过限制。&lt;/p&gt;
&lt;p&gt;除了内容相关的准备，注意幻灯片最好保存三份：网络存储一份、U盘一份、笔记本电脑中一份 - 带上自己的笔记本电脑去演讲现场，另外最好还打印一份纸质版的。&lt;/p&gt;
&lt;p&gt;应保证提前到场 - 熟悉环境及做好心理准备，还可以看看前面的演讲者的演讲过程。如果到演讲场地的路程较远，则应该把可能的堵车考虑在内。&lt;/p&gt;
&lt;h4&gt;演讲时&lt;/h4&gt;
&lt;p&gt;演讲时如果听众人数不多，或场地很大而听众坐得比较稀疏，则可以鼓励听众集中坐到前排来。&lt;/p&gt;
&lt;p&gt;如果预先不清楚听众的背景，那么可以先做个小的调查确定一下演讲的节奏、内容上的取舍等再开始演讲。&lt;/p&gt;
&lt;p&gt;演讲开始时简单自我介绍一下，然后设定一下演讲的步调：内容大致有哪些，所花时间为多少（当然可能听众通过会议日程已经获知），如果可以最好以一个笑话或故事开场激活一下现场氛围。&lt;/p&gt;
&lt;p&gt;注意正对听众，注意眼神交流，坦诚、自然而有激情，如果需要按照现场情况与听众进行一些小的互动。&lt;/p&gt;
&lt;p&gt;如果可以，在演讲的开始或结束告知听众的Email、社交网络ID（写在幻灯片上），以便进一步的交流或获取用户反馈。&lt;/p&gt;
&lt;p&gt;注意演讲时表达上的重读或者说声调上最好抑扬顿挫，以便听众更好地把握重点，也更容易吸引听众的注意力。&lt;/p&gt;
&lt;p&gt;适当地使用停顿 - 凝聚听众注意力、给听众留下思考和总结的空间。&lt;/p&gt;
&lt;p&gt;演讲时即使发生一些意外情况，也没什么大不了的，谨记：坦诚、自然/淡定、不卑不亢。&lt;/p&gt;
&lt;h4&gt;演讲后&lt;/h4&gt;
&lt;p&gt;为了提升自身的演讲水平，演讲后可以和听众交流一下，请他们提提意见。如果有朋友也在现场，那就最好了。&lt;/p&gt;
&lt;p&gt;如果演讲有视频记录，则也可以自己观看一下，找一下问题，查一下原因。&lt;/p&gt;
&lt;p&gt;也可以在社交网络上鼓励大家提意见（多半演讲之后会有很多人在社交网络关注你）。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;细节决定成败！更多演讲相关的细节问题推荐阅读《演讲之禅-一个技术演讲家的自白》。附上该书的思维导图笔记：&lt;/p&gt;
&lt;p&gt;&lt;img alt="read-confessions-of-a-public-speaker" src="/assets/uploads/pics/read-confessions-of-a-public-speaker.png" /&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/read-confessions-of-a-public-speaker.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;</summary><category term="笔记"></category><category term="演讲"></category></entry><entry><title>读书笔记：高性能PHP应用开发</title><link href="http://youngsterxyf.github.io/2014/12/08/read-high-performance-php-application/" rel="alternate"></link><updated>2014-12-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-12-08:2014/12/08/read-high-performance-php-application/</id><summary type="html">&lt;p&gt;注：&lt;em&gt;该书的部分内容过时了点 - 比如Opcode缓存：PHP 5.5之后内置一个用于缓存Opcode的组件Opcache，无需额外使用APC组件。所以需要“批判”地阅读。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mindmap-high-performance-php-application" src="/assets/uploads/pics/High-performance-php-app.png" /&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/High-performance-php-app.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;</summary><category term="PHP"></category><category term="笔记"></category></entry><entry><title>Yii源码阅读笔记 - 应用模块化</title><link href="http://youngsterxyf.github.io/2014/11/20/read-yii-code-7/" rel="alternate"></link><updated>2014-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-20:2014/11/20/read-yii-code-7/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架有个“模块（Module）”的概念，与“应用（Application）”类似，模块必须归属于一个父模块或者一个应用，模块不能单独部署，一个应用不一定要分模块。&lt;/p&gt;
&lt;p&gt;由此可以看到，Yii的“模块”和“应用”类似于Django框架中的“应用（App）”和“项目（Project）”。&lt;/p&gt;
&lt;p&gt;当一个应用的规模大到一定的程度 - 可能涉及多个团队来开发，就应该考虑分“模块”开发。“模块”通常对应应用的一个相对独立的功能。&lt;/p&gt;
&lt;p&gt;一个模块化的Yii框架应用的工程目录结构大致示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Yii-WebApp-Modules" src="/assets/uploads/pics/yii-webapp-modules.png" /&gt;&lt;/p&gt;
&lt;p&gt;上图所示项目有一个名为“forum”的模块，该模块下也有自己的&lt;code&gt;components&lt;/code&gt;、&lt;code&gt;controllers&lt;/code&gt;、&lt;code&gt;models&lt;/code&gt;、&lt;code&gt;views&lt;/code&gt;、&lt;code&gt;extensions&lt;/code&gt;目录，与一个普通的/不分模块的Yii框架Web应用的项目结构非常相似。&lt;/p&gt;
&lt;p&gt;Yii框架模块化应用的所有模块默认都是放在&lt;code&gt;protected/modules&lt;/code&gt;目录下，每个模块的内容又各自放在以模块ID（如&lt;code&gt;forum&lt;/code&gt;）为名称的子目录下，并且在模块子目录下要有一个模块类文件，如&lt;code&gt;ForumModule.php&lt;/code&gt;，该类文件的命名规范是：模块ID首字母大写，然后拼接上字符串Module。&lt;/p&gt;
&lt;p&gt;模块化的应用需要在配置文件中配置&lt;code&gt;modules&lt;/code&gt;一项 - 指定模块列表，示例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;#39;modules&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;forum&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        ...&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;anotherModule&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;
&lt;span class="x"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每个模块的配置，可以只指定模块ID，也可以通过数组来指定额外的信息，如模块类、类实例化参数、params、components，以及子模块等等。Yii中模块是可以嵌套的，并且嵌套深度没有限制（有这个必要么？不要玩脱了啊）。&lt;/p&gt;
&lt;p&gt;对应某个模块中的控制器及控制器中的Action，路由中需要带模块ID前缀，如&lt;code&gt;moduleID/controllerID/actionID&lt;/code&gt;，对于嵌套的模块，路由的形式则为&lt;code&gt;parentModuleID/childModuleID/controllerID/actionID&lt;/code&gt;。路由分发逻辑会根据模块ID到配置信息中查找对应的模块，最终分发到某个模块的某个控制器的某个Action中做处理。&lt;/p&gt;
&lt;p&gt;另外，Yii框架应用的模块化并不是必须把所有功能逻辑都拆分到各个模块，而是可以部分功能逻辑归到应用，部分逻辑归到模块，即可以不彻底地模块化，但个人认为最好别这么玩（应用下的controller的id和模块的id冲突怎么办？），并且最好不要用模块嵌套，以免搞得过于复杂，降低项目的可维护性。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;先从继承关系上看看“模块”与“应用”的相似性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CWebApplication&lt;/code&gt; -&amp;gt; &lt;code&gt;CApplication&lt;/code&gt; -&amp;gt; &lt;code&gt;CModule&lt;/code&gt; -&amp;gt; &lt;code&gt;CComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自定义模块类 -&amp;gt; &lt;code&gt;CWebModule&lt;/code&gt; -&amp;gt; &lt;code&gt;CModule&lt;/code&gt; -&amp;gt; &lt;code&gt;CComponent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可以看到继承链中类&lt;code&gt;CModule&lt;/code&gt;及上溯类的属性和方法，“模块”类和“应用”都有。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;由&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt;一文可知，应用配置的加载是抽象类CApplication的构造方法中调用方法&lt;code&gt;configure&lt;/code&gt;来完成的，
该方法定义于类&lt;code&gt;CModule&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Configures the module with the specified configuration.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $config the configuration array&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function configure($config)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($config))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($config as $key=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;$key=$value;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于配置项“modules”的加载，则是通过类&lt;code&gt;CComponent&lt;/code&gt;中的魔术方法&lt;code&gt;__set&lt;/code&gt;最终调用类&lt;code&gt;CModule&lt;/code&gt;中的&lt;code&gt;setModules&lt;/code&gt;方法来完成的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Configures the sub-modules of this module.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * Call this method to declare sub-modules and configure them with their initial property values.&lt;/span&gt;
&lt;span class="x"&gt; * The parameter should be an array of module configurations. Each array element represents a single module,&lt;/span&gt;
&lt;span class="x"&gt; * which can be either a string representing the module ID or an ID-configuration pair representing&lt;/span&gt;
&lt;span class="x"&gt; * a module with the specified ID and the initial property values.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * For example, the following array declares two modules:&lt;/span&gt;
&lt;span class="x"&gt; * &amp;lt;pre&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; * array(&lt;/span&gt;
&lt;span class="x"&gt; *     &amp;#39;admin&amp;#39;,                // a single module ID&lt;/span&gt;
&lt;span class="x"&gt; *     &amp;#39;payment&amp;#39;=&amp;gt;array(       // ID-configuration pair&lt;/span&gt;
&lt;span class="x"&gt; *         &amp;#39;server&amp;#39;=&amp;gt;&amp;#39;paymentserver.com&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt; *     ),&lt;/span&gt;
&lt;span class="x"&gt; * )&lt;/span&gt;
&lt;span class="x"&gt; * &amp;lt;/pre&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * By default, the module class is determined using the expression &amp;lt;code&amp;gt;ucfirst($moduleID).&amp;#39;Module&amp;#39;&amp;lt;/code&amp;gt;.&lt;/span&gt;
&lt;span class="x"&gt; * And the class file is located under &amp;lt;code&amp;gt;modules/$moduleID&amp;lt;/code&amp;gt;.&lt;/span&gt;
&lt;span class="x"&gt; * You may override this default by explicitly specifying the &amp;#39;class&amp;#39; option in the configuration.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * You may also enable or disable a module by specifying the &amp;#39;enabled&amp;#39; option in the configuration.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * @param array $modules module configurations.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function setModules($modules)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    foreach($modules as $id=&amp;gt;$module)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 如果只指定了模块的id&lt;/span&gt;
&lt;span class="x"&gt;        if(is_int($id))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $id=$module;&lt;/span&gt;
&lt;span class="x"&gt;            $module=array();&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 如果未指定模块对应的模块类，则默认通过路径别名$id.&amp;#39;.&amp;#39;.ucfirst($id).&amp;#39;Module&amp;#39;来查找对应的模块类&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($module[&amp;#39;class&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            Yii::setPathOfAlias($id,$this-&amp;gt;getModulePath().DIRECTORY_SEPARATOR.$id);&lt;/span&gt;
&lt;span class="x"&gt;            $module[&amp;#39;class&amp;#39;]=$id.&amp;#39;.&amp;#39;.ucfirst($id).&amp;#39;Module&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;

&lt;span class="x"&gt;        // 将模块配置信息存入属性_moduleConfig中&lt;/span&gt;
&lt;span class="x"&gt;        if(isset($this-&amp;gt;_moduleConfig[$id]))&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_moduleConfig[$id]=CMap::mergeArray($this-&amp;gt;_moduleConfig[$id],$module);&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_moduleConfig[$id]=$module;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到模块列表配置信息加载后并未对模块类进行实例化初始化。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;请求处理在路由解析得到目标路由后，调用方法&lt;code&gt;createController&lt;/code&gt;来做路由分发（这样表述可能不太严谨），该方法定义于类&lt;code&gt;CWebApplication&lt;/code&gt;中，实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function createController($route,$owner=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 如果未提供参数$owner，即未指定当前$route所属的模块，则默认当前应用对象为owner，可以将应用当做是顶级模块&lt;/span&gt;
&lt;span class="x"&gt;    if($owner===null)&lt;/span&gt;
&lt;span class="x"&gt;        $owner=$this;&lt;/span&gt;
&lt;span class="x"&gt;    // 如果路由为空，则使用默认路由&lt;/span&gt;
&lt;span class="x"&gt;    // 应用的默认路由ID是site，模块的默认路由ID为default&lt;/span&gt;
&lt;span class="x"&gt;    if(($route=trim($route,&amp;#39;/&amp;#39;))===&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;        $route=$owner-&amp;gt;defaultController;&lt;/span&gt;
&lt;span class="x"&gt;    // 路由是否大小写敏感&lt;/span&gt;
&lt;span class="x"&gt;    $caseSensitive=$this-&amp;gt;getUrlManager()-&amp;gt;caseSensitive;&lt;/span&gt;

&lt;span class="x"&gt;    $route.=&amp;#39;/&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    // 如果路由中还有斜杠&lt;/span&gt;
&lt;span class="x"&gt;    // 注意这里是个while循环&lt;/span&gt;
&lt;span class="x"&gt;    while(($pos=strpos($route,&amp;#39;/&amp;#39;))!==false)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 取出第一个斜杠之前的部分，用于之后的代码看看是否有对应该ID的controller或module&lt;/span&gt;
&lt;span class="x"&gt;        $id=substr($route,0,$pos);&lt;/span&gt;
&lt;span class="x"&gt;        if(!preg_match(&amp;#39;/^\w+$/&amp;#39;,$id))&lt;/span&gt;
&lt;span class="x"&gt;            return null;&lt;/span&gt;
&lt;span class="x"&gt;        if(!$caseSensitive)&lt;/span&gt;
&lt;span class="x"&gt;            $id=strtolower($id);&lt;/span&gt;
&lt;span class="x"&gt;        // 取出第一个斜杠之后的部分，用于可能的下一次循环处理&lt;/span&gt;
&lt;span class="x"&gt;        $route=(string)substr($route,$pos+1);&lt;/span&gt;
&lt;span class="x"&gt;        // 看看是否是第一次循环处理&lt;/span&gt;
&lt;span class="x"&gt;        // $basePath是在第一次循环处理时在这个if条件分支中才赋值的，所以第一次循环处理到这里时$basePath是未定义&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($basePath))  // first segment&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            // 先从应用或模块配置的controllerMap中看看是否有$id为key的controller，若有，则直接实例化对应的controll类并返回&lt;/span&gt;
&lt;span class="x"&gt;            if(isset($owner-&amp;gt;controllerMap[$id]))&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                return array(&lt;/span&gt;
&lt;span class="x"&gt;                    Yii::createComponent($owner-&amp;gt;controllerMap[$id],$id,$owner===$this?null:$owner),&lt;/span&gt;
&lt;span class="x"&gt;                    $this-&amp;gt;parseActionParams($route),&lt;/span&gt;
&lt;span class="x"&gt;                );&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;

&lt;span class="x"&gt;            // 看看当前应用的modules配置项中是否有以$id为key的模块，或当前模块的modules配置中是否有以$id为key的子模块，如果有则以$module为$owner参数值递归调用createController方法&lt;/span&gt;
&lt;span class="x"&gt;            if(($module=$owner-&amp;gt;getModule($id))!==null)&lt;/span&gt;
&lt;span class="x"&gt;                return $this-&amp;gt;createController($route,$module);&lt;/span&gt;

&lt;span class="x"&gt;            // 当前应用或模块下的控制器类的存放目录&lt;/span&gt;
&lt;span class="x"&gt;            $basePath=$owner-&amp;gt;getControllerPath();&lt;/span&gt;
&lt;span class="x"&gt;            $controllerID=&amp;#39;&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $controllerID.=&amp;#39;/&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;        // 默认以$id为controller的ID，在当前应用或模块下查找是否有对应的控制器类文件&lt;/span&gt;
&lt;span class="x"&gt;        $className=ucfirst($id).&amp;#39;Controller&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;        $classFile=$basePath.DIRECTORY_SEPARATOR.$className.&amp;#39;.php&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;        // 擦，怎么多出一个命名空间的东西？&lt;/span&gt;
&lt;span class="x"&gt;        if($owner-&amp;gt;controllerNamespace!==null)&lt;/span&gt;
&lt;span class="x"&gt;            $className=$owner-&amp;gt;controllerNamespace.&amp;#39;\\&amp;#39;.$className;&lt;/span&gt;
&lt;span class="x"&gt;        // 如果有对应的控制器类文件，则尝试加载实例化&lt;/span&gt;
&lt;span class="x"&gt;        if(is_file($classFile))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(!class_exists($className,false))&lt;/span&gt;
&lt;span class="x"&gt;                require($classFile);&lt;/span&gt;
&lt;span class="x"&gt;            if(class_exists($className,false) &amp;amp;&amp;amp; is_subclass_of($className,&amp;#39;CController&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                $id[0]=strtolower($id[0]);&lt;/span&gt;
&lt;span class="x"&gt;                return array(&lt;/span&gt;
&lt;span class="x"&gt;                    new $className($controllerID.$id,$owner===$this?null:$owner),&lt;/span&gt;
&lt;span class="x"&gt;                    $this-&amp;gt;parseActionParams($route),&lt;/span&gt;
&lt;span class="x"&gt;                );&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            return null;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 否则把$id看成普通的一级目录名&lt;/span&gt;
&lt;span class="x"&gt;        $controllerID.=$id;&lt;/span&gt;
&lt;span class="x"&gt;        $basePath.=DIRECTORY_SEPARATOR.$id;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述代码中可以看到，控制器类在实例化时需要传入该控制器类属于应用还是属于某个模块，这个归属记录在控制器类实例的_module属性中，如果属性值为null，则表示属于应用，_module属性定义于类&lt;code&gt;CController&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;我们来看看上述代码中调用的方法&lt;code&gt;getModule&lt;/code&gt;的实现，这个方法调用的&lt;code&gt;$owner&lt;/code&gt;可能是应用对象也可能是某个模块类对象，该方法定义于抽象类&lt;code&gt;CModule&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getModule($id)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 如果$id对应的module已经实例化好，则直接返回&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($this-&amp;gt;_modules[$id]) || array_key_exists($id,$this-&amp;gt;_modules))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_modules[$id];&lt;/span&gt;
&lt;span class="x"&gt;    // 看是否配置了$id对应的module&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;_moduleConfig[$id]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $config=$this-&amp;gt;_moduleConfig[$id];&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($config[&amp;#39;enabled&amp;#39;]) || $config[&amp;#39;enabled&amp;#39;])&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            Yii::trace(&amp;quot;Loading \&amp;quot;$id\&amp;quot; module&amp;quot;,&amp;#39;system.base.CModule&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;            $class=$config[&amp;#39;class&amp;#39;];&lt;/span&gt;
&lt;span class="x"&gt;            unset($config[&amp;#39;class&amp;#39;], $config[&amp;#39;enabled&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;            // 实例化module，module的$owner可能是当前应用对象，也可能是一个模块对象&lt;/span&gt;
&lt;span class="x"&gt;            if($this===Yii::app())&lt;/span&gt;
&lt;span class="x"&gt;                $module=Yii::createComponent($class,$id,null,$config);&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                $module=Yii::createComponent($class,$this-&amp;gt;getId().&amp;#39;/&amp;#39;.$id,$this,$config);&lt;/span&gt;
&lt;span class="x"&gt;            return $this-&amp;gt;_modules[$id]=$module;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述代码可以看到，每个模块对象也会记录它的归属 - 属于应用对象，还是某个父模块对象。&lt;/p&gt;
&lt;p&gt;自定义模块类无需定义自己的构造方法，构造方法可以间接继承自抽象类&lt;code&gt;CModule&lt;/code&gt;（&lt;code&gt;CWebModule&lt;/code&gt;类并未定义自己的构造方法），其构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($id,$parent,$config=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_id=$id;&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_parentModule=$parent;&lt;/span&gt;

&lt;span class="x"&gt;    // set basePath at early as possible to avoid trouble&lt;/span&gt;
&lt;span class="x"&gt;    if(is_string($config))&lt;/span&gt;
&lt;span class="x"&gt;        $config=require($config);&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($config[&amp;#39;basePath&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;setBasePath($config[&amp;#39;basePath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;        unset($config[&amp;#39;basePath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    Yii::setPathOfAlias($id,$this-&amp;gt;getBasePath());&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;preinit();&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;configure($config);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;preloadComponents();&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;init();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个方法与Web应用类的构造方法（定义于抽象类&lt;code&gt;CApplication&lt;/code&gt;中）实现非常相似。这两个构造方法是调用同一个&lt;code&gt;configure&lt;/code&gt;方法来加载配置的，所以很多“应用”的配置项，“模块”也都支持。
从上述模块的构造方法中可以看到当前模块属于哪个父模块是记录在属性&lt;code&gt;_parentModule&lt;/code&gt;中的，如果该属性值为null，则表示当前模块属于当前Web应用对象。这样通过获取控制器对象的&lt;code&gt;_module&lt;/code&gt;属性值，继而获取模块对象的&lt;code&gt;_parentModule&lt;/code&gt;属性值，就能知道整个归属关系链。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;注：&lt;em&gt;以下部分是对&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-2/"&gt;Yii源码阅读笔记 - 路由解析&lt;/a&gt;一文的补充。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;前面讨论的方法&lt;code&gt;createController&lt;/code&gt;中还调用了方法&lt;code&gt;parseActionParams&lt;/code&gt;来解析获取Action的ID，也定义于类&lt;code&gt;CWebApplication&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Parses a path info into an action ID and GET variables.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $pathInfo path info&lt;/span&gt;
&lt;span class="x"&gt; * @return string action ID&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function parseActionParams($pathInfo)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 屌！其实就是以斜杠分割$pathInfo取第一个部分作为Action的ID&lt;/span&gt;
&lt;span class="x"&gt;    if(($pos=strpos($pathInfo,&amp;#39;/&amp;#39;))!==false)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $manager=$this-&amp;gt;getUrlManager();&lt;/span&gt;
&lt;span class="x"&gt;        // 第一个部分之外剩余的部分做请求参数解析&lt;/span&gt;
&lt;span class="x"&gt;        $manager-&amp;gt;parsePathInfo((string)substr($pathInfo,$pos+1));&lt;/span&gt;

&lt;span class="x"&gt;        $actionID=substr($pathInfo,0,$pos);&lt;/span&gt;
&lt;span class="x"&gt;        return $manager-&amp;gt;caseSensitive ? $actionID : strtolower($actionID);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        // 如果$pathInfoH中不存在斜杠，则就将$pathInfo作为Action的ID&lt;/span&gt;
&lt;span class="x"&gt;        return $pathInfo;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的&lt;code&gt;parsePathInfo&lt;/code&gt;方法，定义于类&lt;code&gt;CUrlManager&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Parses a path info into URL segments and saves them to $_GET and $_REQUEST.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $pathInfo path info&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function parsePathInfo($pathInfo)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($pathInfo===&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;        return;&lt;/span&gt;
&lt;span class="x"&gt;    $segs=explode(&amp;#39;/&amp;#39;,$pathInfo.&amp;#39;/&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    $n=count($segs);&lt;/span&gt;
&lt;span class="x"&gt;    for($i=0;$i&amp;lt;$n-1;$i+=2)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $key=$segs[$i];&lt;/span&gt;
&lt;span class="x"&gt;        if($key===&amp;#39;&amp;#39;) continue;&lt;/span&gt;
&lt;span class="x"&gt;        $value=$segs[$i+1];&lt;/span&gt;
&lt;span class="x"&gt;        if(($pos=strpos($key,&amp;#39;[&amp;#39;))!==false &amp;amp;&amp;amp; ($m=preg_match_all(&amp;#39;/\[(.*?)\]/&amp;#39;,$key,$matches))&amp;gt;0)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $name=substr($key,0,$pos);&lt;/span&gt;
&lt;span class="x"&gt;            for($j=$m-1;$j&amp;gt;=0;--$j)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                if($matches[1][$j]===&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;                    $value=array($value);&lt;/span&gt;
&lt;span class="x"&gt;                else&lt;/span&gt;
&lt;span class="x"&gt;                    $value=array($matches[1][$j]=&amp;gt;$value);&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            if(isset($_GET[$name]) &amp;amp;&amp;amp; is_array($_GET[$name]))&lt;/span&gt;
&lt;span class="x"&gt;                $value=CMap::mergeArray($_GET[$name],$value);&lt;/span&gt;
&lt;span class="x"&gt;            $_REQUEST[$name]=$_GET[$name]=$value;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $_REQUEST[$key]=$_GET[$key]=$value;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;仔细看看上述代码的逻辑吧，累觉不爱啊！&lt;/p&gt;
&lt;p&gt;这个方法的作用：在目标路由去除Controller ID和Action ID两个部分后，从剩余部分中按一定规则解析出请求参数，那么规则是什么样的呢？&lt;/p&gt;
&lt;p&gt;举例来说，这个目标路由剩余部分的基本形式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;key/value/key/value/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;key&lt;/code&gt;为参数名，&lt;code&gt;value&lt;/code&gt;为参数值。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;key&lt;/code&gt;的形式可以数组取值的形式，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name[x][y][z]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种形式的&lt;code&gt;key&lt;/code&gt;对应的&lt;code&gt;value&lt;/code&gt;会从原来的字符串转换成数组形式，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;x&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;y&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;z&amp;#39; =&amp;gt; array(&amp;#39;value&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;        )&lt;/span&gt;
&lt;span class="x"&gt;    )&lt;/span&gt;
&lt;span class="x"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;多个&lt;code&gt;key&lt;/code&gt;的&lt;code&gt;name&lt;/code&gt;可以相同，如果相同，则会合并数组。如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name[a][b][c]/value1/name[A][B][C]/value2/name[x][y][z]/value3/name[a][X][f]/value4/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最终会转换成请求参数项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;$_REQUEST[&amp;#39;name&amp;#39;] = $_GET[&amp;#39;name&amp;#39;] = array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;a&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;b&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;c&amp;#39; =&amp;gt; array(&amp;#39;value1&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;        ),&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;X&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;f&amp;#39; =&amp;gt; array(&amp;#39;value4&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;        ),&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;A&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;B&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;C&amp;#39; =&amp;gt; array(&amp;#39;value2&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;        ),&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;x&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;y&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;z&amp;#39; =&amp;gt; array(&amp;#39;value3&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;        ),&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;擦，牛逼到死啊！&lt;/p&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 缓存</title><link href="http://youngsterxyf.github.io/2014/11/19/read-yii-code-6/" rel="alternate"></link><updated>2014-11-19T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-19:2014/11/19/read-yii-code-6/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;从之前的文章&lt;a href="http://youngsterxyf.github.io/2014/11/12/read-yii-code-2/"&gt;Yii源码阅读笔记 - 路由解析&lt;/a&gt;
及&lt;a href="http://youngsterxyf.github.io/2014/11/14/read-yii-code-4/"&gt;Yii源码阅读笔记 - Model层实现&lt;/a&gt;可以看到Yii框架对于&lt;strong&gt;解析好的路由规则&lt;/strong&gt;及&lt;strong&gt;数据表的schema&lt;/strong&gt;都会根据条件尝试读写缓存
来提高应用性能。&lt;/p&gt;
&lt;p&gt;但缓存组件并非核心组件，需要额外的配置，默认ID为&lt;code&gt;cache&lt;/code&gt;，如果不使用该ID，那么就得注意同时配置好框架中使用缓存的组件。&lt;/p&gt;
&lt;p&gt;恰当地使用缓存组件，能明显地提高应用的性能。&lt;/p&gt;
&lt;p&gt;针对不同的缓存后端（backend），Yii框架提供了多种缓存组件，如文件缓存（CFileCache）、Memcached缓存（CMemCache）、Redis缓存（CRedisCache）等。这些缓存组件（除CDummyCache外，CDummyCache并不是一个有效的缓存组件）均直接继承自抽象类CCache（见文件&lt;code&gt;yii/framework/caching/CCache.php&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面以使用Memcached缓存为例，分析Yii框架缓存组件的实现。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;类&lt;code&gt;CMemcache&lt;/code&gt;所在的整个继承树（&lt;code&gt;CMemcache&lt;/code&gt; -&amp;gt; &lt;code&gt;CCache&lt;/code&gt; -&amp;gt; &lt;code&gt;CApplicationComponent&lt;/code&gt; -&amp;gt; &lt;code&gt;CComponent&lt;/code&gt;）上的类都没有构造方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CMemcache&lt;/code&gt;的init方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function init()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 调用父类CCache的init方法&lt;/span&gt;
&lt;span class="x"&gt;    parent::init();&lt;/span&gt;
&lt;span class="x"&gt;    // 获取配置的Memcached服务器列表&lt;/span&gt;
&lt;span class="x"&gt;    $servers=$this-&amp;gt;getServers();&lt;/span&gt;
&lt;span class="x"&gt;    // 获取一个Memcache或Memcached对象&lt;/span&gt;
&lt;span class="x"&gt;    $cache=$this-&amp;gt;getMemCache();&lt;/span&gt;
&lt;span class="x"&gt;    if(count($servers))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 将配置的Memcached服务器加到池中&lt;/span&gt;
&lt;span class="x"&gt;        foreach($servers as $server)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            // 可选择使用memcached php扩展，但最好别这样，因为memcached扩展不支持一些有用的配置选项，从addServer方法的参数列表就可以看出&lt;/span&gt;
&lt;span class="x"&gt;            // memcached扩展默认使用余数分步哈希算法，但可配置使用一致性哈希算法&lt;/span&gt;
&lt;span class="x"&gt;            // 应使用memcache扩展&lt;/span&gt;
&lt;span class="x"&gt;            if($this-&amp;gt;useMemcached)&lt;/span&gt;
&lt;span class="x"&gt;                $cache-&amp;gt;addServer($server-&amp;gt;host,$server-&amp;gt;port,$server-&amp;gt;weight);&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                $cache-&amp;gt;addServer($server-&amp;gt;host,$server-&amp;gt;port,$server-&amp;gt;persistent,$server-&amp;gt;weight,$server-&amp;gt;timeout,$server-&amp;gt;retryInterval,$server-&amp;gt;status);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 如果没有配置服务器列表，则默认使用localhost:11211&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $cache-&amp;gt;addServer(&amp;#39;localhost&amp;#39;,11211);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的父类的init方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function init()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    parent::init();&lt;/span&gt;
&lt;span class="x"&gt;    // 可以为整个应用的缓存的key加一个统一的前缀，这是为了避免在同一个缓存池中，不同应用的key冲突&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;keyPrefix===null)&lt;/span&gt;
&lt;span class="x"&gt;        // 如果没有配置keyPrefix，则以应用的id作为keyPrefix，这个key，可以配置，如果未配置，则`sprintf(&amp;#39;%x&amp;#39;,crc32($this-&amp;gt;getBasePath().$this-&amp;gt;name))`这样生成，&lt;/span&gt;
&lt;span class="x"&gt;        // 其中name表示应用的名称，可配置，默认为“My Application”&lt;/span&gt;
&lt;span class="x"&gt;        // getId方法定义于抽象类CApplication中&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;keyPrefix=Yii::app()-&amp;gt;getId();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;CMemcache&lt;/code&gt;的init方法中调用的方法&lt;code&gt;getServers&lt;/code&gt;和&lt;code&gt;getMemcache&lt;/code&gt;，实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getMemCache()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 单例&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_cache!==null)&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_cache;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 还是用memcache吧&lt;/span&gt;
&lt;span class="x"&gt;        $extension=$this-&amp;gt;useMemcached ? &amp;#39;memcached&amp;#39; : &amp;#39;memcache&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;        // 检测一下是否记载了所需扩展&lt;/span&gt;
&lt;span class="x"&gt;        if(!extension_loaded($extension))&lt;/span&gt;
&lt;span class="x"&gt;            throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;quot;CMemCache requires PHP {extension} extension to be loaded.&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                array(&amp;#39;{extension}&amp;#39;=&amp;gt;$extension)));&lt;/span&gt;
&lt;span class="x"&gt;        // 实例化&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_cache=$this-&amp;gt;useMemcached ? new Memcached : new Memcache;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;public function getServers()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;_servers;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;与&lt;code&gt;getServers&lt;/code&gt;对应的有方法&lt;code&gt;setServers&lt;/code&gt;，如果需要配置缓存服务器列表，则应该为缓存组件配置&lt;code&gt;servers&lt;/code&gt;一项，基本形式为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;#39;servers&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;    array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;host&amp;#39;=&amp;gt;&amp;#39;127.0.0.1&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;port&amp;#39;=&amp;gt;11211,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;setServers&lt;/code&gt;方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function setServers($config)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    foreach($config as $c)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_servers[]=new CMemCacheServerConfiguration($c);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中实例化的类&lt;code&gt;CMemCacheServerConfiguration&lt;/code&gt;也定义于文件&lt;code&gt;yii/framework/caching/CMemCache.php&lt;/code&gt;中，其构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($config)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($config))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($config as $key=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;$key=$value;&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;host===null)&lt;/span&gt;
&lt;span class="x"&gt;            throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CMemCache server configuration must have &amp;quot;host&amp;quot; value.&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CMemCache server configuration must be an array.&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从该构造方法可以看到该类的作用就是将一个Memcached缓存服务器的配置信息封装成一个配置类对象。该类有如下public的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @var string memcache server hostname or IP address&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public $host;&lt;/span&gt;
&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @var integer memcache server port&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public $port=11211;&lt;/span&gt;
&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @var boolean whether to use a persistent connection&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public $persistent=true;&lt;/span&gt;
&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @var integer probability of using this server among all servers.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public $weight=1;&lt;/span&gt;
&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @var integer value in seconds which will be used for connecting to the server&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public $timeout=15;&lt;/span&gt;
&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @var integer how often a failed server will be retried (in seconds)&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public $retryInterval=15;&lt;/span&gt;
&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @var boolean if the server should be flagged as online upon a failure&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public $status=true;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些属性也即是每台缓存服务器的可配置项，当然如果用的是memcached扩展，某些配置项就用不上了。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;类&lt;code&gt;CCache&lt;/code&gt;定义了访问控制类型public的方法&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;mget&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;、&lt;code&gt;flush&lt;/code&gt;，对应Yii框架缓存组件提供的几个操作，即开发者可以使用这些方法来操作缓存。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;// 根据单个key，获取对应的value&lt;/span&gt;
&lt;span class="x"&gt;public function get($id)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // generateUniqueKey是根据$id来生成一个唯一的key，也即真正存到缓存的key并不是get方法的$id参数值&lt;/span&gt;
&lt;span class="x"&gt;    $value = $this-&amp;gt;getValue($this-&amp;gt;generateUniqueKey($id));&lt;/span&gt;
&lt;span class="x"&gt;    // 如果设置为不进行序列化，则直接返回取得的值&lt;/span&gt;
&lt;span class="x"&gt;    if($value===false || $this-&amp;gt;serializer===false)&lt;/span&gt;
&lt;span class="x"&gt;        return $value;&lt;/span&gt;
&lt;span class="x"&gt;    // 如果未设置serializer，则说明存储时使用的是默认的序列化方法，取到数据后对应地需要使用默认的方法进行反序列化&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;serializer===null)&lt;/span&gt;
&lt;span class="x"&gt;        $value=unserialize($value);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        // 否则，使用指定的方法进行反序列化&lt;/span&gt;
&lt;span class="x"&gt;        $value=call_user_func($this-&amp;gt;serializer[1], $value);&lt;/span&gt;
&lt;span class="x"&gt;    // 依赖检查，如果依赖没有变，则说明缓存有效，&lt;/span&gt;
&lt;span class="x"&gt;    // 否则，返回false，表示缓存无效&lt;/span&gt;
&lt;span class="x"&gt;    // 咦，不要清掉无效的缓存项么？&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($value) &amp;amp;&amp;amp; (!$value[1] instanceof ICacheDependency || !$value[1]-&amp;gt;getHasChanged()))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        Yii::trace(&amp;#39;Serving &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; from cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));&lt;/span&gt;
&lt;span class="x"&gt;        return $value[0];&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;// 根据多个key值（$ids），获取多个value&lt;/span&gt;
&lt;span class="x"&gt;public function mget($ids)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $uids = array();&lt;/span&gt;
&lt;span class="x"&gt;    foreach ($ids as $id)&lt;/span&gt;
&lt;span class="x"&gt;        $uids[$id] = $this-&amp;gt;generateUniqueKey($id);&lt;/span&gt;

&lt;span class="x"&gt;    $values = $this-&amp;gt;getValues($uids);&lt;/span&gt;
&lt;span class="x"&gt;    $results = array();&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;serializer === false)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach ($uids as $id =&amp;gt; $uid)&lt;/span&gt;
&lt;span class="x"&gt;            $results[$id] = isset($values[$uid]) ? $values[$uid] : false;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($uids as $id =&amp;gt; $uid)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $results[$id] = false;&lt;/span&gt;
&lt;span class="x"&gt;            if(isset($values[$uid]))&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                $value = $this-&amp;gt;serializer === null ? unserialize($values[$uid]) : call_user_func($this-&amp;gt;serializer[1], $values[$uid]);&lt;/span&gt;
&lt;span class="x"&gt;                if(is_array($value) &amp;amp;&amp;amp; (!$value[1] instanceof ICacheDependency || !$value[1]-&amp;gt;getHasChanged()))&lt;/span&gt;
&lt;span class="x"&gt;                {&lt;/span&gt;
&lt;span class="x"&gt;                    Yii::trace(&amp;#39;Serving &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; from cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));&lt;/span&gt;
&lt;span class="x"&gt;                    $results[$id] = $value[0];&lt;/span&gt;
&lt;span class="x"&gt;                }&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    return $results;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;// 向$id存储一个元素值为 $value&lt;/span&gt;
&lt;span class="x"&gt;public function set($id,$value,$expire=0,$dependency=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    Yii::trace(&amp;#39;Saving &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; to cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));&lt;/span&gt;

&lt;span class="x"&gt;    if ($dependency !== null &amp;amp;&amp;amp; $this-&amp;gt;serializer !== false)&lt;/span&gt;
&lt;span class="x"&gt;        // 获取依赖值&lt;/span&gt;
&lt;span class="x"&gt;        $dependency-&amp;gt;evaluateDependency();&lt;/span&gt;

&lt;span class="x"&gt;    // 连同依赖一起序列化然后缓存起来&lt;/span&gt;
&lt;span class="x"&gt;    // 下次获取缓存后，检查一下依赖是否发生变更，是则说明缓存已经失效&lt;/span&gt;
&lt;span class="x"&gt;    if ($this-&amp;gt;serializer === null)&lt;/span&gt;
&lt;span class="x"&gt;        $value = serialize(array($value,$dependency));&lt;/span&gt;
&lt;span class="x"&gt;    elseif ($this-&amp;gt;serializer !== false)&lt;/span&gt;
&lt;span class="x"&gt;        $value = call_user_func($this-&amp;gt;serializer[0], array($value,$dependency));&lt;/span&gt;

&lt;span class="x"&gt;    return $this-&amp;gt;setValue($this-&amp;gt;generateUniqueKey($id), $value, $expire);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;// 在缓存服务器之前不存在$id时， 以id作为key存储一个变量$value到缓存服务器&lt;/span&gt;
&lt;span class="x"&gt;public function add($id,$value,$expire=0,$dependency=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    Yii::trace(&amp;#39;Adding &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; to cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));&lt;/span&gt;

&lt;span class="x"&gt;    if ($dependency !== null &amp;amp;&amp;amp; $this-&amp;gt;serializer !== false)&lt;/span&gt;
&lt;span class="x"&gt;        $dependency-&amp;gt;evaluateDependency();&lt;/span&gt;

&lt;span class="x"&gt;    if ($this-&amp;gt;serializer === null)&lt;/span&gt;
&lt;span class="x"&gt;        $value = serialize(array($value,$dependency));&lt;/span&gt;
&lt;span class="x"&gt;    elseif ($this-&amp;gt;serializer !== false)&lt;/span&gt;
&lt;span class="x"&gt;        $value = call_user_func($this-&amp;gt;serializer[0], array($value,$dependency));&lt;/span&gt;

&lt;span class="x"&gt;    return $this-&amp;gt;addValue($this-&amp;gt;generateUniqueKey($id), $value, $expire);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;// 根据id删除缓存项&lt;/span&gt;
&lt;span class="x"&gt;public function delete($id)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    Yii::trace(&amp;#39;Deleting &amp;quot;&amp;#39;.$id.&amp;#39;&amp;quot; from cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;deleteValue($this-&amp;gt;generateUniqueKey($id));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;// 清空缓存&lt;/span&gt;
&lt;span class="x"&gt;public function flush()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    Yii::trace(&amp;#39;Flushing cache&amp;#39;,&amp;#39;system.caching.&amp;#39;.get_class($this));&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;flushValues();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述代码中可以看到，每种操作方法实际上都是调用另一个方法来完成操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get -&amp;gt; getValue&lt;/li&gt;
&lt;li&gt;mget -&amp;gt; getValues&lt;/li&gt;
&lt;li&gt;set -&amp;gt; setValue&lt;/li&gt;
&lt;li&gt;add -&amp;gt; addValue&lt;/li&gt;
&lt;li&gt;delete -&amp;gt; deleteValue&lt;/li&gt;
&lt;li&gt;flush -&amp;gt; flushValues&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但抽象类&lt;code&gt;CCache&lt;/code&gt;中对于后面的这些方法并没有真正实现操作逻辑（除了getValues，其实现是循环调用getValue，也许并不是开发者想要的实现，&lt;code&gt;CMemCache&lt;/code&gt;类重写了这个方法），需要在继承类中实现。&lt;code&gt;CMemCache&lt;/code&gt;类中对这些方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;protected function getValue($key)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;_cache-&amp;gt;get($key);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;protected function getValues($keys)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;useMemcached ? $this-&amp;gt;_cache-&amp;gt;getMulti($keys) : $this-&amp;gt;_cache-&amp;gt;get($keys);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;protected function setValue($key,$value,$expire)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 注意：这个地方对于开发者来说也许是个坑&lt;/span&gt;
&lt;span class="x"&gt;    // 该方法的参数$expire并不是一个时间点，而是一个时间间隔&lt;/span&gt;
&lt;span class="x"&gt;    // $expire = 0表示不会超时失效&lt;/span&gt;
&lt;span class="x"&gt;    if($expire&amp;gt;0)&lt;/span&gt;
&lt;span class="x"&gt;        $expire+=time();&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $expire=0;&lt;/span&gt;

&lt;span class="x"&gt;    // 使用memcache扩展时，add方法的那个额外参数值0，对应参数flag，表示是否对数据使用zlib进行压缩&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;useMemcached ? $this-&amp;gt;_cache-&amp;gt;set($key,$value,$expire) : $this-&amp;gt;_cache-&amp;gt;set($key,$value,0,$expire);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;protected function addValue($key,$value,$expire)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($expire&amp;gt;0)&lt;/span&gt;
&lt;span class="x"&gt;        $expire+=time();&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $expire=0;&lt;/span&gt;

&lt;span class="x"&gt;    return $this-&amp;gt;useMemcached ? $this-&amp;gt;_cache-&amp;gt;add($key,$value,$expire) : $this-&amp;gt;_cache-&amp;gt;add($key,$value,0,$expire);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;protected function deleteValue($key)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;_cache-&amp;gt;delete($key, 0);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;protected function flushValues()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;_cache-&amp;gt;flush();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;mget&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;、&lt;code&gt;flush&lt;/code&gt;的实现有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实际存储的key并不是方法调用时提供的key，而是经过方法&lt;code&gt;generateUniqueKey&lt;/code&gt;处理的&lt;/li&gt;
&lt;li&gt;实际存储的value可能是经过序列化的，而且可能还包含依赖值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于第一点，&lt;code&gt;generateUniqueKey&lt;/code&gt;方法在抽象类&lt;code&gt;CCache&lt;/code&gt;中实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @param string $key a key identifying a value to be cached&lt;/span&gt;
&lt;span class="x"&gt; * @return string a key generated from the provided key which ensures the uniqueness across applications&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function generateUniqueKey($key)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;hashKey ? md5($this-&amp;gt;keyPrefix.$key) : $this-&amp;gt;keyPrefix.$key;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将原本的$key拼接上统一的前缀，如果需要，还进行md5哈希，这样能保证不同的应用之间不会有key冲突。属性hashKey默认值为true。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关于第二点，缓存依赖的概念简单来说就是在取到一个缓存项后，判断该缓存项是否失效的一个条件。
以页面缓存为例，也许应用中在页面模板渲染后并没有直接将结果响应给用户，而是先缓存起来，但页面可能涉及一些动态内容，这些动态内容是从数据库中某些数据生成的，为了保证正确性，下次读取页面缓存后，还得去数据库里读一下某些相关数据看是否有变更，，如果有变更，则需要重新渲染页面模板，如果没有变更，则直接将缓存的结果返回给用户。这样对于某些变更频率不高的动态内容，在请求处理时就可以避免不必要的页面模板渲染过程。&lt;/p&gt;
&lt;p&gt;判断缓存依赖是否有变更的逻辑是：&lt;strong&gt;在写缓存时，将当时缓存依赖的结果一并存入缓存，读缓存的时候，再将最新缓存依赖的结果与之前存入缓存的依赖结果做对比，不相同，则说明有变更&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;缓存依赖类需要实现接口&lt;code&gt;ICacheDependency&lt;/code&gt;，该接口声明了两个方法&lt;code&gt;evaluateDependency&lt;/code&gt;和&lt;code&gt;getHasChanged&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以缓存依赖类&lt;code&gt;CDbCacheDependency&lt;/code&gt;为例（见文件&lt;code&gt;yii/framework/caching/dependencies/CDbCacheDependency.php&lt;/code&gt;），
该类直接继承自类&lt;code&gt;CCacheDependency&lt;/code&gt;。类&lt;code&gt;CDbCacheDependency&lt;/code&gt;的作用就是根据一条SQL语句从数据库查询数据，然后根据查询结果来判断缓存是否有效。&lt;/p&gt;
&lt;p&gt;父类&lt;code&gt;CCacheDependency&lt;/code&gt;中实现方法&lt;code&gt;evaluateDependency&lt;/code&gt;和&lt;code&gt;getHasChanged&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Evaluates the dependency by generating and saving the data related with dependency.&lt;/span&gt;
&lt;span class="x"&gt; * This method is invoked by cache before writing data into it.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function evaluateDependency()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 判断是否复用缓存依赖结果&lt;/span&gt;
&lt;span class="x"&gt;    // 默认为false，可在实例化缓存依赖类时设置&lt;/span&gt;
&lt;span class="x"&gt;    // 另外对于PHP来说，这个“复用”也只能是一次请求处理过程中的复用&lt;/span&gt;
&lt;span class="x"&gt;    if ($this-&amp;gt;reuseDependentData)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // hash方法：求当前对象序列化结果的sha1哈希值&lt;/span&gt;
&lt;span class="x"&gt;        $hash=$this-&amp;gt;getHash();&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset(self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;            // 如果没有结果可复用，则得重新生成&lt;/span&gt;
&lt;span class="x"&gt;            self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]=$this-&amp;gt;generateDependentData();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_data=self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;];&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_data=$this-&amp;gt;generateDependentData();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * @return boolean whether the dependency has changed.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;// 这个方法其实是读缓存时，从缓存数据中取出缓存依赖的部分反序列化后得到一个依赖对象，由该依赖对象调用它的这个方法来判断缓存依赖是否有变更，&lt;/span&gt;
&lt;span class="x"&gt;// 所以它的_data属性是写缓存时的缓存依赖数据&lt;/span&gt;
&lt;span class="x"&gt;public function getHasChanged()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if ($this-&amp;gt;reuseDependentData)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $hash=$this-&amp;gt;getHash();&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset(self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;            self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]=$this-&amp;gt;generateDependentData();&lt;/span&gt;
&lt;span class="x"&gt;        // 不相等，则说明发生了变更&lt;/span&gt;
&lt;span class="x"&gt;        return self::$_reusableData[$hash][&amp;#39;dependentData&amp;#39;]!=$this-&amp;gt;_data;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;generateDependentData()!=$this-&amp;gt;_data;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但父类&lt;code&gt;CCacheDependency&lt;/code&gt;并未有效实现上述两个方法中调用的&lt;code&gt;generateDependentData&lt;/code&gt;方法，在类&lt;code&gt;CDbCacheDependency&lt;/code&gt;中实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;protected function generateDependentData()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;sql!==null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 获取数据库连接组件对象&lt;/span&gt;
&lt;span class="x"&gt;        $db=$this-&amp;gt;getDbConnection();&lt;/span&gt;
&lt;span class="x"&gt;        // 准备SQL执行，其中sql属性在构造方法中赋值&lt;/span&gt;
&lt;span class="x"&gt;        $command=$db-&amp;gt;createCommand($this-&amp;gt;sql);&lt;/span&gt;
&lt;span class="x"&gt;        if(is_array($this-&amp;gt;params))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            // 绑定参数&lt;/span&gt;
&lt;span class="x"&gt;            foreach($this-&amp;gt;params as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;                $command-&amp;gt;bindValue($name,$value);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 避免从缓存中读取数据库查询结果&lt;/span&gt;
&lt;span class="x"&gt;        if($db-&amp;gt;queryCachingDuration&amp;gt;0)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            // temporarily disable and re-enable query caching&lt;/span&gt;
&lt;span class="x"&gt;            $duration=$db-&amp;gt;queryCachingDuration;&lt;/span&gt;
&lt;span class="x"&gt;            $db-&amp;gt;queryCachingDuration=0;&lt;/span&gt;
&lt;span class="x"&gt;            $result=$command-&amp;gt;queryRow();&lt;/span&gt;
&lt;span class="x"&gt;            $db-&amp;gt;queryCachingDuration=$duration;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $result=$command-&amp;gt;queryRow();&lt;/span&gt;
&lt;span class="x"&gt;        return $result;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbCacheDependency.sql cannot be empty.&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 模板引擎集成</title><link href="http://youngsterxyf.github.io/2014/11/18/read-yii-code-5/" rel="alternate"></link><updated>2014-11-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-18:2014/11/18/read-yii-code-5/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;通常我们会使用模板引擎来渲染HTML页面，而不是使用HTML代码中插入PHP代码的方式来编写动态页面。Yii框架中模板引擎也是作为组件引入的，默认ID为viewRenderer，
但从&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;可以看到Yii Web应用加载的核心组件中并没有viewRenderer，所以需要自己配置。
Yii提供了一个直接可用的模板引擎组件类CPradoViewRenderer（见文件&lt;code&gt;yii/framework/web/renderers/CPradoViewRenderer.php&lt;/code&gt;），该模板引擎类让开发者可以使用类Prado框架的模板语法。&lt;/p&gt;
&lt;p&gt;如果你想使用Smarty这种第三方模板引擎，有两种方式将模板引擎引入Yii中使用（以Smarty为例）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将Smarty封装成一个Yii的普通组件，然后配置加载到Yii::app()。假设组件ID为smarty，那么就可以通过&lt;code&gt;Yii::app()-&amp;gt;smarty&lt;/code&gt;来调用组件。&lt;/li&gt;
&lt;li&gt;参考CPradoViewRenderer类的实现，将Smarty封装成一个模板引擎组件，并以ID为viewRenderer进行配置加载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相比而言，第二种方式更好。原因是：第一种方式由于每种第三方模板引擎的接口不一样，如果应用要替换模板引擎，就需要修改控制器类中的代码。而第二种方式由于第三方组件统一封装成Yii框架定义的模板引擎接口形式，
所以如果要替换模板引擎，只需修改自定义模板引擎组件类的接口实现就可以了。这样调用模板引擎的代码逻辑就只依赖接口形式，而不是依赖于接口实现，从而实现解耦。&lt;/p&gt;
&lt;p&gt;本文主要分析第二种方式的实现。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;Yii中对页面模板进行渲染可以调用&lt;code&gt;CController&lt;/code&gt;类（见文件&lt;code&gt;yii/framework/web/CController.php&lt;/code&gt;）的方法&lt;code&gt;render&lt;/code&gt;，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Renders a view with a layout.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * This method first calls {@link renderPartial} to render the view (called content view).&lt;/span&gt;
&lt;span class="x"&gt; * It then renders the layout view which may embed the content view at appropriate place.&lt;/span&gt;
&lt;span class="x"&gt; * In the layout view, the content view rendering result can be accessed via variable&lt;/span&gt;
&lt;span class="x"&gt; * &amp;lt;code&amp;gt;$content&amp;lt;/code&amp;gt;. At the end, it calls {@link processOutput} to insert scripts&lt;/span&gt;
&lt;span class="x"&gt; * and dynamic contents if they are available.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * By default, the layout view script is &amp;quot;protected/views/layouts/main.php&amp;quot;.&lt;/span&gt;
&lt;span class="x"&gt; * This may be customized by changing {@link layout}.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * @param string $view name of the view to be rendered. See {@link getViewFile} for details&lt;/span&gt;
&lt;span class="x"&gt; * about how the view script is resolved.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $data data to be extracted into PHP variables and made available to the view script&lt;/span&gt;
&lt;span class="x"&gt; * @param boolean $return whether the rendering result should be returned instead of being displayed to end users.&lt;/span&gt;
&lt;span class="x"&gt; * @return string the rendering result. Null if the rendering result is not required.&lt;/span&gt;
&lt;span class="x"&gt; * @see renderPartial&lt;/span&gt;
&lt;span class="x"&gt; * @see getLayoutFile&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function render($view,$data=null,$return=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // beforeRender默认返回true，&lt;/span&gt;
&lt;span class="x"&gt;    // 可以在自定义controller类中重写该方法，实现渲染之前的预处理&lt;/span&gt;
&lt;span class="x"&gt;    // 但和beforeAction一样，应该要返回true或false&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;beforeRender($view))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 渲染真正的内容部分&lt;/span&gt;
&lt;span class="x"&gt;        $output=$this-&amp;gt;renderPartial($view,$data,true);&lt;/span&gt;
&lt;span class="x"&gt;        // 获取布局文件&lt;/span&gt;
&lt;span class="x"&gt;        if(($layoutFile=$this-&amp;gt;getLayoutFile($this-&amp;gt;layout))!==false)&lt;/span&gt;
&lt;span class="x"&gt;            // 渲染整个页面&lt;/span&gt;
&lt;span class="x"&gt;            $output=$this-&amp;gt;renderFile($layoutFile,array(&amp;#39;content&amp;#39;=&amp;gt;$output),true);&lt;/span&gt;

&lt;span class="x"&gt;        // 渲染的后处理，默认为空，在processOutput之前调用&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;afterRender($view,$output);&lt;/span&gt;

&lt;span class="x"&gt;        // 对渲染结果进行处理&lt;/span&gt;
&lt;span class="x"&gt;        $output=$this-&amp;gt;processOutput($output);&lt;/span&gt;

&lt;span class="x"&gt;        // 可以将渲染结果作为方法的返回值返回，或者直接输出到用户浏览器&lt;/span&gt;
&lt;span class="x"&gt;        if($return)&lt;/span&gt;
&lt;span class="x"&gt;            return $output;&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            echo $output;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中方法renderPartial的实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Renders a view.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * The named view refers to a PHP script (resolved via {@link getViewFile})&lt;/span&gt;
&lt;span class="x"&gt; * that is included by this method. If $data is an associative array,&lt;/span&gt;
&lt;span class="x"&gt; * it will be extracted as PHP variables and made available to the script.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * This method differs from {@link render()} in that it does not&lt;/span&gt;
&lt;span class="x"&gt; * apply a layout to the rendered result. It is thus mostly used&lt;/span&gt;
&lt;span class="x"&gt; * in rendering a partial view, or an AJAX response.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * @param string $view name of the view to be rendered. See {@link getViewFile} for details&lt;/span&gt;
&lt;span class="x"&gt; * about how the view script is resolved.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $data data to be extracted into PHP variables and made available to the view script&lt;/span&gt;
&lt;span class="x"&gt; * @param boolean $return whether the rendering result should be returned instead of being displayed to end users&lt;/span&gt;
&lt;span class="x"&gt; * @param boolean $processOutput whether the rendering result should be postprocessed using {@link processOutput}.&lt;/span&gt;
&lt;span class="x"&gt; * @return string the rendering result. Null if the rendering result is not required.&lt;/span&gt;
&lt;span class="x"&gt; * @throws CException if the view does not exist&lt;/span&gt;
&lt;span class="x"&gt; * @see getViewFile&lt;/span&gt;
&lt;span class="x"&gt; * @see processOutput&lt;/span&gt;
&lt;span class="x"&gt; * @see render&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function renderPartial($view,$data=null,$return=false,$processOutput=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 获取目标模板文件&lt;/span&gt;
&lt;span class="x"&gt;    $viewFile=$this-&amp;gt;getViewFile($view);&lt;/span&gt;
&lt;span class="x"&gt;    echo (basename(__FILE__).&amp;#39;:&amp;#39;.__LINE__.&amp;#39;:&amp;#39;.__FUNCTION__.&amp;#39;() $viewFile &amp;#39;. var_export($viewFile, true));&lt;/span&gt;
&lt;span class="x"&gt;    if(($viewFile)!==false)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 渲染&lt;/span&gt;
&lt;span class="x"&gt;        $output=$this-&amp;gt;renderFile($viewFile,$data,true);&lt;/span&gt;
&lt;span class="x"&gt;        // 如果$processOutput为真，则也会对结果进行后处理&lt;/span&gt;
&lt;span class="x"&gt;        if($processOutput)&lt;/span&gt;
&lt;span class="x"&gt;            $output=$this-&amp;gt;processOutput($output);&lt;/span&gt;
&lt;span class="x"&gt;        if($return)&lt;/span&gt;
&lt;span class="x"&gt;            return $output;&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            echo $output;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;{controller} cannot find the requested view &amp;quot;{view}&amp;quot;.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{controller}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{view}&amp;#39;=&amp;gt;$view)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;renderPartial&lt;/code&gt;方法并不会渲染出一个完整的页面，只是渲染页面的一部分，通常是主体部分，或者为AJAX请求渲染出响应结果。
其中调用的getViewFile方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getViewFile($viewName)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 如果未配置theme项，即表示不使用theme，那么getTheme方法返回null&lt;/span&gt;
&lt;span class="x"&gt;    if(($theme=Yii::app()-&amp;gt;getTheme())!==null &amp;amp;&amp;amp; ($viewFile=$theme-&amp;gt;getViewFile($this,$viewName))!==false)&lt;/span&gt;
&lt;span class="x"&gt;        return $viewFile;&lt;/span&gt;
&lt;span class="x"&gt;    // viewPath默认为views，可配置&lt;/span&gt;
&lt;span class="x"&gt;    $moduleViewPath=$basePath=Yii::app()-&amp;gt;getViewPath();&lt;/span&gt;
&lt;span class="x"&gt;    echo (basename(__FILE__).&amp;#39;:&amp;#39;.__LINE__.&amp;#39;:&amp;#39;.__FUNCTION__.&amp;#39;() $moduleViewPath &amp;#39;. var_export($moduleViewPath, true)),&amp;quot;\n&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    // 模块化，如果没有，则getModule返回null&lt;/span&gt;
&lt;span class="x"&gt;    if(($module=$this-&amp;gt;getModule())!==null)&lt;/span&gt;
&lt;span class="x"&gt;        $moduleViewPath=$module-&amp;gt;getViewPath();&lt;/span&gt;
&lt;span class="x"&gt;    // $this-&amp;gt;getViewPath()得到的路径相比$moduleViewPath就是多了controller的ID一级&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;resolveViewFile($viewName,$this-&amp;gt;getViewPath(),$basePath,$moduleViewPath);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码中&lt;code&gt;$this-&amp;gt;getViewPath()&lt;/code&gt;方法的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getViewPath()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(($module=$this-&amp;gt;getModule())===null)&lt;/span&gt;
&lt;span class="x"&gt;        $module=Yii::app();&lt;/span&gt;
&lt;span class="x"&gt;    // $this-&amp;gt;getId()是得到当前controller的ID，这个ID是在controller实例化时构造方法中赋值给属性_id的。&lt;/span&gt;
&lt;span class="x"&gt;    // 这也就意味着页面模板文件需要按照controller的ID分目录存放&lt;/span&gt;
&lt;span class="x"&gt;    return $module-&amp;gt;getViewPath().DIRECTORY_SEPARATOR.$this-&amp;gt;getId();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getViewFile&lt;/code&gt;中最后调用的方法&lt;code&gt;resolveViewFile&lt;/code&gt;实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function resolveViewFile($viewName,$viewPath,$basePath,$moduleViewPath=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 连模板文件名都不给，还玩个屁啊&lt;/span&gt;
&lt;span class="x"&gt;    if(empty($viewName))&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;

&lt;span class="x"&gt;    // 若$moduleViewPath未设置，则在应用的页面模板的根目录下找&lt;/span&gt;
&lt;span class="x"&gt;    if($moduleViewPath===null)&lt;/span&gt;
&lt;span class="x"&gt;        $moduleViewPath=$basePath;&lt;/span&gt;

&lt;span class="x"&gt;    // 获取设置的模板渲染引擎，其实就是加载ID为viewRenderer的组件&lt;/span&gt;
&lt;span class="x"&gt;    if(($renderer=Yii::app()-&amp;gt;getViewRenderer())!==null)&lt;/span&gt;
&lt;span class="x"&gt;        // 模板文件的扩展类型默认为&amp;#39;.php&amp;#39;，可配置&lt;/span&gt;
&lt;span class="x"&gt;        $extension=$renderer-&amp;gt;fileExtension;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $extension=&amp;#39;.php&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    echo (basename(__FILE__).&amp;#39;:&amp;#39;.__LINE__.&amp;#39;:&amp;#39;.__FUNCTION__.&amp;#39;() $extension &amp;#39;. var_export($extension, true)),&amp;quot;\n&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    // 如果指定的模板文件名以/开始&lt;/span&gt;
&lt;span class="x"&gt;    if($viewName[0]===&amp;#39;/&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 如果指定的模板文件名以//开始，则表示在模板的根目录下查找&lt;/span&gt;
&lt;span class="x"&gt;        if(strncmp($viewName,&amp;#39;//&amp;#39;,2)===0)&lt;/span&gt;
&lt;span class="x"&gt;            $viewFile=$basePath.$viewName;&lt;/span&gt;
&lt;span class="x"&gt;        // 否则（以单个/开始）在模块的模板目录下查找&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $viewFile=$moduleViewPath.$viewName;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 如果模板文件名中存在.且.不出现在第一个位置，则认为这是一个路径别名，需要转换真正的路径&lt;/span&gt;
&lt;span class="x"&gt;    elseif(strpos($viewName,&amp;#39;.&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;        $viewFile=Yii::getPathOfAlias($viewName);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        // 否则在当前controller的模板目录下找&lt;/span&gt;
&lt;span class="x"&gt;        $viewFile=$viewPath.DIRECTORY_SEPARATOR.$viewName;&lt;/span&gt;

&lt;span class="x"&gt;    // 可能站点是需要国际化的&lt;/span&gt;
&lt;span class="x"&gt;    // 所以在找到默认的模板文件后，尝试找一下对应用户目标语言的模板文件&lt;/span&gt;
&lt;span class="x"&gt;    if(is_file($viewFile.$extension))&lt;/span&gt;
&lt;span class="x"&gt;        return Yii::app()-&amp;gt;findLocalizedFile($viewFile.$extension);&lt;/span&gt;
&lt;span class="x"&gt;    // 如果不存在指定扩展类型的模板文件，且扩展类型不为&amp;#39;.php&amp;#39;，则看一下&amp;#39;.php&amp;#39;类型的模板文件是否存在&lt;/span&gt;
&lt;span class="x"&gt;    elseif($extension!==&amp;#39;.php&amp;#39; &amp;amp;&amp;amp; is_file($viewFile.&amp;#39;.php&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;        return Yii::app()-&amp;gt;findLocalizedFile($viewFile.&amp;#39;.php&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法&lt;code&gt;resolveViewFile&lt;/code&gt;中最后调用的方法&lt;code&gt;findLocalizedFile&lt;/code&gt;，定义于抽象类CApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function findLocalizedFile($srcFile,$srcLanguage=null,$language=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($srcLanguage===null)&lt;/span&gt;
&lt;span class="x"&gt;        // sourceLanguage为public的属性，可配置，默认为en_us&lt;/span&gt;
&lt;span class="x"&gt;        $srcLanguage=$this-&amp;gt;sourceLanguage;&lt;/span&gt;
&lt;span class="x"&gt;    if($language===null)&lt;/span&gt;
&lt;span class="x"&gt;        // getLanguage的实现：$this-&amp;gt;_language===null ? $this-&amp;gt;sourceLanguage : $this-&amp;gt;_language&lt;/span&gt;
&lt;span class="x"&gt;        // 默认_language为未赋值，即null，所以取到的还是sourceLanguage属性值。&lt;/span&gt;
&lt;span class="x"&gt;        // 但因为__set，所以也是可赋值的，这个赋值不应该是配置造成的，应该是根据用户的cookie中指定的语言选项，在请求处理时设置的，表示用户的目标语言&lt;/span&gt;
&lt;span class="x"&gt;        $language=$this-&amp;gt;getLanguage();&lt;/span&gt;
&lt;span class="x"&gt;    // 如果用户的目标语言（或者用户选择的是默认语言），则直接返回默认模板文件的路径&lt;/span&gt;
&lt;span class="x"&gt;    if($language===$srcLanguage)&lt;/span&gt;
&lt;span class="x"&gt;        return $srcFile;&lt;/span&gt;
&lt;span class="x"&gt;    // 否则取到对应目标语言的模板文件&lt;/span&gt;
&lt;span class="x"&gt;    $desiredFile=dirname($srcFile).DIRECTORY_SEPARATOR.$language.DIRECTORY_SEPARATOR.basename($srcFile);&lt;/span&gt;
&lt;span class="x"&gt;    // 如果对应目标语言的模板文件不存在，则还是返回默认的模板文件&lt;/span&gt;
&lt;span class="x"&gt;    return is_file($desiredFile) ? $desiredFile : $srcFile;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述模板文件的寻找过程可以看到，最后返回的目标模板文件的路径是一个相对路径，以动态脚本根目录（默认为protected）开始。&lt;/p&gt;
&lt;p&gt;方法&lt;code&gt;renderPartial&lt;/code&gt;中在得到目标模板文件相对路径后，即调用renderFile方法（定义于CBaseController类中）来渲染模板，该方法的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function renderFile($viewFile,$data=null,$return=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $widgetCount=count($this-&amp;gt;_widgetStack);&lt;/span&gt;
&lt;span class="x"&gt;    // Yii::app()-&amp;gt;getViewRenderer() 获取模板引擎组件&lt;/span&gt;
&lt;span class="x"&gt;    if(($renderer=Yii::app()-&amp;gt;getViewRenderer())!==null &amp;amp;&amp;amp; $renderer-&amp;gt;fileExtension===&amp;#39;.&amp;#39;.CFileHelper::getExtension($viewFile))&lt;/span&gt;
&lt;span class="x"&gt;        $content=$renderer-&amp;gt;renderFile($this,$viewFile,$data,$return);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        // 如果没法用模板引擎来渲染（可能不是模板引擎的目标模板，也可能是没设置模板引擎组件），则当前普通的PHP文件（HTML代码中夹杂着PHP代码）来渲染&lt;/span&gt;
&lt;span class="x"&gt;        $content=$this-&amp;gt;renderInternal($viewFile,$data,$return);&lt;/span&gt;
&lt;span class="x"&gt;    if(count($this-&amp;gt;_widgetStack)===$widgetCount)&lt;/span&gt;
&lt;span class="x"&gt;        return $content;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $widget=end($this-&amp;gt;_widgetStack);&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;{controller} contains improperly nested widget tags in its view &amp;quot;{view}&amp;quot;. A {widget} widget does not have an endWidget() call.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{controller}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{view}&amp;#39;=&amp;gt;$viewFile, &amp;#39;{widget}&amp;#39;=&amp;gt;get_class($widget))));&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;renderFile&lt;/code&gt;中&lt;code&gt;$content=$renderer-&amp;gt;renderFile($this,$viewFile,$data,$return);&lt;/code&gt;一行调用的renderFile方法，在抽象类CViewRenderer中定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function renderFile($context,$sourceFile,$data,$return)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(!is_file($sourceFile) || ($file=realpath($sourceFile))===false)&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;View file &amp;quot;{file}&amp;quot; does not exist.&amp;#39;,array(&amp;#39;{file}&amp;#39;=&amp;gt;$sourceFile)));&lt;/span&gt;
&lt;span class="x"&gt;    // 尝试从runtime目录中获取已编译好的模板，如果编译好的模板不是同一存放在runtime目录下，则默认和未编译的模板文件在同一个目录下，并且文件名多一个&amp;quot;c&amp;quot;后缀&lt;/span&gt;
&lt;span class="x"&gt;    // 得到$viewFile可能并不存在，第一次请求该模板&lt;/span&gt;
&lt;span class="x"&gt;    $viewFile=$this-&amp;gt;getViewFile($sourceFile);&lt;/span&gt;
&lt;span class="x"&gt;    // 如果相比已编译好的模板文件，未编译的模板已发生变更，则需要重新编译&lt;/span&gt;
&lt;span class="x"&gt;    // 如果已编译好的模板文件不存在，则@filemtime($viewFile)返回的是false，这个条件也是返回true&lt;/span&gt;
&lt;span class="x"&gt;    if(@filemtime($sourceFile)&amp;gt;@filemtime($viewFile))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 抽象类CViewRenderer中generateViewFile方法并未实现，所以自己封装模板引擎组件时需要实现该方法&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;generateViewFile($sourceFile,$viewFile);&lt;/span&gt;
&lt;span class="x"&gt;        // 设置编译好的模板文件的访问权限，默认是0755 (owner rwx, group rx and others rx)&lt;/span&gt;
&lt;span class="x"&gt;        @chmod($viewFile,$this-&amp;gt;filePermission);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 编译好的模板文件其实就是一个PHP脚本（HTML代码中夹杂PHP代码），所以还需要渲染一下&lt;/span&gt;
&lt;span class="x"&gt;    return $context-&amp;gt;renderInternal($viewFile,$data,$return);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类&lt;code&gt;CController&lt;/code&gt;的&lt;code&gt;render&lt;/code&gt;方法在调用&lt;code&gt;renderPartial&lt;/code&gt;得到渲染结果后，取得页面布局模板文件，然后将&lt;code&gt;renderPartial&lt;/code&gt;的渲染结果作为数据渲染布局模板，从而得到一个完整HTML页面。
获取布局模板文件路径的方法&lt;code&gt;getLayoutFile&lt;/code&gt;实现如下所示（定义于类CController中）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getLayoutFile($layoutName)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($layoutName===false)&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;    if(($theme=Yii::app()-&amp;gt;getTheme())!==null &amp;amp;&amp;amp; ($layoutFile=$theme-&amp;gt;getLayoutFile($this,$layoutName))!==false)&lt;/span&gt;
&lt;span class="x"&gt;        return $layoutFile;&lt;/span&gt;

&lt;span class="x"&gt;    if(empty($layoutName))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $module=$this-&amp;gt;getModule();&lt;/span&gt;
&lt;span class="x"&gt;        // 递归向父级模板查找布局文件&lt;/span&gt;
&lt;span class="x"&gt;        while($module!==null)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if($module-&amp;gt;layout===false)&lt;/span&gt;
&lt;span class="x"&gt;                return false;&lt;/span&gt;
&lt;span class="x"&gt;            if(!empty($module-&amp;gt;layout))&lt;/span&gt;
&lt;span class="x"&gt;                break;&lt;/span&gt;
&lt;span class="x"&gt;            $module=$module-&amp;gt;getParentModule();&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 如果当前controller不属于某个module&lt;/span&gt;
&lt;span class="x"&gt;        if($module===null)&lt;/span&gt;
&lt;span class="x"&gt;            $module=Yii::app();&lt;/span&gt;
&lt;span class="x"&gt;        // 默认为main，可配置&lt;/span&gt;
&lt;span class="x"&gt;        $layoutName=$module-&amp;gt;layout;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    elseif(($module=$this-&amp;gt;getModule())===null)&lt;/span&gt;
&lt;span class="x"&gt;        $module=Yii::app();&lt;/span&gt;

&lt;span class="x"&gt;    return $this-&amp;gt;resolveViewFile($layoutName,$module-&amp;gt;getLayoutPath(),Yii::app()-&amp;gt;getViewPath(),$module-&amp;gt;getViewPath());&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其逻辑与方法&lt;code&gt;getViewFile&lt;/code&gt;类似。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;由上述分析可知，将第三方模板引擎封装成Yii框架的模板引擎组件，可以继承自抽象类&lt;code&gt;CViewRenderer&lt;/code&gt;，并实现其方法&lt;code&gt;generateViewFile&lt;/code&gt;，然后配置该组件的ID为&lt;code&gt;viewRenderer&lt;/code&gt;。
对于模板文件的存放，需要考虑Web应用是否分模块、应用是否国际化、模板文件相关controller的ID等，模板文件名的扩展类型应与模板引擎组件配置的一样。&lt;/p&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - Model层实现</title><link href="http://youngsterxyf.github.io/2014/11/14/read-yii-code-4/" rel="alternate"></link><updated>2014-11-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-14:2014/11/14/read-yii-code-4/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii中，对Model层的使用，有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过类CDbConnection和CDbCommand来操作&lt;/li&gt;
&lt;li&gt;使用ORM形式：编写model类继承自抽象类CActiveRecord&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第1种方式的示例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$connection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Yii&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;app&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;db&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 或者Yii::app()-&amp;gt;getComponent(&amp;#39;db&amp;#39;);&lt;/span&gt;
&lt;span class="nv"&gt;$queryResult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$connection&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;createCommand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$sql&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;queryRow&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第2种方式中编写的model类可能需要实现方法&lt;code&gt;getDbConnection&lt;/code&gt;、&lt;code&gt;model&lt;/code&gt;、&lt;code&gt;tableName&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在实现上，第2种方式是基于第1种方式的，即第2种方式的抽象程度更高。Yii没有屏蔽第1种方式，这样能让开发者按需选择。
但我个人并不喜欢这样，两种方式同时存在，会导致应用的model实现稍显混乱。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;Yii框架model层的入口为CDbConnection类，该类有很多public的属性可供配置，如&lt;code&gt;connectionString&lt;/code&gt;、&lt;code&gt;username&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;根据&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;一文可知，组件初始化时会调用init方法。
类CDbConnection的init类实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function init()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    parent::init();&lt;/span&gt;
&lt;span class="x"&gt;    // 属性autoConnect默认为true&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;autoConnect)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;setActive(true);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的setActive方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function setActive($value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 当$value为true，而_active为false（表示数据库连接未打开），则打开数据库连接&lt;/span&gt;
&lt;span class="x"&gt;    // 当$value为false, 而_active为true（表示数据库连接已打开），则关闭数据库连接&lt;/span&gt;
&lt;span class="x"&gt;    if($value!=$this-&amp;gt;_active)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($value)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;open();&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;close();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法open实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Opens DB connection if it is currently not&lt;/span&gt;
&lt;span class="x"&gt; * @throws CException if connection fails&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function open()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_pdo===null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 所以需要配置connectionString&lt;/span&gt;
&lt;span class="x"&gt;        if(empty($this-&amp;gt;connectionString))&lt;/span&gt;
&lt;span class="x"&gt;            throw new CDbException(&amp;#39;CDbConnection.connectionString cannot be empty.&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        try&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            Yii::trace(&amp;#39;Opening DB connection&amp;#39;,&amp;#39;system.db.CDbConnection&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;            // 基于PDO类建立数据库连接（对于某些数据库不使用PDO）&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_pdo=$this-&amp;gt;createPdoInstance();&lt;/span&gt;
&lt;span class="x"&gt;            // 设置数据库连接的一些属性，如字符编码等&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;initConnection($this-&amp;gt;_pdo);&lt;/span&gt;
&lt;span class="x"&gt;            // 标志位设置为已打开&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_active=true;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        catch(PDOException $e)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            // 省略&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法close实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Closes the currently active DB connection.&lt;/span&gt;
&lt;span class="x"&gt; * It does nothing if the connection is already closed.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function close()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    Yii::trace(&amp;#39;Closing DB connection&amp;#39;,&amp;#39;system.db.CDbConnection&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_pdo=null;&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_active=false;&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_schema=null;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;open方法中调用的方法createPdoInstance实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Creates the PDO instance.&lt;/span&gt;
&lt;span class="x"&gt; * When some functionalities are missing in the pdo driver, we may use&lt;/span&gt;
&lt;span class="x"&gt; * an adapter class to provide them.&lt;/span&gt;
&lt;span class="x"&gt; * @throws CDbException when failed to open DB connection&lt;/span&gt;
&lt;span class="x"&gt; * @return PDO the pdo instance&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function createPdoInstance()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 属性pdoClass默认为PDO&lt;/span&gt;
&lt;span class="x"&gt;    $pdoClass=$this-&amp;gt;pdoClass;&lt;/span&gt;
&lt;span class="x"&gt;    if(($pos=strpos($this-&amp;gt;connectionString,&amp;#39;:&amp;#39;))!==false)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 取出数据库驱动类型&lt;/span&gt;
&lt;span class="x"&gt;        $driver=strtolower(substr($this-&amp;gt;connectionString,0,$pos));&lt;/span&gt;
&lt;span class="x"&gt;        if($driver===&amp;#39;mssql&amp;#39; || $driver===&amp;#39;dblib&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;            $pdoClass=&amp;#39;CMssqlPdoAdapter&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;        elseif($driver===&amp;#39;sqlsrv&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;            $pdoClass=&amp;#39;CMssqlSqlsrvPdoAdapter&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    if(!class_exists($pdoClass))&lt;/span&gt;
&lt;span class="x"&gt;        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbConnection is unable to find PDO class &amp;quot;{className}&amp;quot;. Make sure PDO is installed correctly.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{className}&amp;#39;=&amp;gt;$pdoClass)));&lt;/span&gt;

&lt;span class="x"&gt;    // 实例化类PDO，可能失败&lt;/span&gt;
&lt;span class="x"&gt;    @$instance=new $pdoClass($this-&amp;gt;connectionString,$this-&amp;gt;username,$this-&amp;gt;password,$this-&amp;gt;_attributes);&lt;/span&gt;

&lt;span class="x"&gt;    if(!$instance)&lt;/span&gt;
&lt;span class="x"&gt;        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbConnection failed to open the DB connection.&amp;#39;));&lt;/span&gt;

&lt;span class="x"&gt;    return $instance;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从中可以看出，对于MySQL数据库而言，方法createPdoInstance返回的是一个PDO对象，赋值给CDbConnection对象的_pdo属性。&lt;/p&gt;
&lt;p&gt;方法initConnection的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Initializes the open db connection.&lt;/span&gt;
&lt;span class="x"&gt; * This method is invoked right after the db connection is established.&lt;/span&gt;
&lt;span class="x"&gt; * The default implementation is to set the charset for MySQL and PostgreSQL database connections.&lt;/span&gt;
&lt;span class="x"&gt; * @param PDO $pdo the PDO instance&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function initConnection($pdo)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 设置数据库连接的一些属性&lt;/span&gt;
&lt;span class="x"&gt;    $pdo-&amp;gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;emulatePrepare!==null &amp;amp;&amp;amp; constant(&amp;#39;PDO::ATTR_EMULATE_PREPARES&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;        $pdo-&amp;gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,$this-&amp;gt;emulatePrepare);&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;charset!==null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $driver=strtolower($pdo-&amp;gt;getAttribute(PDO::ATTR_DRIVER_NAME));&lt;/span&gt;
&lt;span class="x"&gt;        if(in_array($driver,array(&amp;#39;pgsql&amp;#39;,&amp;#39;mysql&amp;#39;,&amp;#39;mysqli&amp;#39;)))&lt;/span&gt;
&lt;span class="x"&gt;            $pdo-&amp;gt;exec(&amp;#39;SET NAMES &amp;#39;.$pdo-&amp;gt;quote($this-&amp;gt;charset));&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 执行一些初始化的SQL语句&lt;/span&gt;
&lt;span class="x"&gt;    // public $initSQLs : array list of SQL statements that should be executed right after the DB connection is established.&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;initSQLs!==null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($this-&amp;gt;initSQLs as $sql)&lt;/span&gt;
&lt;span class="x"&gt;            $pdo-&amp;gt;exec($sql);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;由于第2种方式是基于第1中方式实现的，所以我们先看看第1种方式的实现。&lt;/p&gt;
&lt;p&gt;类CDbConnection中方法createCommand的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function createCommand($query=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;setActive(true);&lt;/span&gt;
&lt;span class="x"&gt;    return new CDbCommand($this,$query);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中实例化的类CDbCommand的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Constructor.&lt;/span&gt;
&lt;span class="x"&gt; * @param CDbConnection $connection the database connection&lt;/span&gt;
&lt;span class="x"&gt; * @param mixed $query the DB query to be executed. This can be either&lt;/span&gt;
&lt;span class="x"&gt; * a string representing a SQL statement, or an array whose name-value pairs&lt;/span&gt;
&lt;span class="x"&gt; * will be used to set the corresponding properties of the created command object.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * For example, you can pass in either &amp;lt;code&amp;gt;&amp;#39;SELECT * FROM tbl_user&amp;#39;&amp;lt;/code&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; * or &amp;lt;code&amp;gt;array(&amp;#39;select&amp;#39;=&amp;gt;&amp;#39;*&amp;#39;, &amp;#39;from&amp;#39;=&amp;gt;&amp;#39;tbl_user&amp;#39;)&amp;lt;/code&amp;gt;. They are equivalent&lt;/span&gt;
&lt;span class="x"&gt; * in terms of the final query result.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * When passing the query as an array, the following properties are commonly set:&lt;/span&gt;
&lt;span class="x"&gt; * {@link select}, {@link distinct}, {@link from}, {@link where}, {@link join},&lt;/span&gt;
&lt;span class="x"&gt; * {@link group}, {@link having}, {@link order}, {@link limit}, {@link offset} and&lt;/span&gt;
&lt;span class="x"&gt; * {@link union}. Please refer to the setter of each of these properties for details&lt;/span&gt;
&lt;span class="x"&gt; * about valid property values. This feature has been available since version 1.1.6.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * Since 1.1.7 it is possible to use a specific mode of data fetching by setting&lt;/span&gt;
&lt;span class="x"&gt; * {@link setFetchMode FetchMode}. See {@link http://www.php.net/manual/en/function.PDOStatement-setFetchMode.php}&lt;/span&gt;
&lt;span class="x"&gt; * for more details.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function __construct(CDbConnection $connection,$query=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_connection=$connection;&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($query))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($query as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;$name=$value;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;setText($query);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到参数$query并不是必须提供，如果提供，则$query参数值可以是字符串也可以是数组。如果是字符串也就是一个原生的SQL语句（可能有参数需要填充），如果是数组，
则可以为CDbCommand对象的select、distinct、from等属性赋值。&lt;/p&gt;
&lt;p&gt;方法setText实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Specifies the SQL statement to be executed.&lt;/span&gt;
&lt;span class="x"&gt; * Any previous execution will be terminated or cancel.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $value the SQL statement to be executed&lt;/span&gt;
&lt;span class="x"&gt; * @return CDbCommand this command instance&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function setText($value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_connection-&amp;gt;tablePrefix!==null &amp;amp;&amp;amp; $value!=&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_text=preg_replace(&amp;#39;/{{(.*?)}}/&amp;#39;,$this-&amp;gt;_connection-&amp;gt;tablePrefix.&amp;#39;\1&amp;#39;,$value);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_text=$value;&lt;/span&gt;
&lt;span class="x"&gt;    // 因为是要新执行一条语句，所以需要重置状态，将属性_statement置为null。&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;cancel();&lt;/span&gt;
&lt;span class="x"&gt;    return $this;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果调用类CDbConnection的createCommand方法时提供了&lt;code&gt;$query&lt;/code&gt;参数值，则在得到CDbCommand对象后，即可调用CDbCommand对象的execute方法（对于增、删、改操作）或query、queryAll、queryRow等方法（对于查询操作）来执行数据库操作。&lt;/p&gt;
&lt;p&gt;如果调用createCommand时未提供&lt;code&gt;$query&lt;/code&gt;参数值，则有3种方式来完成数据库操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于普通的数据库查询操作，得到CDbCommand对象后，链式调用方法select、from、where等（之所以能够链式调用，是因为这些方法的最后都返回了对象本身），并且链式调用的最后调用query一类方法来执行数据库操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于会对数据表结构或数据产生变更的操作，得到CDbCommand对象后，可以直接调用方法insert、update、delete、createTable等来执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在得到CDbCommand对象后，调用方法setText来设置待执行的SQL语句，setText方法的$value参数类型应为字符串。如果调用setText方法前$value参数类型是关联数组，则可以先调用方法buildQuery从关联数组生成一个SQL语句字符串，再调用setText方法；或者直接调用setSelect、setFrom、setWhere等方法来设置SQL语句的各个组成部分。最后调用execute方法或query一类方法。可以看出相比传递&lt;code&gt;$query&lt;/code&gt;参数，这种方式只不过是显式地设置SQL语句。通常这是不推荐的（搞这么麻烦，何必呢？呵呵）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样一看，类CDbCommand的实现稍显混乱。本意上额外的第3种方式应该是提供给类CActiveRecord使用的，所以不建议使用。&lt;/p&gt;
&lt;p&gt;接下来看看方法execute方法及query一类（仅以方法query、queryAll为例）方法的实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Executes the SQL statement.&lt;/span&gt;
&lt;span class="x"&gt; * This method is meant only for executing non-query SQL statement.&lt;/span&gt;
&lt;span class="x"&gt; * No result set will be returned.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $params input parameters (name=&amp;gt;value) for the SQL execution. This is an alternative&lt;/span&gt;
&lt;span class="x"&gt; * to {@link bindParam} and {@link bindValue}. If you have multiple input parameters, passing&lt;/span&gt;
&lt;span class="x"&gt; * them in this way can improve the performance. Note that if you pass parameters in this way,&lt;/span&gt;
&lt;span class="x"&gt; * you cannot bind parameters or values using {@link bindParam} or {@link bindValue}, and vice versa.&lt;/span&gt;
&lt;span class="x"&gt; * Please also note that all values are treated as strings in this case, if you need them to be handled as&lt;/span&gt;
&lt;span class="x"&gt; * their real data types, you have to use {@link bindParam} or {@link bindValue} instead.&lt;/span&gt;
&lt;span class="x"&gt; * @return integer number of rows affected by the execution.&lt;/span&gt;
&lt;span class="x"&gt; * @throws CDbException execution failed&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function execute($params=array())&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_connection-&amp;gt;enableParamLogging &amp;amp;&amp;amp; ($pars=array_merge($this-&amp;gt;_paramLog,$params))!==array())&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $p=array();&lt;/span&gt;
&lt;span class="x"&gt;        foreach($pars as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $p[$name]=$name.&amp;#39;=&amp;#39;.var_export($value,true);&lt;/span&gt;
&lt;span class="x"&gt;        $par=&amp;#39;. Bound with &amp;#39; .implode(&amp;#39;, &amp;#39;,$p);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $par=&amp;#39;&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    Yii::trace(&amp;#39;Executing SQL: &amp;#39;.$this-&amp;gt;getText().$par,&amp;#39;system.db.CDbCommand&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    try&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)&lt;/span&gt;
&lt;span class="x"&gt;            Yii::beginProfile(&amp;#39;system.db.CDbCommand.execute(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.execute&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;        // 以通过setText设置的SQL语句为参数间接调用PDO对象的prepare方法，并将返回的PDOStatement对象赋值给当前CDbCommand对象的_statement属性。&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;prepare();&lt;/span&gt;
&lt;span class="x"&gt;        if($params===array())&lt;/span&gt;
&lt;span class="x"&gt;            // 无参执行&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_statement-&amp;gt;execute();&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            // 带参执行&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_statement-&amp;gt;execute($params);&lt;/span&gt;
&lt;span class="x"&gt;        // 操作影响的数据表行数&lt;/span&gt;
&lt;span class="x"&gt;        $n=$this-&amp;gt;_statement-&amp;gt;rowCount();&lt;/span&gt;

&lt;span class="x"&gt;        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)&lt;/span&gt;
&lt;span class="x"&gt;            Yii::endProfile(&amp;#39;system.db.CDbCommand.execute(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.execute&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;        return $n;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    catch(Exception $e)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 省略&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;public function query($params=array())&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;queryInternal(&amp;#39;&amp;#39;,0,$params);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;public function queryAll($fetchAssociative=true,$params=array())&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;queryInternal(&amp;#39;fetchAll&amp;#39;,$fetchAssociative ? $this-&amp;gt;_fetchMode : PDO::FETCH_NUM, $params);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到query一类方法都是间接调用方法queryInternal来完成操作的。queryInternal方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;private function queryInternal($method,$mode,$params=array())&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $params=array_merge($this-&amp;gt;params,$params);&lt;/span&gt;

&lt;span class="x"&gt;    if($this-&amp;gt;_connection-&amp;gt;enableParamLogging &amp;amp;&amp;amp; ($pars=array_merge($this-&amp;gt;_paramLog,$params))!==array())&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $p=array();&lt;/span&gt;
&lt;span class="x"&gt;        foreach($pars as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $p[$name]=$name.&amp;#39;=&amp;#39;.var_export($value,true);&lt;/span&gt;
&lt;span class="x"&gt;        $par=&amp;#39;. Bound with &amp;#39;.implode(&amp;#39;, &amp;#39;,$p);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $par=&amp;#39;&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    Yii::trace(&amp;#39;Querying SQL: &amp;#39;.$this-&amp;gt;getText().$par,&amp;#39;system.db.CDbCommand&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;    // 先尝试从缓存中读取查询结果&lt;/span&gt;
&lt;span class="x"&gt;    // 这里涉及CDbConnection类的三个属性queryCachingCount、queryCachingDuration、queryCacheID&lt;/span&gt;
&lt;span class="x"&gt;    // 另外对于方法query（调用queryInternal时提供的method参数为空字符串）的操作不会缓存&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_connection-&amp;gt;queryCachingCount&amp;gt;0 &amp;amp;&amp;amp; $method!==&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="x"&gt;            &amp;amp;&amp;amp; $this-&amp;gt;_connection-&amp;gt;queryCachingDuration&amp;gt;0&lt;/span&gt;
&lt;span class="x"&gt;            &amp;amp;&amp;amp; $this-&amp;gt;_connection-&amp;gt;queryCacheID!==false&lt;/span&gt;
&lt;span class="x"&gt;            &amp;amp;&amp;amp; ($cache=Yii::app()-&amp;gt;getComponent($this-&amp;gt;_connection-&amp;gt;queryCacheID))!==null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_connection-&amp;gt;queryCachingCount--;&lt;/span&gt;
&lt;span class="x"&gt;        $cacheKey=&amp;#39;yii:dbquery&amp;#39;.$this-&amp;gt;_connection-&amp;gt;connectionString.&amp;#39;:&amp;#39;.$this-&amp;gt;_connection-&amp;gt;username;&lt;/span&gt;
&lt;span class="x"&gt;        $cacheKey.=&amp;#39;:&amp;#39;.$this-&amp;gt;getText().&amp;#39;:&amp;#39;.serialize(array_merge($this-&amp;gt;_paramLog,$params));&lt;/span&gt;
&lt;span class="x"&gt;        if(($result=$cache-&amp;gt;get($cacheKey))!==false)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            Yii::trace(&amp;#39;Query result found in cache&amp;#39;,&amp;#39;system.db.CDbCommand&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;            return $result[0];&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    try&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)&lt;/span&gt;
&lt;span class="x"&gt;            Yii::beginProfile(&amp;#39;system.db.CDbCommand.query(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.query&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;        $this-&amp;gt;prepare();&lt;/span&gt;
&lt;span class="x"&gt;        if($params===array())&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_statement-&amp;gt;execute();&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_statement-&amp;gt;execute($params);&lt;/span&gt;

&lt;span class="x"&gt;        // $method对应PDOStatement的结果获取方法，如果未提供$method，自然无法直接通过PDOStatement获取查询结果。&lt;/span&gt;
&lt;span class="x"&gt;        if($method===&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;            // 这个细看一下&lt;/span&gt;
&lt;span class="x"&gt;            $result=new CDbDataReader($this);&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $mode=(array)$mode;&lt;/span&gt;
&lt;span class="x"&gt;            call_user_func_array(array($this-&amp;gt;_statement, &amp;#39;setFetchMode&amp;#39;), $mode);&lt;/span&gt;
&lt;span class="x"&gt;            // 调用PDOStatement对应的方法&lt;/span&gt;
&lt;span class="x"&gt;            $result=$this-&amp;gt;_statement-&amp;gt;$method();&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_statement-&amp;gt;closeCursor();&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;

&lt;span class="x"&gt;        if($this-&amp;gt;_connection-&amp;gt;enableProfiling)&lt;/span&gt;
&lt;span class="x"&gt;            Yii::endProfile(&amp;#39;system.db.CDbCommand.query(&amp;#39;.$this-&amp;gt;getText().$par.&amp;#39;)&amp;#39;,&amp;#39;system.db.CDbCommand.query&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;        // 如果设置了$cache和$cacheKey&lt;/span&gt;
&lt;span class="x"&gt;        // 将查询结果存入缓存&lt;/span&gt;
&lt;span class="x"&gt;        if(isset($cache,$cacheKey))&lt;/span&gt;
&lt;span class="x"&gt;            $cache-&amp;gt;set($cacheKey, array($result), $this-&amp;gt;_connection-&amp;gt;queryCachingDuration, $this-&amp;gt;_connection-&amp;gt;queryCachingDependency);&lt;/span&gt;

&lt;span class="x"&gt;        return $result;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    catch(Exception $e)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 省略&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到query方法调用queryInternal时，结果是通过CDbDataReader对象来获取的。类CDbDataReader的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct(CDbCommand $command)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_statement=$command-&amp;gt;getPdoStatement();&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_statement-&amp;gt;setFetchMode(PDO::FETCH_ASSOC);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到CDbDataReader对象，即可通过它的read一类方法&lt;strong&gt;迭代&lt;/strong&gt;获取查询结果。这些方法实际上是调用PDOStatement的fetch一类方法来获取结果的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;再来看看Yii框架Model层的第2种使用方式。&lt;/p&gt;
&lt;p&gt;CActiveRecord的用法是，对于数据库的每个数据表，创建一个model类，如UserModel，这个类继承自CActiveRecord类。model类名可以和数据表名一致，也可以不一致，如果不一致，则需要重写CActiveRecord类的tableName方法，标明该model类对应的数据表名。方法tableName默认的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt;* Returns the name of the associated database table.&lt;/span&gt;
&lt;span class="x"&gt;* By default this method returns the class name as the table name.&lt;/span&gt;
&lt;span class="x"&gt;* You may override this method if the table is not named after this convention.&lt;/span&gt;
&lt;span class="x"&gt;* @return string the table name&lt;/span&gt;
&lt;span class="x"&gt;*/&lt;/span&gt;
&lt;span class="x"&gt;public function tableName()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return get_class($this);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;假设UserModel类对应的数据表名为User，则应如下重写tableName：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function tableName()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return &amp;#39;User&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用CActiveRecord方式，若想向数据表中插入一条新纪录，则需要实例化当前model类。以UserModel类为例，若想向User表中插入一条新纪录，则需要先实例化UserModel，得到一个对象，然后对该对象的属性进行赋值指明对应数据表新记录每个字段的值。对象的属性名即数据表的字段名，赋值完毕，调用save或insert即向数据表中存入该新纪录。&lt;/p&gt;
&lt;p&gt;CActiveRecord类的构造方法如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($scenario=&amp;#39;insert&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($scenario===null) // internally used by populateRecord() and model()&lt;/span&gt;
&lt;span class="x"&gt;        return;&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;setScenario($scenario);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;setIsNewRecord(true);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_attributes=$this-&amp;gt;getMetaData()-&amp;gt;attributeDefaults;&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;init();&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors());&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;afterConstruct();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;$scenario='insert'，表示新实例化的对象处于待插入数据表的状态，在调用save等方法时，会检测该状态。在新实例化的对象插入到数据表后，该状态立即会变为"update"，表示之后对该对象的数据库写入操作，属于update操作。&lt;/p&gt;
&lt;p&gt;CActiveRecord类的save方法的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function save($runValidation=true,$attributes=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 若需要则对某些属性做校验&lt;/span&gt;
&lt;span class="x"&gt;    if(!$runValidation || $this-&amp;gt;validate($attributes))&lt;/span&gt;
&lt;span class="x"&gt;        // 如果是新纪录，则插入，否则更新&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;getIsNewRecord() ? $this-&amp;gt;insert($attributes) : $this-&amp;gt;update($attributes);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而insert、update方法的实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function insert($attributes=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(!$this-&amp;gt;getIsNewRecord())&lt;/span&gt;
&lt;span class="x"&gt;        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The active record cannot be inserted to database because it is not new.&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;beforeSave())&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        Yii::trace(get_class($this).&amp;#39;.insert()&amp;#39;,&amp;#39;system.db.ar.CActiveRecord&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        // ...&lt;/span&gt;
&lt;span class="x"&gt;        $builder=$this-&amp;gt;getCommandBuilder();&lt;/span&gt;
&lt;span class="x"&gt;        // ...&lt;/span&gt;
&lt;span class="x"&gt;        $table=$this-&amp;gt;getMetaData()-&amp;gt;tableSchema;&lt;/span&gt;
&lt;span class="x"&gt;        $command=$builder-&amp;gt;createInsertCommand($table,$this-&amp;gt;getAttributes($attributes));&lt;/span&gt;
&lt;span class="x"&gt;        if($command-&amp;gt;execute())&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $primaryKey=$table-&amp;gt;primaryKey;&lt;/span&gt;
&lt;span class="x"&gt;            if($table-&amp;gt;sequenceName!==null)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                if(is_string($primaryKey) &amp;amp;&amp;amp; $this-&amp;gt;$primaryKey===null)&lt;/span&gt;
&lt;span class="x"&gt;                    $this-&amp;gt;$primaryKey=$builder-&amp;gt;getLastInsertID($table);&lt;/span&gt;
&lt;span class="x"&gt;                elseif(is_array($primaryKey))&lt;/span&gt;
&lt;span class="x"&gt;                {&lt;/span&gt;
&lt;span class="x"&gt;                    foreach($primaryKey as $pk)&lt;/span&gt;
&lt;span class="x"&gt;                    {&lt;/span&gt;
&lt;span class="x"&gt;                        if($this-&amp;gt;$pk===null)&lt;/span&gt;
&lt;span class="x"&gt;                        {&lt;/span&gt;
&lt;span class="x"&gt;                            $this-&amp;gt;$pk=$builder-&amp;gt;getLastInsertID($table);&lt;/span&gt;
&lt;span class="x"&gt;                            break;&lt;/span&gt;
&lt;span class="x"&gt;                        }&lt;/span&gt;
&lt;span class="x"&gt;                    }&lt;/span&gt;
&lt;span class="x"&gt;                }&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_pk=$this-&amp;gt;getPrimaryKey();&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;afterSave();&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;setIsNewRecord(false);&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;setScenario(&amp;#39;update&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;            return true;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    return false;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;public function update($attributes=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;getIsNewRecord())&lt;/span&gt;
&lt;span class="x"&gt;        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The active record cannot be updated because it is new.&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;beforeSave())&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        Yii::trace(get_class($this).&amp;#39;.update()&amp;#39;,&amp;#39;system.db.ar.CActiveRecord&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;_pk===null)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_pk=$this-&amp;gt;getPrimaryKey();&lt;/span&gt;
&lt;span class="x"&gt;        // 间接调用updateByPk来完成操作&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;updateByPk($this-&amp;gt;getOldPrimaryKey(),$this-&amp;gt;getAttributes($attributes));&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_pk=$this-&amp;gt;getPrimaryKey();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;afterSave();&lt;/span&gt;
&lt;span class="x"&gt;        return true;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;insert方法中调用的getCommandBuilder方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getCommandBuilder()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;getDbConnection()-&amp;gt;getSchema()-&amp;gt;getCommandBuilder();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中getDbConnection方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getDbConnection()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(self::$db!==null)&lt;/span&gt;
&lt;span class="x"&gt;        return self::$db;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        self::$db=Yii::app()-&amp;gt;getDb();&lt;/span&gt;
&lt;span class="x"&gt;        if(self::$db instanceof CDbConnection)&lt;/span&gt;
&lt;span class="x"&gt;            return self::$db;&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Active Record requires a &amp;quot;db&amp;quot; CDbConnection application component.&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yii中默认的DB组件名为db，所以如果你使用的是默认的db数据库，那么不用重写这个方法。否则，需要重写该方法，指明需要使用的数据库连接。&lt;/p&gt;
&lt;p&gt;getDbConnection方法返回的是一个CDbConnection对象，其getSchema方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getSchema()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_schema!==null)&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_schema;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 返回数据库配置信息connectionString字段中的数据库驱动类型，如mysql&lt;/span&gt;
&lt;span class="x"&gt;        $driver=$this-&amp;gt;getDriverName();&lt;/span&gt;
&lt;span class="x"&gt;        /*&lt;/span&gt;
&lt;span class="x"&gt;            driverMap属性的定义：&lt;/span&gt;
&lt;span class="x"&gt;            public $driverMap=array(&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;pgsql&amp;#39;=&amp;gt;&amp;#39;CPgsqlSchema&amp;#39;,    // PostgreSQL&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;mysqli&amp;#39;=&amp;gt;&amp;#39;CMysqlSchema&amp;#39;,   // MySQL&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;mysql&amp;#39;=&amp;gt;&amp;#39;CMysqlSchema&amp;#39;,    // MySQL&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;sqlite&amp;#39;=&amp;gt;&amp;#39;CSqliteSchema&amp;#39;,  // sqlite 3&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;sqlite2&amp;#39;=&amp;gt;&amp;#39;CSqliteSchema&amp;#39;, // sqlite 2&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;mssql&amp;#39;=&amp;gt;&amp;#39;CMssqlSchema&amp;#39;,    // Mssql driver on windows hosts&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;dblib&amp;#39;=&amp;gt;&amp;#39;CMssqlSchema&amp;#39;,    // dblib drivers on linux (and maybe others os) hosts&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;sqlsrv&amp;#39;=&amp;gt;&amp;#39;CMssqlSchema&amp;#39;,   // Mssql&lt;/span&gt;
&lt;span class="x"&gt;              &amp;#39;oci&amp;#39;=&amp;gt;&amp;#39;COciSchema&amp;#39;,        // Oracle driver&lt;/span&gt;
&lt;span class="x"&gt;           );&lt;/span&gt;
&lt;span class="x"&gt;        */&lt;/span&gt;
&lt;span class="x"&gt;        if(isset($this-&amp;gt;driverMap[$driver]))&lt;/span&gt;
&lt;span class="x"&gt;            // 加载对应的数据库驱动组件&lt;/span&gt;
&lt;span class="x"&gt;            return $this-&amp;gt;_schema=Yii::createComponent($this-&amp;gt;driverMap[$driver], $this);&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;CDbConnection does not support reading schema for {driver} database.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                array(&amp;#39;{driver}&amp;#39;=&amp;gt;$driver)));&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以mysql的CMysqlSchema为例，&lt;code&gt;Yii::createComponent($this-&amp;gt;driverMap[$driver], $this)&lt;/code&gt;一句会实例化yii/framework/db/schema/mysql/CMysqlSchema.php中定义的CMysqlSchema类。该类自身无构造方法，继承自抽象类CDbSchema，CDbSchema的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($conn)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 保存着当前CDbConnection数据库连接对象&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_connection=$conn;&lt;/span&gt;
&lt;span class="x"&gt;    foreach($conn-&amp;gt;schemaCachingExclude as $name)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_cacheExclude[$name]=true;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到CMysqlSchema对象后，调用其getCommandBuilder方法，该方法定义于类CDbSchema中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getCommandBuilder()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;_builder!==null)&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_builder;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_builder=$this-&amp;gt;createCommandBuilder();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的方法createCommandBuilder实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;protected function createCommandBuilder()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return new CDbCommandBuilder($this);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实例化的CDbCommandBuilder类的构造方法如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($schema)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_schema=$schema;&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_connection=$schema-&amp;gt;getDbConnection();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样insert方法中调用的getCommandBuilder最终返回了一个CDbCommandBuilder对象。&lt;/p&gt;
&lt;p&gt;而insert方法中&lt;code&gt;$table=$this-&amp;gt;getMetaData()-&amp;gt;tableSchema&lt;/code&gt;一句调用的getMetaData方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getMetaData()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $className=get_class($this);&lt;/span&gt;
&lt;span class="x"&gt;    if(!array_key_exists($className,self::$_md))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        self::$_md[$className]=null; // preventing recursive invokes of {@link getMetaData()} via {@link __get()}&lt;/span&gt;
&lt;span class="x"&gt;        self::$_md[$className]=new CActiveRecordMetaData($this);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    return self::$_md[$className];&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中实例化的类CActiveRecordMetaData，构造方法如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($model)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 当前model类名&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_modelClassName=get_class($model);&lt;/span&gt;

&lt;span class="x"&gt;    // 得到表名&lt;/span&gt;
&lt;span class="x"&gt;    $tableName=$model-&amp;gt;tableName();&lt;/span&gt;

&lt;span class="x"&gt;    // 调用_schema（以mysql为例，其值为CMysqlSchema对象）的getTable方法&lt;/span&gt;
&lt;span class="x"&gt;    if(($table=$model-&amp;gt;getDbConnection()-&amp;gt;getSchema()-&amp;gt;getTable($tableName))===null)&lt;/span&gt;
&lt;span class="x"&gt;        throw new CDbException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The table &amp;quot;{table}&amp;quot; for active record class &amp;quot;{class}&amp;quot; cannot be found in the database.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{class}&amp;#39;=&amp;gt;$this-&amp;gt;_modelClassName,&amp;#39;{table}&amp;#39;=&amp;gt;$tableName)));&lt;/span&gt;
&lt;span class="x"&gt;    if($table-&amp;gt;primaryKey===null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $table-&amp;gt;primaryKey=$model-&amp;gt;primaryKey();&lt;/span&gt;
&lt;span class="x"&gt;        if(is_string($table-&amp;gt;primaryKey) &amp;amp;&amp;amp; isset($table-&amp;gt;columns[$table-&amp;gt;primaryKey]))&lt;/span&gt;
&lt;span class="x"&gt;            $table-&amp;gt;columns[$table-&amp;gt;primaryKey]-&amp;gt;isPrimaryKey=true;&lt;/span&gt;
&lt;span class="x"&gt;        elseif(is_array($table-&amp;gt;primaryKey))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            foreach($table-&amp;gt;primaryKey as $name)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                if(isset($table-&amp;gt;columns[$name]))&lt;/span&gt;
&lt;span class="x"&gt;                    $table-&amp;gt;columns[$name]-&amp;gt;isPrimaryKey=true;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 将数据表结构信息存于属性tableSchema&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;tableSchema=$table;&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;columns=$table-&amp;gt;columns;&lt;/span&gt;

&lt;span class="x"&gt;    foreach($table-&amp;gt;columns as $name=&amp;gt;$column)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if(!$column-&amp;gt;isPrimaryKey &amp;amp;&amp;amp; $column-&amp;gt;defaultValue!==null)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;attributeDefaults[$name]=$column-&amp;gt;defaultValue;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    foreach($model-&amp;gt;relations() as $name=&amp;gt;$config)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;addRelation($name,$config);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的getTable方法，定义于抽象类CDbSchema中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getTable($name,$refresh=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($refresh===false &amp;amp;&amp;amp; isset($this-&amp;gt;_tables[$name]))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_tables[$name];&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;_connection-&amp;gt;tablePrefix!==null &amp;amp;&amp;amp; strpos($name,&amp;#39;{{&amp;#39;)!==false)&lt;/span&gt;
&lt;span class="x"&gt;            $realName=preg_replace(&amp;#39;/\{\{(.*?)\}\}/&amp;#39;,$this-&amp;gt;_connection-&amp;gt;tablePrefix.&amp;#39;$1&amp;#39;,$name);&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $realName=$name;&lt;/span&gt;

&lt;span class="x"&gt;        // temporarily disable query caching&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;_connection-&amp;gt;queryCachingDuration&amp;gt;0)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $qcDuration=$this-&amp;gt;_connection-&amp;gt;queryCachingDuration;&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_connection-&amp;gt;queryCachingDuration=0;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;

&lt;span class="x"&gt;        // 先尝试从缓存中取数据表结构信息&lt;/span&gt;
&lt;span class="x"&gt;        // CDbConnection类的schemaCachingDuration属性默认为0，如果不配置该属性，那么就不会使用缓存，那么每次增、删、改、查操作都需要loadTable，&lt;/span&gt;
&lt;span class="x"&gt;        // 对数据库的压力，以及性能影响是不是很大？！但如果加了缓存，那么当对数据表的结构做变更时会不会有问题？&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($this-&amp;gt;_cacheExclude[$name]) &amp;amp;&amp;amp; ($duration=$this-&amp;gt;_connection-&amp;gt;schemaCachingDuration)&amp;gt;0 &amp;amp;&amp;amp; $this-&amp;gt;_connection-&amp;gt;schemaCacheID!==false &amp;amp;&amp;amp; ($cache=Yii::app()-&amp;gt;getComponent($this-&amp;gt;_connection-&amp;gt;schemaCacheID))!==null)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $key=&amp;#39;yii:dbschema&amp;#39;.$this-&amp;gt;_connection-&amp;gt;connectionString.&amp;#39;:&amp;#39;.$this-&amp;gt;_connection-&amp;gt;username.&amp;#39;:&amp;#39;.$name;&lt;/span&gt;
&lt;span class="x"&gt;            $table=$cache-&amp;gt;get($key);&lt;/span&gt;
&lt;span class="x"&gt;            // 没取到或者需要刷新缓存，则从数据库获取，并更新缓存&lt;/span&gt;
&lt;span class="x"&gt;            if($refresh===true || $table===false)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                $table=$this-&amp;gt;loadTable($realName);&lt;/span&gt;
&lt;span class="x"&gt;                if($table!==null)&lt;/span&gt;
&lt;span class="x"&gt;                    $cache-&amp;gt;set($key,$table,$duration);&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_tables[$name]=$table;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            // 直接从数据库获取数据表结构信息&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_tables[$name]=$table=$this-&amp;gt;loadTable($realName);&lt;/span&gt;

&lt;span class="x"&gt;        if(isset($qcDuration))  // re-enable query caching&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_connection-&amp;gt;queryCachingDuration=$qcDuration;&lt;/span&gt;

&lt;span class="x"&gt;        return $table;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的loadTable方法最终是通过执行SQL语句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'SHOW FULL COLUMNS FROM '.$table-&amp;gt;rawName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'SHOW CREATE TABLE '.$table-&amp;gt;rawName&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来获取数据表信息，并将信息存于一个CMysqlColumnSchema对象中（以mysql为例）。&lt;/p&gt;
&lt;p&gt;insert方法中&lt;code&gt;$command=$builder-&amp;gt;createInsertCommand($table,$this-&amp;gt;getAttributes($attributes))&lt;/code&gt;一句createInsertCommand方法定义于CDbCommandBuilder类中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function createInsertCommand($table,$data)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;ensureTable($table);&lt;/span&gt;
&lt;span class="x"&gt;    $fields=array();&lt;/span&gt;
&lt;span class="x"&gt;    $values=array();&lt;/span&gt;
&lt;span class="x"&gt;    $placeholders=array();&lt;/span&gt;
&lt;span class="x"&gt;    $i=0;&lt;/span&gt;
&lt;span class="x"&gt;    foreach($data as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if(($column=$table-&amp;gt;getColumn($name))!==null &amp;amp;&amp;amp; ($value!==null || $column-&amp;gt;allowNull))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $fields[]=$column-&amp;gt;rawName;&lt;/span&gt;
&lt;span class="x"&gt;            if($value instanceof CDbExpression)&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                $placeholders[]=$value-&amp;gt;expression;&lt;/span&gt;
&lt;span class="x"&gt;                foreach($value-&amp;gt;params as $n=&amp;gt;$v)&lt;/span&gt;
&lt;span class="x"&gt;                    $values[$n]=$v;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;            {&lt;/span&gt;
&lt;span class="x"&gt;                $placeholders[]=self::PARAM_PREFIX.$i;&lt;/span&gt;
&lt;span class="x"&gt;                $values[self::PARAM_PREFIX.$i]=$column-&amp;gt;typecast($value);&lt;/span&gt;
&lt;span class="x"&gt;                $i++;&lt;/span&gt;
&lt;span class="x"&gt;            }&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    if($fields===array())&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $pks=is_array($table-&amp;gt;primaryKey) ? $table-&amp;gt;primaryKey : array($table-&amp;gt;primaryKey);&lt;/span&gt;
&lt;span class="x"&gt;        foreach($pks as $pk)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $fields[]=$table-&amp;gt;getColumn($pk)-&amp;gt;rawName;&lt;/span&gt;
&lt;span class="x"&gt;            $placeholders[]=$this-&amp;gt;getIntegerPrimaryKeyDefaultValue();&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    $sql=&amp;quot;INSERT INTO {$table-&amp;gt;rawName} (&amp;quot;.implode(&amp;#39;, &amp;#39;,$fields).&amp;#39;) VALUES (&amp;#39;.implode(&amp;#39;, &amp;#39;,$placeholders).&amp;#39;)&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    $command=$this-&amp;gt;_connection-&amp;gt;createCommand($sql);&lt;/span&gt;

&lt;span class="x"&gt;    foreach($values as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;        $command-&amp;gt;bindValue($name,$value);&lt;/span&gt;

&lt;span class="x"&gt;    return $command;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外还有与update、delete等操作对应的方法createUpdateCommand、createDeleteCommand等。&lt;/p&gt;
&lt;p&gt;update方法与insert方法的逻辑基本是一致的。&lt;/p&gt;
&lt;p&gt;CActiveRecord中所有数据库增、删、改、查操作，在构建出目标sql语句后，都是调用CDbConnection类的方法createCommand来得到一个CDbCommand类的对象，最后调用该对象的execute、query、queryAll等方法来完成查询获取结果。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;对于model类实例对象的属性赋值，依赖于CActiveRecord类的方法__set，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __set($name,$value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;setAttribute($name,$value)===false)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if(isset($this-&amp;gt;getMetaData()-&amp;gt;relations[$name]))&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_related[$name]=$value;&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            parent::__set($name,$value);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的setAttribute方法的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function setAttribute($name,$value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(property_exists($this,$name))&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;$name=$value;&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;getMetaData()-&amp;gt;columns[$name]))&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_attributes[$name]=$value;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;    return true;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;基于CActiveRecord类，如果想进行读取操作，那么子类需要重写model方法。CActiveRecord类的model方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/**
 * Returns the static model of the specified AR class.
 * The model returned is a static instance of the AR class.
 * It is provided for invoking class-level methods (something similar to static class methods.)
 *
 * EVERY derived AR class must override this method as follows,
 * &lt;span class="nt"&gt;&amp;lt;pre&amp;gt;&lt;/span&gt;
 * public static function model($className=__CLASS__)
 * {
 *     return parent::model($className);
 * }
 * &lt;span class="nt"&gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
 *
 * @param string $className active record class name.
 * @return CActiveRecord active record model instance.
 */
public static function model($className=__CLASS__)
{
    if(isset(self::$_models[$className]))
        return self::$_models[$className];
    else
    {
        $model=self::$_models[$className]=new $className(null);
        $model-&amp;gt;attachBehaviors($model-&amp;gt;behaviors());
        return $model;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据该方法的注释可知道，所有的子类必须如下重写model方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public static function model($className = __CLASS__)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return parent::model($className);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为什么必须重写model方法呢？因为&lt;code&gt;__CLASS__&lt;/code&gt;指的并不是当前对象所属的类，而是方法定义所在的类。&lt;/p&gt;
&lt;p&gt;隔壁的哥们告诉我，在 PHP 5.3 之后，如果CActiveRecord的model方法如下实现，就可以不用这样使用需要重写了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public static function model()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $className = get_called_class();&lt;/span&gt;
&lt;span class="x"&gt;    if(isset(self::$_models[$className]))&lt;/span&gt;
&lt;span class="x"&gt;        return self::$_models[$className];&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $model=self::$_models[$className]=new $className(null);&lt;/span&gt;
&lt;span class="x"&gt;        $model-&amp;gt;attachBehaviors($model-&amp;gt;behaviors());&lt;/span&gt;
&lt;span class="x"&gt;        return $model;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在得到$model后，就可以调用对象的query、find、findAll、findByPk、findAllByPk、findByAttributes、findAllByAttributes、findBySql、findAllBySql等方法来查询数据。其中find、findAll、findByPk、findAllByPk、findByAttributes、findAllByAttributes最终是通过调用query方法来实现查询的。query方法的第一个参数是一个CDbCriteria类实例对象，这就意味着调用query方法来实现查询的方法需要根据参数实例化一个CDbCriteria类对象。如find方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Finds a single active record with the specified condition.&lt;/span&gt;
&lt;span class="x"&gt; * @param mixed $condition query condition or criteria.&lt;/span&gt;
&lt;span class="x"&gt; * If a string, it is treated as query condition (the WHERE clause);&lt;/span&gt;
&lt;span class="x"&gt; * If an array, it is treated as the initial values for constructing a {@link CDbCriteria} object;&lt;/span&gt;
&lt;span class="x"&gt; * Otherwise, it should be an instance of {@link CDbCriteria}.&lt;/span&gt;
&lt;span class="x"&gt; * @param array $params parameters to be bound to an SQL statement.&lt;/span&gt;
&lt;span class="x"&gt; * This is only used when the first parameter is a string (query condition).&lt;/span&gt;
&lt;span class="x"&gt; * In other cases, please use {@link CDbCriteria::params} to set parameters.&lt;/span&gt;
&lt;span class="x"&gt; * @return CActiveRecord the record found. Null if no record is found.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function find($condition=&amp;#39;&amp;#39;,$params=array())&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    Yii::trace(get_class($this).&amp;#39;.find()&amp;#39;,&amp;#39;system.db.ar.CActiveRecord&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    // 实例化一个CDbCriteria对象&lt;/span&gt;
&lt;span class="x"&gt;    $criteria=$this-&amp;gt;getCommandBuilder()-&amp;gt;createCriteria($condition,$params);&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;query($criteria);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而query方法的实现如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;protected function query($criteria,$all=false)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;beforeFind();&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;applyScopes($criteria);&lt;/span&gt;

&lt;span class="x"&gt;    if(empty($criteria-&amp;gt;with))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if(!$all)&lt;/span&gt;
&lt;span class="x"&gt;            $criteria-&amp;gt;limit=1;&lt;/span&gt;
&lt;span class="x"&gt;        // createFindCommand在上面提过&lt;/span&gt;
&lt;span class="x"&gt;        $command=$this-&amp;gt;getCommandBuilder()-&amp;gt;createFindCommand($this-&amp;gt;getTableSchema(),$criteria,$this-&amp;gt;getTableAlias());&lt;/span&gt;
&lt;span class="x"&gt;        return $all ? $this-&amp;gt;populateRecords($command-&amp;gt;queryAll(), true, $criteria-&amp;gt;index) : $this-&amp;gt;populateRecord($command-&amp;gt;queryRow());&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $finder=$this-&amp;gt;getActiveFinder($criteria-&amp;gt;with);&lt;/span&gt;
&lt;span class="x"&gt;        return $finder-&amp;gt;query($criteria,$all);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;对于查询操作，很多时候需要多表关联查询。那么基于CActiveRecord如何实现多表关联查询（隐式自动地）呢？&lt;/p&gt;
&lt;p&gt;CActiveRecord类有个方法relations()：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function relations()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return array();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个方法的注释非常长，说明如何通过该方法声明当前model对应的数据表有哪些关联数据表，是何种关联关系。继承自CActiveRecord类的model类若想使用隐式的多表关联查询，则需要重写该方法。&lt;/p&gt;
&lt;p&gt;举例来说，有数据表UserContacts、Users，UserContacts中有外键字段user_id关联到Users。如果基于CActiveRecord在查询UserContacts记录时，需要便捷地获取关联Users的记录。那么可以在UserContacts数据表对应的model类中，这样重写relations方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function relations()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return array(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;#39;user&amp;#39; =&amp;gt; array(self::BELONGS_TO, &amp;#39;Users&amp;#39;, &amp;#39;user_id&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;    );&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么在得到一条记录对象（$uc）时，通过调用$uc-&amp;gt;user，即可得到与该UserContacts记录关联的Users记录。不过这条关联记录的获取可能是在调用$uc-&amp;gt;user时才去查询数据库的。&lt;/p&gt;
&lt;p&gt;若想提前将关联记录查询出来准备好，则可以再调用find、findAll等查询方法之前先调用with方法，如&lt;code&gt;self::model()-&amp;gt;with('user')-&amp;gt;find(array('usercontact_id' =&amp;gt; 1))&lt;/code&gt;，或者这样调用find方法&lt;code&gt;self::model()-&amp;gt;find(array('usercontact_id' =&amp;gt; 1, 'with' =&amp;gt; 'user'))&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么在调用&lt;code&gt;$uc-&amp;gt;user&lt;/code&gt;时，如何知道user是一个关联项，而不是一个当前对象的属性？如果当前对象对应的数据表已有一个名为user的字段，是否会屏蔽掉关联项？且看CActiveRecord类的__get方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __get($name)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 先查看当前model类对应的数据表是否有名为$name的字段&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($this-&amp;gt;_attributes[$name]))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_attributes[$name];&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;getMetaData()-&amp;gt;columns[$name]))&lt;/span&gt;
&lt;span class="x"&gt;        return null;&lt;/span&gt;
&lt;span class="x"&gt;    // 查看是否有名为$name的关联项&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;_related[$name]))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_related[$name];&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;getMetaData()-&amp;gt;relations[$name]))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;getRelated($name);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return parent::__get($name);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;注：本文为草稿状态&lt;/em&gt;&lt;/p&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 组件集成</title><link href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/" rel="alternate"></link><updated>2014-11-13T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-13:2014/11/13/read-yii-code-3/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架将各种功能封装成组件，使用时按需配置加载，从而提高应用的性能。内置的组件又分为核心组件与非核心组件，核心组件是任何Web应用和Console应用都需要的。
此外，应用开发者还可以按照一定规则封装配置使用自己的功能组件。Yii会把应用需要的组件都加载到应用容器&lt;code&gt;Yii::app()&lt;/code&gt;中，使得组件的使用方式一致方便。&lt;/p&gt;
&lt;p&gt;基于Yii框架开发应用需要理解如何配置组件、如何开发自己的组件，对应着需要理解Yii是如何注册加载组件的。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;从&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt;一文可知，Yii加载组件的入口为抽象类CApplication构造方法中的以下两行代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;$this-&amp;gt;registerCoreComponents();&lt;/span&gt;
&lt;span class="x"&gt;$this-&amp;gt;configure($config);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;registerCoreComponents&lt;/code&gt;方法定义于类CWebApplication中，用于加载Web应用的核心组件，组件列表如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;array(&lt;/span&gt;
&lt;span class="x"&gt;    // 核心组件&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;coreMessages&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CPhpMessageSource&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;language&amp;#39;=&amp;gt;&amp;#39;en_us&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;basePath&amp;#39;=&amp;gt;YII_PATH.DIRECTORY_SEPARATOR.&amp;#39;messages&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;db&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CDbConnection&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;messages&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CPhpMessageSource&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;errorHandler&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CErrorHandler&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;securityManager&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CSecurityManager&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;statePersister&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CStatePersister&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;urlManager&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CUrlManager&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;request&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CHttpRequest&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;format&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CFormatter&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;

&lt;span class="x"&gt;    // 以下是Web应用额外需要的核心组件&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;session&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CHttpSession&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;assetManager&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CAssetManager&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;user&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CWebUser&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;themeManager&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CThemeManager&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;authManager&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CPhpAuthManager&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;clientScript&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CClientScript&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;widgetFactory&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CWidgetFactory&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注册加载组件都是直接调用方法&lt;code&gt;setComponents&lt;/code&gt;，间接调用方法&lt;code&gt;setComponent&lt;/code&gt;来完成的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;configure&lt;/code&gt;方法定义于类&lt;code&gt;CModule&lt;/code&gt;中，是用于加载所有配置信息的，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function configure($config)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($config))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($config as $key=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;$key=$value;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt;一文可知，配置信息的加载是基于类&lt;code&gt;CComponent&lt;/code&gt;中的魔术方法&lt;code&gt;__set&lt;/code&gt;来完成的，该方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __set($name,$value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // PHP的类名、函数名、方法名都是不区分大小写的！&lt;/span&gt;
&lt;span class="x"&gt;    $setter=&amp;#39;set&amp;#39;.$name;&lt;/span&gt;
&lt;span class="x"&gt;    if(method_exists($this,$setter))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;$setter($value);&lt;/span&gt;
&lt;span class="x"&gt;    elseif(strncasecmp($name,&amp;#39;on&amp;#39;,2)===0 &amp;amp;&amp;amp; method_exists($this,$name))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // duplicating getEventHandlers() here for performance&lt;/span&gt;
&lt;span class="x"&gt;        $name=strtolower($name);&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($this-&amp;gt;_e[$name]))&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_e[$name]=new CList;&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_e[$name]-&amp;gt;add($value);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    elseif(is_array($this-&amp;gt;_m))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($this-&amp;gt;_m as $object)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if($object-&amp;gt;getEnabled() &amp;amp;&amp;amp; (property_exists($object,$name) || $object-&amp;gt;canSetProperty($name)))&lt;/span&gt;
&lt;span class="x"&gt;                return $object-&amp;gt;$name=$value;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    if(method_exists($this,&amp;#39;get&amp;#39;.$name))&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is read only.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is not defined.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而类CModule中又定义了方法&lt;code&gt;setComponents&lt;/code&gt;，所以对于key为&lt;code&gt;components&lt;/code&gt;的配置项，也是调用方法&lt;code&gt;setComponents&lt;/code&gt;，间接调用方法&lt;code&gt;setComponent&lt;/code&gt;来完成的。&lt;/p&gt;
&lt;p&gt;方法&lt;code&gt;setComponent&lt;/code&gt;实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Puts a component under the management of the module.&lt;/span&gt;
&lt;span class="x"&gt; * The component will be initialized by calling its {@link CApplicationComponent::init() init()}&lt;/span&gt;
&lt;span class="x"&gt; * method if it has not done so.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $id component ID&lt;/span&gt;
&lt;span class="x"&gt; * @param array|IApplicationComponent $component application component&lt;/span&gt;
&lt;span class="x"&gt; * (either configuration array or instance). If this parameter is null,&lt;/span&gt;
&lt;span class="x"&gt; * component will be unloaded from the module.&lt;/span&gt;
&lt;span class="x"&gt; * @param boolean $merge whether to merge the new component configuration&lt;/span&gt;
&lt;span class="x"&gt; * with the existing one. Defaults to true, meaning the previously registered&lt;/span&gt;
&lt;span class="x"&gt; * component configuration with the same ID will be merged with the new configuration.&lt;/span&gt;
&lt;span class="x"&gt; * If set to false, the existing configuration will be replaced completely.&lt;/span&gt;
&lt;span class="x"&gt; * This parameter is available since 1.1.13.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function setComponent($id,$component,$merge=true)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($component===null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        unset($this-&amp;gt;_components[$id]);&lt;/span&gt;
&lt;span class="x"&gt;        return;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    elseif($component instanceof IApplicationComponent)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_components[$id]=$component;&lt;/span&gt;

&lt;span class="x"&gt;        if(!$component-&amp;gt;getIsInitialized())&lt;/span&gt;
&lt;span class="x"&gt;            $component-&amp;gt;init();&lt;/span&gt;

&lt;span class="x"&gt;        return;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;_components[$id]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if(isset($component[&amp;#39;class&amp;#39;]) &amp;amp;&amp;amp; get_class($this-&amp;gt;_components[$id])!==$component[&amp;#39;class&amp;#39;])&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            unset($this-&amp;gt;_components[$id]);&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_componentConfig[$id]=$component; //we should ignore merge here&lt;/span&gt;
&lt;span class="x"&gt;            return;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;

&lt;span class="x"&gt;        foreach($component as $key=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if($key!==&amp;#39;class&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;_components[$id]-&amp;gt;$key=$value;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 以configure方法为入口的组件注册可能走的分支&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;_componentConfig[$id][&amp;#39;class&amp;#39;],$component[&amp;#39;class&amp;#39;])&lt;/span&gt;
&lt;span class="x"&gt;        &amp;amp;&amp;amp; $this-&amp;gt;_componentConfig[$id][&amp;#39;class&amp;#39;]!==$component[&amp;#39;class&amp;#39;])&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_componentConfig[$id]=$component; //we should ignore merge here&lt;/span&gt;
&lt;span class="x"&gt;        return;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    // 以configure方法为入口的组件注册可能走的分支&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($this-&amp;gt;_componentConfig[$id]) &amp;amp;&amp;amp; $merge)&lt;/span&gt;
&lt;span class="x"&gt;        // 对组件的信息进行合并，即意味着如果是对核心组件做额外配置，可以不用指定class等信息。&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_componentConfig[$id]=CMap::mergeArray($this-&amp;gt;_componentConfig[$id],$component);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        // 核心组件注册全走这个分支&lt;/span&gt;
&lt;span class="x"&gt;        // 非核心组件、自定义组件注册走这个分支&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_componentConfig[$id]=$component;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于以registerCoreComponents方法、configure方法为入口的组件注册，调用setComponent方法时的参数$component是一个数组。&lt;/p&gt;
&lt;p&gt;注册核心组件前，应用对象的属性&lt;code&gt;_component&lt;/code&gt;和&lt;code&gt;_componentConfig&lt;/code&gt;都为空，所以核心组件注册最终走的都是&lt;strong&gt;最后一个else分支&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于可以配置与核心组件相同ID的组件，比如db，那么注册配置的组件（以configure方法为入口）走的是&lt;strong&gt;最后一个elseif分支或者最后一个if分支&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以看到以这两个方法为入口的组件注册都没有对组件进行初始化。那么什么时候初始化组件的呢？只能是调用组件的时候了。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;组件是通过应用对象容器来调用的。以db组件为例，调用方式为：&lt;code&gt;Yii::app()-&amp;gt;db&lt;/code&gt;，但实际是基于魔术方法&lt;code&gt;__get&lt;/code&gt;来完成的，该魔术方法定义于类CModule中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __get($name)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;hasComponent($name))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;getComponent($name);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return parent::__get($name);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先尝试查找对应$name的组件。从这里可以看出Web应用容器中除了存组件，还可以存其他信息，如所有的配置信息。&lt;/p&gt;
&lt;p&gt;方法hasComponent实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function hasComponent($id)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return isset($this-&amp;gt;_components[$id]) || isset($this-&amp;gt;_componentConfig[$id]);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之所以会先查看属性_components，是因为_components中保存的组件是已经加载好的，而_componentConfig保存的是所有注册的组件，但未初始化。即_components中的组件是_componentConfig中组件的子集，检测起来会更快？我的理解是这样的。&lt;/p&gt;
&lt;p&gt;方法getComponent实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getComponent($id,$createIfNull=true)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($this-&amp;gt;_components[$id]))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_components[$id];&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($this-&amp;gt;_componentConfig[$id]) &amp;amp;&amp;amp; $createIfNull)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $config=$this-&amp;gt;_componentConfig[$id];&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($config[&amp;#39;enabled&amp;#39;]) || $config[&amp;#39;enabled&amp;#39;])&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            Yii::trace(&amp;quot;Loading \&amp;quot;$id\&amp;quot; application component&amp;quot;,&amp;#39;system.CModule&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;            unset($config[&amp;#39;enabled&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;            $component=Yii::createComponent($config);&lt;/span&gt;
&lt;span class="x"&gt;            $component-&amp;gt;init();&lt;/span&gt;
&lt;span class="x"&gt;            return $this-&amp;gt;_components[$id]=$component;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先查看属性_components中是否已保存初始化好的对应组件，是，则直接取出来返回，这样重复调用相同组件只会初始化一次；否，则对该组件进行初始化。&lt;/p&gt;
&lt;p&gt;组件初始化分为两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Yii根据组件的配置信息实例化一个组件对象，即&lt;code&gt;$component=Yii::createComponent($config)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组件对象调用自己的方法&lt;code&gt;init&lt;/code&gt;完成一些初始化操作，即&lt;code&gt;$component-&amp;gt;init()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;初始化结束后，将组件对象存入属性_components中。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;静态方法&lt;code&gt;createComponent&lt;/code&gt;定义于类YiiBase中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Creates an object and initializes it based on the given configuration.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * The specified configuration can be either a string or an array.&lt;/span&gt;
&lt;span class="x"&gt; * If the former, the string is treated as the object type which can&lt;/span&gt;
&lt;span class="x"&gt; * be either the class name or {@link YiiBase::getPathOfAlias class path alias}.&lt;/span&gt;
&lt;span class="x"&gt; * If the latter, the &amp;#39;class&amp;#39; element is treated as the object type,&lt;/span&gt;
&lt;span class="x"&gt; * and the rest of the name-value pairs in the array are used to initialize&lt;/span&gt;
&lt;span class="x"&gt; * the corresponding object properties.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * Any additional parameters passed to this method will be&lt;/span&gt;
&lt;span class="x"&gt; * passed to the constructor of the object being created.&lt;/span&gt;
&lt;span class="x"&gt; *&lt;/span&gt;
&lt;span class="x"&gt; * @param mixed $config the configuration. It can be either a string or an array.&lt;/span&gt;
&lt;span class="x"&gt; * @return mixed the created object&lt;/span&gt;
&lt;span class="x"&gt; * @throws CException if the configuration does not have a &amp;#39;class&amp;#39; element.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public static function createComponent($config)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 如果传入的组件配置信息是字符串类型，则认为是对象类型&lt;/span&gt;
&lt;span class="x"&gt;    if(is_string($config))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $type=$config;&lt;/span&gt;
&lt;span class="x"&gt;        $config=array();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 如果是数组，则必须指定组件所对应的class&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($config[&amp;#39;class&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $type=$config[&amp;#39;class&amp;#39;];&lt;/span&gt;
&lt;span class="x"&gt;        unset($config[&amp;#39;class&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Object configuration must be an array containing a &amp;quot;class&amp;quot; element.&amp;#39;));&lt;/span&gt;

&lt;span class="x"&gt;    // 如果组件所对应的类型还没加载，则加载进来&lt;/span&gt;
&lt;span class="x"&gt;    if(!class_exists($type,false))&lt;/span&gt;
&lt;span class="x"&gt;        $type=Yii::import($type,true);&lt;/span&gt;

&lt;span class="x"&gt;    // 如果除了$config，还传递了其他参数，则根据额外的参数来实例化。对于组件初始化来说，不会走这个分支&lt;/span&gt;
&lt;span class="x"&gt;    if(($n=func_num_args())&amp;gt;1)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $args=func_get_args();&lt;/span&gt;
&lt;span class="x"&gt;        if($n===2)&lt;/span&gt;
&lt;span class="x"&gt;            $object=new $type($args[1]);&lt;/span&gt;
&lt;span class="x"&gt;        elseif($n===3)&lt;/span&gt;
&lt;span class="x"&gt;            $object=new $type($args[1],$args[2]);&lt;/span&gt;
&lt;span class="x"&gt;        elseif($n===4)&lt;/span&gt;
&lt;span class="x"&gt;            $object=new $type($args[1],$args[2],$args[3]);&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            unset($args[0]);&lt;/span&gt;
&lt;span class="x"&gt;            $class=new ReflectionClass($type);&lt;/span&gt;
&lt;span class="x"&gt;            // Note: ReflectionClass::newInstanceArgs() is available for PHP 5.1.3+&lt;/span&gt;
&lt;span class="x"&gt;            // $object=$class-&amp;gt;newInstanceArgs($args);&lt;/span&gt;
&lt;span class="x"&gt;            $object=call_user_func_array(array($class,&amp;#39;newInstance&amp;#39;),$args);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 没有额外的参数，则直接实例化组件&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $object=new $type;&lt;/span&gt;

&lt;span class="x"&gt;    // $config中除了class外的其他字段都作为组件对象的属性进行赋值&lt;/span&gt;
&lt;span class="x"&gt;    foreach($config as $key=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;        $object-&amp;gt;$key=$value;&lt;/span&gt;

&lt;span class="x"&gt;    return $object;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述代码可以看出，在配置组件时，如果是配置核心组件，可以不提供class字段，否则一定要提供。除了class字段，还可以为组件对象的属性赋值。按照PHP中对一个对象的属性进行赋值的规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果该对象有public的该属性，则直接赋值&lt;/li&gt;
&lt;li&gt;否则看该对象所在继承树上是否有定义魔术方法&lt;code&gt;__set&lt;/code&gt;，如果有则调用&lt;code&gt;__set&lt;/code&gt;来处理赋值过程&lt;/li&gt;
&lt;li&gt;如果连&lt;code&gt;__set&lt;/code&gt;也没有，则为该对象生成一个public的属性，然后赋值给它&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以将自定义组件类需要初始化赋值的属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义为public访问控制&lt;/li&gt;
&lt;li&gt;如果非public，则应该魔术方法&lt;code&gt;__set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;也可以不定义该属性（我觉得还是定义一下比较好，否则不好理解）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;在静态方法createComponent返回组件对象后，接着调用组件对象自身的init方法来完成一些初始化工具。这也就意味着自定义组件需要有init方法。&lt;/p&gt;
&lt;p&gt;从核心组件的定义可以看到，组件应该继承自抽象类&lt;code&gt;CApplicationComponent&lt;/code&gt;（见文件&lt;code&gt;yii/framework/base/CApplicationComponent.php&lt;/code&gt;）。该类定义了方法init和getIsInitialized。
自定义组件继承自&lt;code&gt;CApplicationComponent&lt;/code&gt;，若没有额外的初始化操作，也可以不再定义自己的init方法。如果定义自己的init方法，最好也间接调用一下父类的init方法（&lt;code&gt;parent::init()&lt;/code&gt;），
从而避免一些可能潜在的兼容问题。&lt;/p&gt;
&lt;p&gt;关于自定义组件的更多具体细节，可以参考&lt;a href="http://youngsterxyf.github.io/2014/09/06/socket.io-push-server/"&gt;基于socket.io的实时消息推送&lt;/a&gt;一文中的示例。&lt;/p&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>Yii源码阅读笔记 - 路由解析</title><link href="http://youngsterxyf.github.io/2014/11/12/read-yii-code-2/" rel="alternate"></link><updated>2014-11-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-12:2014/11/12/read-yii-code-2/</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架的路由解析功能由核心组件urlManager来完成。路由的形式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get：通过URL中查询字符串（query string）参数r来指定路由，如：&lt;code&gt;r=controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;path：直接通过URL来指定，如：&lt;code&gt;/controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认使用get路由形式。由于Yii中controller类命名和action方法都是按照规则命名的，而路由也是按照规则来匹配的，所以完全可以不用额外配置urlManager。&lt;/p&gt;
&lt;p&gt;若需要使用path方式，则可如下配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;quot;components&amp;quot; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;urlManager&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;urlFormat&amp;#39; =&amp;gt; &amp;#39;path&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;rules&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;            ...&lt;/span&gt;
&lt;span class="x"&gt;        ),&lt;/span&gt;
&lt;span class="x"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进一步说明可参考&lt;a href="http://youngsterxyf.github.io/2014/09/06/experience-about-restful-api/"&gt;RESTful API设计的一点经验&lt;/a&gt;一文。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;在“请求处理基本流程”一篇可以看到Yii框架路由解析流程的入口在类CWebApplication的processRequest方法中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;$route=$this-&amp;gt;getUrlManager()-&amp;gt;parseUrl($this-&amp;gt;getRequest());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中getUrlManager方法定义于类CApplication中，作用是初始化获取URL管理组件（ID为urlManager），实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function getUrlManager()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;getComponent(&amp;#39;urlManager&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在获取urlManager组件对象过程中，会对对象做初始化，调用对象的init方法，见类CUrlManager的init方法实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function init()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    parent::init();&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;processRules();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用的方法processRules，是根据配置的rules解析创建规则对象，放到属性_rules中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;protected function processRules()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 如果未配置rules，或使用的路由形式是get，则根本无需解析路由规则&lt;/span&gt;
&lt;span class="x"&gt;    if(empty($this-&amp;gt;rules) || $this-&amp;gt;getUrlFormat()===self::GET_FORMAT)&lt;/span&gt;
&lt;span class="x"&gt;        return;&lt;/span&gt;
&lt;span class="x"&gt;    // 否则尝试从缓存中读取解析好的路由规则&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;cacheID!==false &amp;amp;&amp;amp; ($cache=Yii::app()-&amp;gt;getComponent($this-&amp;gt;cacheID))!==null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $hash=md5(serialize($this-&amp;gt;rules));&lt;/span&gt;
&lt;span class="x"&gt;        if(($data=$cache-&amp;gt;get(self::CACHE_KEY))!==false &amp;amp;&amp;amp; isset($data[1]) &amp;amp;&amp;amp; $data[1]===$hash)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_rules=$data[0];&lt;/span&gt;
&lt;span class="x"&gt;            return;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 否则逐条路由规则解析&lt;/span&gt;
&lt;span class="x"&gt;    foreach($this-&amp;gt;rules as $pattern=&amp;gt;$route)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_rules[]=$this-&amp;gt;createUrlRule($route,$pattern);&lt;/span&gt;
&lt;span class="x"&gt;    // 尝试缓存解析好的路由规则&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($cache))&lt;/span&gt;
&lt;span class="x"&gt;        $cache-&amp;gt;set(self::CACHE_KEY,array($this-&amp;gt;_rules,$hash));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述代码中，在解析创建规则对象前会先检查是否已缓存了解析创建好的规则，如果没有，则在解析创建好规则后，将这些规则缓存起来。这样就避免了每次请求处理都要解析一次rules列表。
但这里需要注意的是&lt;strong&gt;urlManager组件默认使用ID为&lt;code&gt;cache&lt;/code&gt;的缓存组件（CUrlManager类的属性cacheID默认值为cache），而核心组件并不包含ID为&lt;code&gt;cache&lt;/code&gt;的缓存组件，所以若希望缓存解析好路由规则，
则应该配置ID为cache的缓存组件，如果缓存组件的ID不是cache，则需要配置urlManager组件的cacheID属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果没有设置缓存组件，或者缓存中未找到解析好的路由规则，则需要对配置的rules逐条解析，解析过程见类CUrlManager的createUrlRule方法实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Creates a URL rule instance.&lt;/span&gt;
&lt;span class="x"&gt; * The default implementation returns a CUrlRule object.&lt;/span&gt;
&lt;span class="x"&gt; * @param mixed $route the route part of the rule. This could be a string or an array&lt;/span&gt;
&lt;span class="x"&gt; * @param string $pattern the pattern part of the rule&lt;/span&gt;
&lt;span class="x"&gt; * @return CUrlRule the URL rule instance&lt;/span&gt;
&lt;span class="x"&gt; * @since 1.1.0&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function createUrlRule($route,$pattern)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 说明可以配置自定义的路由规则解析类&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($route) &amp;amp;&amp;amp; isset($route[&amp;#39;class&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;        return $route;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $urlRuleClass=Yii::import($this-&amp;gt;urlRuleClass,true);&lt;/span&gt;
&lt;span class="x"&gt;        return new $urlRuleClass($route,$pattern);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以以下rules配置为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;#39;rules&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;    array(&amp;#39;industry/index&amp;#39;, &amp;#39;pattern&amp;#39; =&amp;gt; &amp;#39;/v1/partner/industry/&amp;#39;, &amp;#39;verb&amp;#39; =&amp;gt; &amp;#39;GET&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;    array(&amp;#39;token/create&amp;#39;, &amp;#39;pattern&amp;#39; =&amp;gt; &amp;#39;/v1/partner/token&amp;#39;, &amp;#39;verb&amp;#39; =&amp;gt; &amp;#39;POST&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在处理第一条规则时，方法createUrlRule的参数$pattern的值为数组的索引0，$route的值为关联数组&lt;code&gt;array('industry/index', 'pattern' =&amp;gt; '/v1/partner/industry/', 'verb' =&amp;gt; 'GET')&lt;/code&gt;，
但因为$route里没有设置class字段，所以走的是else分支 - 先引入类CUrlRule（$this-&amp;gt;urlRuleClass的默认值），然后根据$route、$pattern实例化类CUrlRule，该类也定义在文件&lt;code&gt;yii/framework/web/CUrlManager.php&lt;/code&gt;中，
直接继承自抽象类CBaseUrlRule。CUrlRule的构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($route,$pattern)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($route))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 从这里可知$route支持&amp;#39;urlSuffix&amp;#39;, &amp;#39;caseSensitive&amp;#39;, &amp;#39;defaultParams&amp;#39;, &amp;#39;matchValue&amp;#39;, &amp;#39;verb&amp;#39;, &amp;#39;parsingOnly&amp;#39;这些配置项&lt;/span&gt;
&lt;span class="x"&gt;        foreach(array(&amp;#39;urlSuffix&amp;#39;, &amp;#39;caseSensitive&amp;#39;, &amp;#39;defaultParams&amp;#39;, &amp;#39;matchValue&amp;#39;, &amp;#39;verb&amp;#39;, &amp;#39;parsingOnly&amp;#39;) as $name)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(isset($route[$name]))&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;$name=$route[$name];&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 如果$route中有pattern配置项，则将配置值赋值给$pattern&lt;/span&gt;
&lt;span class="x"&gt;        if(isset($route[&amp;#39;pattern&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;            $pattern=$route[&amp;#39;pattern&amp;#39;];&lt;/span&gt;
&lt;span class="x"&gt;        // 而$route的第一个配置项才是真正的目标路由&lt;/span&gt;
&lt;span class="x"&gt;        $route=$route[0];&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;route=trim($route,&amp;#39;/&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;    $tr2[&amp;#39;/&amp;#39;]=$tr[&amp;#39;/&amp;#39;]=&amp;#39;\\/&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    if(strpos($route,&amp;#39;&amp;lt;&amp;#39;)!==false &amp;amp;&amp;amp; preg_match_all(&amp;#39;/&amp;lt;(\w+)&amp;gt;/&amp;#39;,$route,$matches2))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($matches2[1] as $name)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;references[$name]=&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    // 是否带协议头&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;hasHostInfo=!strncasecmp($pattern,&amp;#39;http://&amp;#39;,7) || !strncasecmp($pattern,&amp;#39;https://&amp;#39;,8);&lt;/span&gt;

&lt;span class="x"&gt;    // 如果原$route有verb配置项&lt;/span&gt;
&lt;span class="x"&gt;    // verb配置支持多个HTTP方法，以空格或逗号分隔，如：“GET,POST”&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;verb!==null)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;verb=preg_split(&amp;#39;/[\s,]+/&amp;#39;,strtoupper($this-&amp;gt;verb),-1,PREG_SPLIT_NO_EMPTY);&lt;/span&gt;

&lt;span class="x"&gt;    // $pattern中类正则片段支持两种形式：命名的和未命名的，如“&amp;lt;id:\d+&amp;gt;”和“&amp;lt;\d+&amp;gt;”&lt;/span&gt;
&lt;span class="x"&gt;    if(preg_match_all(&amp;#39;/&amp;lt;(\w+):?(.*?)?&amp;gt;/&amp;#39;,$pattern,$matches))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $tokens=array_combine($matches[1],$matches[2]);&lt;/span&gt;
&lt;span class="x"&gt;        foreach($tokens as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if($value===&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;                $value=&amp;#39;[^\/]+&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;            $tr[&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;]=&amp;quot;(?P&amp;lt;$name&amp;gt;$value)&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;            if(isset($this-&amp;gt;references[$name]))&lt;/span&gt;
&lt;span class="x"&gt;                $tr2[&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;]=$tr[&amp;quot;&amp;lt;$name&amp;gt;&amp;quot;];&lt;/span&gt;
&lt;span class="x"&gt;            else&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;params[$name]=$value;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 好吧，之后的这段代码我还没太看懂作用&lt;/span&gt;
&lt;span class="x"&gt;    // 就是为了将$pattern转换成一个真正的正则表达式？&lt;/span&gt;
&lt;span class="x"&gt;    $p=rtrim($pattern,&amp;#39;*&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;append=$p!==$pattern;&lt;/span&gt;
&lt;span class="x"&gt;    $p=trim($p,&amp;#39;/&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;template=preg_replace(&amp;#39;/&amp;lt;(\w+):?.*?&amp;gt;/&amp;#39;,&amp;#39;&amp;lt;$1&amp;gt;&amp;#39;,$p);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;pattern=&amp;#39;/^&amp;#39;.strtr($this-&amp;gt;template,$tr).&amp;#39;\/&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;append)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;pattern.=&amp;#39;/u&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;pattern.=&amp;#39;$/u&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    if($this-&amp;gt;references!==array())&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;routePattern=&amp;#39;/^&amp;#39;.strtr($this-&amp;gt;route,$tr2).&amp;#39;$/u&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    if(YII_DEBUG &amp;amp;&amp;amp; @preg_match($this-&amp;gt;pattern,&amp;#39;test&amp;#39;)===false)&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;The URL pattern &amp;quot;{pattern}&amp;quot; for route &amp;quot;{route}&amp;quot; is not a valid regular expression.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{route}&amp;#39;=&amp;gt;$route,&amp;#39;{pattern}&amp;#39;=&amp;gt;$pattern)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;在得到&lt;strong&gt;urlManager组件对象&lt;/strong&gt;后，调用其parseUrl方法，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function parseUrl($request)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;getUrlFormat()===self::PATH_FORMAT)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $rawPathInfo=$request-&amp;gt;getPathInfo();&lt;/span&gt;
&lt;span class="x"&gt;        $pathInfo=$this-&amp;gt;removeUrlSuffix($rawPathInfo,$this-&amp;gt;urlSuffix);&lt;/span&gt;
&lt;span class="x"&gt;        foreach($this-&amp;gt;_rules as $i=&amp;gt;$rule)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(is_array($rule))&lt;/span&gt;
&lt;span class="x"&gt;                $this-&amp;gt;_rules[$i]=$rule=Yii::createComponent($rule);&lt;/span&gt;
&lt;span class="x"&gt;            // 逐个路由规则匹配&lt;/span&gt;
&lt;span class="x"&gt;            if(($r=$rule-&amp;gt;parseUrl($this,$request,$pathInfo,$rawPathInfo))!==false)&lt;/span&gt;
&lt;span class="x"&gt;                // 即使匹配到了路由规则，也还是得看一下URL中是否指定了路由，是的话则优先使用URL中指定的路由&lt;/span&gt;
&lt;span class="x"&gt;                return isset($_GET[$this-&amp;gt;routeVar]) ? $_GET[$this-&amp;gt;routeVar] : $r;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        // 如果一定要匹配到某个路由规则才行，那么执行到这里就表示未有匹配的路由规则，所以就抛404错误了。&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;useStrictParsing)&lt;/span&gt;
&lt;span class="x"&gt;            throw new CHttpException(404,Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Unable to resolve the request &amp;quot;{route}&amp;quot;.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;                array(&amp;#39;{route}&amp;#39;=&amp;gt;$pathInfo)));&lt;/span&gt;
&lt;span class="x"&gt;        // 否则先返回请求路径作为目标路由&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            return $pathInfo;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    // 如果使用的是get路由形式，则从GET请求的查询字符串或POST请求的请求体找目标路由&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($_GET[$this-&amp;gt;routeVar]))&lt;/span&gt;
&lt;span class="x"&gt;        return $_GET[$this-&amp;gt;routeVar];&lt;/span&gt;
&lt;span class="x"&gt;    elseif(isset($_POST[$this-&amp;gt;routeVar]))&lt;/span&gt;
&lt;span class="x"&gt;        return $_POST[$this-&amp;gt;routeVar];&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return &amp;#39;&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法的参数是一个request组件对象。&lt;/p&gt;
&lt;p&gt;先判断应用使用的路由形式是否为path，如果不是，则根据路由的参数名（默认为&lt;code&gt;r&lt;/code&gt;，由于urlManager类的routeVar属性是public的，所以可以通过配置routeVar的值来修改路由参数名）获取路由。并且路由可以通过GET方法放在URL查询字符串中，也可以通过POST方法放在请求体中。&lt;/p&gt;
&lt;p&gt;对于path形式的路由，解析过程则要复杂一些。先通过request组件对象的getPathInfo方法取到请求的URL（会对原本的请求URL做一定的处理），然后根据解析好的路由规则列表逐个匹配。其中&lt;strong&gt;CUrlRule类&lt;/strong&gt;的parseUrl方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function parseUrl($manager,$request,$pathInfo,$rawPathInfo)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 先检查HTTP谓词（verb）是否匹配&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;verb!==null &amp;amp;&amp;amp; !in_array($request-&amp;gt;getRequestType(), $this-&amp;gt;verb, true))&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;    // 是否关心大小写&lt;/span&gt;
&lt;span class="x"&gt;    if($manager-&amp;gt;caseSensitive &amp;amp;&amp;amp; $this-&amp;gt;caseSensitive===null || $this-&amp;gt;caseSensitive)&lt;/span&gt;
&lt;span class="x"&gt;        $case=&amp;#39;&amp;#39;;&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $case=&amp;#39;i&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    // urlSiffix配置项是用来干嘛的？&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;urlSuffix!==null)&lt;/span&gt;
&lt;span class="x"&gt;        $pathInfo=$manager-&amp;gt;removeUrlSuffix($rawPathInfo,$this-&amp;gt;urlSuffix);&lt;/span&gt;

&lt;span class="x"&gt;    // URL suffix required, but not found in the requested URL&lt;/span&gt;
&lt;span class="x"&gt;    if($manager-&amp;gt;useStrictParsing &amp;amp;&amp;amp; $pathInfo===$rawPathInfo)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $urlSuffix=$this-&amp;gt;urlSuffix===null ? $manager-&amp;gt;urlSuffix : $this-&amp;gt;urlSuffix;&lt;/span&gt;
&lt;span class="x"&gt;        if($urlSuffix!=&amp;#39;&amp;#39; &amp;amp;&amp;amp; $urlSuffix!==&amp;#39;/&amp;#39;)&lt;/span&gt;
&lt;span class="x"&gt;            return false;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    if($this-&amp;gt;hasHostInfo)&lt;/span&gt;
&lt;span class="x"&gt;        $pathInfo=strtolower($request-&amp;gt;getHostInfo()).rtrim(&amp;#39;/&amp;#39;.$pathInfo,&amp;#39;/&amp;#39;);&lt;/span&gt;

&lt;span class="x"&gt;    $pathInfo.=&amp;#39;/&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    // 正则匹配：用pattern来匹配路径&lt;/span&gt;
&lt;span class="x"&gt;    if(preg_match($this-&amp;gt;pattern.$case,$pathInfo,$matches))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // 可以配置defaultParams数组来为请求未提供的必要参数指定默认值&lt;/span&gt;
&lt;span class="x"&gt;        foreach($this-&amp;gt;defaultParams as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(!isset($_GET[$name]))&lt;/span&gt;
&lt;span class="x"&gt;                $_REQUEST[$name]=$_GET[$name]=$value;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        $tr=array();&lt;/span&gt;
&lt;span class="x"&gt;        foreach($matches as $key=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if(isset($this-&amp;gt;references[$key]))&lt;/span&gt;
&lt;span class="x"&gt;                $tr[$this-&amp;gt;references[$key]]=$value;&lt;/span&gt;
&lt;span class="x"&gt;            elseif(isset($this-&amp;gt;params[$key]))&lt;/span&gt;
&lt;span class="x"&gt;                $_REQUEST[$key]=$_GET[$key]=$value;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;        if($pathInfo!==$matches[0]) // there&amp;#39;re additional GET params&lt;/span&gt;
&lt;span class="x"&gt;            $manager-&amp;gt;parsePathInfo(ltrim(substr($pathInfo,strlen($matches[0])),&amp;#39;/&amp;#39;));&lt;/span&gt;
&lt;span class="x"&gt;        if($this-&amp;gt;routePattern!==null)&lt;/span&gt;
&lt;span class="x"&gt;            return strtr($this-&amp;gt;route,$tr);&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            return $this-&amp;gt;route;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        return false;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上述代码可以看出，路由解析关键是根据$pattern匹配请求URL，并&lt;strong&gt;从URL取出需要的东西作为请求参数&lt;/strong&gt;，一旦匹配，就以$route作为该次请求的目标路由。&lt;/p&gt;
&lt;p&gt;获得目标路由后，就可以根据目标路由查找调用对应的controller和action了。&lt;/p&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>读文笔记：An Introduction to APIs</title><link href="http://youngsterxyf.github.io/2014/11/09/an-introduction-to-apis/" rel="alternate"></link><updated>2014-11-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-09:2014/11/09/an-introduction-to-apis/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://zapier.com/learn/apis/"&gt;An Introduction to APIs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：该文是入门级别的文章&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mind-mapping" src="/assets/uploads/pics/An-Introduction-to-APIs.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/An-Introduction-to-APIs.png"&gt;高清无码大图&lt;/a&gt;&lt;/p&gt;</summary><category term="笔记"></category><category term="API"></category><category term="REST"></category></entry><entry><title>Yii源码阅读笔记 - 请求处理基本流程</title><link href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/" rel="alternate"></link><updated>2014-11-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-11-04:2014/11/04/read-yii-code-1/</id><summary type="html">&lt;p&gt;对于Web框架，我认为其主要有三点作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供多人协作的基本规范&lt;/li&gt;
&lt;li&gt;避免重复造轮子&lt;/li&gt;
&lt;li&gt;开发者只需关注业务逻辑，脏活（如：基本的安全防范、兼容问题）Web框架都已完成并提供设计良好的API&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但代价是学习成本 - 为了尽可能发挥Web框架的优势，需要花一些阅读文档，甚至是框架源码（特别是文档缺乏或者文档写得垃圾的），然后经过几次项目实践，一切才能了然于胸。&lt;/p&gt;
&lt;p&gt;喏，为了在工作中更好地使用、避免误用Yii框架，大致阅读了Yii框架的部分代码，然后有了这个系列的笔记。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;深入学习一个Web框架，首先要理解的是请求处理流程。对于PHP而言，处理流程也即包含了应用的初始化过程，如加载配置、初始化组件等。请求处理流程中最核心的应该是路由解析和分发，此外可能还有过滤器处理、事件处理等，直到请求处理进入具体的Controller和Action。响应生成、过滤等也可以关注。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;基于Yii框架的工程目录结构大致如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Yii-Project-Structure" src="/assets/uploads/pics/yii-project-structure.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;index.php是应用的入口&lt;/li&gt;
&lt;li&gt;protected目录是存放动态脚本的地方&lt;ul&gt;
&lt;li&gt;components子目录存放各种组件类&lt;/li&gt;
&lt;li&gt;configs存放应用的配置文件&lt;/li&gt;
&lt;li&gt;controllers存放Controller类文件&lt;/li&gt;
&lt;li&gt;models存放Model类文件&lt;/li&gt;
&lt;li&gt;runtime存放一些应用生成的临时文件或者缓存文件，如Smarty编译好的模板、日志文件&lt;/li&gt;
&lt;li&gt;views存放View模板文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;static目录存放静态文件，如CSS、JS、图片等&lt;/li&gt;
&lt;li&gt;yii目录则存放Yii框架的源码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;index.php&lt;/code&gt;文件的内容大致如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nb"&gt;defined&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;APP_ENV&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;APP_ENV&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;development&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;APP_ENV&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;production&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;ini_set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;display_errors&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nb"&gt;error_reporting&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;E_ALL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;YII_ENABLE_ERROR_HANDLER&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nv"&gt;$yii&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;__FILE__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/yii/framework/yiilite.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;defined&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;error_reporting&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;E_ALL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nv"&gt;$yii&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;__FILE__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/yii/framework/yii.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;defined&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;YII_DEBUG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;YII_DEBUG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nb"&gt;defined&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;YII_TRACE_LEVEL&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;$config&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;__FILE__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/protected/configs/&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nx"&gt;APP_ENV&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;require_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$yii&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$YiiApp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Yii&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;createWebApplication&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$config&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$YiiApp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据应用所处的环境（开发环境或生产环境）配置不同的环境变量，加载不同的配置文件，然后根据配置信息创建一个Web应用对象（这个对象类似一个容器），并处理请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Yii::createWebApplication($config)&lt;/code&gt;中类Yii直接继承自类YiiBase，并且没有自定义属性和方法，即调用的静态方法createWebApplication来自类YiiBase，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public static function createWebApplication($config=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return self::createApplication(&amp;#39;CWebApplication&amp;#39;, $config);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之所以这么实现，是因为Yii还支持控制台/命令行类型的应用实现，比如cron脚本。&lt;/p&gt;
&lt;p&gt;静态方法createApplication实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public static function createApplication($class, $config=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return new $class($config);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;真正实例化的类CWebApplication见文件&lt;code&gt;yii/framework/web/CWebApplication.php&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类CWebApplication自己也没有实现构造方法，直接继承自抽象类CApplication（见文件&lt;code&gt;yii/framework/base/CApplication.php&lt;/code&gt;），其构造方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __construct($config=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    Yii::setApplication($this);&lt;/span&gt;

&lt;span class="x"&gt;    // set basePath at early as possible to avoid trouble&lt;/span&gt;
&lt;span class="x"&gt;    if(is_string($config))&lt;/span&gt;
&lt;span class="x"&gt;        $config=require($config);&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($config[&amp;#39;basePath&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;setBasePath($config[&amp;#39;basePath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;        unset($config[&amp;#39;basePath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;setBasePath(&amp;#39;protected&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    Yii::setPathOfAlias(&amp;#39;application&amp;#39;,$this-&amp;gt;getBasePath());&lt;/span&gt;
&lt;span class="x"&gt;    Yii::setPathOfAlias(&amp;#39;webroot&amp;#39;,dirname($_SERVER[&amp;#39;SCRIPT_FILENAME&amp;#39;]));&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($config[&amp;#39;extensionPath&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;setExtensionPath($config[&amp;#39;extensionPath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;        unset($config[&amp;#39;extensionPath&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        Yii::setPathOfAlias(&amp;#39;ext&amp;#39;,$this-&amp;gt;getBasePath().DIRECTORY_SEPARATOR.&amp;#39;extensions&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;    if(isset($config[&amp;#39;aliases&amp;#39;]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;setAliases($config[&amp;#39;aliases&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;        unset($config[&amp;#39;aliases&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;preinit();&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;initSystemHandlers();&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;registerCoreComponents();&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;configure($config);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors);&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;preloadComponents();&lt;/span&gt;

&lt;span class="x"&gt;    $this-&amp;gt;init();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;Yii::setApplication($this)&lt;/code&gt;将当前类CWebApplication的实例化对象赋值给类YiiBase的私有属性&lt;code&gt;$_app&lt;/code&gt;，之后通过&lt;code&gt;Yii::app()&lt;/code&gt;就能取到这个对象（app方法其实是类YiiBase中定义的）。&lt;/p&gt;
&lt;p&gt;构造方法根据配置信息初始化一些路径和别名相关的属性。以路径别名&lt;code&gt;application&lt;/code&gt;为例，如果想将日志目录配置为&lt;code&gt;protected/runtime&lt;/code&gt;，则可以指定路径为&lt;code&gt;application.runtime&lt;/code&gt;，这样的好处是你可以配置&lt;code&gt;basePath&lt;/code&gt;来指定动态脚本所在的目录，不一定必须是&lt;code&gt;protected&lt;/code&gt;，即使你的修改了basePath，其余相对basePath的路径配置都不需要变动。&lt;/p&gt;
&lt;p&gt;类CApplication又直接继承自类CModule（见文件&lt;code&gt;yii/framework/base/CModule.php&lt;/code&gt;），上述构造方法中调用的方法&lt;code&gt;preinit&lt;/code&gt;、&lt;code&gt;configure&lt;/code&gt;、&lt;code&gt;preloadComponents&lt;/code&gt;定义在类CModule中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;preinit&lt;/code&gt;的方法体为空。这个方法调用之后主要是加载核心组件、及将配置信息存到&lt;code&gt;Yii::app()&lt;/code&gt;这个容器对象中。如果需要在这些操作之前做一些初始化准备工作，则可以自定义一个类继承自类&lt;code&gt;CWebApplication&lt;/code&gt;，然后实现&lt;code&gt;preinit&lt;/code&gt;方法。但这样的话，index.php中创建web应用对象的方式就有所不同的了，假设自定义的类为&lt;code&gt;MyWebApplication&lt;/code&gt;，index.php中在引入该类文件后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;$yiiApp = Yii::createApplication(&amp;#39;MyWebApplication&amp;#39;, $config);&lt;/span&gt;
&lt;span class="x"&gt;$yiiApp-&amp;gt;run();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法&lt;code&gt;initSystemHandler&lt;/code&gt;则是根据条件设置框架的异常和错误处理方法。&lt;/p&gt;
&lt;p&gt;方法&lt;code&gt;registerCoreComponents&lt;/code&gt;则是加载框架的核心组件，当然如果有需要可以配置同名（同名指的是key相同，Yii中每个组件都是通过一个key或者说别名来注册和引用）的自定义组件来覆盖默认的核心组件，如db、urlManager。&lt;/p&gt;
&lt;p&gt;组件的注册加载细节我们会另外写一篇文章来介绍。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;方法&lt;code&gt;configure&lt;/code&gt;定义在类&lt;code&gt;CModule&lt;/code&gt;中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function configure($config)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($config))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($config as $key=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;$key=$value;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来是不是很简单？但其实没你想的那么简单呢... 思考一下如果代码中当前对象&lt;code&gt;$this&lt;/code&gt;不存在属性&lt;code&gt;$key&lt;/code&gt;或者名为&lt;code&gt;$key&lt;/code&gt;的属性是私有的会发生什么事情？这时PHP的魔术方法&lt;code&gt;__set&lt;/code&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;类&lt;code&gt;CModule&lt;/code&gt;直接继承自类&lt;code&gt;CComponent&lt;/code&gt;。在类CComponent中定义了方法&lt;code&gt;__set&lt;/code&gt;，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function __set($name,$value)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $setter=&amp;#39;set&amp;#39;.$name;&lt;/span&gt;
&lt;span class="x"&gt;    if(method_exists($this,$setter))&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;$setter($value);&lt;/span&gt;
&lt;span class="x"&gt;    elseif(strncasecmp($name,&amp;#39;on&amp;#39;,2)===0 &amp;amp;&amp;amp; method_exists($this,$name))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        // duplicating getEventHandlers() here for performance&lt;/span&gt;
&lt;span class="x"&gt;        $name=strtolower($name);&lt;/span&gt;
&lt;span class="x"&gt;        if(!isset($this-&amp;gt;_e[$name]))&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;_e[$name]=new CList;&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;_e[$name]-&amp;gt;add($value);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    elseif(is_array($this-&amp;gt;_m))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        foreach($this-&amp;gt;_m as $object)&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            if($object-&amp;gt;getEnabled() &amp;amp;&amp;amp; (property_exists($object,$name) || $object-&amp;gt;canSetProperty($name)))&lt;/span&gt;
&lt;span class="x"&gt;                return $object-&amp;gt;$name=$value;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    if(method_exists($this,&amp;#39;get&amp;#39;.$name))&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is read only.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CException(Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Property &amp;quot;{class}.{property}&amp;quot; is not defined.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{class}&amp;#39;=&amp;gt;get_class($this), &amp;#39;{property}&amp;#39;=&amp;gt;$name)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PHP中对一个对象的属性进行赋值的规则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果该对象有public的该属性，则直接赋值&lt;/li&gt;
&lt;li&gt;否则看该对象所在继承树上是否有定义魔术方法&lt;code&gt;__set&lt;/code&gt;，如果有则调用&lt;code&gt;__set&lt;/code&gt;来处理赋值过程&lt;/li&gt;
&lt;li&gt;如果连&lt;code&gt;__set&lt;/code&gt;也没有，则为该对象生成一个public的属性，然后赋值给它&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类CComponent中定义的魔术方法&lt;code&gt;__set&lt;/code&gt;其逻辑是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看当前对象是否有名为&lt;code&gt;'set'.$key&lt;/code&gt;的方法，如果有，则以该方法来处理赋值过程&lt;/li&gt;
&lt;li&gt;否则，检查$key是否以字符串&lt;code&gt;on&lt;/code&gt;开头，如果是且当前对象具有名为$key的方法，则认为这是一个事件的赋值过程，将赋值到事件列表中&lt;/li&gt;
&lt;li&gt;否则，则认为这是一个行为(behavior)赋值，尝试为属性&lt;code&gt;_m&lt;/code&gt;对象列表中对象的属性赋值。（貌似是这样，我也还懂&lt;code&gt;_m&lt;/code&gt;的作用）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上述规则逻辑，所以类CModule中定义了很多方法名以字符串&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;get&lt;/code&gt;开头的方法，如setComponents、getComponents、setParams、getParams等。说到这里，你是不是领会到什么了？&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;$this-&amp;gt;attachBehaviors($this-&amp;gt;behaviors)&lt;/code&gt;一句中当前对象的属性behaviors的访问权限为public，默认值为空数组，可以在配置文件中配置如下一项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;#39;behaviors&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;behaviorName&amp;#39;=&amp;gt;array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;path.to.BehaviorClass&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;property1&amp;#39;=&amp;gt;&amp;#39;value1&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;property2&amp;#39;=&amp;gt;&amp;#39;value2&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    )&lt;/span&gt;
&lt;span class="x"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;按照上述对象属性的赋值规则，该配置项会赋值给属性behaviors。&lt;/p&gt;
&lt;p&gt;方法attachBehaviors对这些配置项逐个初始化然后存入属性&lt;code&gt;_m&lt;/code&gt;中。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;方法&lt;code&gt;preloadComponents&lt;/code&gt;定义在类CModule中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Loads static application components.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;protected function preloadComponents()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    foreach($this-&amp;gt;preload as $id)&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;getComponent($id);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中属性preload访问权限为public，默认也是空数组，可以在其中配置需要预加载的组件的ID。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;$this-&amp;gt;init()&lt;/code&gt;一行中方法&lt;code&gt;init&lt;/code&gt;定义在类CWebApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;protected function init()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    parent::init();&lt;/span&gt;
&lt;span class="x"&gt;    // preload &amp;#39;request&amp;#39; so that it has chance to respond to onBeginRequest event.&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;getRequest();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中方法&lt;code&gt;getRequest&lt;/code&gt;就是预加载request组件。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;index.php中得到Web应用对象后继而调用其方法run，该run方法定义于类CApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Runs the application.&lt;/span&gt;
&lt;span class="x"&gt; * This method loads static application components. Derived classes usually overrides this&lt;/span&gt;
&lt;span class="x"&gt; * method to do more application-specific tasks.&lt;/span&gt;
&lt;span class="x"&gt; * Remember to call the parent implementation so that static application components are loaded.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function run()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;hasEventHandler(&amp;#39;onBeginRequest&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;onBeginRequest(new CEvent($this));&lt;/span&gt;
&lt;span class="x"&gt;    // 这里为了处理程序主动调用exit()或者抛出异常时的情况&lt;/span&gt;
&lt;span class="x"&gt;    register_shutdown_function(array($this,&amp;#39;end&amp;#39;),0,false);&lt;/span&gt;
&lt;span class="x"&gt;    // 请求处理&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;processRequest();&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;hasEventHandler(&amp;#39;onEndRequest&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;onEndRequest(new CEvent($this));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中方法processRequest定义于类CWebApplication中，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function processRequest()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    // 可以在配置文件里配置request组件时，提供catchAllRequest参数&lt;/span&gt;
&lt;span class="x"&gt;    // catchAllRequest是一个数组，第一个元素指定一个controller及一个action，其余元素是这个action的参数&lt;/span&gt;
&lt;span class="x"&gt;    // 如果配置了catchAllRequest，就可以用这个controller/action来处理所有的请求，当网站进入维护状态时，有其用处。&lt;/span&gt;
&lt;span class="x"&gt;    if(is_array($this-&amp;gt;catchAllRequest) &amp;amp;&amp;amp; isset($this-&amp;gt;catchAllRequest[0]))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $route=$this-&amp;gt;catchAllRequest[0];&lt;/span&gt;
&lt;span class="x"&gt;        foreach(array_splice($this-&amp;gt;catchAllRequest,1) as $name=&amp;gt;$value)&lt;/span&gt;
&lt;span class="x"&gt;            $_GET[$name]=$value;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        // 正常的路由解析&lt;/span&gt;
&lt;span class="x"&gt;        // 组件urlManager -&amp;gt;parseUrl 组件request&lt;/span&gt;
&lt;span class="x"&gt;        $route=$this-&amp;gt;getUrlManager()-&amp;gt;parseUrl($this-&amp;gt;getRequest());&lt;/span&gt;
&lt;span class="x"&gt;    // 根据路由执行控制器处理函数&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;runController($route);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中路由解析的过程我们也会以单独的一篇文章来分析，暂不细说。&lt;/p&gt;
&lt;p&gt;方法runController的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;/**&lt;/span&gt;
&lt;span class="x"&gt; * Creates the controller and performs the specified action.&lt;/span&gt;
&lt;span class="x"&gt; * @param string $route the route of the current request. See {@link createController} for more details.&lt;/span&gt;
&lt;span class="x"&gt; * @throws CHttpException if the controller could not be created.&lt;/span&gt;
&lt;span class="x"&gt; */&lt;/span&gt;
&lt;span class="x"&gt;public function runController($route)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(($ca=$this-&amp;gt;createController($route))!==null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        list($controller,$actionID)=$ca;&lt;/span&gt;
&lt;span class="x"&gt;        $oldController=$this-&amp;gt;_controller;&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_controller=$controller;&lt;/span&gt;
&lt;span class="x"&gt;        $controller-&amp;gt;init();&lt;/span&gt;
&lt;span class="x"&gt;        $controller-&amp;gt;run($actionID);&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_controller=$oldController;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        throw new CHttpException(404,Yii::t(&amp;#39;yii&amp;#39;,&amp;#39;Unable to resolve the request &amp;quot;{route}&amp;quot;.&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;{route}&amp;#39;=&amp;gt;$route===&amp;#39;&amp;#39;?$this-&amp;gt;defaultController:$route)));&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中方法createController根据$route按照一定的规则找到对应的controller类，之后调用controller的init方法和run方法。但这个调用之前和之后还恢复老的controller，这应该是因为在一个controller中可以forward到另一个controller中去，也即controller可以递归执行，所以需要保存和恢复上下文。&lt;/p&gt;
&lt;p&gt;Yii中所有Controller类都必须直接或间接继承自类CController，该类的init方法实现为空，如有需要可以在子类中重写。而其run方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function run($actionID)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(($action=$this-&amp;gt;createAction($actionID))!==null)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if(($parent=$this-&amp;gt;getModule())===null)&lt;/span&gt;
&lt;span class="x"&gt;            $parent=Yii::app();&lt;/span&gt;
&lt;span class="x"&gt;        if($parent-&amp;gt;beforeControllerAction($this,$action))&lt;/span&gt;
&lt;span class="x"&gt;        {&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;runActionWithFilters($action,$this-&amp;gt;filters());&lt;/span&gt;
&lt;span class="x"&gt;            $parent-&amp;gt;afterControllerAction($this,$action);&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;missingAction($actionID);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;$this-&amp;gt;runActionWithFilters($action,$this-&amp;gt;filters())&lt;/code&gt;一行中，方法filters的实现仅是返回一个空数组，如果想要使用过滤器就需要在自定义的Controller类中重写该方法，过滤器的配置方法见源码中注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;* For a method-based filter (called inline filter), it is specified as &amp;#39;FilterName[ +|- Action1, Action2, ...]&amp;#39;,
 * where the &amp;#39;+&amp;#39; (&amp;#39;-&amp;#39;) operators describe which actions should be (should not be) applied with the filter.
 *
 * For a class-based filter, it is specified as an array like the following:
 * &amp;lt;pre&amp;gt;
 * array(
 *     &amp;#39;FilterClass[ +|- Action1, Action2, ...]&amp;#39;,
 *     &amp;#39;name1&amp;#39;=&amp;gt;&amp;#39;value1&amp;#39;,
 *     &amp;#39;name2&amp;#39;=&amp;gt;&amp;#39;value2&amp;#39;,
 *     ...
 * )
 * &amp;lt;/pre&amp;gt;
 * where the name-value pairs will be used to initialize the properties of the filter.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法runActionWithFilters实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function runActionWithFilters($action,$filters)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if(empty($filters))&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;runAction($action);&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $priorAction=$this-&amp;gt;_action;&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_action=$action;&lt;/span&gt;
&lt;span class="x"&gt;        CFilterChain::create($this,$action,$filters)-&amp;gt;run();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;_action=$priorAction;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果没有设置过滤器，则直接执行目标action，方法runAction的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function runAction($action)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $priorAction=$this-&amp;gt;_action;&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_action=$action;&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;beforeAction($action))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        if($action-&amp;gt;runWithParams($this-&amp;gt;getActionParams())===false)&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;invalidActionParams($action);&lt;/span&gt;
&lt;span class="x"&gt;        else&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;afterAction($action);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;_action=$priorAction;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类CController中定义的beforeAction直接返回true，如果需要在目标action执行之前做一些检查过滤操作则需要在自定义的Controller类中重写beforeAction方法，该方法最后必须返回true或false。beforeAction的作用类似于简化版的过滤器。&lt;/p&gt;
&lt;p&gt;beforeAction通过后，则执行目标action。由于路由配置是类正则的，URL解析出来的一些片段值（算是放在url中的请求参数）应该传入目标action，方法getActionParams即是取到这些参数值。Yii在路由解析时将这些参数值也存放到全局变量&lt;code&gt;$_GET&lt;/code&gt;中，所以getActionParams直接返回了&lt;code&gt;$_GET&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果设置了过滤器，则需要根据controller、action、filters创建一个CFilterChain对象（过程中当然会对过滤器配置进行解析），类CFilterChain的run方法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function run()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    if($this-&amp;gt;offsetExists($this-&amp;gt;filterIndex))&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $filter=$this-&amp;gt;itemAt($this-&amp;gt;filterIndex++);&lt;/span&gt;
&lt;span class="x"&gt;        Yii::trace(&amp;#39;Running filter &amp;#39;.($filter instanceof CInlineFilter ? get_class($this-&amp;gt;controller).&amp;#39;.filter&amp;#39;.$filter-&amp;gt;name.&amp;#39;()&amp;#39;:get_class($filter).&amp;#39;.filter()&amp;#39;),&amp;#39;system.web.filters.CFilterChain&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        $filter-&amp;gt;filter($this);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    else&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;controller-&amp;gt;runAction($this-&amp;gt;action);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;$this-&amp;gt;filterIndex&lt;/code&gt;的初始值为0，方法offsetExits定义于类CList中，逻辑就是检测是否遍历执行完所有的过滤器，如果还有，则取出一个过滤器对象，执行其filter方法，该方法的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public function filter($filterChain)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $method=&amp;#39;filter&amp;#39;.$this-&amp;gt;name;&lt;/span&gt;
&lt;span class="x"&gt;    $filterChain-&amp;gt;controller-&amp;gt;$method($filterChain);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个时候你应该感到疑惑 - 既然是一个过滤器链，那么循环在哪？事实上，Yii的这个地方并没有提供循环来让过滤器逐个执行，这就意味着在自定义的过滤器中，如果过滤条件通过，则需要尾递归地显式调用过滤器链的run方法，这样直到所有的过滤器都通过，才执行目标action&lt;code&gt;$this-&amp;gt;controller-&amp;gt;runAction($this-&amp;gt;action)&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;2014-12-18 补充：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类YiiBase的方法createApplication：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;public static function createApplication($class, $config=null)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    return new $class($config);&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是如何找到&lt;code&gt;$class&lt;/code&gt;代表的类（CWebApplication或CConsoleApplication类）的呢？类文件&lt;code&gt;yii/framework/YiiBase.php&lt;/code&gt;的倒数第二行代码为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spl_autoload_register(array('YiiBase','autoload'));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当类文件&lt;code&gt;yii/framework/yii.php&lt;/code&gt;中 &lt;strong&gt;require&lt;/strong&gt; YiiBase类文件时就执行了这句代码。&lt;/p&gt;</summary><category term="PHP"></category><category term="Yii"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>QCon上海2014大会见闻录</title><link href="http://youngsterxyf.github.io/2014/10/21/qcon-sh-2014-seen-heard/" rel="alternate"></link><updated>2014-10-21T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-10-21:2014/10/21/qcon-sh-2014-seen-heard/</id><summary type="html">&lt;h2&gt;技术&lt;/h2&gt;
&lt;h4&gt;主题演讲&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;软件项目变更的管理和生存之道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人对这个演讲的印象比较深。演讲者即是最近比较火的《Java程序员修炼之道》一书的作者。&lt;/p&gt;
&lt;p&gt;演讲大致以“提出问题 -&amp;gt; 分析问题 -&amp;gt; 解决问题”的思路陈述。&lt;/p&gt;
&lt;p&gt;问题是：在软件演化的整个过程中，变化是始终存在的。如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础架构层面的变化：迁移到新的服务提供商、系统升级&lt;/li&gt;
&lt;li&gt;用户数的变化：突然的增长、持续稳定地增长&lt;/li&gt;
&lt;li&gt;代码的变更：发布新版本、依赖库升级、新的子系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些变化可能会导致两个问题的发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务中断：完全无法为用户提供服务，特别是生产环境变更导致的，发布后的服务中断&lt;/li&gt;
&lt;li&gt;性能问题：性能退化/降级，但可能也不是完全不可用，在预览版(pre-release)和正式发布后(post-release)都可能发生，经常是因为不完全的性能测试造成的。(性能测试是指&lt;strong&gt;基于测量的方法&lt;/strong&gt;来理解一定负载下应用的行为)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“变化”导致的问题，说到底是人为造成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No matter what they tell you, it's always a people problem.    --- Gerald Weinberg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应对“变化”所带来的问题，需要实现以下几个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低变化的风险&lt;/li&gt;
&lt;li&gt;提升可靠性：减小服务中断的损失&lt;/li&gt;
&lt;li&gt;提高可维护性：减小整个平台的耗费&lt;/li&gt;
&lt;li&gt;可量化的影响：最好可以以节省了多少钱来衡量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“服务中断”、“性能问题”发生的原因通常有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;误解了生产环境&lt;ul&gt;
&lt;li&gt;UAT is My Desktop：“User Acceptance Test”的简写，也就是用户验收测试&lt;/li&gt;
&lt;li&gt;PROD-like Data is Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置问题&lt;/li&gt;
&lt;li&gt;不恰当的焦点&lt;ul&gt;
&lt;li&gt;Blame Donkey (all the blame and problems of a situation are being placed upon a single person)&lt;/li&gt;
&lt;li&gt;微观分析 (Micro-analysis)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;孤岛思维 (Silo Mentality)：即团队成员通常仅仅关注各自的职能部门或业务单元。如此有限的关注，阻碍了组织的个别部门对整体运营卓越性的促进作用。&lt;ul&gt;
&lt;li&gt;Throw It Over The Wall&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对“不恰当的焦点”，需理解，性能调优不是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小提示和技巧的集合&lt;/li&gt;
&lt;li&gt;秘密武器&lt;/li&gt;
&lt;li&gt;在项目的末期你洒下的魔法粉尘&lt;/li&gt;
&lt;li&gt;“英雄豪杰”才能干的事情&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要把问题的原因始终归于某些组件。如果轻易就Blame Donkey只能说明对问题的分析不够充分。&lt;strong&gt;应顶住压力不忙于下结论，分析分析再分析，并与相关人沟通分析的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要把精力聚焦在系统非常低的层面(very low-level aspects)上，微观变化(micro-changes)的整体影响是不可知的，实际上可能还会降低系统的性能。
不要做微观分析，除非你的项目是一个已知对此微观分析有效的案例(a known use case for it)，如构建一个通用的库或框架，理解其中的权衡；使用已有的工具来做分析，不要构建你自己的分析工具，使用广泛地与他人讨论你的分析结果。&lt;/p&gt;
&lt;p&gt;总而言之，就是测量啊测量，profiling啊profiling。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The first principle is that you must not fool yourself, and you are the easiest person to fool. -- Richard Feynman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧，上边这些只是在解释问题是什么，然后分析了一下问题，那么如何有效地解决问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解架构！！！&lt;ul&gt;
&lt;li&gt;能凭记忆画出整个应用的架构吗？ 组件关系图、时序图、数据流图 ...&lt;/li&gt;
&lt;li&gt;部署：知道应用是如何跨机器/虚拟机分布的吗？&lt;/li&gt;
&lt;li&gt;如果架构都没理解，服务中断了还搞个屁啊&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以数据说话&lt;ul&gt;
&lt;li&gt;收集监控数据：应该作为一个正式的流程存在，而不是得到出问题才去临时收集。监控数据也应该集中化收集保存&lt;/li&gt;
&lt;li&gt;分析数据：这一环节经常缺失；数据分析解释的技能非常罕见；如果可能就用工具来自动生成报表&lt;/li&gt;
&lt;li&gt;确保所有团队都能看到分析报表：团队之间的沟通是必不可少的&lt;/li&gt;
&lt;li&gt;理解正常的系统功能是啥样的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测量与分析&lt;ul&gt;
&lt;li&gt;对抗认知偏见最好的工具就是数据&lt;/li&gt;
&lt;li&gt;打日志、以及监控：但更需要分析，数据量可能非常大，问题的模式并非总能肉眼就能识别&lt;/li&gt;
&lt;li&gt;常规的/适当的收集过程是必要的，临时抱佛脚肯定不行&lt;/li&gt;
&lt;li&gt;确保日志充分：啥叫充分？能够追溯导致服务中断的所有步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于性能，还想说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有完美的性能，只有可接受的性能（尼玛就不要没完没了地优化了）&lt;/li&gt;
&lt;li&gt;是最终用户决定性能需求&lt;/li&gt;
&lt;li&gt;性能不是功能性的需求：但必须有可观测的量化目标，也需要和系统相关人共同来设定&lt;/li&gt;
&lt;li&gt;性能测试一个迭代的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，实际操作的过程也得讲究科学的方法啊...&lt;/p&gt;
&lt;p&gt;演讲的PPT：&lt;a href="/assets/uploads/files/Managing-and-Surviving-Change.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Building a strong engineering culture&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：Kevin Goldsmith，Spotify公司的技术主管(Director of Engineering)&lt;/p&gt;
&lt;p&gt;1 . 什么是文化？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A pattern of &lt;strong&gt;shared basic assumptions&lt;/strong&gt; that a group has learned as it solved its problems of external adaptation and internal integration, that has worked well enough to be considered valid and therefore, to be taught to new members as the correct way to perceive, think, and feel in relation to those problems.   -- Edgar Schein &lt;a href="http://baike.baidu.com/view/1177302.htm"&gt;百度百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;演讲者提出的理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Culture is &lt;strong&gt;the manifestation of the shared values&lt;/strong&gt; of the organization as &lt;strong&gt;represented by the actions&lt;/strong&gt; of its members.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Values -&amp;gt; Culture -&amp;gt; Processes(流程) + Artifacts(人工制品，如Logo、T恤等) + Rituals(仪式，礼仪) + Beliefs(信仰、新年)&lt;/p&gt;
&lt;p&gt;Spotify公司的一些价值观(Values)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Learn from failure&lt;/li&gt;
&lt;li&gt;Innovation at every level&lt;/li&gt;
&lt;li&gt;Iterative development&lt;/li&gt;
&lt;li&gt;Agile-ﬁrst&lt;/li&gt;
&lt;li&gt;Data-driven&lt;/li&gt;
&lt;li&gt;Autonomous Teams&lt;/li&gt;
&lt;li&gt;Continuous improvement&lt;/li&gt;
&lt;li&gt;Shared Responsibility&lt;/li&gt;
&lt;li&gt;Transparency&lt;/li&gt;
&lt;li&gt;Trust&lt;/li&gt;
&lt;li&gt;Servant Leadership&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2 . 为什么文化很重要？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Apply the same level of deep thinking about building a culture as you would about building a product. -- Tim O'Reilly, O’Reilly Media&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3 . 优秀工程[师]文化(engineering culture)的构成是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stuﬀ gets done&lt;/li&gt;
&lt;li&gt;It gets done well&lt;/li&gt;
&lt;li&gt;People are happy&lt;/li&gt;
&lt;li&gt;Leaders provide direction and guidance and GET OUT OF THE WAY&lt;/li&gt;
&lt;li&gt;Success is celebrated&lt;/li&gt;
&lt;li&gt;Failure is used as a way to learn&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 . 保护文化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Walk the talk&lt;/li&gt;
&lt;li&gt;Hiring is crucial&lt;/li&gt;
&lt;li&gt;Firing is also crucial&lt;/li&gt;
&lt;li&gt;Communicate your values&lt;/li&gt;
&lt;li&gt;Measure against your values&lt;/li&gt;
&lt;li&gt;Your organization reﬂects your values&lt;/li&gt;
&lt;li&gt;Watch out for warning signs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5 . 修复破败的文化&lt;/p&gt;
&lt;p&gt;如何知道文化在破败？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;People don’t care&lt;/li&gt;
&lt;li&gt;(Good) People are leaving&lt;/li&gt;
&lt;li&gt;You spend time on the wrong things instead of building your product&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何修复？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start with yourself&lt;/li&gt;
&lt;li&gt;Then your team&lt;/li&gt;
&lt;li&gt;Build on successes&lt;/li&gt;
&lt;li&gt;Recruit others&lt;/li&gt;
&lt;li&gt;Grow bottom up&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6 . 总结&lt;/p&gt;
&lt;p&gt;You have a culture, Whether you think you do or not&lt;/p&gt;
&lt;p&gt;Work on your culture, It will determine how things get (or don’t get) done&lt;/p&gt;
&lt;p&gt;If you have a good culture, protect it, Make sure everyone understands what you value as a team. Make sure everyone you hire will be happy in your culture.&lt;/p&gt;
&lt;p&gt;If you have a bad culture, transform it, A long process, start small and grow. Don’t try to rush it.&lt;/p&gt;
&lt;p&gt;You are the culture, The culture is the intersection (average) of the values of the people in it. Want to improve your culture? LIVE THE VALUES&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;还有另外两个主题演讲“The Containerised Cloud”（集装箱式/容器化的云，看题目也能猜出是介绍Docker的）和“SDN控制器集群中的分布式技术实践”貌似也不错，可惜鄙人对于Docker和SDN都没什么实践经验，不甚了解，也就不多写了。&lt;/p&gt;
&lt;h4&gt;移动与Web&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Blend - 完美地融合WebApp与Native app&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人是来自百度的雷志兴(berg)&lt;/p&gt;
&lt;p&gt;对于做Web开发，觉得原生移动App学与做都比较有难度的人来说，这种主题是比较有吸引力的。&lt;/p&gt;
&lt;p&gt;当然，难度不是主要原因，原因在于混合式开发移动应用的优点，同时具备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web的灵活性，如：应用可随时发布更新，无需用户下载更新新版本&lt;/li&gt;
&lt;li&gt;原生移动应用(Native App)良好的体验，包括：交互与性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从而达到Web应用和原生移动应用的优势互补。&lt;/p&gt;
&lt;p&gt;&lt;img alt="native-vs-web" src="/assets/uploads/pics/native-vs-web.png" /&gt;&lt;/p&gt;
&lt;p&gt;那么如何完美融合，以Web技术开发类原生移动应用呢？百度的同学提出Blend技术方案。&lt;/p&gt;
&lt;p&gt;Blend是一套灵活、低耦的组件库、API及运行环境。Blend将常用或核心组件Native化， 转场、动画、重点组件由Native完成，Native代码针对关键问题，代码规模小，可控；提出“Every element can be a webview”，单个webview变⼩小，局部性能可控。&lt;/p&gt;
&lt;p&gt;具体技术细节见如下PPT截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blend-technique-overview-1" src="/assets/uploads/pics/blend-technique-overview-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blend-technique-overview-2" src="/assets/uploads/pics/blend-technique-overview-2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blend-technique-overview-3" src="/assets/uploads/pics/blend-technique-overview-3.png" /&gt;&lt;/p&gt;
&lt;p&gt;进一步的信息可访问Blend官网：&lt;a href="http://clouda.com/"&gt;Clouda.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好吧，其实我没有移动开发的经验，所以对这一块的技术也不太懂，待学习。&lt;/p&gt;
&lt;p&gt;演讲的PPT：&lt;a href="/assets/uploads/files/Blend-hybrid-app.pdf"&gt;见这里&lt;/a&gt; （嗯，PPT很漂亮！）&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;手机 QQ Hybrid App 优化新思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人是来自腾讯 AlloyTeam 的陈桂鸿&lt;/p&gt;
&lt;p&gt;这个演讲的内容和上面百度同学的类似，同一个技术方向。&lt;/p&gt;
&lt;p&gt;AK (AlloyKit) - 高性能 Hybrid Web 开发框架&lt;/p&gt;
&lt;p&gt;AK 架构体系&lt;/p&gt;
&lt;p&gt;&lt;img alt="ak-arch" src="/assets/uploads/pics/ak-arch.png" /&gt;&lt;/p&gt;
&lt;p&gt;演讲的PPT：&lt;a href="/assets/uploads/files/AK-hybrid-app.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;貌似AK还没开源？&lt;/p&gt;
&lt;p&gt;AlloyTeam博客：&lt;a href="http://www.alloyteam.com/"&gt;见这里&lt;/a&gt;，Github：&lt;a href="https://github.com/AlloyTeam"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;前后端分离实践&lt;/strong&gt; 与 &lt;strong&gt;另一个角度看前后端分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这两个演讲的内容基本一致，题目更具体点就是“基于Node.js的前后端分离”。演讲人都来自阿里，一个淘宝，一个天猫。&lt;/p&gt;
&lt;p&gt;涉及的技术问题用一张图大致就能说明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nodejs-split-frontend-backend" src="/assets/uploads/pics/split-frontend-backend.png" /&gt;&lt;/p&gt;
&lt;p&gt;这种分离方案所要解决的问题是什么呢？&lt;/p&gt;
&lt;p&gt;我们通常将“编写运行在浏览器中的代码”的工程师称为Web前端工程师，“编写运行在服务器上的代码”的工程师称为Web后端工程师，这是一种“物理的”区分方法。&lt;/p&gt;
&lt;p&gt;在这种区分方法下，目前的Web后端开发基本都是采用MVC框架，那么前后端工程师的工作在View层就有耦合 - 前端工程师编写HTML页面模板，后端工程师负责往模板中注入数据进行渲染展示。这种耦合一方面导致需要更多的时间用于协调沟通，另一方面前端也无法尽可能灵活地优化。&lt;/p&gt;
&lt;p&gt;这种耦合在前端也引入MVC框架（如AngularJS、Backbone、EmberJS）后得到解决，但也引入了新的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;SEO问题&lt;/li&gt;
&lt;li&gt;代码重用问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后就有了上图的方案。前端工程师们振臂呐喊 - 我们不要局限于浏览器！后端工程师们，后端MVC的View、Controller、以及部分Model层的开发都由前端工程师来完成吧，你们就负责部分Model层、负责提供数据就行啦！我们有NodeJS神器！我们不再是前端工程师，我们是全栈工程师！&lt;/p&gt;
&lt;p&gt;但这种方案就没问题了么？个人认为至少存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种工程方案的推广的难度有多大？有多少前端工程师熟悉后端开发中的问题？后端开发并不是简单地换个地方写JS代码。&lt;/li&gt;
&lt;li&gt;这种工程方案必须依赖于NodeJS。任何技术都不是银弹，也不会恒久长存。个人认为如果一种工程解决方案必须依赖于某种具体的技术、甚至一门语言，那就不值得推广。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合权衡来看，这种工程方案仅在一定的条件（不缺牛逼的全栈工程师、确实需要将前端性能做到极致）下才有采用的必要。&lt;/p&gt;
&lt;p&gt;相比这种前后端分离方案，我更赞同演讲中提出的“基于JSON + HTTP接口的版本化管理”，让接口的一切变更都可追溯，这个想法是值得思考和实践的。&lt;/p&gt;
&lt;p&gt;演讲PPT：&lt;a href="/assets/uploads/files/刘磊-前后端分离实践.pdf"&gt;前后端分离实践&lt;/a&gt;，&lt;a href="/assets/uploads/files/另一个角度看前后端分离.pdf"&gt;另一个角度看前后端分离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/lifesinger/lifesinger.github.com/issues/184"&gt;Web 研发模式演变&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html"&gt;BigPipe学习研究&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;乐逗游戏发行平台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：余中强&lt;/p&gt;
&lt;p&gt;这个演讲的干货很多，值得一看。&lt;/p&gt;
&lt;p&gt;其中提到的“定位问题-建设云监控系统”和“API监控系统”是我在做或想做的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-cloud-monitor" src="/assets/uploads/pics/ledou-cloud-monitor.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-api-monitor" src="/assets/uploads/pics/ledou-api-monitor.png" /&gt;&lt;/p&gt;
&lt;p&gt;整个系统的演化经历了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;萌芽期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage1" src="/assets/uploads/pics/ledou-arch-stage1.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发展期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发展期的第1阶段只是添加缓存、负载均衡集群化：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage2" src="/assets/uploads/pics/ledou-arch-stage2.png" /&gt;&lt;/p&gt;
&lt;p&gt;发展期的第2阶段则是根据业务垂直化切分系统、水平拆分数据表等：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage2-ext" src="/assets/uploads/pics/ledou-arch-stage2-ext.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;壮大期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ledou-arch-stage3" src="/assets/uploads/pics/ledou-arch-stage3.png" /&gt;&lt;/p&gt;
&lt;p&gt;在系统演化过程中也得到了如下经验：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-optimize-lessons" src="/assets/uploads/pics/ledou-optimize-lessons.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ledou-design-lessons" src="/assets/uploads/pics/ledou-design-lessons.png" /&gt;&lt;/p&gt;
&lt;p&gt;演讲PPT：&lt;a href="/assets/uploads/files/余中强-乐逗手游发行技术平台.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;跨平台移动应用的自动化验收测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：平安科技 柴锋、高云&lt;/p&gt;
&lt;p&gt;内容主要是基于Cucumber实现的一个自动化测试工具&lt;/p&gt;
&lt;p&gt;Cucumber官网：&lt;a href="http://cukes.info/"&gt;http://cukes.info&lt;/a&gt;，推广“行为驱动的开发”（behaviour driven development - BDD），貌似挺有意思。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;大数据&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;eBay用户行为数据流实时处理系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：eBay 汪兴朗&lt;/p&gt;
&lt;p&gt;用户行为数据流是指用户在系统/网站的操作，以及操作之间的前后关系。这些数据经过过滤噪音抽取后可以用于用户行为分析、个性化推荐等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ebay-jetstream-arch" src="/assets/uploads/pics/ebay-jetstream-arch.png" /&gt;&lt;/p&gt;
&lt;p&gt;图中Jetstream是eBay自研的一个系统，貌似年内会开源，可以关注一下。&lt;/p&gt;
&lt;p&gt;系统处理好的metrics数据存储在TSDB（OpenTSDB？）中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ebay-jetstream-key-tech" src="/assets/uploads/pics/ebay-jetstream-key-tech.png" /&gt;&lt;/p&gt;
&lt;p&gt;演讲PPT：&lt;a href="/assets/uploads/files/汪兴郎-eBay用户行为数据流实时处理系统.pdf"&gt;见这里&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;互联网常用场景下的大数据架构解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：MediaV 聚效CTO 胡宁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一切不以具体应用为前提谈大数据都是耍流氓！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;精准的网络广告和个人化推荐（如网购）的原理是一样的。通过这页PPT看看“精准”“个性化”需要考虑的哪些问题：&lt;/p&gt;
&lt;p&gt;&lt;img alt="for-precise-advertisement" src="/assets/uploads/pics/for-precise-advertisement.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;京东基于大数据技术的个性化电商搜索引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人： 京东 刘尚堃&lt;/p&gt;
&lt;p&gt;1 . 为什么需要个性化搜索&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助用户从海量商品中快速找到商品&lt;/li&gt;
&lt;li&gt;满足不同用户的检索诉求&lt;/li&gt;
&lt;li&gt;提升搜索的惊喜性&lt;/li&gt;
&lt;li&gt;帮助京东提升长尾商品的曝光&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2 . 京东个性化搜索考虑的因素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行为&lt;/li&gt;
&lt;li&gt;偏好&lt;ul&gt;
&lt;li&gt;用户画像：兴趣、类目、产品、品牌、修饰（主客观）、购买力、性别、敏感度&lt;/li&gt;
&lt;li&gt;偏好三要素：长期偏好、实时偏好、偏好跨平台能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;地域&lt;ul&gt;
&lt;li&gt;身边的陌生人对什么感兴趣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间&lt;/li&gt;
&lt;li&gt;好友&lt;ul&gt;
&lt;li&gt;身边的熟人对什么感兴趣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;云计算&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;云服务-精益创业者的工具箱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：英语流利说 胡哲人&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算资源 + 数据的存储：阿里云, AWS中国, 青云, UCloud&lt;/li&gt;
&lt;li&gt;用户行为的分析：Talking Data, 友盟&lt;/li&gt;
&lt;li&gt;多媒体资源的存储和分发：七牛, 又拍云&lt;/li&gt;
&lt;li&gt;消息推送：个推，极光推送&lt;/li&gt;
&lt;li&gt;系统监控：监控宝，OneAPM&lt;/li&gt;
&lt;li&gt;邮件发送：SendCloud&lt;/li&gt;
&lt;li&gt;其他：&lt;ul&gt;
&lt;li&gt;IM服务：环信/LeanCloud&lt;/li&gt;
&lt;li&gt;社交分享：ShareSDK/友盟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精益创业：创业团队专注自己的产品，快速迭代&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;环信支持千万并发即时通讯的技术要点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：环信联合创始人 刘少壮&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-1" src="/assets/uploads/pics/huanxin-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-2" src="/assets/uploads/pics/huanxin-2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-3" src="/assets/uploads/pics/huanxin-3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="huanxin-4" src="/assets/uploads/pics/huanxin-4.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;自动化运维&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;实时运维数据分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：医树网 曾勇&lt;/p&gt;
&lt;p&gt;基于 ElasticSearch + Logstash + Kibana 实现日志的集中收集分析展示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="yishu-elk-usage" src="/assets/uploads/pics/yishu-elk-usage.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;织云自动化运维技术介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：腾讯 梁定安&lt;/p&gt;
&lt;p&gt;1 . 运营规范&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境标准化&lt;/li&gt;
&lt;li&gt;操作工具化&lt;/li&gt;
&lt;li&gt;对象抽象化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一切均可配置，从而达到低维护成本。&lt;/p&gt;
&lt;p&gt;2 . 资源设计&lt;/p&gt;
&lt;p&gt;&lt;img alt="tencent-resource-design" src="/assets/uploads/pics/tencent-resource-design.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;海量在线交易背后的运维监控体系建设&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ctrip-monitor-set" src="/assets/uploads/pics/ctrip-monitor-set.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 CATS 用于监控告警追踪管理，包含以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理报警统一入口&lt;/li&gt;
&lt;li&gt;报警信息补充&lt;/li&gt;
&lt;li&gt;重复报警去除&lt;/li&gt;
&lt;li&gt;报警优先级区分&lt;/li&gt;
&lt;li&gt;报警抑制&lt;/li&gt;
&lt;li&gt;报警聚合&lt;/li&gt;
&lt;li&gt;与工作流系统联动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="ctrip-monitor-future" src="/assets/uploads/pics/ctrip-monitor-future.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ctrip-monitor-future-arch" src="/assets/uploads/pics/ctrip-monitor-future-arch.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;互联网金融&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;火币网比特币交易所构建实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：巨建华&lt;/p&gt;
&lt;p&gt;&lt;img alt="huobi-arch-timeline" src="/assets/uploads/pics/huobi-arch-timeline.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;浅谈互联网金融的资金安全和对账体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：爱投资CTO 谷云&lt;/p&gt;
&lt;p&gt;&lt;img alt="aitouzi-definition" src="/assets/uploads/pics/aitouzi-definition.png" /&gt;&lt;/p&gt;
&lt;p&gt;互联网金融的价值之一在于发挥平台的专业性，给用户提供更多的投资产品选择。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;互联网金融浅析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：聚爱财 任衡&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-simple-analysis-1" src="/assets/uploads/pics/juaicai-simple-analysis-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;金融的本质是实现资产最优配置，要求平等、高效，而这，恰好与互联网的精髓不谋而合&lt;/em&gt;
&lt;em&gt;互联网金融的三大基石：货币、支付交易、信用体系&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-people-credit" src="/assets/uploads/pics/juaicai-people-credit.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-2014-trend" src="/assets/uploads/pics/juaicai-2014-trend.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Lending Club 会对贷款项目进行评级&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="juaicai-p2b" src="/assets/uploads/pics/juaicai-p2b.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;隐私与安全&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;程序员与黑客&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;架构思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑客思维需要贯穿「...-&amp;gt;架构-&amp;gt;研发-&amp;gt;运维-&amp;gt;...」&lt;/li&gt;
&lt;li&gt;优美的架构一定是健壮的&lt;/li&gt;
&lt;li&gt;优美的架构一定是处处优美的：文档、代码、逻辑、人-&amp;gt;团队&lt;/li&gt;
&lt;li&gt;安全的本质是信任&lt;ul&gt;
&lt;li&gt;「紧内聚、松耦合」设计思想：紧内聚 -&amp;gt; 最小单元 -&amp;gt; 到一段逻辑代码，松耦合 -&amp;gt; 分离 -&amp;gt; 不信任任何输入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;漏洞产生的本质：黑客通过输入提交「特殊数据」，特殊数据在数据流的每个单元里处理，如果某个单元没处理好，在单元输出的时候，就会出现相应单元的安全问题。&lt;/p&gt;
&lt;p&gt;分离的艺术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人员职权分离：人是万恶之源；每个角色应该职权清晰，在保证这个「生态系统」可以稳定运行的基础上，尽可能限制目标角色的职权&lt;/li&gt;
&lt;li&gt;服务器分离：&lt;ul&gt;
&lt;li&gt;研发与线上服务器分离：杜绝在线上调试，杜绝把不成熟的代码发布到线上&lt;/li&gt;
&lt;li&gt;线上服务器各司其职：按业务分离（主站、子站等业务不一样）、按服务器类型分离（Web、数据库、缓存、X、Y、Z、...）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;账号权限分离：账号权限和认证授权模型有关&lt;/li&gt;
&lt;li&gt;文件目录分离：&lt;ul&gt;
&lt;li&gt;文件目录设计的关键：命名风格要优美，目录各司其职 &amp;amp; RWX权限要做好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码分离：&lt;ul&gt;
&lt;li&gt;代码设计的关键：命名风格要优美；代码紧内聚、松耦合（系统、包、文件、类、函数、一段逻辑代码……）；  挫代码 -&amp;gt; 一堆bugs -&amp;gt; 必然包含一堆漏洞&lt;/li&gt;
&lt;li&gt;线上不应该出现SVN/Git权限&lt;/li&gt;
&lt;li&gt;线上如果能提交编译后的文件就编译后的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cookie分离&lt;/li&gt;
&lt;li&gt;子域分离：&lt;ul&gt;
&lt;li&gt;子域设计的关键：不同的业务放到不同的子域下；松耦合的公共模块可以考虑放到其他域名下&lt;/li&gt;
&lt;li&gt;域分离对于XSS攻击来说是一只「拦路虎」&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术选型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何组件都有漏洞：&lt;ul&gt;
&lt;li&gt;一般规律：越流行的开源组件越靠谱；越靠谱的团队打造的组件越靠谱&lt;/li&gt;
&lt;li&gt;时刻做好被黑个透的准备：优美的架构多重要；分离设计能大大提高入侵门槛；快速应急 -&amp;gt; 快速自愈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;千里之堤溃于蚁穴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序员使用不靠谱的组件、工具：&lt;ul&gt;
&lt;li&gt;有些模块/代码直接COPY自不靠谱的地方&lt;/li&gt;
&lt;li&gt;研发、运维工具下载自不靠谱的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;升级中心的相关程序被植入后门&lt;ul&gt;
&lt;li&gt;建议用靠谱的源、官方源&lt;/li&gt;
&lt;li&gt;做正确的MD5校验&lt;/li&gt;
&lt;li&gt;但绝大多数情况下会非常无奈，所以有些高保密机构就不会轻易允许升级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GitHub Hack：&lt;ul&gt;
&lt;li&gt;GitHub的搜索语法：&lt;ul&gt;
&lt;li&gt;smtp @163.com&lt;/li&gt;
&lt;li&gt;insert password extension:sql size:&amp;gt;1000&lt;/li&gt;
&lt;li&gt;svn co username password&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;邮箱Hack&lt;/li&gt;
&lt;li&gt;组件严重漏洞爆发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黑客思维需要贯穿「...-&amp;gt;架构-&amp;gt;研发-&amp;gt;运维-&amp;gt;...」&lt;ul&gt;
&lt;li&gt;安全意识优先，安全经验逐渐培养&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一定要有个优美的架构&lt;ul&gt;
&lt;li&gt;更少Bugs意味着更少漏洞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透彻理解：安全的本质是信任&lt;ul&gt;
&lt;li&gt;明白单元与分离的重要性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全策略的部署一定要全面&lt;/li&gt;
&lt;li&gt;定期备份机制一定要有&lt;ul&gt;
&lt;li&gt;出问题能快速diff排查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Code Review值得提倡：&lt;ul&gt;
&lt;li&gt;万一代码被植入了后门，还有机会发现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应急响应要争分夺秒&lt;/li&gt;
&lt;li&gt;可以请专业的安全团队把把脉&lt;ul&gt;
&lt;li&gt;四个维度：培训、防御、审计、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;善用安全辅助工具&lt;ul&gt;
&lt;li&gt;日志分析：splunk, logcheck, logwatch&lt;/li&gt;
&lt;li&gt;入侵检测/防御：snort, iptables, ipfw, fail2ban, portsentry, tripwire, ossec&lt;/li&gt;
&lt;li&gt;后门检测：rkhunter, chkrootkit, lynis&lt;/li&gt;
&lt;li&gt;流量监控：Nagios, Cacti, Zabbix&lt;/li&gt;
&lt;li&gt;环境隔离：chroot&lt;/li&gt;
&lt;li&gt;Web抗D/CC：推荐自家产品 jiasule&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;扩展性、可用性、高性能&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;基于PXC的MySQL高可用架构探索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：去哪儿网 周彦伟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MMM：http://mysql-mmm.org&lt;/li&gt;
&lt;li&gt;Galera&lt;/li&gt;
&lt;li&gt;Percona Xtradb Cluster（PXC）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;构建高可用和弹性伸缩的KV系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：Ucloud 吴斌炜&lt;/p&gt;
&lt;p&gt;Redis&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用场景：&lt;ul&gt;
&lt;li&gt;取最新N个数据的操作&lt;/li&gt;
&lt;li&gt;排行榜应用，取TOP N操作&lt;/li&gt;
&lt;li&gt;需要精准设定过期时间的应用&lt;/li&gt;
&lt;li&gt;计数器应用&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4&gt;创业&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;我们在豌豆荚如何做产品研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：丁吉昌&lt;/p&gt;
&lt;p&gt;豌豆文化：开放、透明、公平&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;董事会议、报告和文档全员可阅&lt;/li&gt;
&lt;li&gt;你可以问创始人任何问题并得到答复&lt;/li&gt;
&lt;li&gt;个人成就及评级全公司可阅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;研发五步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立项（定方向）&lt;ul&gt;
&lt;li&gt;电梯时间（一句话愿景）&lt;/li&gt;
&lt;li&gt;目标用户的特征和核心需求&lt;/li&gt;
&lt;li&gt;现存的解决方案和各自的优劣势&lt;/li&gt;
&lt;li&gt;依赖、相关技术驱动和限制&lt;/li&gt;
&lt;li&gt;人力需求、发布策略和核心衡量指标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定目标（目标管理）：团队朝一个方向努力&lt;ul&gt;
&lt;li&gt;Objectives &amp;amp; Key Results&lt;ul&gt;
&lt;li&gt;首先是个沟通工具&lt;/li&gt;
&lt;li&gt;努力的方向和目标，非 Roadmap&lt;/li&gt;
&lt;li&gt;必须可量化&lt;/li&gt;
&lt;li&gt;制定和执行者一致，团队和个人目标一致&lt;/li&gt;
&lt;li&gt;和个人绩效考核无关，不是 KPI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;季度 OKR &amp;amp; Review&lt;ul&gt;
&lt;li&gt;最佳实践：目标不变，调整主要成果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;月度会议 Month Review：&lt;ul&gt;
&lt;li&gt;是否需要资源和方向调整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控进度（项目管理）&lt;ul&gt;
&lt;li&gt;状态同步透明&lt;/li&gt;
&lt;li&gt;用最合适的方式多方位沟通&lt;/li&gt;
&lt;li&gt;周会/总结&lt;/li&gt;
&lt;li&gt;数据验证 (MUCE)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;带团队（人员管理）&lt;ul&gt;
&lt;li&gt;找最优秀的人&lt;/li&gt;
&lt;li&gt;Re-Org &amp;amp; 换组：绩效合格，每季度可申请换组/工作内容&lt;/li&gt;
&lt;li&gt;One on One：&lt;ul&gt;
&lt;li&gt;经理还是教练？&lt;/li&gt;
&lt;li&gt;排忧解难助成长&lt;/li&gt;
&lt;li&gt;分享职业规划&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;个人绩效：&lt;ul&gt;
&lt;li&gt;绩效不与 OKR 挂钩&lt;/li&gt;
&lt;li&gt;鼓励挑战难度&lt;/li&gt;
&lt;li&gt;鼓励超越优秀&lt;/li&gt;
&lt;li&gt;低 Level 的事情做不到优秀会惩罚&lt;/li&gt;
&lt;li&gt;做事不及格会惩罚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排干扰（兴趣管理）&lt;ul&gt;
&lt;li&gt;Hack Day 发现好玩意&lt;/li&gt;
&lt;li&gt;Polish Week 查漏补缺&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;创业期技术团队杂谈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：岳旭强&lt;/p&gt;
&lt;p&gt;创业实践&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速试错&lt;/li&gt;
&lt;li&gt;活下去是第一诉求&lt;/li&gt;
&lt;li&gt;极致结果：&lt;ul&gt;
&lt;li&gt;简化沟通：下乡、突击队、扁平化&lt;/li&gt;
&lt;li&gt;兴趣激发：自由选择权、黑暗骑士&lt;ul&gt;
&lt;li&gt;技术工作的三个特性：产品性、工程性、技术(艺术)性。对于这三个特性，工程师有不同的偏向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成就感驱动&lt;ul&gt;
&lt;li&gt;明意义&lt;/li&gt;
&lt;li&gt;重参与&lt;/li&gt;
&lt;li&gt;追结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;极致环境&lt;ul&gt;
&lt;li&gt;氛围：自由、简单、开放&lt;/li&gt;
&lt;li&gt;极致要求：凡事必有解，且必有最优解&lt;/li&gt;
&lt;li&gt;攻城师支持：工具平台、一日三餐、全员Mac、1:1 （实际上应该是有条件了才会有这些福利）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文化养成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选拔人才&lt;ul&gt;
&lt;li&gt;技术热情&lt;/li&gt;
&lt;li&gt;逻辑思维&lt;/li&gt;
&lt;li&gt;拿到结果&lt;/li&gt;
&lt;li&gt;工程 vs 产品 vs 技术&lt;/li&gt;
&lt;li&gt;计划 vs 随机应变&lt;/li&gt;
&lt;li&gt;严谨 vs 脱缰野⻢马&lt;/li&gt;
&lt;li&gt;重细节 vs 重宏观&lt;/li&gt;
&lt;li&gt;深度 vs 广度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Building Lean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;演讲人：Kevin Goldsmith&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The one thing you can’t recycle is wasted time. -- Taiichi Ohno&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Key Lean Concepts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Anything that doesn’t produce value for customers is waste and a candidate for elimination&lt;/li&gt;
&lt;li&gt;Get value to customers as quickly as possible&lt;/li&gt;
&lt;li&gt;Validate product/market fit in the shortest amount of time necessary&lt;/li&gt;
&lt;li&gt;Scientific, data-driven, approach&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Key Lean Ideas：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minimum Viable(可行的) Product&lt;/li&gt;
&lt;li&gt;Create hypotheses, validate with experiments and DATA （大胆假设、小心验证？）&lt;/li&gt;
&lt;li&gt;Learn fast, fail fast&lt;/li&gt;
&lt;li&gt;The speed of iteration is more important than the quality of iteration  -- John Boyd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overcoming doubt：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruthlessly cut features to make the launch&lt;/li&gt;
&lt;li&gt;Commit to consistent, quick, iterations to make up the features we cut&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;吐槽&lt;/h2&gt;
&lt;p&gt;梁漱溟晚年口述一书《这个世界会好吗》，我的回答是：会！只不过需要不断地吐槽！！！&lt;/p&gt;
&lt;h4&gt;演讲即招聘&lt;/h4&gt;
&lt;p&gt;这一点本来是没什么好吐槽的。各种大大小小技术会议几乎每个演讲都会在最后附带一句“我们在招人！”，为了增大吸引力，还在演讲中有意无意地说明公司的待遇如何如何、美女如何如何。不过，我倒怀疑这种招聘形式到底能成功招到几个牛人呢？牛人都是主动规划自己的人生的，想去你们公司的，即使你不说招人，他们也会主动联系你，不想去的，说了也等于没说。特别是那些演讲内容或演讲效果一坨屎的，你还想啥呢。所以，对于技术会议，如果要演讲，就好好准备点干货，好好分享，这样才能给招聘增加吸引力。&lt;/p&gt;
&lt;h4&gt;演讲即产品推销&lt;/h4&gt;
&lt;p&gt;这种演讲，我真想将它吐槽至死！一点节操都不要！厚着脸皮浪费大家的时间。作为技术人应该是最讨厌这种，产品推销反而适得其反。（好吧，也许这只是我的想法）&lt;/p&gt;
&lt;h4&gt;演讲即不知所云&lt;/h4&gt;
&lt;p&gt;这种演讲，怎么说呢... 特别是如果演讲人是个高级工程师之类的，就真心对不起公司、对不起人民了。如果哆哆嗦嗦、词不达意、连个完整的话都说不清、不知所云，通常并不是你水平不行，只能说明你没有好好准备。作为高级工程师，或者有个title的人，紧张、心理素质不好，不应该成为一个糟糕演讲的理由。你的一个糟糕演讲对公司带来的负面影响是很大的，更别想在演讲的最后说“我们招人！”。&lt;/p&gt;
&lt;p&gt;该如何准备一次演讲？我的想法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只分享自己有心得的：如做过的事情或者认真研究过的技术，不是真正懂的东西就不要提，不要给自己挖坑&lt;/li&gt;
&lt;li&gt;制作幻灯片&lt;ul&gt;
&lt;li&gt;先写大纲，划一个演讲内容的范围&lt;/li&gt;
&lt;li&gt;根据大纲，逐个部分充实内容&lt;/li&gt;
&lt;li&gt;最后根据叙述逻辑（一个比较通用的叙述逻辑是：提出问题-&amp;gt;分析问题-&amp;gt;解决问题的方案）调整内容的位置，目的是方便听众快速理解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在正式演讲前对着幻灯片演练几遍，组织一下表述的语言，特别是幻灯片切换时的语言表述，在大脑中大致记住整个幻灯片的起承转合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好吧，虽然我说得貌似挺有道理，但也多少经验，有时间准备读读《演说之禅：职场必知的幻灯片秘技》一书。&lt;/p&gt;
&lt;h2&gt;感想&lt;/h2&gt;
&lt;p&gt;技术这东西，基本上都是围着业务转（不管是技术选型，还是深入实践），各家的业务不同，所以有各自的技术方案，但道道也就那些，没多少神奇之处。对于技术人来说，应该紧抓业务深研技术，才能出好成果，涨牛逼经验。&lt;/p&gt;
&lt;p&gt;故此，技术会议也没必要那么积极参加，个人觉得大型技术会议对于各中小公司的业务交流及宣传比较有用，对于技术交流的作用其实比较有限。非技术细节的东西要么没必要知道，要么已知道；技术细节也是如此。&lt;/p&gt;
&lt;p&gt;不过对于年轻的技术人来说，可以以讲师的身份多参加技术会议，可能对自己的帮助更大。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://2014.qconshanghai.com/slides.html"&gt;QCon上海2014大会 幻灯片下载&lt;/a&gt;&lt;/p&gt;</summary><category term="笔记"></category><category term="总结"></category></entry><entry><title>中心化日志记录架构（译）</title><link href="http://youngsterxyf.github.io/2014/10/14/centralized-logging-architecture/" rel="alternate"></link><updated>2014-10-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-10-14:2014/10/14/centralized-logging-architecture/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://jasonwilder.com/blog/2013/07/16/centralized-logging-architecture/"&gt;Centralized Logging Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://jasonwilder.com/blog/2012/01/03/centralized-logging/"&gt;中心化日志记录&lt;/a&gt;一文中，我介绍了几个工具，用于解决中心化日志记录的问题。但这些工具一般仅能解决这个问题的一部分，
这意味着需要综合使用几个工具来构建一个健壮的解决方案。&lt;/p&gt;
&lt;p&gt;你需要解决问题的这几个主要方面：&lt;em&gt;收集&lt;/em&gt;、&lt;em&gt;传输&lt;/em&gt;、&lt;em&gt;存储&lt;/em&gt;、以及&lt;em&gt;分析&lt;/em&gt;。某些特殊的应用场景下，也许还希望具备&lt;em&gt;告警&lt;/em&gt;的能力。&lt;/p&gt;
&lt;h4&gt;收集&lt;/h4&gt;
&lt;p&gt;应用程序以不同的方式产生日志，一些是通过syslog，其他一些是直接写到文件。考虑一个运行在linux主机上的典型web应用，在&lt;code&gt;/var/log&lt;/code&gt;目录会有十几个甚至更多的日志文件，
如果一些应用指定日志存放在HOME目录或者其他位置，则这些目录下也是如此。&lt;/p&gt;
&lt;p&gt;如果你正在运营一个基于web的应用，开发人员或者运维同事需要快速地访问日志数据以便对线上问题进行排错，那么就需要一个能够近乎实时监控日志文件变化的方案。
如果使用基于日志拷贝的方式 --- 文件以固定的时间间隔拷贝到一台中心服务器上，那么仅能检查与复制操作频率相同的新增日志数据。当站点已经挂掉，而你正在等待相关日志数据的复制，
那么一分钟一次的 rsync cron 任务也许还不够快。&lt;/p&gt;
&lt;p&gt;从另外一个角度来看，如果需要分析线下日志数据，计算各种度量指标，或者其他批量的工作，文件复制的策略也许正合适。&lt;/p&gt;
&lt;h4&gt;传输&lt;/h4&gt;
&lt;p&gt;日志数据会在多个主机上快速地累积起来。为了高效传输日志数据到中心位置，并保证数据不丢失，可能需要额外的工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/facebookarchive/scribe"&gt;Scribe&lt;/a&gt;、&lt;a href="http://flume.apache.org/"&gt;Flume&lt;/a&gt;、&lt;a href="https://github.com/mozilla-services/heka"&gt;Heka&lt;/a&gt;、&lt;a href="http://logstash.net/"&gt;Logstash&lt;/a&gt;、
&lt;a href="http://chukwa.apache.org/"&gt;Chukwa&lt;/a&gt;、&lt;a href="http://www.fluentd.org/"&gt;fluentd&lt;/a&gt;、&lt;a href="https://github.com/bitly/nsq"&gt;nsq&lt;/a&gt;、&lt;a href="http://kafka.apache.org/"&gt;Kafka&lt;/a&gt; 这些框架正是被设计用于
从一个主机到另一个主机可靠地传输大量数据。虽然它们都是用于解决数据传输问题，但做法却不相同。&lt;/p&gt;
&lt;p&gt;例如，&lt;a href="https://github.com/facebookarchive/scribe"&gt;Scribe&lt;/a&gt;、&lt;a href="https://github.com/bitly/nsq"&gt;nsq&lt;/a&gt; 以及 &lt;a href="http://kafka.apache.org/"&gt;Kafka&lt;/a&gt;，要求客户端通过它们的API记录日志数据，
通常，应用程序代码会编写成直接将日志写到这些工具中，这样能够减小延迟，提高可靠性。如果你需要的是中心化的日志文件数据，那么就需要跟踪(tail)日志文件变更，
然后将日志数据通过这些工具各自的API流式写入。如果产生需要收集的日志数据的应用由你控制着，一切会高效得多。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://logstash.net/"&gt;Logstash&lt;/a&gt;、&lt;a href="https://github.com/mozilla-services/heka"&gt;Heka&lt;/a&gt;、&lt;a href="http://www.fluentd.org/"&gt;fluentd&lt;/a&gt; 以及 &lt;a href="http://flume.apache.org/"&gt;Flume&lt;/a&gt; 则提供许多输入源方式，
支持本机跟踪(tailing)文件变化并可靠地传输数据。对于更广泛的日志收集来说，是个更合适的选择。&lt;/p&gt;
&lt;p&gt;虽然 &lt;a href="http://rsyslog.com/"&gt;rsyslog&lt;/a&gt;和&lt;a href="http://www.balabit.com/network-security/syslog-ng"&gt;Syslog-ng&lt;/a&gt; 通常被认为是事实上的日志收集器，但并不是所有应用程序都使用 syslog。&lt;/p&gt;
&lt;h4&gt;存储&lt;/h4&gt;
&lt;p&gt;现在可以传输日志数据了，但数据存放在哪呢？中心化的存储系统需要能够处理数据随着时间的增长。每天都会增加一定量的数据存储，数据量和产生日志数据的主机和进程数量相关。&lt;/p&gt;
&lt;p&gt;如何存储依赖于以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;需要存储多长时间&lt;/em&gt; --- 如果日志是用于长期归档的目的，并且不需要即时分析，那么 &lt;a href="http://aws.amazon.com/cn/s3/"&gt;S3&lt;/a&gt;、&lt;a href="http://aws.amazon.com/cn/glacier/"&gt;AWS Glacier&lt;/a&gt; 或磁带备份
    也许是合适的选择，因为它们对于大量数据的存储相对比较廉价。如果仅需要几天或者几个月的日志，将数据存储到某种分布式存储系统，
    如：&lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt;、&lt;a href="http://cassandra.apache.org/"&gt;Cassandara&lt;/a&gt;、
    &lt;a href="http://www.mongodb.org/"&gt;MongoDB&lt;/a&gt; 或 &lt;a href="http://elasticsearch.org/"&gt;ElasticSearch&lt;/a&gt;也是不错的。如果仅需要保留几个小时的数据用于实时分析，使用&lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;也可以。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;应用场景的数据量&lt;/em&gt; --- Google一天的日志数据量肯定远大于ACME运输物资公司（译注：原文是ACME Fishing Supplies，正确的应该是ACME Shipping Supplies）一天的日志。
    你选择的存储系统当数据量增大时应该允许水平扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;需要如何访问日志&lt;/em&gt; --- 某些存储系统是适于实时甚至批量分析的。AWS Glacier 或磁盘备份加载一个文件就需要花费若干小时，如果需要访问日志进行产品排错，这就不好使了。
    如果计划进行更多的交互式数据分析，将日志数据存储到 &lt;a href="http://elasticsearch.org/"&gt;ElasticSearch&lt;/a&gt; 或 &lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt;
    让你能够更加有效地使用原始数据。某些日志数据非常庞大，就只能使用面向批量处理的框架进行分析了。这种情况下事实上的标准方案是 &lt;a href="http://hadoop.apache.org/"&gt;Apache Hadoop&lt;/a&gt; 
    配合 &lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;分析&lt;/h4&gt;
&lt;p&gt;一旦日志已经存到一个中心化存储平台，就需要一种方式来分析日志。最常见的方式是定期执行一个面向批量处理的进程。如果日志是存储在 &lt;a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"&gt;HDFS&lt;/a&gt; 中，
那么 &lt;a href="http://hive.apache.org/"&gt;Hive&lt;/a&gt; 或 &lt;a href="http://pig.apache.org/"&gt;Pig&lt;/a&gt; 相比编写原生MapReduce任务，更易于帮助分析数据。&lt;/p&gt;
&lt;p&gt;如果需要一个用于分析的用户界面，可以将解析过的日志数据存到 &lt;a href="http://elasticsearch.org/"&gt;ElasticSearch&lt;/a&gt;，然后使用一个前端方案，如 &lt;a href="http://kibana.org/"&gt;Kibana&lt;/a&gt; 或
&lt;a href="http://www.graylog2.org/"&gt;Graylog2&lt;/a&gt;来查询检查数据。日志解析可以通过 &lt;a href="http://logstash.net/"&gt;Logstash&lt;/a&gt; 或 &lt;a href="https://github.com/mozilla-services/heka"&gt;Heka&lt;/a&gt;来处理，
应用程序也可以直接以JSON格式记录日志。这种方式允许更加实时、交互式的数据获取，但不适于大批量的处理。&lt;/p&gt;
&lt;h4&gt;告警&lt;/h4&gt;
&lt;p&gt;最后一个组件，有时是可以锦上添花的 --- 针对日志模式或基于日志数据计算出来的度量指标进行告警。两种常见用法是：错误报告和监控。&lt;/p&gt;
&lt;p&gt;多数日志数据是无关紧要的，但错误日志则通常说明存在问题。让日志系统在问题发生时给相关人员发送邮件或通知，相比让某个人重复地监视事件，要高效得多。
有几种服务组件可单独提供应用错误日志记录的功能，如 &lt;a href="https://www.getsentry.com/"&gt;Sentry&lt;/a&gt; 或 &lt;a href="https://www.honeybadger.io/"&gt;HoneyBadger&lt;/a&gt; 。这些服务也可以聚合重复的异常，
方便你获知错误发生的频率是怎样的。&lt;/p&gt;
&lt;p&gt;另一个使用案例是监控。例如，你可能有上百个web服务器，想知道它们是否开始返回500响应状态码。如果可以解析web日志文件，根据状态码记录一个度量指标，
当度量指标超过了一个特定的阈值就可以触发告警。 &lt;a href="http://riemann.io/"&gt;Riemann&lt;/a&gt; 就是被设计用于检测这种场景的。&lt;/p&gt;
&lt;p&gt;希望本文能提供一个基本模型帮助你针对你的应用环境设计一个中心化日志记录方案。&lt;/p&gt;</summary><category term="翻译"></category><category term="日志"></category><category term="架构"></category></entry><entry><title>流行PHP项目的phpmetrics分析（译）</title><link href="http://youngsterxyf.github.io/2014/09/22/phpmetrics-of-popular-php-projects/" rel="alternate"></link><updated>2014-09-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-09-22:2014/09/22/phpmetrics-of-popular-php-projects/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://peteraba.com/blog/phpmetrics-of-popular-projects/"&gt;phpmetrics of popular php projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前我偶然发现一个名为&lt;a href="http://www.phpmetrics.org/"&gt;phpmetrics&lt;/a&gt;的新工具，可用于计算及展示php的度量指标。我当时立马喜欢上了这个工具，并决定用它分析我认为重要的一些php项目。
我知道这个项目列表还远远不够完善，但应该仍然值得一看。我特别喜欢其中的“可维护性”报告，我发现视觉上那些红色的斑点就和丑陋的代码一样令人厌恶。&lt;/p&gt;
&lt;p&gt;这个工具貌似还有点小bug，我会尽力尽快修复这个工具项目的这些小问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些重要的说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前我还无法得到Cakephp和Typo3的分析报告，之后我会尽快调查一下这个问题。&lt;/li&gt;
&lt;li&gt;我是在完整的代码库或下载的源码包上执行这个工具的，这意味着某些情况下还分析了项目的外部依赖库。之后我可能会调整，但目前不在计划之内。&lt;/li&gt;
&lt;li&gt;有些项目包含很多代码库，所以我无法确保测试的都是正确的那个代码库。&lt;em&gt;Joomla&lt;/em&gt;尤其可能这样。&lt;/li&gt;
&lt;li&gt;某些项目并非非常知名，但在github上呈现关注度上升趋势。&lt;/li&gt;
&lt;li&gt;dm-mailer这个项目无足轻重，只是我最新的个人兴趣项目。我将它与phpmetrics一起归到Backfire一节。&lt;/li&gt;
&lt;li&gt;注意：php-yaf和phalcon都是非常有意思的php框架，但多数代码是C实现的，因此没有包含进来。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;说明：阅读该报告的一点小提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多的斑点只是意味着更多的类&lt;/li&gt;
&lt;li&gt;红色意味着不可维护，黄色表示可接受，绿色则表明良好、可维护的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;分析结果&lt;/h3&gt;
&lt;h4&gt;框架&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://www.agavi.org/"&gt;agavi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="agavi-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/agavi-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/agavi/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/agavi/agavi"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交（均指master分支上的）：&lt;em&gt;4个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://auraphp.com/"&gt;aura&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="aura-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/aura-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/aura/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/auraphp/Aura.Framework_Project"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://cakephp.org/"&gt;cakephp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="cakephp-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/na.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;s&gt;戳这里&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/cakephp/cakephp"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="https://ellislab.com/codeigniter"&gt;codeigniter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="codeigniter-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/codeigniter-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/codeigniter/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/EllisLab/CodeIgniter"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="https://github.com/colindean/deano"&gt;deano&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="deano-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/deano-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/deano/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/colindean/deano"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;10个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://fatfreeframework.com/home"&gt;fatfree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="fatfree-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/fatfree-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/fatfree/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/bcosca/fatfree"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1个月内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://flightphp.com/"&gt;flight&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="flight-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/flight-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/flight/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/mikecao/flight"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://fuelphp.com/"&gt;fuelphp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="fuelphp-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/fuelphp-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/fuelphp/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/fuel/fuel"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2个月内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://laravel.com/"&gt;laravel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="laravel-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/laravel-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/laravel/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/laravel/laravel"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://limonade-php.github.io/"&gt;limonade&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="limonade-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/limonade-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/limonade/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/sofadesign/limonade/"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2个月内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://nette.org/en/"&gt;nette&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="nette-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/nette-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/nette/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/nette/nette"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://phavour-project.com/"&gt;phavour&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phavour-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phavour-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phavour/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/phavour/phavour"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;6个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.php-mvc.net/"&gt;php-mvc(advanced)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="php-mvc-advanced-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/php-mvc-advanced-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/php-mvc-advanced/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/panique/php-mvc-advanced"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://phpixie.com/"&gt;phpixie&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phpixie-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phpixie-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phpixie/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/dracony/PHPixie"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;5个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.popphp.org/"&gt;popphp2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="popphp2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/popphp2-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/popphp2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/popphp/popphp2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：3周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://silex.sensiolabs.org/"&gt;silex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="silex-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/silex-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/silex/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/silexphp/Silex"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://slimframework.com/"&gt;slim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="slim-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/slim-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/slim/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/codeguy/Slim"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：5个月内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://symfony.com/legacy"&gt;symfony1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="symfony1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/symfony1-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/symfony1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/symfony/symfony1"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;2年内&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://symfony.com/"&gt;symfony2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="symfony2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/symfony2-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/symfony2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/symfony/symfony"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://typo3.org/"&gt;typo3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="typo3-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/na.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;s&gt;戳这里&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://git.typo3.org/Packages/TYPO3.CMS.git"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.yiiframework.com/"&gt;yii1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="yii1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/yii1-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/yii1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/yiisoft/yii"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.yiiframework.com/"&gt;yii2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="yii2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/yii2-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/yii2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/yiisoft/yii2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://framework.zend.com/"&gt;zf1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="zf1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/zf1-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/zf1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/zendframework/zf1"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://framework.zend.com/"&gt;zf2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="zf2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/zf2-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/zf2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/zendframework/zf2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2周内&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;CMS&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="https://www.drupal.org/"&gt;drupal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="drupal-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/drupal-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/drupal/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/drupal/drupal"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.joomla.org/"&gt;joomla&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="joomla-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/joomla-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/joomla/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/joomla/joomla-framework"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：5个月内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://getgrav.org/"&gt;grav&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="grav-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/grav-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/grav/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/getgrav/grav"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://pagekit.com/"&gt;pagekit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="pagekit-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/pagekit-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/pagekit/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/pagekit/pagekit"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.webasyst.com/"&gt;os webasyst projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="os-webasyst-projects-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/os-webasyst-projects-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/webasyst/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：N/A&lt;/p&gt;
&lt;p&gt;最近提交：N/A&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://wordpress.org/"&gt;wordpress&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="wordpress-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/wordpress-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/wordpress/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/WordPress/WordPress"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;电子商务&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://magento.com/"&gt;magento1(1.8 copy)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="magento1-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/magento1-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/magento1/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://bitbucket.org/ecgkodokux/magento1.8.git"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：N/A&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://magento.com/"&gt;magento2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="magento2-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/magento2-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/magento2/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/magento/magento2"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.opencart.com/"&gt;opencart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="opencart-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/opencart-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/opencart/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/opencart/opencart"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.oscommerce.com/"&gt;oscommerce&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="oscommerce-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/oscommerce-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/oscommerce/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/osCommerce/oscommerce"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：2年内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.prestashop.com/"&gt;prestashop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="prestashop-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/prestashop-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/prestashop/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/PrestaShop/PrestaShop"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://sylius.org/"&gt;sylius&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="sylius-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/sylius-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/sylius/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/Sylius/Sylius"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;10个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://virtuemart.net/"&gt;virtuemart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="virtuemart-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/virtuemart-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/virtuemart/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="http://dev.virtuemart.net/projects/virtuemart/repository"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：N/A&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.zen-cart.com/"&gt;zencart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="zencart-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/zencart-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/zencart/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/zencart/zc-v1-series"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;开发工具&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://codeception.com/"&gt;codeception&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="codeception-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/codeception-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/codeception/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/Codeception/Codeception"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://phpunit.de/"&gt;phpunit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phpunit-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phpunit-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phpunit/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/sebastianbergmann/phpunit"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;其他&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="http://piwik.org/"&gt;piwik&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="piwik-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/piwik-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/piwik/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/piwik/piwik"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Backfire&lt;/h4&gt;
&lt;p&gt;项目：&lt;a href="https://github.com/peteraba/zf2-mailer"&gt;dm-mailer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="dm-mailer-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/dm-mailer-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/dm-mailer/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/peteraba/zf2-mailer"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：&lt;em&gt;7个月内&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;项目：&lt;a href="http://www.phpmetrics.org/"&gt;phpmetrics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可维护性：&lt;img alt="phpmetrics-phpmetrics" src="/assets/uploads/pics/phpmetrics-result/phpmetrics-phpmetric-maintenability.png" /&gt;&lt;/p&gt;
&lt;p&gt;分析报告：&lt;a href="https://peteraba.com/metrics/phpmetrics/phpmetrics/report.html"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码库：&lt;a href="https://github.com/Halleck45/PhpMetrics"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近提交：1周内&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;问题(Issues)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Cakephp&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;594/666 [========================&amp;gt;---]  89%

[Exception]                         
Closure detected instead of method
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Deano&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;2/9 [======&amp;gt;---------------------]  22%file /home/peter/dev/php/opensource/deano/views/layout/layout.php is not valid and has been skipped
9/9 [============================] 100%file /home/peter/dev/php/opensource/deano/deano.php is not valid and has been skipped
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Limonade&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; 9/16 [===============&amp;gt;------------]  56%file /home/peter/dev/php/opensource/limonade/examples/example02/index.php is not valid and has been skipped
16/16 [============================] 100%file /home/peter/dev/php/opensource/limonade/examples/example06/index.php is not valid and has been skipped
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Magento&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;3361/9868 [=========&amp;gt;------------------]  34%file ../../opensource/magento2/lib/internal/Zend/Mail/Protocol/Pop3.php is not valid and has been skipped
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Pagekit&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;102/215 [=============&amp;gt;--------------]  47%file /home/peter/dev/php/opensource/pagekit/extensions/system/src/System/Console/skeleton/extension/src/Controller/SiteController.php is not valid and has been skipped
103/215 [=============&amp;gt;--------------]  47%file /home/peter/dev/php/opensource/pagekit/extensions/system/src/System/Console/skeleton/extension/src/DefaultExtension.php is not valid and has been skipped
105/215 [=============&amp;gt;--------------]  48%file /home/peter/dev/php/opensource/pagekit/extensions/system/src/System/Console/skeleton/theme/src/DefaultTheme.php is not valid and has been skipped
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Symfony1&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;199/1320 [====&amp;gt;-----------------------]  15%file /home/peter/dev/php/opensource/symfony1/lib/task/generator/skeleton/module/module/actions/actions.class.php is not valid and has been skipped
205/1320 [====&amp;gt;-----------------------]  15%file /home/peter/dev/php/opensource/symfony1/lib/task/generator/skeleton/app/web/index.php is not valid and has been skipped
206/1320 [====&amp;gt;-----------------------]  15%file /home/peter/dev/php/opensource/symfony1/lib/task/generator/skeleton/app/app/config/ApplicationConfiguration.class.php is not valid and has been skipped
397/1320 [========&amp;gt;-------------------]  30%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/admin/skeleton/lib/helper.php is not valid and has been skipped
398/1320 [========&amp;gt;-------------------]  30%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/admin/skeleton/lib/configuration.php is not valid and has been skipped
399/1320 [========&amp;gt;-------------------]  30%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/admin/skeleton/actions/actions.class.php is not valid and has been skipped
445/1320 [=========&amp;gt;------------------]  33%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfPropelPlugin/data/generator/sfPropelModule/default/skeleton/actions/actions.class.php is not valid and has been skipped
652/1320 [=============&amp;gt;--------------]  49%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/admin/skeleton/lib/helper.php is not valid and has been skipped
653/1320 [=============&amp;gt;--------------]  49%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/admin/skeleton/lib/configuration.php is not valid and has been skipped
654/1320 [=============&amp;gt;--------------]  49%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/admin/skeleton/actions/actions.class.php is not valid and has been skipped
700/1320 [==============&amp;gt;-------------]  53%file /home/peter/dev/php/opensource/symfony1/lib/plugins/sfDoctrinePlugin/data/generator/sfDoctrineModule/default/skeleton/actions/actions.class.php is not valid and has been skipped
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Typo3&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;76/2583 [&amp;gt;---------------------------]   2%

[Exception]                         
Closure detected instead of method
&lt;/pre&gt;&lt;/div&gt;</summary><category term="翻译"></category><category term="PHP"></category></entry><entry><title>RESTful API设计的一点经验</title><link href="http://youngsterxyf.github.io/2014/09/06/experience-about-restful-api/" rel="alternate"></link><updated>2014-09-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-09-06:2014/09/06/experience-about-restful-api/</id><summary type="html">&lt;p&gt;前段时间的工作涉及产品开放API的设计与实现，整个过程大致可分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据需求、原有数据库设计等，花了半天左右的工夫完成初稿；&lt;/li&gt;
&lt;li&gt;就初稿与相关同事进行讨论，确定一些细节问题，逐步完善；&lt;/li&gt;
&lt;li&gt;根据设计稿，基于Yii框架，配置路由，实现用户身份认证模块；&lt;/li&gt;
&lt;li&gt;基于步骤3，逐个实现业务相关API；&lt;/li&gt;
&lt;li&gt;对部分代码进行重构，减少不必要的代码重复。主要使用Yii控制器的beforeAction方法来实现多层过滤器。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;设计&lt;/h3&gt;
&lt;p&gt;考虑到RESTful API简洁明了的接口表现形式，一开始我们就一致确定使用RESTful风格的API。参考以前自己使用多个开放平台API的经验，
及&lt;a href="https://developer.github.com/v3/"&gt;Github的开放API文档&lt;/a&gt;，大致完成设计初稿。&lt;/p&gt;
&lt;h5&gt;资源&lt;/h5&gt;
&lt;p&gt;RESTful API主要有两个核心：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP协议的4个谓词 - GET、POST、PUT、DELETE，分别对应“查询”、“新增”、“更新”、“删除”4种操作&lt;/li&gt;
&lt;li&gt;资源（resource）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RESTful风格API的设计，最难之处，我认为就是“资源”。&lt;/p&gt;
&lt;p&gt;“资源”是什么？“资源”并不是对应数据库中一个一个数据表，“资源”是一个抽象的概念，
你需要思考你的产品服务要通过API为用户提供什么？一个API提供的数据可能涉及多张数据表，所以“资源”与具体的数据库设计是独立的。&lt;/p&gt;
&lt;p&gt;“资源”的抽象会遇到一个“粒度”的问题，比如一个API返回的数据不应该太多太复杂。&lt;/p&gt;
&lt;p&gt;另外，不同“资源”之间可能存在归属关系，那么是否需要在HTTP API的URL中体现这种归属关系？如果要体现，那么当归属关系的层次较多时，URL的长度可能过长。&lt;/p&gt;
&lt;p&gt;举个简单的例子来进一步解释上述问题：&lt;/p&gt;
&lt;p&gt;假设我们要通过API提供“全国县一级的天气预报数据”。从这句话的表述可以很明显地知道（因为这句话本身是一个明确的需求）这里的“资源”是“全国县一级的天气预报数据”。&lt;/p&gt;
&lt;p&gt;这个“全国县一级的天气预报数据”其实仍是抽象的，天气预报数据可能包含天气、气温、湿度、空气质量等指标，这些指标又是分别存储在不同的数据表中的，那么这个API
的代码逻辑就需要读取几张数据表，然后做合并处理。又或者数据库中存储的数据是区域范围更小更准备的天气预报数据，那么也需要对这些数据按照一定的算法进行处理
得出县一级的天气预报数据。&lt;/p&gt;
&lt;p&gt;如果仅通过一个API来提供全国所有县一级的天气数据，那么可以想象，这个API返回的数据有多大多复杂。并且用户可能需要更灵活的数据查询方式，如仅查询某个省份
所有县一级的天气预报数据。那么可以将这个API拆分成以下几个API：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;GET /province/
GET /province/{province_name_or_id}/county/
GET /province/{province_name_or_id}/county/{county_id_or_name}/weather/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拆分之后，可能需要多次调用API才能获取到需要的数据，但每个API的定义都简单而明确。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;GET /province/{province_name_or_id}/county/{county_id_or_name}/weather/&lt;/code&gt;这个URL，可能有人觉得它过长了，可以缩短设计为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;GET /county/{county_id_or_name}/weather/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;甚至&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;GET /{county_id_or_name}/weather/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但我更倾向于归属关系明确的长URL，主要原因是，API服务器端可以验证province_name_or_id与county_id_or_name之间的归属关系，以避免用户错误地调用API，
特别是当涉及增删改操作时。&lt;/p&gt;
&lt;p&gt;所以RESTful API设计时有许多细节之处需要权衡。&lt;/p&gt;
&lt;h5&gt;响应码&lt;/h5&gt;
&lt;p&gt;RESTful API请求的响应码通常有两种表现形式，一种是直接使用HTTP协议的HTTP code，另一种是HTTP协议的响应码始终为200，但在响应体中加入类似名为code的字段，
来表达当前API请求的响应状态，这个code字段值的含义就是HTTP code含义，除了code字段外可能还会附加一个类似名为message的字段来进一步解释响应状态。&lt;/p&gt;
&lt;p&gt;我倾向使用第二种形式，理由是：HTTP协议的HTTP code，在为404、500等错误码时，表现的应该是API服务器端程序的健壮性等问题，是未预期的错误，而响应体中的code字段，
在返回404或500等错误码时，表达是API服务器端已预期到这些可能存在的错误，是主动返回这样的错误码的。这样API的调用者也能更容易判断某些问题的原因；&lt;/p&gt;
&lt;h5&gt;请求的唯一标识&lt;/h5&gt;
&lt;p&gt;为了方便快速定位用户反馈的问题，我们在每个API的响应内容中加入一个request_id字段作为API请求的唯一性标识，这个请求处理过程中产生的所有日志都是和这个
request_id关联的，这样可以根据request_id聚合处理关联的log。在用户反馈问题时，仅需提供request_id，我们很容易地就能找到这个请求的所有日志。&lt;/p&gt;
&lt;p&gt;但这个request_id是应该作为HTTP相应头的一个字段，还是作为响应体的一个字段返回？我倾向于第二种，理由是：我们希望API调用方能够在日志或数据库中记录
所有请求的request_id，便于以后发现问题时进行问题追踪。对于这种调用方应该处理的响应数据项，明确地放在响应体中会更好。&lt;/p&gt;
&lt;p&gt;另外，我们也会每个request_id记录对应请求的监控数据，如响应码、请求处理耗费的时间、请求的调用方、请求处理的路由等。这样在对监控数据进行数据可视化后，
可以主动发现某些隐藏的问题。&lt;/p&gt;
&lt;h5&gt;兼容&lt;/h5&gt;
&lt;p&gt;在某些情况下，客户端库或工具可能并不支持HTTP协议谓词PUT和DELETE，那么基于这两个谓词的RESTful
API就需要提供兼容方案。我们的兼容方案是：以POST谓词来替代PUT和DELETE，同时在API请求URL的查询字符串中添加_method一项，指明POST替代的是PUT还是DELETE。如以&lt;code&gt;POST
/xxx/yyy/?_method=DELETE&lt;/code&gt;作为&lt;code&gt;DELETE /xxx/yyy/&lt;/code&gt;的兼容方案。&lt;/p&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;我们的开放API是基于Yii框架实现。&lt;/p&gt;
&lt;h5&gt;路由&lt;/h5&gt;
&lt;p&gt;Yii框架默认的路由形式为：查询字符串r=xxx/yyy，其中xxx为控制器(controller)的名称，yyy为动作方法(action)的名称，这种路由形式对应Yii内部的get路由类型，
因为是默认形式，所以无需额外配置。
Yii另外提供一种名为path的路由形式，即使用URL的路径(path)部分来表达路由。要这种形式的路由需要额外配置Yii框架，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;#39;components&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;urlManager&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;urlFormat&amp;#39; =&amp;gt; &amp;#39;path&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;rules&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;            array(&amp;#39;aaa/bbb&amp;#39;, &amp;#39;pattern&amp;#39; =&amp;gt; &amp;#39;/xxx/yyy&amp;#39;, &amp;#39;verb&amp;#39; =&amp;gt; &amp;#39;POST&amp;#39;),&lt;/span&gt;
&lt;span class="x"&gt;            ...&lt;/span&gt;
&lt;span class="x"&gt;        ),&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;
&lt;span class="x"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;urlManager是Yii使用的路由管理组件，其中的urlFormat指明使用path形式的路由，rules中的每一数组项即一个路由配置，路由配置数组的第一个元素（如aaa/bbb），
其中aaa为实际控制器类的名称(不包含Controller后缀)，bbb为控制器类aaa中实际动作方法的名称(不包含action前缀)，pattern元素指明当前路由配置项会处理的URL，
xxx为控制器名称，yyy为动作方法名称，这里可以看出HTTP API URL中的控制器名称、动作方法名称可以和实际的控制器类名称、动作方法名称不一样。verb元素指明
当前路由配置项会处理哪个或哪些HTTP谓词对URL“/xxx/yyy”的请求，多个谓词时以逗号分隔。&lt;/p&gt;
&lt;h5&gt;兼容方案&lt;/h5&gt;
&lt;p&gt;对于兼容方案，POST谓词原本是用来“新增”资源，那么对于相同的URL，POST谓词可能已经被占用，也即意味着谓词“DELETE”或“PUT”的“POST”兼容方案的API请求，也会被Yii框架路由到“新增”资源的处理逻辑，那么需要在“新增”资源的控制器类的beforeAction方法中，通过检查查询字符串参数_method，重新将请求路由到正确的
动作方法上，代码如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;protected function beforeAction($action)&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    $this-&amp;gt;requestMethod = Yii::app()-&amp;gt;request-&amp;gt;getRequestType();&lt;/span&gt;
&lt;span class="x"&gt;    // 兼容方案&lt;/span&gt;
&lt;span class="x"&gt;    // 带参数_method=DELETE的POST请求来代替DELETE请求&lt;/span&gt;
&lt;span class="x"&gt;    // 带参数_method=PUT的POST请求来代替PUT请求&lt;/span&gt;
&lt;span class="x"&gt;    if ($this-&amp;gt;requestMethod === &amp;#39;POST&amp;#39; &amp;amp;&amp;amp; isset($_POST[&amp;#39;_method&amp;#39;])) {&lt;/span&gt;
&lt;span class="x"&gt;        if ($_POST[&amp;#39;_method&amp;#39;] === &amp;#39;DELETE&amp;#39;) {&lt;/span&gt;
&lt;span class="x"&gt;            // 避免死循环&lt;/span&gt;
&lt;span class="x"&gt;            unset($_POST[&amp;#39;_method&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;forward($this-&amp;gt;getUniqueId() . &amp;#39;/delete&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        } elseif ($_POST[&amp;#39;_method&amp;#39;] === &amp;#39;PUT&amp;#39;) {&lt;/span&gt;
&lt;span class="x"&gt;            unset($_POST[&amp;#39;_method&amp;#39;]);&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;forward($this-&amp;gt;getUniqueId() . &amp;#39;/update&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;        } else {&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;echoJson(CodeStatus::WRONG_PARAM);&lt;/span&gt;
&lt;span class="x"&gt;            return false;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;响应码&lt;/h5&gt;
&lt;p&gt;对于API可能用到的所有响应码及其说明，我们使用一个单独的类来集中管理，以避免API中硬编码响应码，以及避免代码重复。如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CodeStatus&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;OK&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 成功&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;CREATED&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;201&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 创建成功&lt;/span&gt;

        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;REQUEST_WRONG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;TOKEN_WRONG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// token已过期或不存在&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;NOT_FOUND&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 资源不存在&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;LACK_PARAM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;423&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 缺少必要的请求参数&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;WRONG_PARAM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;425&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 请求参数不正确&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;DUPLICATE_RESOURCE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;426&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 已经存在相同的资源&lt;/span&gt;

        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;SYSTEM_ERROR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 系统异常&lt;/span&gt;

        &lt;span class="o"&gt;...&lt;/span&gt;

        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="nv"&gt;$status_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;OK&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;成功&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;CREATED&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;创建成功&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;TOKEN_WRONG&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;token已过期或不存在&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;LACK_PARAM&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;缺少必要的请求参数&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;SYSTEM_ERROR&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;系统异常&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;WRONG_PARAM&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;请求参数不正确&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;DUPLICATE_RESOURCE&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;已经存在相同的资源&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;NOT_FOUND&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;资源不存在&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;API中仅需使用CodeStatus类定义的常量成员即可（如CodeStatus::OK）。&lt;/p&gt;
&lt;h3&gt;推荐阅读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.github.com/v3/"&gt;Github API v3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/interagent/http-api-design"&gt;Heroku HTTP API Design Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="笔记"></category><category term="RESTful"></category></entry><entry><title>基于socket.io的实时消息推送</title><link href="http://youngsterxyf.github.io/2014/09/06/socket.io-push-server/" rel="alternate"></link><updated>2014-09-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-09-06:2014/09/06/socket.io-push-server/</id><summary type="html">&lt;p&gt;用户访问Web站点的过程是基于HTTP协议的，而HTTP协议的工作模式是：请求-响应，客户端发出访问请求，服务器端以资源数据响应请求。
也就是说，服务器端始终是被动的，即使服务器端的资源数据发生变化，如果没有来自客户端的请求，用户就不会看到这些变化。
这种模式是不适合某些应用场景的，比如在社交网络用户需要近乎实时地知道其他用户最新的信息。对于普通站点来说，
请求-响应模式可以满足绝大多数的功能需求，但总有某些功能我们希望能够为用户提供实时消息的体验。&lt;/p&gt;
&lt;p&gt;为解决这个问题，有两种方案可以选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仍旧使用请求-响应模式，只是增大请求的频率或者使用长连接，来达到尽可能接近实时的效果，如使用polling/long-polling，但可能会极大地增加服务器的负载压力或降低服务器的吞吐量&lt;/li&gt;
&lt;li&gt;使用新的协议，在服务器端有资源数据更新时，主动推送给客户端，如WebSocket，虽然这种思路也是使用了长连接，但效率更高，且是客户端服务器端之间的全双工通信。
问题在于目前各大浏览器并不都支持WebSocket。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么目前最好的方式就是结合以上两种方案，在不同的浏览器中，尽可能使用浏览器支持的最好的方案，即浏览器支持第二种方案时，优先使用第二种方案，否则使用第一种方案。socket.io就是这么做的，并且在服务器端和客户端对于不同的方案提供统一的接口。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在我们产品的站内信功能中，希望能够给在线用户实时推送公共消息或私有消息。考虑到以后可能还有其他功能需要实现实时消息推送，所以将实时消息推送实现为一个单独的服务。这种针对不同特性的功能进行解耦也为之后针对性的优化做了铺垫。&lt;/p&gt;
&lt;p&gt;解耦之后的系统结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="socket.io-push-server" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/socket.io-push-server.png" /&gt;&lt;/p&gt;
&lt;p&gt;当站点服务器(A)监测到资源数据更新事件发生时，先将数据推送到消息推送服务器(B)，B根据消息的类型以及消息的目标接收人来决定是否推送，如何推送。&lt;/p&gt;
&lt;p&gt;由于我们的Web后端是基于Yii框架实现，那么该如何实现A与B的socket.io服务通信呢？socket.io有自己的一套协议，如果自己实现PHP库来与socket.io服务交互，还有一些工作量。最终我们选择&lt;a href="https://github.com/oncesk/elephant.io"&gt;elephant.io这个PHP库&lt;/a&gt;，并将elephant.io封装为Yii框架的一个组件，实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class="nv"&gt;$basePath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Yii&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;getPathOfAlias&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;application.vendor.elephantio.lib.ElephantIO&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;require_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$basePath&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nx"&gt;DIRECTORY_SEPARATOR&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Client.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;require_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$basePath&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nx"&gt;DIRECTORY_SEPARATOR&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Payload.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nx"&gt;ElephantIO\Client&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nx"&gt;Elephant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;extElephantIO&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;CApplicationComponent&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nv"&gt;$host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nv"&gt;$port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nv"&gt;$namespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nv"&gt;$elephant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nv"&gt;$ioNameSpace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;host&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;port&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%s: %s: %s, Please give me parameters host and port&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;basename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="k"&gt;__FILE__&lt;/span&gt;
            &lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;__FUNCTION__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;__LINE__&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;setNameSpace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$nameSpace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;elephant&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;elephant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Elephant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;http://&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;host&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;
                &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;socket.io&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;elephant&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;ioNameSpace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;elephant&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;createFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$nameSpace&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;sendMsg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;ioNameSpace&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;namespace&lt;/span&gt; &lt;span class="o"&gt;!==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;ioNameSpace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;elephant&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;createFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;namespace&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%s: %s: %s, Please setNameSpace before sendMsg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;basename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="k"&gt;__FILE__&lt;/span&gt;
                &lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;__FUNCTION__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;__LINE__&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;ioNameSpace&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$msg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;elephant&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;elephant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将该代码文件放在应用目录extensions下，然后为Yii添加如下配置项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;#39;components&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;ElephantIO&amp;#39; =&amp;gt; array(&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;class&amp;#39; =&amp;gt; &amp;#39;application.extensions.extElephantIO&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;host&amp;#39; =&amp;gt; &amp;#39;xxx&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;        &amp;#39;port&amp;#39; =&amp;gt; xxx,&lt;/span&gt;
&lt;span class="x"&gt;    ),&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;
&lt;span class="x"&gt;),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当有资源数据变更事件产生时，如下调用向消息推送服务器发送消息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;$elephant = Yii::app()-&amp;gt;ElephantIO;&lt;/span&gt;
&lt;span class="x"&gt;$elephant-&amp;gt;setNameSpace(&amp;#39;/message_namespace&amp;#39;);&lt;/span&gt;
&lt;span class="x"&gt;$elephant-&amp;gt;sendMsg(&lt;/span&gt;
&lt;span class="x"&gt;    &amp;#39;message_event_type&amp;#39;,&lt;/span&gt;
&lt;span class="x"&gt;    $messageContent&lt;/span&gt;
&lt;span class="x"&gt;);       &lt;/span&gt;
&lt;span class="x"&gt;$elephant-&amp;gt;close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;对于私有消息推送，如何判断用户当前是否在线？如何验证用户的身份？&lt;/p&gt;
&lt;p&gt;可以基于cookie来实现，socket.io提供的浏览器端JS库，在每次连接时，和普通HTTP请求一样，会携带站点域名下的cookie（我们的消息推送服务的域名为站点服务器域名的子域，所以能拿到站点域名下的所有cookie），消息推送服务器在接收到连接(connection事件)请求时，从连接中取出所有cookie，然后向站点Web后端的某个API转发这些cookie，这个API根据cookie验证用户身份，并将用户信息返回给消息推送服务器，消息推送服务器根据用户信息存储当前连接对象，之后当站点服务器向消息推送服务器发送该用户的消息时，就通过该连接对象给用户推送消息。&lt;/p&gt;
&lt;p&gt;对于公有消息，即广播消息，实现则比较简单，直接向当前所有连接推送消息即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;也许有人会问，既然在某些浏览器中socket.io会退化为使用polling/long-polling来传输消息，那么相比直接向站点服务器进行polling/long-polling，有什么优势吗？&lt;/p&gt;
&lt;p&gt;我认为优势有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NodeJS的异步事件回调的方式，适合大并发长连接的应用场景。如果Web后端是使用PHP等实现，则更适合短连接的服务。&lt;/li&gt;
&lt;li&gt;将站点的业务逻辑与消息推送逻辑解耦，那么浏览器通过polling/long-polling来获取消息时，只是涉及消息推送逻辑，不需要执行业务逻辑的代码，而业务逻辑的代码可能很复杂，每次polling，都需要执行一遍的话，会浪费服务器很多资源。&lt;/li&gt;
&lt;/ol&gt;</summary><category term="socket.io"></category><category term="消息推送"></category><category term="笔记"></category></entry><entry><title>面向分布式系统工程师的分布式系统理论（译）</title><link href="http://youngsterxyf.github.io/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/" rel="alternate"></link><updated>2014-08-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-08-10:2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/"&gt;Distributed systems theory for the distributed systems engineer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gwen Shapira，大腕级的解决方案架构师（SA），如今Cloudera的全职工程师，在&lt;a href="https://twitter.com/gwenshap/status/497203248332165121"&gt;Twitter上提的一个问题&lt;/a&gt;引起了我的思考。&lt;/p&gt;
&lt;p&gt;如果是以前，我可能会回答“嗯，这里有篇FLP论文，这里有篇Paxos论文，这里还有篇拜占庭将军问题的论文...”，我会罗列一箩筐重要的材料，如果你一头扎进去，至少花费6个月的时间才能过一遍这些材料。然而我已逐渐明白推荐大量的理论性的论文通常恰恰是着手学习分布式系统理论的错误方式（除非你在做一个PhD项目）。论文通常比较深入难懂，需要认真地研习，通常还需要&lt;em&gt;大量的时间投入(significant experience)&lt;/em&gt;来理清这些论文的重要贡献，以及在整个理论体系中的位置。要求工程师具备这样的专业水平又有多大的意义呢？&lt;/p&gt;
&lt;p&gt;但是，很遗憾，对分布式系统理论方面的重大研究成果和思想进行概括、归纳、背景分析的‘导引’性质的优秀材料非常缺乏；特别是没有居高临下态度的材料。对这块空白区域的思考让我想到了另一个有趣的问题：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一个分布式系统工程师应该知道些什么分布式系统理论？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下，一知半解(a little theory)并不会是一件多危险的事情。因此我尝试整理一个列表，罗列出作为一个分布式系统工程师的我认为能够直接应用于我日常工作的一些基本概念；或者让分布式系统工程师完全有能力设计一个新系统的“筹码”。如果你认为我漏掉了一些东西，请联系我。&lt;/p&gt;
&lt;h4&gt;入门第一步&lt;/h4&gt;
&lt;p&gt;以下4篇材料出色地解释了构建分布式系统会遇到的一些挑战，共同概述了一系列分布式系统工程师必须要解决的技术上的难题，为之后章节中更深入的研究做好准备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://book.mixu.net/distsys/"&gt;好玩又实在的分布式系统理论&lt;/a&gt;是一本简短的书籍，其内容覆盖了分布式系统领域的一些基本议题，包括时间的作用及不同的复制策略。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/"&gt;为分布式系统领域新人整理的笔记&lt;/a&gt; - 不是理论对理论地讲述，而是做一个非常好非常实用的平衡，让你对其余材料的阅读能够落地。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.7628"&gt;分布式系统研究综述报告&lt;/a&gt; - 一篇经典的论文，解释了为什么不能将所有远程交互都模拟成和本地对象一样。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing"&gt;关于分布式计算的若干谬论&lt;/a&gt; - 分布式计算方面的8点谬论，提醒系统设计者可能会忘记的几类事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;失败和时间&lt;/h4&gt;
&lt;p&gt;分布式系统工程师需要面对的许多困难最终都可以归咎于两个潜在的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程可能会失败&lt;/li&gt;
&lt;li&gt;不存在一种好的方式来周知目前为止进程已经做了些什么&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程之间对于&lt;em&gt;时间&lt;/em&gt;的认知能共享些什么？哪些失败的场景是能够检测到？什么算法和原语可能被正确地实现？这三个问题有着非常深层的联系。多数时候，我们会假设两个不同节点之间对于时间概念或时间以什么样的速度逝去没有任何可共享的认知。&lt;/p&gt;
&lt;p&gt;你应该知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;失败模式的（部分）分层：&lt;a href="http://www.cse.psu.edu/~gcao/teach/513-00/c7.pdf"&gt;崩溃停止-&amp;gt;排除(omission)&lt;/a&gt;-&amp;gt;&lt;a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance"&gt;拜占庭容错&lt;/a&gt;。你应该理解：在高层次上可能发生的问题在低层次上肯定可能发生，在低层次上不可能发生的问题在高层次上也肯定不可能发生。&lt;/li&gt;
&lt;li&gt;在没有任何共享时钟的情况下如何判断在另一个事件之前是否产生了某事件。这意味着你需要理解&lt;a href="http://web.stanford.edu/class/cs240/readings/lamport.pdf"&gt;Lamport时钟&lt;/a&gt;及其一般化的&lt;a href="http://en.wikipedia.org/wiki/Vector_clock"&gt;向量始终&lt;/a&gt;，也需要阅读一下&lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf"&gt;这篇Dynamo论文&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;单个失败发生的可能性对于我们实现正确的分布式系统到底会有多大的影响（请阅读下面关于FLP结果的笔记）？&lt;/li&gt;
&lt;li&gt;不同的时间模型：同步、部分同步和异步（若我找到好的参考文献会添加链接）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;容错的基本矛盾&lt;/h4&gt;
&lt;p&gt;一个系统，若要不降级而容忍某些错误的发生，就必须能够好像那些错误没有发生一样地运作。这通常意味着系统的这些部分必须能够冗余地工作，但是非绝对必要地做更多的工作通常会在性能和资源耗用方面产生一些消耗。这是为系统添加容错带来的基本矛盾。&lt;/p&gt;
&lt;p&gt;你应该知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保单拷贝可串行化(single-copy serialisability)的仲裁(quorum)技术。可阅读&lt;a href="https://ecommons.library.cornell.edu/bitstream/1813/6323/1/82-483.pdf"&gt;Skeen的原始论文&lt;/a&gt;，但可能更建议阅读&lt;a href="http://en.wikipedia.org/wiki/Quorum_(distributed_computing)"&gt;这个Wikipedia词条&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;关于&lt;a href="http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/"&gt;两阶段提交&lt;/a&gt;、&lt;a href="http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/"&gt;三阶段提交&lt;/a&gt;和&lt;a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/"&gt;Paxos&lt;/a&gt;算法，以及为什么它们有不同的容错性质。&lt;/li&gt;
&lt;li&gt;最终一致性，及其他技术是如何以弱化对系统行为的保证为代价来尝试避免这种矛盾的。这篇&lt;a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf"&gt;Dynamo论文&lt;/a&gt;是一个很好的起点，同时Pat Helland的经典之作&lt;a href="http://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf"&gt;Life Beyond Transactions&lt;/a&gt;也是必读的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基本的原语&lt;/h4&gt;
&lt;p&gt;分布式系统中很少有大家一致认同的基本构建块，但越来越多地在出现。你应该以下的问题是什么，以及在哪可以找到它们的解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;群首选举(leader election)（例如&lt;a href="http://en.wikipedia.org/wiki/Bully_algorithm"&gt;Bully算法&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;一致的快照（例如Chandy和Lamport所写的&lt;a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf"&gt;经典论文&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;共识（阅读上文提到的关于2PC和Paxos的博文）&lt;/li&gt;
&lt;li&gt;分布式状态机复制（看看&lt;a href="http://en.wikipedia.org/wiki/State_machine_replication"&gt;Wikipedia&lt;/a&gt;就可以，但&lt;a href="http://research.microsoft.com/en-us/um/people/blampson/58-Consensus/Acrobat.pdf"&gt;Lampson的论文&lt;/a&gt;更权威，只是枯燥了点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基础结论&lt;/h4&gt;
&lt;p&gt;某些客观事实是需要内化于心的，以下是几个关键点（a flavour）（当然还有更多）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果进程之间可能丢失某些消息，那么不可能在实现一致性存储的同时能响应所有的请求。这就是&lt;a href="http://lpd.epfl.ch/sgilbert/pubs/BrewersConjecture-SigAct.pdf"&gt;CAP定理&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;以这样一种方式（a.始终是正确的、b.始终能终止-若在一个可能因失败崩溃停止(crash-* stop failures)的异步系统中有（甚至仅）一台机器失效时(FLP的结果)）。我希望在&lt;a href="http://www.slideshare.net/HenryRobinson/pwl-nonotes"&gt;洛杉矶题为Papers We Love报告&lt;/a&gt;的第一部分幻灯片-进行证明之前-已经合理地解释了这个结论。&lt;em&gt;建议：没有实际的必要理解这个证明。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;一般而言，消息交互少于两轮是不可能达成共识(Consensus)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;真实系统&lt;/h4&gt;
&lt;p&gt;最重要的练习是重复地阅读新兴的、真实系统的描述，并尝试评价它们的设计决策。一遍又一遍地这样去做。一些建议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/gfs-sosp2003.pdf"&gt;GFS&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/spanner-osdi2012.pdf"&gt;Spanner&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41344.pdf"&gt;F1&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/chubby-osdi06.pdf"&gt;Chubby&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/bigtable-osdi06.pdf"&gt;BigTable&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41378.pdf"&gt;MillWheel&lt;/a&gt;、&lt;a href="http://eurosys2013.tudos.org/wp-content/uploads/2013/paper/Schwarzkopf.pdf"&gt;Omega&lt;/a&gt;、&lt;a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf"&gt;Dapper&lt;/a&gt;、&lt;a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf"&gt;Paxos Made Live&lt;/a&gt;、&lt;a href="http://cacm.acm.org/magazines/2013/2/160173-the-tail-at-scale/abstract"&gt;The Tail At Scale&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Not Google:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://research.microsoft.com/en-us/projects/dryad/eurosys07.pdf"&gt;Dryad&lt;/a&gt;, &lt;a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf"&gt;Cassandra&lt;/a&gt;, &lt;a href="http://ceph.com/papers/weil-ceph-osdi06.pdf"&gt;Ceph&lt;/a&gt;, &lt;a href="https://ramcloud.stanford.edu/wiki/display/ramcloud/RAMCloud+Papers"&gt;RAMCloud&lt;/a&gt;, &lt;a href="http://hyperdex.org/papers/"&gt;HyperDex&lt;/a&gt;, &lt;a href="http://www.mpi-sws.org/~druschel/courses/ds/papers/cooper-pnuts.pdf"&gt;PNUTS&lt;/a&gt;&lt;/p&gt;</summary><category term="分布式系统"></category><category term="翻译"></category></entry><entry><title>技术问题一问一答</title><link href="http://youngsterxyf.github.io/2014/06/26/recently-technology-tips/" rel="alternate"></link><updated>2014-06-26T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-06-26:2014/06/26/recently-technology-tips/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何方便地删除某目录下所有空文件？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;find . -size 0 -exec rm {} \;&lt;/code&gt; 或 &lt;code&gt;find . -size 0 | xargs rm -f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;find默认会递归遍历所有子目录，如果想只在当前目录查找，可以添加参数&lt;code&gt;-prune&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何查看某进程打开了哪些文件？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先通过&lt;code&gt;ps aux | grep [进程名]&lt;/code&gt;找到该进程的进程号，然后&lt;code&gt;ls -la /proc/[进程号]/fd&lt;/code&gt;，输出不仅包含打开的普通文件。&lt;/p&gt;
&lt;p&gt;另一种不太直观的方法是使用lsof，&lt;code&gt;lsof -c [进程名]&lt;/code&gt;，但这个命令的输出包含进程打开的各种类型的文件，可以简单过滤一下&lt;code&gt;lsof -c [进程名] | grep REG&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何重启php-fpm？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;php5.3.3以上版本的php-fpm不再支持php-fpm以前具有的&lt;code&gt;php-fpm (start|stop|reload)&lt;/code&gt;等命令，需要使用信号控制。
master进程可以理解以下信号：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;INT, TERM 立刻终止&lt;/li&gt;
&lt;li&gt;QUIT 平滑终止&lt;/li&gt;
&lt;li&gt;USR1 重新打开日志文件&lt;/li&gt;
&lt;li&gt;USR2 平滑重载所有worker进程并重新载入配置和二进制模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么应该这样重启php-fpm：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kill -USR2 $(cat php-fpm.pid)&lt;/code&gt; 或 先&lt;code&gt;ps aux | grep php-fpm&lt;/code&gt;找到php-fpm主进程的进程号，然后&lt;code&gt;kill -USR2 [进程号]&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于Nginx、php-fpm等的日志文件使用shell脚本进行切分备份时，发现Nginx、php-fpm还是往备份的老文件中，而不是往新的access.log或error.log文件中写日志，如何解决？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;shell脚本中通常使用mv + touch 或 cp + touch的方式对日志文件进行备份。由于Nginx或php-fpm进程其实只知道日志文件打开后的文件描述符，而不知道打开的是哪个文件。使用mv或cp备份文件后，应该是修改了内核中文件描述符对应的文件路径（我猜的！），但Nginx或php-fpm并不知道现在该文件描述符指向的不再是原来的日志文件。所以解决方法就是通知Nginx或php-fpm根据配置重新打开日志文件。根据前一个问题，可知可以通过kill命令给进程发送USR1信号来实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;kill&lt;/span&gt; -USR1 &lt;span class="sb"&gt;`&lt;/span&gt;cat php-fpm.pid&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;kill&lt;/span&gt; -USR1 &lt;span class="sb"&gt;`&lt;/span&gt;cat nginx.pid&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作中使用git的分支模式进行协作开发，需要在测试服务器（HTTP Server使用Nginx，应用程序基于PHP的Yii框架实现）上为每个分支开一个测试环境，为了标识使用方便，希望使用同一个HTTP端口，不同的URL前缀标识不同的分支，如master分支的URL为/master/，其他分支的URL为/test/[分支名]/。该如何配置Nginx的虚拟主机？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们的应用使用Yii框架默认的URL风格(/?r=controller/action)，意味着所有非静态内容(非js、css、图片等)请求指向的服务器资源都是相同的（如&lt;code&gt;/&lt;/code&gt;或&lt;code&gt;/xxx/&lt;/code&gt;），而Yii框架的请求处理入口统一为一个index.php文件。Nginx有一个配置变量&lt;code&gt;$uri&lt;/code&gt;，保存着请求的URL（不带请求参数）。那么可以让所有分支的测试环境共用一个root，再将所有非静态内容请求重定向到&lt;code&gt;$uri/index.php&lt;/code&gt;就可以了。对于静态文件请求让其根据路径直接获取文件内容即可。但还有一个问题，怎么让分支代码中所有静态文件超链接都带上分支对应的URL前缀？可以通过为Yii配置一个名为url_prefix的参数，指定该分支所使用的URL前缀，然后在HTML模板（我们使用smarty来渲染）中让所有静态文件超链接都带上这个URL前缀参数。&lt;/p&gt;
&lt;p&gt;根据&lt;a href="http://www.yiiframework.com/doc/guide/1.1/en/quickstart.apache-nginx-config#nginx"&gt;Yii官方文档给出的Nginx虚拟主机配置&lt;/a&gt;进行修改得到我们需要的配置，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;listen 80;
server_name  localhost;

root html;
set $yii_bootstrap &amp;quot;index.php&amp;quot;;
location / {
    index index.html $yii_bootstrap;
    try_files $uri $uri/ $uri/$yii_bootstrap?$args;
}

location ~ ^/(protected|framework|themes/\w+/views) {
    deny all;
}

location ~ \.(js|css|png|jpg|gif|swf|ico|pdf|mov|fla|zip|rar)$ {
    try_files $uri =404;
}

location ~ \.php {
    fastcgi_split_path_info ^(.+\.php)(.*)$;

    set $fsn /$yii_bootstrap;
    if (-f $document_root$fastcgi_script_name){
        set $fsn $fastcgi_script_name;
    }

    fastcgi_pass 127.0.0.1:9000;
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root$fsn;

    fastcgi_param PATH_INFO $fastcgi_path_info;
    fastcgi_param PATH_TRANSLATED $document_root$fsn;
}

location ~ /\. {
    deny all;
    access_log off;
    log_not_found off;
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="笔记"></category></entry><entry><title>微信服务号开发笔记</title><link href="http://youngsterxyf.github.io/2014/06/14/wechat-service-account-development/" rel="alternate"></link><updated>2014-06-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-06-14:2014/06/14/wechat-service-account-development/</id><summary type="html">&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;微信服务号的原理比较简单。从请求响应角度来看，逻辑是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户微信客户端 &amp;lt;---&amp;gt; 微信服务器 &amp;lt;---&amp;gt; 微信服务号后台程序 &amp;lt;---&amp;gt; 数据库或Web Service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是，用户的各种请求先经过微信的服务器，微信服务器将请求转发给微信服务号后台程序。&lt;/p&gt;
&lt;p&gt;既然是微信服务器把用户请求数据转发给我们开发的微信服务号后台程序，那么在启用服务号的开发模式时就需要提供一个URL。另外为了安全
考虑，还需要提供一个token，用来校验请求是否来自微信服务器。校验的方法见&lt;a href="http://mp.weixin.qq.com/wiki/index.php?title=%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF%E7%9C%9F%E5%AE%9E%E6%80%A7"&gt;微信开发者文档&lt;/a&gt;。校验又分两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在开发者首次提交验证申请时，微信服务器将发送GET请求到填写的URL上，并且带上四个参数（signature、timestamp、nonce、echostr），开发者通过对签名（即signature）的效验，来判断此条消息的真实性。&lt;/p&gt;
&lt;p&gt;此后，每次开发者接收用户消息的时候，微信也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微信服务器转发到微信服务号后台程序的消息以及服务号后台程序返回给微信服务器的响应，都是XML格式，消息中都会指明发送者和接收者。
请求消息中的发送者为微信用户的openid，接收者为服务号开发者微信号，响应消息则相反。&lt;/p&gt;
&lt;p&gt;消息中还有一个关键字段MsgType指明消息类型。微信将请求消息分为：普通消息、事件推送、语音识别结果三大类，其中，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通消息分6种：文本、图片、语音、视频、地理位置、链接。&lt;/li&gt;
&lt;li&gt;事件推送分4种：关注/取消关注事件、扫描带参数二维码事件、上报地理位置事件、自定义菜单事件(点击菜单拉取消息时的事件推送、点击菜单跳转链接时的事件推送)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;响应消息也分6种：文本、图片、语音、视频、音乐、图文。&lt;/p&gt;
&lt;p&gt;工作中为产品开发的微信服务号，目前对于普通消息，服务号后台程序自动响应一段文本消息；对于事件推送中的关注事件，则是响应一段欢迎、
功能简介的文本消息。&lt;/p&gt;
&lt;p&gt;另外我们使用了自定义菜单事件，要想使用该事件，先要为你的微信服务号提供自定义菜单。自定义菜单是通过微信提供的API向其推送的。&lt;/p&gt;
&lt;p&gt;在通过API向微信服务器推送自定义菜单时，微信服务器需要确认是否为可信任请求，确认方法是基于请求参数access_token。
access_token需要通过API向微信服务器获取。成功启用服务号的开发模式后，微信会为服务号分配一个AppId和AppSecret，获取access_token时
需要带上这两个参数，用于微信服务器确认是否为已注册服务号的请求。access_token相关文档见&lt;a href="http://mp.weixin.qq.com/wiki/index.php?title=%E8%8E%B7%E5%8F%96access_token"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当成功获取access_token后就可以通过API创建、删除、查询服务号的自定义菜单了。&lt;/p&gt;
&lt;p&gt;自定义菜单相关文档见&lt;a href="http://mp.weixin.qq.com/wiki/index.php?title=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;以下Python代码是对自定义菜单API的简单封装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#coding: utf-8&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;WechatAdmin&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;app_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;app_secret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;access_token_file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;access_token.json&amp;#39;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;access_token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;access_token&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;access_token&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;access_token_file&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;access_token_file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;origin_content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;origin_content&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;update_time&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;origin_content&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_remote_fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;origin_content&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_remote_fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_remote_fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;target_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;amp;secret=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; \
                     &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;app_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;app_secret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target_url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;response_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;response_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;response_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;new_access_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expires_in&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;response_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;response_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;access_token_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;w+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;access_token&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;new_access_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;expires_in&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expires_in&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                               &lt;span class="s"&gt;&amp;#39;update_time&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()},&lt;/span&gt; &lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_access_token&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;响应内容不对！&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;非正常响应，&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create_menu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;menu_create_api&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
        &lt;span class="n"&gt;target_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu_create_api&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;(),)&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target_url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;非正常响应, &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_remote_fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_menu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fetch_menu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;target_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/menu/get?access_token=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;(),)&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target_url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;非正常响应，&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;, &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_remote_fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch_menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;delete_menu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;target_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;(),)&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target_url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;非正常响应, &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;, &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_remote_fetch_access_token&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delete_menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;wechat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;WechatAdmin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c"&gt;# print wechat.fetch_access_token()&lt;/span&gt;

    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;menus.json&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;wechat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_menu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

    &lt;span class="n"&gt;wechat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch_menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c"&gt;# wechat.delete_menu()&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;开发&lt;/h3&gt;
&lt;p&gt;对于微信服务号后台程序，当然可以参照微信官方文档，从头开始实现。但可用非官方微信公众号SDK也不少。比如我使用的PHP
SDK是&lt;a href="https://github.com/netputer/wechat-php-sdk"&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其他语言的SDK也可以找找看。&lt;/p&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我在启用微信服务号的开发模式之后，就直接使用该服务号进行开发测试，但在开发测试过程中，已经有一些产品的用户关注了该服务号，那么这个过程中用户的体验会很差。正确的过程应该是&lt;strong&gt;先申请测试帐号进行开发测试，等开发测试完成后，再上线服务号&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义菜单在变更之后并不是实时更新的，官方文档的说明是：&lt;em&gt;创建自定义菜单后，由于微信客户端缓存，需要24小时微信客户端才会展现出来。建议测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微信客户端应该是基于浏览器内核技术的，所以能解释渲染网页元素。图文消息中图片其实是一个img元素，所以需要你自己提供图床。微信官方的公众平台提供的消息发送功能，对于图文消息要求必须带图片，但服务号后台程序响应的图文消息中其实可以留空图片链接，这样用户收到图文消息看到的效果也许就是你需要的。另外，文本消息也是可以带超链接a元素的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="微信"></category><category term="PHP"></category><category term="笔记"></category></entry><entry><title>高流量站点NGINX与PHP-fpm配置优化（译）</title><link href="http://youngsterxyf.github.io/2014/05/03/optimizing-nginx-and-php-fpm-for-high-traffic-sites/" rel="alternate"></link><updated>2014-05-03T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-05-03:2014/05/03/optimizing-nginx-and-php-fpm-for-high-traffic-sites/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.softwareprojects.com/resources/programming/t-optimizing-nginx-and-php-fpm-for-high-traffic-sites-2081.html"&gt;Optimizing NGINX and PHP-fpm for high traffic sites&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Nginx搭配PHP已有7年的这份经历让我们学会如何为高流量站点优化NGINX和PHP-fpm配置。&lt;/p&gt;
&lt;p&gt;以下正是这方面的一些提示和建议：&lt;/p&gt;
&lt;h4&gt;1. 将TCP切换为UNIX域套接字&lt;/h4&gt;
&lt;p&gt;UNIX域套接字相比TCP套接字在loopback接口上能提供更好的性能（更少的数据拷贝和上下文切换）。&lt;/p&gt;
&lt;p&gt;但有一点需要牢记：仅运行在同一台服务器上的程序可以访问UNIX域套接字（显然没有网络支持）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;upstream backend
{
    # UNIX domain sockets
    server unix:/var/run/fastcgi.sock;

    # TCP sockets
    # server 127.0.0.1:8080;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2. 调整工作进程数&lt;/h4&gt;
&lt;p&gt;现代计算机硬件是多处理器的，NGINX可以利用多物理或虚拟处理器。&lt;/p&gt;
&lt;p&gt;多数情况下，你的Web服务器都不会配置为处理多种任务（比如作为Web服务器提供服务的同时也是一个打印服务器），你可以配置NGINX使用所有可用的处理器，NGINX工作进程并不是多线程的。&lt;/p&gt;
&lt;p&gt;运行以下命令可以获知你的机器有多少个处理器：&lt;/p&gt;
&lt;p&gt;Linux上 -&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat /proc/cpuinfo &lt;span class="p"&gt;|&lt;/span&gt; grep processor
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FreeBSD上 -&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sysctl dev .cpu &lt;span class="p"&gt;|&lt;/span&gt; grep location
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将nginx.conf文件中work_processes的值设置为机器的处理器核数。&lt;/p&gt;
&lt;p&gt;同时，增大worker_connections（每个处理器核心可以处理多少个连接）的值，以及将"multi_accept"设置为ON，如果你使用的是Linux，则也使用"epoll"：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# We have 16 cores
worker_processes 16;

# connections per worker
events
{
    worker_connections 4096;
    multi_accept on;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3. 设置upstream负载均衡&lt;/h4&gt;
&lt;p&gt;以我们的经验来看，同一台机器上多个upstream后端相比单个upstream后端能够带来更高的吞吐量。&lt;/p&gt;
&lt;p&gt;例如，如果你想支持最大1000个PHP-fpm子进程（children），可以将该数字平均分配到两个upstream后端，各自处理500个PHP-fpm子进程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;upstream backend {
    server unix:/var/run/php5-fpm.sock1 weight=100 max_fails=5 fail_timeout=5;
    server unix:/var/run/php5-fpm.sock2 weight=100 max_fails=5 fail_timeout=5;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以下是两个来自php-fpm.conf的进程池：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;section name=&amp;quot;pool&amp;quot;&amp;gt;

    &amp;lt;value name=&amp;quot;name&amp;quot;&amp;gt;www1&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;listen_address&amp;quot;&amp;gt;/var/run/php5-fpm.sock1&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;listen_options&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;backlog&amp;quot;&amp;gt;-1&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;owner&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;mode&amp;quot;&amp;gt;0666&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;user&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;pm&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;style&amp;quot;&amp;gt;static&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;max_children&amp;quot;&amp;gt;500&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;rlimit_files&amp;quot;&amp;gt;50000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;rlimit_core&amp;quot;&amp;gt;0&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;request_slowlog_timeout&amp;quot;&amp;gt;20s&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;slowlog&amp;quot;&amp;gt;/var/log/php-slow.log&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chroot&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chdir&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;catch_workers_output&amp;quot;&amp;gt;no&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;max_requests&amp;quot;&amp;gt;5000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;allowed_clients&amp;quot;&amp;gt;127.0.0.1&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;environment&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;HOSTNAME&amp;quot;&amp;gt;$HOSTNAME&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;PATH&amp;quot;&amp;gt;/usr/local/bin:/usr/bin:/bin&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMPDIR&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TEMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;OSTYPE&amp;quot;&amp;gt;$OSTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MACHTYPE&amp;quot;&amp;gt;$MACHTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MALLOC_CHECK_&amp;quot;&amp;gt;2&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

&amp;lt;/section&amp;gt;

&amp;lt;section name=&amp;quot;pool&amp;quot;&amp;gt;

    &amp;lt;value name=&amp;quot;name&amp;quot;&amp;gt;www2&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;listen_address&amp;quot;&amp;gt;/var/run/php5-fpm.sock2&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;listen_options&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;backlog&amp;quot;&amp;gt;-1&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;owner&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;mode&amp;quot;&amp;gt;0666&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;user&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;group&amp;quot;&amp;gt;www&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;pm&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;style&amp;quot;&amp;gt;static&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;max_children&amp;quot;&amp;gt;500&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;rlimit_files&amp;quot;&amp;gt;50000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;rlimit_core&amp;quot;&amp;gt;0&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;request_slowlog_timeout&amp;quot;&amp;gt;20s&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;slowlog&amp;quot;&amp;gt;/var/log/php-slow.log&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chroot&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;chdir&amp;quot;&amp;gt;&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;catch_workers_output&amp;quot;&amp;gt;no&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;max_requests&amp;quot;&amp;gt;5000&amp;lt;/value&amp;gt;
    &amp;lt;value name=&amp;quot;allowed_clients&amp;quot;&amp;gt;127.0.0.1&amp;lt;/value&amp;gt;

    &amp;lt;value name=&amp;quot;environment&amp;quot;&amp;gt;
        &amp;lt;value name=&amp;quot;HOSTNAME&amp;quot;&amp;gt;$HOSTNAME&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;PATH&amp;quot;&amp;gt;/usr/local/bin:/usr/bin:/bin&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TMPDIR&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;TEMP&amp;quot;&amp;gt;/usr/tmp&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;OSTYPE&amp;quot;&amp;gt;$OSTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MACHTYPE&amp;quot;&amp;gt;$MACHTYPE&amp;lt;/value&amp;gt;
        &amp;lt;value name=&amp;quot;MALLOC_CHECK_&amp;quot;&amp;gt;2&amp;lt;/value&amp;gt;
    &amp;lt;/value&amp;gt;

&amp;lt;/section&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4. 禁用访问日志文件&lt;/h4&gt;
&lt;p&gt;这一点影响较大，因为高流量站点上的日志文件涉及大量必须在所有线程之间同步的IO操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;access_log off;
log_not_found off;
error_log /var/log/nginx-error.log warn;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若你不能关闭访问日志文件，至少应该使用缓冲：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;access_log /var/log/nginx/access.log main buffer=16k;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;5. 启用GZip&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gzip on;
gzip_disable &amp;quot;msie6&amp;quot;;
gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_min_length 1100;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;6. 缓存被频繁访问的文件相关的信息&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;open_file_cache max=200000 inactive=20s;
open_file_cache_valid 30s;
open_file_cache_min_uses 2;
open_file_cache_errors on;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;7. 调整客户端超时时间&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;client_max_body_size 500M;
client_body_buffer_size 1m;
client_body_timeout 15;
client_header_timeout 15;
keepalive_timeout 2 2;
send_timeout 15;
sendfile on;
tcp_nopush on;
tcp_nodelay on;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;8. 调整输出缓冲区大小&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fastcgi_buffers 256 16k;
fastcgi_buffer_size 128k;
fastcgi_connect_timeout 3s;
fastcgi_send_timeout 120s;
fastcgi_read_timeout 120s;
reset_timedout_connection on;
server_names_hash_bucket_size 100;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;9. /etc/sysctl.conf调优&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# Recycle Zombie connections
net.inet.tcp.fast_finwait2_recycle=1
net.inet.tcp.maxtcptw=200000

# Increase number of files
kern.maxfiles=65535
kern.maxfilesperproc=16384

# Increase page share factor per process
vm.pmap.pv_entry_max=54272521
vm.pmap.shpgperproc=20000

# Increase number of connections
vfs.vmiodirenable=1
kern.ipc.somaxconn=3240000
net.inet.tcp.rfc1323=1
net.inet.tcp.delayed_ack=0
net.inet.tcp.restrict_rst=1
kern.ipc.maxsockbuf=2097152
kern.ipc.shmmax=268435456

# Host cache
net.inet.tcp.hostcache.hashsize=4096
net.inet.tcp.hostcache.cachelimit=131072
net.inet.tcp.hostcache.bucketlimit=120

# Increase number of ports
net.inet.ip.portrange.first=2000
net.inet.ip.portrange.last=100000
net.inet.ip.portrange.hifirst=2000
net.inet.ip.portrange.hilast=100000
kern.ipc.semvmx=131068

# Disable Ping-flood attacks
net.inet.tcp.msl=2000
net.inet.icmp.bmcastecho=1
net.inet.icmp.icmplim=1
net.inet.tcp.blackhole=2
net.inet.udp.blackhole=1
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;10. 监控&lt;/h4&gt;
&lt;p&gt;持续监控打开连接的数目，空闲内存以及等待状态线程的数目。&lt;/p&gt;
&lt;p&gt;设置警报在超出阈值时通知你。你可以自己构建这些警报，或者使用类似&lt;a href="http://serverdensity.io"&gt;ServerDensity&lt;/a&gt;的东西。&lt;/p&gt;
&lt;p&gt;确认安装了NGINX的&lt;a href="http://wiki.nginx.org/HttpStubStatusModule"&gt;stub_status&lt;/a&gt;模块。该模块默认并不会编译进NGINX，所以可能你需要重新编译NGINX -&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./configure --with-http_ssl_module --with-http_stub_status_module --without-mail_pop3_module
--without-mail_imap_module --without-mail_smtp_module
make install BATCH=yes
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Nginx"></category><category term="PHP"></category><category term="服务器"></category></entry><entry><title>Firefox中“max-width:100%”不兼容问题</title><link href="http://youngsterxyf.github.io/2014/04/28/max-width-in-firefox/" rel="alternate"></link><updated>2014-04-28T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-04-28:2014/04/28/max-width-in-firefox/</id><summary type="html">&lt;p&gt;这个博客是基于“&lt;a href="http://docs.getpelican.com/en/3.3.0/"&gt;Pelican&lt;/a&gt; + &lt;a href="http://wowubuntu.com/markdown/"&gt;Markdown&lt;/a&gt; +
&lt;a href="https://github.com/youngsterxyf/my-pelican-themes/tree/master/my-gum"&gt;定制的my-gum主题&lt;/a&gt;”的。定制的主题将博文正文页面的
右边栏去掉，这导致在Firefox等浏览器中，正文中大的图片会突破正文块的宽度，高度也得不到限制，显示效果非常差。&lt;/p&gt;
&lt;p&gt;其原因是：Markdown的&lt;a href="http://wowubuntu.com/markdown/#img"&gt;图片区块元素&lt;/a&gt;&lt;code&gt;![Alt
text](/path/to/img.jpg)&lt;/code&gt;渲染成HTML元素的结果为 -&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;img&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/path/to/img.jpg&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;alt=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Alt text&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/img&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素内的元素是行内(inline)元素。主题my-gum使用的CSS框架&lt;a href="http://gumbyframework.com/"&gt;gumby&lt;/a&gt;对img元素是使用&lt;code&gt;max-width:
100%&lt;/code&gt;将图片的最大宽度限制为父元素的宽度。但&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/max-width"&gt;在Firefox中max-width对于行内元素并不会生效(all elements but non-replaced 
inline elements, table rows, and row
groups)&lt;/a&gt;，所以造成了显示问题。&lt;/p&gt;
&lt;p&gt;网络上有人说可以用&lt;code&gt;width: 100%&lt;/code&gt;替代之，但&lt;code&gt;width: 100%&lt;/code&gt;和&lt;code&gt;max-width: 100%&lt;/code&gt;的区别是：&lt;code&gt;width: 100%&lt;/code&gt;是将所有指定元素的宽度
拉伸或收缩到和父元素的宽度一致，而&lt;code&gt;max-width:
100%&lt;/code&gt;则是如果指定元素的宽度不超过父元素的宽度，则大小不变，如果超过了父元素的宽度，则将宽度收缩为父元素的宽度。如果使用&lt;code&gt;width:
100%&lt;/code&gt;，那么我博文中的图片，即使再小，都会被拉伸为正文的宽度，自然是不会好看的。&lt;/p&gt;
&lt;p&gt;我的想法是：既然使用CSS不能解决这个问题，那就尝试使用Javascript。当图片加载完毕后，将图片宽度与正文宽度做比较，如果
图片宽度大于正文宽度，则为该图片设置&lt;code&gt;width: 100%&lt;/code&gt;。唯一不完美的地方是某些大图片加载完毕之前的宽度很大，比较难看。&lt;/p&gt;
&lt;p&gt;代码如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;entryContentWidth&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;.row&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;width&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;.entry-content img&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;load&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;width&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;entryContentWidth&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;width&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;100%&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/14550356/image-mysteriously-ignoring-max-width-in-firefox-ie"&gt;Image mysteriously ignoring max-width in Firefox &amp;amp; IE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2789727/is-p-a-block-level-or-inline-level-element"&gt;is &amp;lt;p&gt; a block-level or inline-level element?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/max-width"&gt;MDN - max-width&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://api.jquery.com/load-event/"&gt;JQuery - load event&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="CSS"></category><category term="浏览器兼容"></category><category term="JavaScript"></category></entry><entry><title>Windows命令提示符中统计行数（译）</title><link href="http://youngsterxyf.github.io/2014/03/05/counting-lines-in-cmd/" rel="alternate"></link><updated>2014-03-05T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-03-05:2014/03/05/counting-lines-in-cmd/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://rickardnobel.se/counting-lines-in-windows-command-prompt/"&gt;Counting lines in Windows command prompt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用内置工具FIND统计cmd.exe输出的行数非常方便！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在命令行环境中工作时，能够统计不同工具的输出结果的行数有时会非常有用。许多Unix/Linux操作系统都包含带有许多功能选项的&lt;strong&gt;wc&lt;/strong&gt;
工具，Windows则没有内置一样的替代品，但是Windows命令提示符(cmd.exe)原生支持了部分相同功能。&lt;/p&gt;
&lt;p&gt;本文将讲述在cmd.exe中我们可以如何使用&lt;strong&gt;FIND&lt;/strong&gt;工具来统计行数。工具find，有些类似于Unix上的grep，自MS-DOS以来就一直存在，
使用简单。&lt;/p&gt;
&lt;p&gt;假设我们有一台Windows服务器，想看看当前有多少个活跃的TCP会话。这可以使用netstat命令，并且通过管道连接FIND来查找已建立的会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;netstat -ano | find /i "estab"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="established-TCP-2.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/established-TCP-2.png" /&gt;&lt;/p&gt;
&lt;p&gt;这行命令的输出可能会有几百行以至于占满整个命令提示符窗口，而我们可能仅仅关心会话的数目。通过在这行命令之后增加一个&lt;strong&gt;/c&lt;/strong&gt;开关选项，
我们就能得到打开的TCP会话的数目。&lt;/p&gt;
&lt;p&gt;我们仍然使用上一个命令的过滤规则（通过查找字符串“estab”来找到包含ESTABLISHED状态的行）但带有/c，这样就会仅显现匹配行的数目。&lt;/p&gt;
&lt;p&gt;&lt;img alt="established-TCP.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/established-TCP.png" /&gt;&lt;/p&gt;
&lt;p&gt;如下另一个示例则是查看本地缓存的DNS记录的数目。&lt;/p&gt;
&lt;p&gt;&lt;img alt="displaydns.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/displaydns.png" /&gt;&lt;/p&gt;
&lt;p&gt;选项/c也可以用于统计一个命令输出的所有行。例如，我们想知道目录服务(Active Directory)中分组的数目。通过一个管道连接到&lt;strong&gt;FIND /v "" /c&lt;/strong&gt;，
我们能统计所有不匹配(&lt;strong&gt;/v&lt;/strong&gt;)空字符串（""）的行（即非空白行）。如果你使用过Unix工具wc，这就相当于&lt;strong&gt;wc -l&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="find-group-2.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/find-group-2.png" /&gt;&lt;/p&gt;
&lt;p&gt;另一个示例是：事件查看器命令行工具&lt;strong&gt;wevtutil&lt;/strong&gt;会输出大量日志数据行。如果仅仅想知道现代Windows系统中不同日志的数目，我们可以将几百个日志文件的文件名
通过管道传输给&lt;code&gt;FIND /v "" /c&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="wevutil.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/wevutil.png" /&gt;&lt;/p&gt;
&lt;p&gt;最后一个示例是：假设有一个日志文件或者类似文件，总共有上千行内容。我们想快速知道包含特定短语的数据行的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TYPE C:\Windows\Schedlgu.txt | FIND /i "task failure" /c&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;相关阅读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc725655.aspx"&gt;Technet - Find&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.robvanderwoude.com/type.php"&gt;The TYPE command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc732507.aspx"&gt;Technet - Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc732848.aspx"&gt;Technet - Wevtutil&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://technet.microsoft.com/en-us/library/cc732952.aspx"&gt;Technet - Dsquery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Windows"></category><category term="翻译"></category></entry><entry><title>读书笔记：Web容量规划的艺术</title><link href="http://youngsterxyf.github.io/2014/02/25/read-the-art-of-capacity-planning/" rel="alternate"></link><updated>2014-02-25T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-02-25:2014/02/25/read-the-art-of-capacity-planning/</id><summary type="html">&lt;h3&gt;第1章 容量规划的目标、问题和过程&lt;/h3&gt;
&lt;p&gt;了解你的基础设施中每一部分何时会失败（最好不发生）对容量规划至关重要。&lt;/p&gt;
&lt;p&gt;假设你有一台数据库服务器用于响应从前端Web服务器提交过来的查询。容量规划意味着你应该知道下述问题的答案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑到特定的硬件配置，数据库服务器每秒可管理多少个查询？&lt;/li&gt;
&lt;li&gt;在性能降低到影响终端用户体验之前，它每秒可应答多少次查询？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;性能与容量：两种不同的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能调优是优化已经存在的性能。容量规划通过使用当前性能做为基线决定你的系统需要什么以及什么时候需要。&lt;/p&gt;
&lt;p&gt;当面对容量问题的时候，试着少花精力使已存在的设备运行更快，而是关注当下要解决的重点：找出你到底需要什么，什么时候需要。&lt;/p&gt;
&lt;p&gt;权衡对已有系统进行调优所花的人力时间，可能简简单单的买更多的硬件是正确的。在最优化和容量扩展方面的权衡是一个挑战，并且因环境而异。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网站的架构和架构对容量方面的影响&lt;/p&gt;
&lt;p&gt;你的驾车风格会影响到你的车的里程，类似的原理能够应用于网站的架构上。在本书中一个反复出现的主题是你的网站架构对于如何使用、消耗
和管理容量产生重大影响。在有效使用容量上，相比于调整和改变你的服务器和网络，设计能带来更大的影响。同时，随着需求的出现如何方便和灵活
地进行增加或者减少容量，也是设计能带来的重要作用。&lt;/p&gt;
&lt;p&gt;调整架构以便更容易容量管理。保持你的架构易于分割和分段，可以帮助你处理大量的负载特性问题---即在你创建了一个需要增长什么和何时增长的准确规划之前，
你需要解决的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过开放API所提供的Web服务引入了另一个逐渐扩大的问题，因为你的应用程序数据会被更多的应用程序访问，它们也都有自己的使用和增长模式。
这也意味着用户可以方便地滥用系统，从而将更多不确定因素放入容量公式中。API的使用情况需要监控，以观察新出现的模式。&lt;/p&gt;
&lt;p&gt;容量规划可以变得非常重要，但是并不困难，你所需要做的只是稍微关注一下正确因素。容量规划的过程可分解为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设定你的目标&lt;/li&gt;
&lt;li&gt;收集对应的指标并找出你所面临的限制&lt;/li&gt;
&lt;li&gt;绘制趋势并根据那些指标和限制做出预测&lt;/li&gt;
&lt;li&gt;容量部署和管理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第2章 设定容量目标&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;服务等级协议(SLA)&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;服务等级协议百分比和可接受的宕机时间&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;正常运行服务等级协议      每年的宕机时间&lt;/p&gt;
&lt;p&gt;90.0%                       36天12小时&lt;/p&gt;
&lt;p&gt;95.0%                       18天6小时&lt;/p&gt;
&lt;p&gt;99.0%                       87小时36分钟&lt;/p&gt;
&lt;p&gt;99.50%                      43小时48分钟&lt;/p&gt;
&lt;p&gt;99.90%                      8小时45分钟36秒&lt;/p&gt;
&lt;p&gt;99.99%                      52分钟33秒&lt;/p&gt;
&lt;p&gt;99.999%                     5分钟15秒&lt;/p&gt;
&lt;p&gt;99.9999%                    32秒&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;业务容量需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在当今Web 2.0这样的网络现象中，由于大多数Web服务为个人应用程序开发者提供开放的API接口，以建立基于他们的B2B关系。因此，很多企业
通常把收入流寄托于方便的使用API。这也意味着企业关系依赖于一定程度的API的可用性或者性能，以可用性百分比来测量或者经过协商的API请求的频率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构决策&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的架构是关于你所有的后端组件（包括硬件和软件）是怎样结合的基本的设计。架构的设计对于规划和管理容量起到至关重要的作用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;推荐书籍：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Building Scalable Web Sites (《构建可扩展网站》)&lt;/li&gt;
&lt;li&gt;Scalable Internet Architectures (《可扩展的网络架构》)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;提供测量点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是为了测量的目的，还是对变化的环境快速响应，你都希望你的架构设计完美，以便你能将它分割成不同的部分来执行离散的任务。
在一个理想的情况下，后端的每个组件都有一个单独的工作要做，但如果需要，它也可以很好地执行多个工作。同时，它对每个工作的影响也可以很容易的被测量。&lt;/p&gt;
&lt;p&gt;你会发现，简单的架构改变可以帮助你理解你的容量被使用的用途是什么。当你在考虑架构设计时，一定要记住：分工以及“分块、松耦合”原理，
可以一直在你的站点是如何被使用的方面给你一些线索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬件决策(垂直缩放比例、水平缩放比例、对角缩放比例)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为你架构中的每一个部件选择正确的硬件可以对成本产生很大影响。&lt;/p&gt;
&lt;p&gt;能够横向扩展意味着该架构能简单地通过在现有的基础设施上添加相同功能的网络节点从而达到增加容量的目的。&lt;/p&gt;
&lt;p&gt;能够纵向扩展则是指一种通过在服务器内部添加硬件资源从而达到扩充容量目的。这些硬件资源包括CPU、内存、硬盘和网络。&lt;/p&gt;
&lt;p&gt;对角扩展是指对基础设施中已有的横向扩展节点进行纵向扩展的过程。&lt;/p&gt;
&lt;h3&gt;第3章 测量：容量的单位&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;认可测量本身带来的影响&lt;/p&gt;
&lt;p&gt;为了采集和传输度量指标，一些系统资源就会被消耗。好的监测工具努力做得很轻量，不妨碍系统的主要工作，但是总会有一些额外开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;监测可作为识别紧急问题的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们的站点出现错误的时候，如果能够迅速地获取状态信息是非常重要的。可能你想能够得到如下这些问题的快速回答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是什么错误？&lt;/li&gt;
&lt;li&gt;错误是何时发生的？&lt;/li&gt;
&lt;li&gt;是什么引发了错误？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡器基于一个相对简短的算法列表来建立负载分发，使得你能指定协议来达到跨越所有可用的服务器均衡地处理流量。&lt;/p&gt;
&lt;p&gt;就我们的目的而言，负载均衡器为容量管理提供了一个非常理想的框架，因为通过它可以在生产环境中方便地进行容量的伸缩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序监测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器统计数据只是描绘了容量图的一部分。你还应该特别针对你的应用程序，测量并记录高级别的度量指标---不是针对一个服务器，而是对整个系统。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;数据库容量&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;基本的服务器统计数据之外，还有一些数据库特定的指标你需要跟踪：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每秒的查询（SELECT, INSERT, UPDATE, 和DELETE）&lt;/li&gt;
&lt;li&gt;当前打开的连接数&lt;/li&gt;
&lt;li&gt;复制时主从数据库之间的滞后时间&lt;/li&gt;
&lt;li&gt;高速缓存命中率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;规划数据库（特别是集群的数据库）的容量需求是一件棘手的事情。确定你数据库的性能上限非常困难，因为可能有些隐藏的极端问题仅在一些边缘情况下才会暴露出来。&lt;/p&gt;
&lt;p&gt;但对于数据库而言，性能调优是非常重要的。数据库的性能通常更多依赖于你的方案和查询而不是硬件的速度。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;缓存系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在Web架构中，缓存最经常被用于存储数据库结果（比如用Memcached）或实际文件（比如用Squid和Varnish）。&lt;/p&gt;
&lt;p&gt;影响缓存容量的两个主要因素是你的工作集的大小，以及你的数据动态变化的程度。缓存有一个固定的大小。可缓存对象的工作集是指在给定时期内请求的独特对象的数目---不管数据库结果还是文件。
理想的情况是，你将拥有足够的缓存容量来处理整个工作集。这意味着绝大多数的缓存请求会命中。&lt;/p&gt;
&lt;p&gt;在Flickr，我们使用Squid作为反向代理来缓存照片。我们使用更慢、更便宜、更大容量的磁盘来存储照片，但是利用缓存系统来提供照片，这些缓存系统使用的是更小但更快的磁盘。
随着照片请求率增长，我们横向扩展缓存服务器的数量。随着照片数量的增长，我们还横向扩展后台存储的数量。&lt;/p&gt;
&lt;p&gt;跟踪任何缓存软件最重要的度量指标是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存命中率&lt;/li&gt;
&lt;li&gt;总请求率&lt;/li&gt;
&lt;li&gt;对象平均时间&lt;/li&gt;
&lt;li&gt;LRU参考时间(当使用LRU方法时)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;API的使用率及其对容量的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一些方法来测量并记录每个用户或者每个请求方法对开放的API的使用量，这对于那些提供API接口的网站进行容量跟踪，应被视为必须的。
通常通过独特的API key，或者是其他独特的凭据来进行。每次调用API，通过key就能识别出应用程序和负责构建应用程序的开发者。&lt;/p&gt;
&lt;p&gt;因为产生大量的API调用比使用常规的客户端浏览器要容易得多，你应该跟踪哪个应用程序正在以何种速率调用什么API。&lt;/p&gt;
&lt;p&gt;在Flickr，我们根据在服务条款中列出的规定，使那些看起来滥用API的key自动失效。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;基础架构的每一部分都将花费系统资源来为网站服务，你应该确保对这些资源进行适当的测量。然而，记录正确的测量并不足够。
你还需要知道何时那些资源将耗尽，这也是为什么你需要定期地探测并建立这些上限。&lt;/p&gt;
&lt;p&gt;通过寻找基础架构上限的实践过程，可暴露出你甚至不知道的瓶颈。基于此，你可能需要改变应用程序、硬件、网络或造成问题的其他部分。
每次你对基础架构做一次修改，都需要再次检查上限，因为它们也很有可能改变。这不应该令人惊奇，因为现在你知道容量规划是一个过程，而不是一次性的事件。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;没有测量系统、应用层度量指标的历史数据，则容量规划无法存在。不知道系统的最高性能上限从而避免接近它们，则规划也是没有效果的。
要找到基础架构每部分的上限，需要下面这些步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测量和记录服务器的主要功能。&lt;em&gt;例如：Apache命中，数据库查询&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;测量和记录服务器的基础硬件资源。&lt;em&gt;例如：CPU、内存、硬盘、网络使用量&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;判断服务器的主要功能如何与其硬件资源相关联。&lt;em&gt;例如：N个数据库查询占用M%的CPU使用量&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;通过以下方法之一，基于服务器的主要功能和硬件资源，找到可接受的最大资源使用量（或上限）：&lt;ul&gt;
&lt;li&gt;通过使用负载均衡或应用程序技术，人工（而小心）增加真实的生产负载到服务器。&lt;/li&gt;
&lt;li&gt;尽可能确切地模拟一个真实的生产负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第4章 趋势预测&lt;/h3&gt;
&lt;p&gt;预测容量需求部分靠直觉，部分靠数学。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;曲线拟合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容量预测的整体过程非常简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定、测量和绘制对每个资源定义的度量指标 &lt;em&gt;例如：磁盘消耗&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;对你拥有的资源应用约束限制 &lt;em&gt;例如：总可用磁盘空间&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;使用趋势分析（曲线拟合）说明何时你的使用量会超出限制 &lt;em&gt;例如：找出磁盘空间耗尽的日期&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;第5章 部署&lt;/h3&gt;
&lt;p&gt;&lt;img alt="racp-5.1" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/tacp-fig-5.1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;附录A 虚拟化和云计算&lt;/h3&gt;
&lt;p&gt;容量规划的两个目标：一是以最有效的方式来利用你手头上所拥有的资源，二是根据目前的使用模式来预测未来需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟化指的是一台计算机的不同层面的计算资源的抽象。实际中，虚拟化通常用于描述OS（操作系统）的抽象。&lt;/p&gt;
&lt;h3&gt;附录B 对瞬时增长的处理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;减轻失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下的方法是针对那些最坏情况的场景，当所有其他增加容量的选择都不起作用，并且从根本上改变基础设施本身是不可能的时候。
应该说这种救火似的场景是容量规划所应该极力避免的；但是有些时候它确实是不可避免的。&lt;/p&gt;
&lt;p&gt;以下列出的方法并非万能的，当暴发的访问流量来临并且你的服务器在负载下正要挂掉时，能对你有所帮忙。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;禁用重量级的功能&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种可能的方法就是禁用站点的一些重量级功能。将打开或者关闭一些功能的能力内建到系统中将帮助你对容量问题做出更加有效的响应，
即使是在那些重大的流量问题事件中。拥有一个快捷的，只有一行简单的打开或者关闭的配置参数在你的应用程序中是有巨大价值的，
特别是当该功能就是问题的起因或者是造成不可接受性能的时候。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;烘烤过的静态页面&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那些遭遇非常严重流量问题的网站经常采用的另一种技术就是将动态页面转变为静态页面。这可能会很简单也可能会很难，这取决于页面到底有多动态，
但你可以保守的只将那些最常被访问的页面或者动态性最少的页面转换为静态页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;缓存&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;附录C 容量工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Ganglia, http://ganglia.sourceforge.net/&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nagios, http://www.nagios.org/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dstat，系统统计工具模块化，http://dag.wiee.rs/home-made/dstat/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fabric, http://docs.fabfile.org/, https://github.com/fabric/fabric&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="笔记"></category><category term="容量规划"></category></entry><entry><title>如何实现Golang的http请求处理中间件（译）</title><link href="http://youngsterxyf.github.io/2014/01/17/golang-http-handlers-as-middleware/" rel="alternate"></link><updated>2014-01-17T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-17:2014/01/17/golang-http-handlers-as-middleware/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://capotej.com/blog/2013/10/07/golang-http-handlers-as-middleware/"&gt;Golang Http Handlers as Middleware&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数现代Web组件栈允许通过栈式/组件式中间件“过滤”请求，这样就能干净地从web应用中分离出横切关注点（译注：面向方面程序设计中的概念？）。
本周我尝试在Go语言的&lt;code&gt;http.FileServer&lt;/code&gt;中植入钩子，发现实现起来十分简便，让我非常惊讶。&lt;/p&gt;
&lt;p&gt;让我们从一个基本的文件服务器开始说起：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ListenAndServe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;:8080&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;FileServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Dir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段程序会在端口8080上开启一个本地文件服务器。那么我们该如何在这其中植入钩子从而能够在文件请求处理之前执行一些代码？来看一下&lt;code&gt;http.ListenAndServe&lt;/code&gt;的方法签名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ListenAndServe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;addr&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;handler&lt;/span&gt; &lt;span class="nx"&gt;Handler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来&lt;code&gt;http.FileServer&lt;/code&gt;返回了一个&lt;code&gt;Handler&lt;/code&gt;---给定一个根目录就能知道如何处理文件请求。那我们来看看&lt;code&gt;Handler&lt;/code&gt;接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Handler&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;ServeHTTP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ResponseWriter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据Go语言的接口原理，任何对象只要实现了&lt;code&gt;ServeHTTP&lt;/code&gt;就是一个&lt;code&gt;Handler&lt;/code&gt;。那么似乎我们需要做的事情就是构造一个自己的&lt;code&gt;Handler&lt;/code&gt;---封装&lt;code&gt;http.FileServer&lt;/code&gt;的处理流程。
Go语言的net/http标准库模块内置了一个帮助函数&lt;code&gt;http.HandlerFunc&lt;/code&gt;，用于将普通函数转变为请求处理函数（handler）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;HandlerFunc&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ResponseWriter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么我们这样封装&lt;code&gt;http.FileServer&lt;/code&gt;就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;OurLoggingHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Handler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Handler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HandlerFunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ResponseWriter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;r&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ServeHTTP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fileHandler&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;FileServer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Dir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nx"&gt;wrappedHandler&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;OurLoggingHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;fileHandler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ListenAndServe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;:8080&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;wrappedHandler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Go语言的net/http标准库模块有很多内置的&lt;a href="http://golang.org/pkg/net/http/#Handler"&gt;处理函数&lt;/a&gt;，如&lt;a href="http://golang.org/pkg/net/http/#TimeoutHandler"&gt;TimeoutHandler&lt;/a&gt;和&lt;a href="http://golang.org/pkg/net/http/#RedirectHandler"&gt;RedirectHandler&lt;/a&gt;，
可以相同的方式混合匹配使用。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;译者推荐阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/yjf512/archive/2012/08/22/2650873.html"&gt;Golang Http Server源码阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Golang"></category><category term="翻译"></category><category term="中间件"></category></entry><entry><title>为何Goroutine的栈空间可以无限大？（译）</title><link href="http://youngsterxyf.github.io/2014/01/17/goroutine-stack-infinite/" rel="alternate"></link><updated>2014-01-17T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-17:2014/01/17/goroutine-stack-infinite/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite"&gt;Why is a Goroutine's stack infinite?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go编程新手可能会偶然发现&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;---与一个Goroutine可用栈空间大小相关---的一个古怪特性。这通常是由于程序员
无意间构造了一个无限递归函数调用而产生的。为了阐明这个特性，以如下代码（有点刻意设计的）为例。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;S&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// String implements the fmt.Stringer interface&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;String&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// Sprintf will call s.String()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;S&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你运行这个程序（我不建议你这样做），你会发现你的机器开始频繁地swap（译注：不了解swap的，可以简单理解为“内存与硬盘之间数据的导出导入”），
并且可能不再响应操作事件，除非你在一切无法挽回之前及时地按下^C。我知道所有人都会先在Go官网的playground中尝试运行这个程序，
&lt;a href="http://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite"&gt;所以我已经为你准备好了&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大多数程序员应该都遇到过无限递归导致的问题，但这都只是对于他们的程序来说是致命的，对于他们的机器通常来说并不是。那么，为何Go程序会不同呢？&lt;/p&gt;
&lt;p&gt;Goroutine的主要特征之一是其开销---在内存占用初始化方面，创建一个Goroutine的开销非常小（相比于一个传统POSIX线程的1-8M字节），并且
Goroutine的栈空间是按需扩大和缩小的。这就允许一个Goroutine以单个4096字节的栈空间开始，然后按需扩容缩容，也不用担心栈空间耗尽的风险。&lt;/p&gt;
&lt;p&gt;为了实现这一特性，链接器（5l，6l，8l）在每个函数的开头都插入一小段前导代码$ ^1 $，这段代码会检测该函数需要的栈空间大小是否小于当前可用的栈空间。
若大于，则调用&lt;code&gt;runtime.morestack&lt;/code&gt;分配一个新的栈页（stack page）$ ^2 $，拷贝函数调用方传递来的参数，然后将控制权返回给原来要调用的函数，
这样这个函数就可以安全运行了。当这个函数退出时，再撤销操作，将函数返回值拷贝回函数调用方的栈帧（stack frame），不再需要的栈空间也被释放。&lt;/p&gt;
&lt;p&gt;通过这个过程，栈空间就好像无限大一样，若假设不会持续地跨越两个栈的大小边界-通常称为&lt;em&gt;栈切分（stack splitting）&lt;/em&gt;（译注：不太理解这句话，应该是指：&lt;strong&gt;程序执行
到函数调用方，正好将近耗尽预分配的栈空间，而函数调用方中又不断地调用其他函数，这样每次函数调用就需要分配新的栈空间，函数调用结束后又需要
释放新分配的栈空间，所以开销积累起来就比较大&lt;/strong&gt;），这种栈空间分配方式的开销也会很小。&lt;/p&gt;
&lt;p&gt;然而，直到现在我都还未披露一个细节---粗心地使用递归函数导致内存耗尽的话，当需要新的栈页时，就会&lt;em&gt;从堆上分配&lt;/em&gt;（译注：这句话可能有点问题。应该是Goroutine耗尽操作系统为Go程序分配的栈大小的话，
就从堆上分配）。&lt;/p&gt;
&lt;p&gt;由于无限递归函数持续地调用自己，新的栈页最后就需要从堆上分配。堆的大小很快就会超过机器的可用物理内存空间，到那时，swapping会很快导致你的机器不可用。&lt;/p&gt;
&lt;p&gt;Go程序可用的堆大小依赖于很多东西，包括机器的CPU架构和操作系统，但这通常是一个超出机器物理内存的值，因此机器很可能在程序耗尽它的堆空间之前就会频繁地swap。&lt;/p&gt;
&lt;p&gt;对于Go 1.1，曾有强烈要求增大32位、64位平台上堆的最大值，但这在某种程度上恶化了这一问题，比如，你的机器不太可能有128GB$ ^3 $的物理内存。&lt;/p&gt;
&lt;p&gt;最后提一下，关于这个问题有几个未解决的issue（&lt;a href="https://code.google.com/p/go/issues/detail?id=4692"&gt;链接&lt;/a&gt;，&lt;a href="https://code.google.com/p/go/issues/detail?id=2556"&gt;链接&lt;/a&gt;）,
目前还没找到一个解决方案能够不影响按常规编写的程序的性能。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;也适用于方法（method），虽然方法是作为第一个参数为方法接受者（the method receiver）的函数来实现的，但在讨论Go语言中分段的（segmented）栈如何工作之时，并没有实际的区别。&lt;/li&gt;
&lt;li&gt;使用单词page并不意味着仅按固定的4096字节来分配，如果需要，runtime.morestack会分配一个更大的，倍数于一个页大小的空间。&lt;/li&gt;
&lt;li&gt;由于Go 1.1发布周期中一个后来的改变，64位的Windows平台仅允许32Gb大小的堆。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;译者补充相关文章&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.nella.org/a-trip-down-the-split-rabbithole/"&gt;A trip down the (split) rabbithole&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://runtime.diandian.com/post/2011-12-24/11488238"&gt;go语言中split stack(上)&lt;/a&gt;，&lt;a href="http://runtime.diandian.com/post/2011-12-26/10119542"&gt;go语言中split stack(下)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mikespook.com/2011/03/go%E5%9C%A8stack%E4%B8%8A%E5%B9%B2%E4%BA%86%E7%A5%9E%E9%A9%AC%EF%BC%9F/"&gt;go在stack上干了神马？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Golang"></category><category term="翻译"></category></entry><entry><title>Go - 以任意类型的slices作为输入参数（译）</title><link href="http://youngsterxyf.github.io/2014/01/16/go-input-slices-any-type/" rel="alternate"></link><updated>2014-01-16T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-16:2014/01/16/go-input-slices-any-type/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://ahmetalpbalkan.com/blog/golang-take-slices-of-any-type-as-input-parameter/"&gt;Go – taking slices of any type as input parameters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近参与的一个业余项目，&lt;a href="https://github.com/ahmetalpbalkan/go-linq"&gt;go-linq&lt;/a&gt;，让我了解到Go语言的类型系统并不是为任何类面向
对象编程而设计的。没有泛型，没有类型继承，也没有提供任何对这些特性有用的东西。&lt;/p&gt;
&lt;p&gt;但是，提供了一个名为&lt;code&gt;interface{}&lt;/code&gt;的类型，你可以向其赋予几乎任意类型的值，不会抛出编译错误，就像.NET的&lt;code&gt;Object&lt;/code&gt;或Java的&lt;code&gt;Object&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mf"&gt;3.14&lt;/span&gt;
&lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;Student&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Ahmet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们假设你需要一个可以接收任意类型slices的函数，如果考虑如下这样实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{}){&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="nx"&gt;slice&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;Method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;// 抛出错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的代码会抛出编译错误，因为&lt;code&gt;[]int&lt;/code&gt;不是&lt;code&gt;[]interface{}&lt;/code&gt;。那么该如何解决这个问题呢？你可以要求&lt;code&gt;Method&lt;/code&gt;的使用者先把slices
转换为&lt;code&gt;[]interface{}&lt;/code&gt;类型。也就是说他们必须借助于如下类似函数将他们的&lt;code&gt;[]AnyType&lt;/code&gt;类型参数转换为&lt;code&gt;[]interface{}&lt;/code&gt;类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;conv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="nx"&gt;AnyType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;out&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;out&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;in&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但这种实现的扩展性并不好。如果&lt;code&gt;Method&lt;/code&gt;的使用者（可以是一个常用函数如&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Filter&lt;/code&gt;等）想向&lt;code&gt;Method&lt;/code&gt;传递N种不同类型的参数，
那么他们就必须编写N个&lt;code&gt;conv&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;对此，我们该怎么办呢？使用&lt;strong&gt;reflection&lt;/strong&gt;（反射）呀！实现一个函数以&lt;code&gt;interface{}&lt;/code&gt;（可以赋任意类型的值）为输入参数类型，在函数内部
将这个输入参数转换为一个slice，然后用于我们&lt;code&gt;Method&lt;/code&gt;函数。如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;takeSliceArg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;out&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;takeArg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Slice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;out&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Index&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Interface&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;out&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;takeArg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="nx"&gt;kind&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kind&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kind&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nx"&gt;kind&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数&lt;code&gt;takeArg()&lt;/code&gt;尝试将传入的参数值转换为指定的&lt;a href="http://golang.org/pkg/reflect/#Kind"&gt;reflect.Kind&lt;/a&gt;类型，然后函数&lt;code&gt;takeSliceArg()&lt;/code&gt;
尝试将传递给它的值（经&lt;code&gt;takeArg()&lt;/code&gt;转换后）转换为一个&lt;code&gt;interface{}&lt;/code&gt;的slice。虽然，这样会因为反射而影响到一点性能，但影响并不大。&lt;/p&gt;
&lt;p&gt;就是这样了。这种方案启发于Tobia Confronto的&lt;a href="https://github.com/tobia/fn"&gt;fn项目&lt;/a&gt;，并&lt;a href="https://github.com/ahmetalpbalkan/go-linq/commit/fa1548dc4ad8126e62c1848df6e6d961753d976e#diff-3"&gt;应用到go-linq中&lt;/a&gt;。&lt;/p&gt;</summary><category term="Golang"></category><category term="翻译"></category></entry><entry><title>回顾2013，展望2014</title><link href="http://youngsterxyf.github.io/2014/01/06/review13-lookin14/" rel="alternate"></link><updated>2014-01-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2014-01-06:2014/01/06/review13-lookin14/</id><summary type="html">&lt;p&gt;2013已经过去了。&lt;/p&gt;
&lt;p&gt;时间消逝得太快，以至于很多事情在记忆上相互重叠，无法明确区分事情发生的时间点。那么该如何回顾这过去的一年？&lt;/p&gt;
&lt;h2&gt;工作&lt;/h2&gt;
&lt;p&gt;2013，参加工作的第一年，我几乎全身心地扑在工作上，自认为做了一些事情，也有很多收获，愉快而充实。技术工作于我而言，更多的
是一种兴趣、乐趣。&lt;/p&gt;
&lt;p&gt;非常感谢领导、导师以及伙伴。领导、导师给了我很大的空间，导师始终耐心地给于业务和技术的指导，和伙伴的合作非常愉快。&lt;/p&gt;
&lt;p&gt;这一年，如果说我有了些许成长进步，很大程度上归功于他们。&lt;/p&gt;
&lt;p&gt;这些话说得也许有些像获奖感言，却是发自我的真心。&lt;/p&gt;
&lt;h2&gt;生活&lt;/h2&gt;
&lt;p&gt;2013，我和老婆，订婚、领证，终于结束了长达5年的异地恋，从此以后会有个人始终和我“相依为命”，面对或许琐碎的每一天，在城市飘荡的
日子也不会再孤单，我很安心，很踏实。&lt;/p&gt;
&lt;p&gt;现在，我没车、没房，每个月的工资也不算高，但我始终在努力，除了为自己，还因为有个人值得你去努力把生活过得更好。&lt;/p&gt;
&lt;p&gt;为了记录我们以前和以后人生中的重要时刻，我特意创建了一个&lt;a href="http://youngsterxyf.github.io/love"&gt;大事年表网页&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;读书&lt;/h2&gt;
&lt;p&gt;2013，我读过的书非常少，如果非得为此找个理由，我想应该是：很大部分精力都放在了工作和技术上。&lt;/p&gt;
&lt;p&gt;我非常庆幸自己高中、大学、读研的时候阅读了大量的杂书，虽然在一定程度上影响了我的学业，但我更加看重我如今的心态、思想，气质。&lt;/p&gt;
&lt;p&gt;这里简单罗列一下2013年读过的书：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明朝那些事儿（1-7全）（强烈推荐）&lt;/li&gt;
&lt;li&gt;读者（梁文道著）&lt;/li&gt;
&lt;li&gt;Go Web编程&lt;/li&gt;
&lt;li&gt;Learning Raphael - JS Vector Graphic（对Web数据可视化感兴趣的话，非常推荐）-&amp;gt; &lt;a href="https://github.com/youngsterxyf/Coder-s-code/blob/master/JavaScript/learning_raphael_js_vector_graphic.js"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Just For Fun - The Story of an Accidental Revolutionary （Linus Torvalds自传，推荐）-&amp;gt; &lt;a href="http://youngsterxyf.github.io/2013/11/07/read-just_for_fun/"&gt;读书笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Beginning jQuery [读书笔记）-&amp;gt; &lt;a href="https://github.com/youngsterxyf/Coder-s-code/blob/master/JavaScript/beginning-jquery.js"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Learning from jQuery（推荐给jQuery学习者）-&amp;gt; &lt;a href="https://github.com/youngsterxyf/Coder-s-code/blob/master/JavaScript/learning-from-jQuery.js"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaScript语言精粹 -&amp;gt; &lt;a href="http://youngsterxyf.github.io/2013/03/14/read-js-thegoodparts/"&gt;阅读摘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/zh"&gt;Pro Git&lt;/a&gt; （未读完）&lt;/li&gt;
&lt;li&gt;精通CSS-高级Web标准解决方案 （未读完）&lt;/li&gt;
&lt;li&gt;UNIX环境高级编程 （未读完）&lt;/li&gt;
&lt;li&gt;当我谈跑步时，我谈些什么（村上春树著，未读完）&lt;/li&gt;
&lt;li&gt;研究之美 （是13年读的么？）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;书单中几乎都是技术书，而技术书又是因工作需要而阅读的，所以好几本都未读完。&lt;/p&gt;
&lt;p&gt;仍然希望2014年多花些时间阅读，增强“内功”，目前列入计划的书籍有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;历史研究（汤因比著）&lt;/li&gt;
&lt;li&gt;UNIX环境高级编程&lt;/li&gt;
&lt;li&gt;TCP/IP详解 卷1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;求精而不求多，努力达成目标。&lt;/p&gt;
&lt;h2&gt;博客&lt;/h2&gt;
&lt;p&gt;坚持写博客，也是13年的一大收获，一共写了&lt;a href="http://youngsterxyf.github.io/archives.html"&gt;45篇文章&lt;/a&gt;，主要分为技术译文和工作技术总结两部分。&lt;/p&gt;
&lt;p&gt;深感写博客对于技术、知识积累是非常有帮助的，现在我就经常翻阅以前写的文章。&lt;/p&gt;
&lt;p&gt;勤写博客、总结工作心得，对于工作的帮助也很大，不说别的，就说：有时也许领导突然让你就近期的工作写个总结，如果你已经写了博客，那就可以直接拿过来改改就可以O了，哈哈。&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;13年，我并没有怎么运动锻炼。&lt;a href="http://youngsterxyf.github.io/2013/01/18/review12-lookinto13/"&gt;回顾2012，展望2013&lt;/a&gt;中的“信誓旦旦”让如今的我感到很羞愧。但，住处离公司近，这一优点让我养成了
走路上下班的习惯，从4月份入职到现在，9个月，除了一次睡过头了打车到公司，每天上下班走路各半个小时左右，对于我的身体健康不能说没有积极的影响。&lt;/p&gt;
&lt;h2&gt;未来一年&lt;/h2&gt;
&lt;p&gt;2014年，相比2013年，也许并不会有太多的区别，但我仍非常期望自己---2013年做得好的继续保持，没有达到自己期望的地方则加油努力！&lt;/p&gt;
&lt;p&gt;“活着是一种修行！”&lt;/p&gt;</summary><category term="总结"></category></entry><entry><title>微博"收藏/赞/转发"技术资料汇总</title><link href="http://youngsterxyf.github.io/2013/12/28/weibo_tech_resources_summary/" rel="alternate"></link><updated>2013-12-28T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-28:2013/12/28/weibo_tech_resources_summary/</id><summary type="html">&lt;p&gt;使用新浪微博，我很少发状态，主要是跟踪技术圈的一些动态，技术牛人们都在搞些什么东东，因而收藏和转发了一些优秀的技术资源，
但有些资源当时并没有来得及阅读消化，也没必要马上就阅读学习的，所以这里整理汇总一下，以免湮没在浩瀚的网络信息海洋中。&lt;/p&gt;
&lt;h3&gt;书籍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP权威指南 &amp;lt;- &lt;a href="http://weibo.com/fenng"&gt;@Fenng&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nlp.stanford.edu/IR-book/"&gt;Introduction to Information Retrieval&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/lirenchen"&gt;@陈利人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.codingnow.com/temp/readinglua.pdf"&gt;Lua 源码欣赏&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/deepcold"&gt;@简悦云风&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://aosabook.org/en/index.html"&gt;The Architecture of Open Source Applications&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/2169336083"&gt;@CloudFoundry &lt;/a&gt; (已陆续读了部分章节，赞！图灵社区有章节翻译)&lt;/li&gt;
&lt;li&gt;程序设计实践 &amp;lt;- &lt;a href="http://weibo.com/wintercn"&gt;@寒冬winter&lt;/a&gt; &lt;em&gt;推荐语：薄薄200页，就能让一个掌握一门编程语言基础的人成为一个合格的程序员，其中“算法和数据结构”一章不到30页，我认为细细读过足以应付大多数面试和工作需要。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;七周七语言 &amp;lt;- &lt;a href="http://weibo.com/tchuba"&gt;@淘宝褚霸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C语言接口与实现 &amp;lt;- &lt;a href="http://weibo.com/huangz1990"&gt;@huangz1990&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Linux Programming Interface &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt; &lt;em&gt;推荐语：既《Unix网络编程》一二册、《Unix环境高级编程》这三本书之后的最全面最好的一本介绍linux方面的书籍，非常推荐大家读一读&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;代码阅读方法与实践 &amp;lt;- &lt;a href="http://weibo.com/tchuba"&gt;@淘宝褚霸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/"&gt;JavaScript 设计模式&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/oschina2010"&gt;@开源中国&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://learnvimscriptthehardway.stevelosh.com/"&gt;Learn Vimscript the Hard Way&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C++ 的设计与演化 &amp;lt;- &lt;a href="http://weibo.com/marchliu"&gt;@刘鑫Mars&lt;/a&gt; &lt;em&gt;推荐语：无论你对CPP是爱还是恨，只要对它有强烈的感情，就值得读一读&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nmon.sourceforge.net/pmwiki.php"&gt;nmon for Linux&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/tchuba"&gt;@淘宝褚霸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bitbucket.org/kardianos/rsync"&gt;rsync(Go语言实现)&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://plan9.bell-labs.com/plan9/"&gt;plan9&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/codebox"&gt;@CodeBox-腾讯&lt;/a&gt; &lt;em&gt;推荐语：推荐有技术品味的同学都看看plan9的源码，真正世界级大师的作品。plan9的部分代码后来直接用来实现go语言了。&lt;/em&gt; (前年关注过这个项目，哈哈，我的Github头像就是用的plan9的图标)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/square/maximum-awesome"&gt;maximum-awesome&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://influxdb.org/"&gt;InFluxDB&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/soddyque"&gt;@有点儿欢乐&lt;/a&gt;(目前，我们使用InfluxDB来实现一种时间序列数据后备存储方案。官方的文档还不太完善，也还没生产应用案例)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bitly.github.io/nsq/"&gt;NSQ&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1855563263"&gt;@夏永锋_SJTU&lt;/a&gt; (哈哈，我自己。目前我们使用NSQ来接收服务器上报的各项性能数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://voorloopnul.com/blog/a-python-proxy-in-less-than-100-lines-of-code/"&gt;A python proxy in less than 100 lines of code&lt;/a&gt; &amp;lt;- &lt;a href="http://e.weibo.com/u/2093492691?ref=http%3A%2F%2Fweibo.com%2Ffav%3Fpage%3D5"&gt;@程序员的那些事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pymotw.com/2/"&gt;Python Module of the Week&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/royshan"&gt;@骆逸&lt;/a&gt; (我翻译过其中&lt;a href="http://youngsterxyf.github.io/2013/03/30/argparse/"&gt;argparse&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/"&gt;What really happens when you navigate to a URL&lt;/a&gt;，&lt;a href="http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html"&gt;译文&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/lirenchen"&gt;@陈利人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rxin.github.io/db-readings/"&gt;Readings in Databases&lt;/a&gt; &amp;lt;- &lt;a href="http://e.weibo.com/u/2093492691"&gt;@程序员的那些事&lt;/a&gt; (数据库相关论文列表，赞！)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/"&gt;How Browsers Work: Behind the scenes of modern web browsers&lt;/a&gt;，&lt;a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/"&gt;译文&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/ftqq"&gt;@方糖气球&lt;/a&gt; (大致读过一遍)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.allthingsdistributed.com/2012/12/paper-readings-2012.html"&gt;The Back-to-Basics Readings of 2012&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt; (2014年，我打算跟踪阅读这一系列)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://coderwall.com/p/rklk_a"&gt;Go: Share Memory By Communicating&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.valleytalk.org/2011/06/18/%E5%AF%B9%E5%A4%A7%E9%80%81%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E4%B8%83%E4%B8%AA%E6%9C%9F%E6%9C%9B/"&gt;对大宋下一代系统软件架构师的七个期望&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/baoyungang"&gt;@包云岗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf"&gt;Scaling Memcache at Facebook&lt;/a&gt;，&lt;a href="http://www.oschina.net/translate/scaling-memcache-facebook"&gt;译文&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/emclabschina"&gt;@EMC中国研究院&lt;/a&gt;, &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.bigendian123.com/go/2013/11/29/golang-schedule/"&gt;goroutine与调度器&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/marckywu"&gt;@高端小混混&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.golang.org/go-slices-usage-and-internals"&gt;Go Slices: usage and internals&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/"&gt;Baby's First Garbage Collector&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/forhapy"&gt;@傅海平ICT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/2216172320"&gt;@何_登成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tiewei.github.io/cloud/Docker-Getting-Start/"&gt;Docker介绍: 相关技术&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/ferest"&gt;@fe-rest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/yzsind/article/details/6059209"&gt;面向程序员的数据库访问性能优化法则&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/2216172320"&gt;@何_登成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bash.cumulonim.biz/BashPitfalls.html"&gt;Bash Pitfalls&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/huoding"&gt;@火丁笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.rational.so/blog/2013/11/09/sosp-2013-analysis/"&gt;SOSP 2013 Analysis&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1657470871"&gt;@王威廉&lt;/a&gt; (挺有意思的一篇学术八卦文)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rogueleaderr.com/post/65157477648/the-idiomatic-guide-to-deploying-django-in-production"&gt;The Idiomatic Guide to Deploying Django in Production&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zh.learnlayout.com/"&gt;学习CSS布局&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/royshan"&gt;@骆逸&lt;/a&gt; (读过，不错)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.manong.io/technologies-we-use/"&gt;《码农周刊》用到的一些技术&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt; (不错，赞！)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://chenzhenianqing.cn/articles/943.html"&gt;Redis主从同步源码浅析-Master端&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/chenzhenianqing"&gt;@趁着年轻-海文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.disqus.com/post/62187806135/scaling-django-to-8-billion-page-views"&gt;Scaling Django to 8 Billion Page Views&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://devo.ps/blog/2013/09/11/zookeeper-vs-doozer-vs-etcd.html"&gt;ZooKeeper vs. Doozer vs. Etcd&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.engineyard.com/2012/linux-scalability"&gt;Linux TCP/IP Tuning for Scalability&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.gopheracademy.com/day-22-a-journey-into-nsq"&gt;A Journey Into NSQ&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt; (我们已经在项目中使用NSQ了，哈哈)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://highscalability.com/blog/2013/8/26/reddit-lessons-learned-from-mistakes-made-scaling-to-1-billi.html"&gt;Reddit: Lessons Learned From Mistakes Made Scaling To 1 Billion Pageviews A Month&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/i-m-h-o/231d7499a75"&gt;Programmer’s dilemma&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.soimort.org/posts/160/"&gt;程序语言简史&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/deepcold"&gt;@简悦云风&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://queue.acm.org/detail.cfm?id=1854041"&gt;Thinking Clearly about Performance&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html"&gt;Scaling Pinterest - From 0 To 10s Of Billions Of Page Views A Month In Two Years&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;图片/Slide/其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://photo.weibo.com/2636918231/wbphotos/large/mid/3527795659267872/pid/9d2c2dd7gw1e082ueq8qpj"&gt;图解llinux启动流程图&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/cnhackers"&gt;@中国黑客联盟V&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/chriscoyier/lets-do-a-bunch-of-simple-stuff-to-make-websites-faster"&gt;Let's Do A Bunch of Simple Stuff to Make Websites Faster&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1855563263"&gt;@夏永锋_SJTU&lt;/a&gt; (哈哈，我自己)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rivierarb.fr/presentations/messaging-systems/#1"&gt;Messaging Systems - How to make the right choice?&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hewgill.com/~greg/stackoverflow/ebooks/"&gt;Stack Overflow 上的顶级问答电子书汇总&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/idreamland"&gt;@池建强&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://denvergophers.com/2013-09/tips-and-tricks.slide#1"&gt;Tips and Tricks with Go&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.igvita.com/slides/2013/fluent-perfcourse.pdf"&gt;Building Faster Websites&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/developerworks"&gt;@developerWorks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/springside/springside4/wiki/Redis"&gt;Redis Wiki&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/huangz1990"&gt;@huangz1990&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/11VTTGHVNmiiw6GY0WBdX9laBUtLOhmrdgltuth3_pug/edit#slide=id.p"&gt;Golang Server Design Pattern&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://v.163.com/movie/2013/5/N/R/M8TBJIK7D_M8TBLIINR.html"&gt;乔布斯：遗失的访谈(1995)&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/wensong8"&gt;@淘宝正明&lt;/a&gt; (推荐，非常赞！)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://vdisk.weibo.com/s/s55H8"&gt;分布式基础理论系列论文翻译集&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/phylipsbmy"&gt;@我在地上数星星&lt;/a&gt; (赞！要花点时间认真读一下)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://research.microsoft.com/en-us/um/people/gray/papers/ieee_HA_Swieorick.pdf"&gt;High Available computer systems&lt;/a&gt;, &lt;a href="http://research.microsoft.com/en-us/um/people/gray/papers/TandemTR85.7_WhyDoComputersStop.pdf"&gt;Why do Computers stop&lt;/a&gt;, &lt;a href="http://roc.cs.berkeley.edu/papers/usits03.pdf"&gt;Why do Internet Services Fail&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/1765260200"&gt;@jametong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="微博"></category><category term="技术"></category></entry><entry><title>IE下JavaScript Date对象的不同之处</title><link href="http://youngsterxyf.github.io/2013/12/03/date_difference_in_ie/" rel="alternate"></link><updated>2013-12-03T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-03:2013/12/03/date_difference_in_ie/</id><summary type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/29/inner_warehouse_monitor_system/"&gt;仓库作业机器监控系统&lt;/a&gt;项目中使用&lt;a href="http://www.highcharts.com/demo/line-time-series"&gt;HighCharts的时间序列数据图&lt;/a&gt;来绘制机器CPU使用率、内存使用量、网络流量趋势变化图等，这些图在IE下却没有正常显示，IE也没有报错，按理说HighCharts的IE兼容性是较好的，不会出现这种问题，
最后查明原因---确实不是HighCharts的问题，而是由于IE下JavaScript的Date对象缺少一种构造函数导致的。&lt;/p&gt;
&lt;p&gt;IE中JavaScript的Date对象有如下&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/cd9w2te4.aspx"&gt;三种构造函数&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;dateObj = new Date()
dateObj = new Date(dateVal)
dateObj = new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其他浏览器中除了这三种之外，&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"&gt;还有一种&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;dateObj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;dateString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在IE下使用了这种构造函数，IE不会提示错误，但在调用dateObj的getMonth、getDate等等方法时返回的是&lt;strong&gt;NaN&lt;/strong&gt;，从而导致了其他问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：感谢@yiyun指出，IE中的Date构造函数只是不支持"xxxx-xx-xx"这种格式的时间字符串&lt;/em&gt;。&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/cd9w2te4.aspx"&gt;文档&lt;/a&gt;也有说明，是我阅读不仔细：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;dateVal
    必需。如果是数值，dateVal表示指定日期与1970年1月1日午夜之间相差的协调世界时的毫秒数。   
    如果是字符串，则根据日期和时间字符串(JavaScript)中的规则分析dateVal。dateVal参数也可以是从一些ActiveX对象返回的 VT_DATE值。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中日期和时间字符串的规则见：&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/ff743760.aspx"&gt;http://msdn.microsoft.com/zh-cn/library/ie/ff743760.aspx&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在我的案例中，是需要将时间字符串“xxxx-xx-xx”（如“2013-12-03”）转换成一个Date对象，为了兼容IE，我如下实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;newIEDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;dateStr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// dateStr的格式：xxxx-xx-xx&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;dateParts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;dateStr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;parseInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;dateParts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="nb"&gt;parseInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;dateParts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;parseInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;dateParts&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;objDate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;browser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;msie&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;objDate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;newIEDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;queryDate&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;objDate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;queryDate&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码中，&lt;code&gt;$.browser.msie&lt;/code&gt;来自jQuery。另外，构造函数&lt;code&gt;new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]])&lt;/code&gt;中的&lt;strong&gt;year&lt;/strong&gt;必须是年份全称（如1998，而不应是98），&lt;strong&gt;month&lt;/strong&gt;参数则应在0-11（代表1月至12月）之间取值。&lt;/p&gt;
&lt;h4&gt;参考资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/cd9w2te4.aspx"&gt;MSDN - Date 对象 (JavaScript)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"&gt;MDN - Date&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="JavaScript"></category><category term="笔记"></category></entry><entry><title>某运营平台架构调整</title><link href="http://youngsterxyf.github.io/2013/12/02/operation_platform_arch_change/" rel="alternate"></link><updated>2013-12-02T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-02:2013/12/02/operation_platform_arch_change/</id><summary type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/10/15/standardization-operation-development/"&gt;运营开发规范化&lt;/a&gt;一文中提过工作中涉及一个&lt;strong&gt;运营平台&lt;/strong&gt;。曾有段时间我一直吐槽该平台的代码实现有多烂，各种功能的逻辑有多“野蛮”，应尽快改造，但也许“worse is better”，我的吐槽只能仅仅是吐槽而已了。&lt;/p&gt;
&lt;p&gt;最近该平台终于频繁出问题了。原因是上线了一个新功能---生产系统的模块之间每发生一次模块调用，就会调用该运营平台的API上报一次数据，该API的逻辑是将上报的数据存入Redis中。API由PHP实现，服务器以Nginx + PHP-FPM的方式处理API调用请求。当生产系统的业务量增大，模块直接的调用次数频率增大直接导致API调用的频率增大，
加上该平台所在服务器各种cron任务等的影响，导致在某些时候，PHP-FPM子进程数量飙升，跑满CPU，并且PHP-FPM子进程的数目持续不降（原因不明）。这样导致一方面用户无法访问该平台---服务器响应502（Nginx接受请求，但PHP-FPM无法处理该请求），另一方面更多的数据上报API调用无法完成，造成大量数据丢失和误告警。
用户怨声载道，领导也很头疼，要求尽快搞定该问题，但迟迟没人挑起这个活。&lt;/p&gt;
&lt;p&gt;为了开个头，上上个周末的一天我绘制了两张对比图（如下所示），尝试给出建议方案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="operation_platform_old_arch" src="/assets/uploads/pics/operation_platform_old_arch.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="operation_platform_new_arch" src="/assets/uploads/pics/operation_platform_new_arch.png" /&gt;&lt;/p&gt;
&lt;p&gt;这种方案的时间成本较低，无需改动对外API，也无需大量修改代码。&lt;/p&gt;</summary><category term="架构"></category><category term="笔记"></category></entry><entry><title>HAProxyConsole简介</title><link href="http://youngsterxyf.github.io/2013/12/02/re_introduce_haproxyconsole/" rel="alternate"></link><updated>2013-12-02T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-12-02:2013/12/02/re_introduce_haproxyconsole/</id><summary type="html">&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/01/unescape-html-in-golang-html_template/"&gt;Golang中如何让html/template不转义html标签&lt;/a&gt;、&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;两篇文章中都提到为了方便使用HAProxy，我实现了一个简单的HAProxy负载均衡任务管理系统。前些天我把&lt;a href="http://youngsterxyf.github.io/haproxyconsole/"&gt;代码放在Github上&lt;/a&gt;，算是开源吧。&lt;/p&gt;
&lt;p&gt;同事使用该管理系统，遇到问题时，由于不清楚其实现，也就无法分析问题出在哪，同时也会有些恐慌，生怕搞挂了HAProxy，毕竟上面承载了一些关键的业务，所以我绘制一张图用于说明HAProxyConsole的应用场景和工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="HAProxyConsole-arch" src="/assets/uploads/pics/HAProxyConsole-arch.png" /&gt;&lt;/p&gt;
&lt;p&gt;图中蓝色标识的部分都属于HAProxyConsole。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户通过Web页面增/删/改/查负载均衡任务，但这4个操作直接修改的都仅是数据库（DB.json或MySQL数据库）。另外，HAProxyConsole的Web页面中还嵌入了主从HAProxy自带的数据统计页面。&lt;/li&gt;
&lt;li&gt;只有当用户点击按钮“应用到主HAProxy”或“应用到从HAProxy”后，HAProxyConsole才会根据DB.json或MySQL中存储的数据和配置文件haproxy_conf_comm.json生成最新的HAProxy配置文件，然后拷贝一份为主HAProxy的配置文件或远程拷贝一份为从HAProxy的配置文件，最后重启HAProxy进程（/path/to/haproxy/sbin/haproxy -f /path/to/haproxy/conf/haproxy.conf -st `cat /path/to/haproxy/haproxy.pid`），使最新的配置生效。重启的过程中HAProxy会先检测最新配置文件的正确性，如果不正确，则不会重启。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在部署HAProxyConsole，应按实际情况修改配置文件&lt;code&gt;app_conf.ini&lt;/code&gt;中的参数值。另外，由于HAProxyConsole在为HAProxy应用最新配置时，是直接覆盖HAProxy原来的配置文件，所以&lt;code&gt;haproxy_conf_comm.json&lt;/code&gt;中指定的HAProxy数据统计页面所使用的端口应与你原来为HAProxy指定的数据统计页面的端口一致。&lt;/p&gt;</summary><category term="HAProxy"></category><category term="Keepalived"></category><category term="负载均衡"></category><category term="笔记"></category><category term="总结"></category></entry><entry><title>仓库作业机器监控系统设计与实现</title><link href="http://youngsterxyf.github.io/2013/11/29/inner_warehouse_monitor_system/" rel="alternate"></link><updated>2013-11-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-29:2013/11/29/inner_warehouse_monitor_system/</id><summary type="html">&lt;p&gt;近期在参与一个仓库作业机器监控项目。该项目的需求背景是：公司的电商业务在全国各地有多处或大或小的仓库，仓库的作业人员（没有IT技术背景）经常反馈/投诉作业机器断网、断电、连不了服务等问题。实际情况经常与反馈的不一致，但运维侧并没有数据可以证明，所以才有了这个项目的需求。&lt;/p&gt;
&lt;p&gt;该项目第一期的目标仅是&lt;em&gt;收集、展示作业机器某些监控指标数据，以便在快速定位解决问题，或至少有数据可查&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;为了避免大量监控数据上报影响到生产系统的网络服务，系统采用如下结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt="inner_warehouse_monitor" src="/assets/uploads/pics/inner_warehouse_monitor.png" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现一个agent用于在仓库作业PC或作业PDA上获取机器的监控数据；&lt;/li&gt;
&lt;li&gt;在仓库本地服务器上实现一个数据收集处理服务，提供API给agent上传监控数据；数据收集处理服务会将接收到的数据持久化到数据库，提供给仓库本地服务器上的webApp进行数据展示等；&lt;/li&gt;
&lt;li&gt;中心服务器可以调用各个仓库本地服务器上的webApp提供的数据查询接口（数据用于定位、发现问题）；定期按需对各个仓库本地服务器上的数据进行归档。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，主要的工作都集中在&lt;strong&gt;作业机器上的agent&lt;/strong&gt;和&lt;strong&gt;数据收集处理服务、webApp&lt;/strong&gt;。这其中最关键的又是&lt;strong&gt;数据收集处理服务&lt;/strong&gt;。考虑到需要多地部署运维仓库本地服务器，而且某些大仓库作业机器的数目目前已多达800-1000，我们做了如下技术选型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Golang实现agent、数据收集处理服务、webApp；&lt;/li&gt;
&lt;li&gt;以SQLite作为数据库来存储agent上报的所有数据；&lt;/li&gt;
&lt;li&gt;以&lt;a href="http://bitly.github.io/nsq/"&gt;NSQ&lt;/a&gt;作为异步消息队列中间件；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选用Golang的理由是：可以静态编译，部署简单，只需将变异好的可执行二进制程序丢到服务器上跑起来就可以了。&lt;/p&gt;
&lt;p&gt;选用SQLite的理由是：不必像MySQL那样安装server程序，无需额外部署维护。当然SQLite的文件锁会大大影响数据库读写性能，我们通过尽可能拆分数据库，将不同的指标数据存储在不同的SQLite DB文件中，甚至将每台作业机器每个指标的每天的数据分别存储在不同的DB文件中，来尽可能减小文件锁的性能影响，目前看来效果还不错。&lt;/p&gt;
&lt;p&gt;选择NSQ的理由是：Golang实现、分布式、伸缩性好、性能高、支持HTTP/TCP协议、自带web管理界面等。&lt;/p&gt;
&lt;p&gt;详细的系统结构图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="inner_warehouse_monitor-arch" src="/assets/uploads/pics/inner_warehouse_monitor-arch.png" /&gt;&lt;/p&gt;
&lt;p&gt;NSQ支持多topic（不同topic的数据不同），topic又可以有多个channel（同一个topic的所有channel中的数据相同，以多播的方式实现，每个channel在client中有一个对应的处理流程来处理channel中的数据）。我们将作业机器不同的监控指标数据作为不同topic传入NSQ，多数指标数据只需持久化到数据库以备后用，所以这些topic仅需一个channel。&lt;/p&gt;
&lt;p&gt;webApp基于Beego框架实现，避免重复造轮子、工作量小。webApp中的数据展示采用HighCharts、Raphael实现，兼容性好。&lt;/p&gt;
&lt;p&gt;对于机器指标数据，其实不应该使用关系型数据库来存储，因为这种数据的特点是：写入之后只读不改、时间序列的、几乎没有关系型的读取操作、连续批量数据读取，所以开源监控系统如Cacti、Ganglia等均使用RRDtool来读写指标数据。所以如上所述，我们将指标数据的存储尽可能地拆分成多个文件以提高读写性能而不会造成其他问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;系统的工作流程如下所述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作业机器上的agent启动后会先向NSQ的register topic发送一个注册消息，NSQ Client根据该注册消息在register数据表中将该作业机器的状态改为“正常运行中”；&lt;/li&gt;
&lt;li&gt;然后，agent定期上报监控数据到NSQ，NSQ Client中各种数据的处理流程将数据持久化到SQLite数据库文件；&lt;/li&gt;
&lt;li&gt;用户访问/中心服务器调用API时，webApp读取SQLite数据库；&lt;/li&gt;
&lt;li&gt;有一个Goroutine针对注册过的作业机器定期检测3分钟以内是否收到过其上报的心跳数据，若未收到，则将机器状态从“正常运行中”改成“运行异常”，若收到，则将“运行异常”改为“正常运行中”；&lt;/li&gt;
&lt;li&gt;作业机器在正常关机时会向NSQ的register topic发送一个正常关机的消息，Client读取到该消息后，会将该机器在register数据表中的状态改为“已正常关机”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前，系统工作良好。之后会对系统做压测，如果出现瓶颈，估计可能还是数据存储，这样的话我们可能会尝试RRDtool或&lt;a href="http://influxdb.org/"&gt;InfluxDB&lt;/a&gt;。&lt;/p&gt;</summary><category term="技术"></category><category term="总结"></category><category term="笔记"></category><category term="Golang"></category></entry><entry><title>读书笔记：Just For Fun - The Story of an Accidental Revolutionary</title><link href="http://youngsterxyf.github.io/2013/11/07/read-just_for_fun/" rel="alternate"></link><updated>2013-11-07T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-07:2013/11/07/read-just_for_fun/</id><summary type="html">&lt;p&gt;前些天偶然在图灵社区上看到&lt;a href="http://www.ituring.com.cn/book/1115?q=%E8%B6%8A%E7%8E%A9%E8%B6%8A%E5%A4%A7"&gt;这本书的出版计划&lt;/a&gt;，才猛然想起之前看过一两个章节，遂再次找到该书的&lt;a href="http://ishare.iask.sina.com.cn/f/14439267.html"&gt;中文电子版&lt;/a&gt;（&lt;em&gt;原谅我&lt;/em&gt;）（关于该电子版，我不清楚其来源。中国青年出版社出过该书的中文版，译名为《乐者为王》，不知该电子版即为该中文版，还是开源爱好者自己翻译。不过翻译质量不高，应该不是正式出版的），花了一天左右时间看完。&lt;/p&gt;
&lt;p&gt;本书由Linus Torvalds和David Diamond合著，书写方式是Linus自述，穿插David Diamond的一些采访旁白，主要讲述Linus如何偶然地成为信息时代的一个革命者（The Story of an Accidental Revolutionary）。Linus在书中表达了对Linux这一伟大的开源项目的看法、对于人生意义、事物发展规律等问题的个人理解。以下是书中让我印象比较深刻的几处内容：&lt;/p&gt;
&lt;h3&gt;生活的意义&lt;/h3&gt;
&lt;p&gt;对于这一哲学性的问题，估计现在很多人见到都会发笑。本书以这个问题的讨论开始，并以这个问题结尾。Linus并没有直接地回答，而是举例说明人类社会的事物发展都必然经过三个阶段---生存、社会秩序、娱乐，那么生活的意义就是促成这一发展过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;李纳斯：这个答案基本上简单而漂亮。 它不会给你的生活以任何意义，但可以告诉你将发生什么。
有三件事具有生命的意义。它们是你生活当中所有事情的动机，包括你所做的任何事情和一个生命体该做的所有事情。
第一是生存，第二是社会秩序，第三是娱乐。生活中所有的事情都是按这个顺序发展的。娱乐之后便一无所的。
因此从某种意义上说，这意味着生活的意义就是要达到第三个阶段。你一旦达到了第三个阶段，就算成功了。但首先要越过前两个阶段。
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这一理解是非常漂亮的。对于该问题（我为什么而活？），以前我也思考了很多，但最后的答案竟然是---活着本来就是没有意义的，一切意义都是人为地赋予。答案很悲观，Linus的答案本质上也是如此，只不过避免了直接面对该问题，以顺从事物发展规律作为生活的意义，对我有所启发，也让我多了些生活的“正能量”。&lt;/p&gt;
&lt;p&gt;对于未来的预言，特别是计算机行业的发展，Linus同样并没有直接回答问题，同样地以此作为回答：人们并不是真的需要计算机（包含网络等等），而是需要基于计算机实现生存、社会秩序、娱乐三个目标，那么未来的一切、计算机行业的发展必然是更好地帮助人们实现这三个目标。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于娱乐，有本书《娱乐至死》表达了对人类社会发展泛娱乐化、特别是教育趋向娱乐化的担忧。从另一角度佐证了Linus的看法，只不过一消极悲观，一积极乐观。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;与Andrew S. Tanenbaum的争论&lt;/h3&gt;
&lt;p&gt;这一事件在Wikipedia上还有专门的词条-&lt;a href="http://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate"&gt;Tanenbaum-Torvalds debate&lt;/a&gt;。以前也关注过该事件，但把问题的重心放在了“微内核（Micro kernel）”和“宏内核（Monolithic kernel）”的优缺点上，看了该书之后才真正理解Linus的选择，并赞同他的看法。&lt;/p&gt;
&lt;p&gt;这一争论的原文见&lt;a href="https://groups.google.com/forum/#!topic/comp.os.minix/wlhw16QWltI%5B1-25-false%5D"&gt;邮件列表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于Tanenbaum提出的问题，Linus做了如下回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;安德鲁塔南鲍姆写道： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我在美国待了几个星期，所以没来得及对Linux做多少评论(不是说如果我在，我就会说什么)。但是，Linux确实值得一评。我现在就有话要说。&lt;/p&gt;
&lt;p&gt;正如你们所知，MINIX只是我的爱好，每当晚上我写烦了书，如果当时没有什么战争、 革命、 直播的参议院听政会，我就会摆弄MINIX。我的真正职业是大学教授和操作系统领域中的研究人员。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你用这个作为MINIX局限性的借口？对不起，但是你输了。我的借口比你的还多，而Linux在很多领域还是胜MINIX一筹。更别说MINIX的大部分似乎是由布鲁斯?伊文斯编写的了。 &lt;/p&gt;
&lt;p&gt;反驳一：你说你把 MINIX当作爱好来玩――那么，请问是谁在拿MINIX挣钱呢？又是谁在免费发送Linux呢？再来谈谈爱好。让MINIX能免费获得，我对MINIX的最大抱怨就会消失。Linux在很大程度上对我是一个爱好(但是一个很严肃的爱好，最棒的一种爱好)。我没有从我的爱好中赚一分钱，它也不是我在大学要修的课程之一。我是纯粹用我自己的时间，在自己的机器上做出来的。 &lt;/p&gt;
&lt;p&gt;反驳二：你是教授和研究人员。这真是一个 MINIX出现核心缺陷的好借口。我只能希望 Amoeba不会像MINIX那样垮掉。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.微内核对Monolithic system &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，Linux是Monolithic的，我同意微内核是好一点儿。 如果不是你的话题有争议性，我可能会同意你的大部分意见。从理论角度(及审美角度)而言，Linux输了。如果GNU的kernel在去年春天就已完善的话，我可能就不会开始这个工程。而事实是，GNU还没有完善，也远非如此。如果现在就已实现的这一点而论，Linux才大获全胜。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MINIX是一个基于微内核的系统。Linux是Monolithic的系统。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这是判断一个kernel好坏的唯一标准，你的观点就对了。但你没提到的是，MINIX在微内核方面的表现并不出色，而且对核内真正的多任务操作仍存在着问题。 如果我做的是一个在多线程文件系统上有问题的OS的话，我就不会这么快来责备别人。而事实上，我竭尽所能来使人们忘记软件设计者在此问题上的惨败。(是的，我知道MINIX拥有众多黑客支持者，但他们只是黑客。而布鲁斯?伊文斯告诉我有很多可以竞争的机会。) &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.可移植性 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“可移植性是给那些写不出新程序的人们准备的。” &lt;/p&gt;
&lt;p&gt;――我，现在刚说的，口出狂言 &lt;/p&gt;
&lt;p&gt;事实上，Linux比MINIX更具有可移植性。 “你说什么？”我听见你说。 是真的――但却不是在你所说的意义上。我使Linux尽量符合标准(我当时手边并没有POSIX标准)。 把程序移植到Linux上比到MINIX上要容易得多。 &lt;/p&gt;
&lt;p&gt;我同意，可移植性是个好东西，但是只有在它确实有意义的地方才是个令人向往的特性。没有必要专门使一个操作系统太具有可移植性：能粘到可移植的API上就行了。操作系统的实质就是利用硬件的特点，并将其隐藏在一层高级的系统调用后面。而Linux就是如此，它比任何kernel都更多地利用了386的特性。当然这使得kernel确实不可移植，但是这也使设计大为简化，是一个可以接受的权宜之计，因为这首先保证了Linux的诞生。我也同意，Linux又太不具有可移植性了。去年一月我拥有了自己的386，而Linux系统的创建在一定程度上成为了一个让我认识386的项目。如果要成为一个真正的项目，必须能够在可移植性方面做一些事情。 但是，我最初的设计思想就是没有考虑到可移植性，如果我这样说并不是太过分地为自己辩护。去年四月我开始这个项目时，认为不会有什么人会真的使用它。我很高兴我的这个想法错了。 随着我对源代码的发布，每个人都可以免费来装截Linux，哪怕还不是很方便。 &lt;/p&gt;
&lt;p&gt;李纳斯 &lt;/p&gt;
&lt;p&gt;附：很抱歉我有时言辞过激。如果你没有其他的操作系统可供选择的话，MINIX已经挺好的了。如果你有五到十个386机器闲着没用，那么Amoeba也会不错，只是我确定无疑是没有的。我一般不会勃然大怒，但是在涉及到Linux的问题时，我是有点容易感情用事。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一反驳非常精彩，并且有说服力！特别是对于“可移植性”问题的说明，值得每个程序员阅读。&lt;/p&gt;
&lt;h3&gt;知识产权&lt;/h3&gt;
&lt;p&gt;关于知识产权，通常有两种截然不同的观点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有些人认为，专利和劳动保险形式的知识产权法规是自由世界的祸害，信息提供者(IP)法规并不仅仅是训导，实际上简直就是罪恶，应该尽快地加以铲除。 另一些人认为整个世界经济实际上是由知识产权所驱动的。这些人想通过他们的努力来加强IP法规的法律地位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而Linus是这么认为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于许多人，包括对我自己而言，知识产权是有关人类的创造活动的规则，是关于那些使我们成为人类――而不是动物(当然，这本身是一件好事)的活动的规则。正是在这个意义上，“知识产权”这一名称本身就是一种侮辱。 它并不是如有形财产那样可以出售，它是创造性活动本身，这是人类所能够做到的最伟大的事情。&lt;/p&gt;
&lt;p&gt;那种创造――不管它是以绘画、 音乐、 雕塑、 菱或是程序的方式出现，都应当受到尊重：创造者和他所创造的事物之间有着你所无法切断的密切联系。这就像母亲与孩子之间的联系，或者如同中国菜与味精之间的联系。 但是与此同时，它却又是世界上每一个人都应当分享的事物，因为它是属于人类共同的。&lt;/p&gt;
&lt;p&gt;你拥有你所创造的东西就意味着你可以控制它的使用。 例如，你有权将这一艺术成果出售给其他人，而且在这个问题上，除了美国国税局以外，任何人都不会说什么。 但是，它其实并不仅仅是钱的问题，而是其他人在同样的问题上陷于困惑时帮他们解决了问题，省却了时间与精力。 &lt;/p&gt;
&lt;p&gt;许多要求加强知识产权立法的讨论是基于这样一种观点，即：给创造者和艺术家以更多的“保护”。而人们似乎不曾、或者说是从未意识到，这样一种强有力的权利导致一些人剥夺了另一些人的权利。&lt;/p&gt;
&lt;p&gt;我热爱版权。我只是认为没必要将版权所有者的权利无限扩大。不要扩大到将消费者的权利都被剥夺殆尽。&lt;/p&gt;
&lt;p&gt;很显然，只有极少的个人获得了专利。 另一方面，公司却获得了大量的专利。这些专利是他们用来对付其他公司的有力武器，可以威胁别人因专利侵权而要面临起诉。现今的专利系统基本上可以说是信息提供者这间的冷战，而不是他们之前的核战争。目前这种情况也不见得比过去的冷战好。&lt;/p&gt;
&lt;p&gt;如果你想避免专利申请过程中的麻烦，你可以采用更为厉害的手段：商业秘密。商业秘密的优点在于，你不必担心什么商业秘密办公室或者类似的机构：你只需要将其封存起来，然后就不必顾虑那么多了。
过去人们一直是这样做的，实际上这也就是法规之所以被引入的原因所在。为了鼓励个人和公司公开其秘密，专利法允许在一定期限内保护市场――如果你公开你所拥有的秘密的话。一个针锋相对的基本形式是：你告诉大家你是如何做成某事的，那么我们就允许你拥有一定年限的特殊权利。&lt;/p&gt;
&lt;p&gt;在专利产生之前，人们会充满猜忌地保守他们自己的技术优势，一直到将它们带入坟墓。很显然，那是不利于技术进步的，因为有前途的技术从来没有向其他人公开过。对于专利特权的承诺使得专利成为将秘密告诉大家的一种强有力的刺激，因为你再也不用担心你的竞争对手会发现你在做什么了。&lt;/p&gt;
&lt;p&gt;然而，那是过去，现在情形不同了。 如今，即使是商业秘密也有了法律保护，尽管它们的理由世人无法理解。&lt;/p&gt;
&lt;p&gt;很大程度上，在这场知识产权战争中寻求和平的解决之道正是公开源代码所努力的目标。&lt;/p&gt;
&lt;p&gt;同一事物的另一面在于，的确，知识产权可能是不公平的，的确，知识产权法规在很大程度上将其目标定位于大公司而不是消费者权利，甚至也不是个人著作者或创新者。 然而其主体是积极有利的。知识产权集中于强有力的权利之上，与之相对应的事实是这一强有力的武器在市场上是如此的有效。 核武器是冷战时代的终极力量，同样的原因使得知识产权在技术战争时代里大受欢迎。&lt;/p&gt;
&lt;p&gt;虽然大量的新措施使非法使用他人的知识产权变得更加困难，但同时也使得合法使用他人的知识产权变得更加困难。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;原谅我喋喋不休地摘录了这么多内容，但其实书中这部分的内容还有很多精彩之处。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;知识产权本来的目的是保护创造者的基本权利，以促进创新和分享，但知识产权如果走过了头（例如如今的专利战争）就会导致创新难以普及，他人无法合法合理地使用这些创新。开源运动则鼓励充分地开放分享创新，同时通过各种形式许可证来保护创造者的基本权利，这也就意味着开源运动的理念不仅只是影响计算机行业，也会对所有行业产生巨大的正面影响。&lt;/p&gt;
&lt;p&gt;人类社会的发展是一个积累的过程，创新知识的分享越充分，积累也就越快，人类社会的发展也就越快。这也是我欣赏支持黑客精神和开源运动的缘由。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;关于书名的翻译&lt;/h4&gt;
&lt;p&gt;这本书的书名，中国青年出版社的版本是译为《乐者为王》，而将要出版的人民邮电出版社的版本貌似要译为《越玩越大-我和Linux的故事》（正式出版前的暂译名？）。对于这两个译名我都不满意。原书取名《Just For Fun --- The Story of an Accidental Revolutionary》，我想应该是考虑了两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linus非常看重尊重自己的兴趣。其实Linux就是始于它的个人兴趣，也因此Linux到如今的发展及其造成的广泛影响也是当初Linus没有料想也不可能料想到的，人生往往如此，很多事情都是Accidental的；&lt;/li&gt;
&lt;li&gt;Linus认为任何人类社会事物发展的终极阶段就是---娱乐，那么生活的意义就是不断努力为达到这一终极阶段而贡献自己的一份力量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第二点，该书的最后一节中作者做了明确的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对了，就是这三件事：生存、你在社会中的位置、还有快乐。&lt;/p&gt;
&lt;p&gt;这三件事就是我们正在做着的事情。 任何其他的事物，都是社会学家可能会称之为“突发行为”的东西，它们源于那些规则更为简单的行为模式。&lt;/p&gt;
&lt;p&gt;然而事情不仅仅是“这就是激励人生活的事物”。如果情形是这样的话，那它们也就不会成为关于生命的理论了。令人感兴趣的，这三种激励因素有着内在的次序，而这一次序表明了生命的所在。事情并不仅仅是，我们人类被这三种事物所驱使――对于人类以外的其他生命行为也是如此。 &lt;/p&gt;
&lt;p&gt;这一次序是：生存；社会交往；寻找乐趣。 &lt;/p&gt;
&lt;p&gt;它也是进化的次序。这就是我们选择了“Just for Fun”作为本书名称的原因。
因为我们曾经所做的一切事情，似乎最终都是为了我们自己的乐趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译名《乐者为王》虽然简练，却不能明确地表达这两层意思。《越玩越大-我和Linux的故事》则跟闹着玩似的。&lt;/p&gt;
&lt;p&gt;为什么不直译为《只为乐趣》呢？&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;关于本书，阮一峰也写过一篇阅读笔记，见&lt;a href="http://www.ruanyifeng.com/blog/2012/09/linus_torvalds.html"&gt;《Linus Torvalds自传》摘录&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;</summary><category term="阅读"></category><category term="笔记"></category></entry><entry><title>修改PyPI源</title><link href="http://youngsterxyf.github.io/2013/11/01/change-pypi-mirror/" rel="alternate"></link><updated>2013-11-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-01:2013/11/01/change-pypi-mirror/</id><summary type="html">&lt;p&gt;使用easy_install或pip安装Python第三方库，默认的源地址是：https://pypi.python.org/simple/ 。使用该源有两个问题:&lt;/p&gt;
&lt;p&gt;1.
国内访问速度较慢&lt;/p&gt;
&lt;p&gt;2.
由于该源使用https协议，若机器上没有安装openssl或ssl配置不对，将导致easy_install或pip访问该源失败&lt;/p&gt;
&lt;p&gt;若想解决这两个问题，可以使用国内的PyPI镜像源。&lt;/p&gt;
&lt;p&gt;从 &lt;a href="http://www.pypi-mirrors.org/"&gt;http://www.pypi-mirrors.org/&lt;/a&gt; 可以看到国内的PyPI镜像源主要有三个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.pypi.python.org&lt;/li&gt;
&lt;li&gt;pypi.douban.com&lt;/li&gt;
&lt;li&gt;pypi.hustunique.com&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;修改easy_install和pip使用的源有两种方式（以Linux上从镜像源e.pypi.python.org下载安装requests为例）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令方式：针对一次使用，临时修改&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;easy_install&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;easy_install -i http://e.pypi.python.org/simple requests
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install requests -i http://e.pypi.python.org/simple
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：&lt;em&gt;1. 源路径要包含/simple部分；2. 使用pip时-i参数应放在install xxx的后面&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改（若没有，则创建）easy_install/pip的配置文件&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;easy_install：在&lt;code&gt;~/.pydistutils.cfg&lt;/code&gt;配置文件中写入如下内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[easy_install]
index_url = http://e.pypi.python.org/simple
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip：在&lt;code&gt;~/.pip/pip.conf&lt;/code&gt;配置文件中写入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[global]
index-url = http://e.pypi.python.org/simple
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.lidaren.com/archives/886"&gt;修改easy_install和pip的镜像地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonhosted.org/setuptools/easy_install.html"&gt;easy_install&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pip-installer.org/en/latest/configuration.html"&gt;pip configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category><category term="PyPI"></category><category term="pip"></category><category term="easy_install"></category><category term="ssl"></category></entry><entry><title>Golang中如何让html/template不转义html标签</title><link href="http://youngsterxyf.github.io/2013/11/01/unescape-html-in-golang-html_template/" rel="alternate"></link><updated>2013-11-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-11-01:2013/11/01/unescape-html-in-golang-html_template/</id><summary type="html">&lt;p&gt;近期在使用Golang的&lt;a href="http://golang.org/pkg/net/http/"&gt;net/http&lt;/a&gt;和&lt;a href="http://golang.org/pkg/html/template/"&gt;html/template&lt;/a&gt;开发一个简单的HAProxy负载均衡任务管理系统（见&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;一文说明）。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/pkg/html/template/"&gt;htmp/template&lt;/a&gt;在渲染页面模板的时候默认会转义字符串中的html标签，但有时我们并不想转义html标签，以下图所示为例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="add_haproxy_balance_task" src="/assets/uploads/pics/haproxy_task_add.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="list_haproxy_balance_task" src="/assets/uploads/pics/haproxy_task_list.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;图1中“ip:port列表(一行一个)”和“说明”两个输入框的内容行与行是以&lt;code&gt;\n&lt;/code&gt;分隔的；图2中，这两部分内容分别在表格的“后端机器列表”和“说明”两列中展示，但行与行其实是以&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;分隔的；那么在将数据存入数据库之前或从数据库中取出数据后，会将字符串中的&lt;code&gt;\n&lt;/code&gt;替换为&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;。如果将替换后的数据以字符串类型传入模板，&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;标签渲染后的效果就是&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;文本而不是换行。&lt;/p&gt;
&lt;p&gt;有两种方式避免&lt;code&gt;html/template&lt;/code&gt;转义html标签：&lt;/p&gt;
&lt;p&gt;1.
把字符串类型数据转换成&lt;code&gt;template.HTML&lt;/code&gt;类型再传入模板进行渲染：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;lti&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;listenTaskInfo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;Seq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="nx"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;Id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="nx"&gt;row&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;Servers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HTML&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;row&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Servers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;-&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="nx"&gt;Vip&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="nx"&gt;appConf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Vip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;Vport&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="nx"&gt;row&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;VPort&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;Comment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HTML&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;row&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Comment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="nx"&gt;LogOrNot&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;row&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;LogOrNot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;row&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
&lt;code&gt;html/template&lt;/code&gt;允许根据需要为模板变量添加一个处理函数，在模板解析的时候该函数就能对模板变量做进一步的处理，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;a href=&amp;quot;/search?q={{. | urlquery}}&amp;quot;&amp;gt;{{. | html}}&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;html/template&lt;/code&gt;貌似并没有内置这样的函数让其不转义html标签，但提供了接口让我们按需自定义这类函数。那么我们可以自定义一个函数-在模板解析的时候将模板变量转换成&lt;code&gt;template.HTML&lt;/code&gt;类型，如（该例子来自&lt;a href="http://coderdave.com/view/how-to-unescape-text-in-a-golang-html-template"&gt;How To Unescape Text In A Golang Html Template&lt;/a&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;unescaped&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HTML&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;renderTemplate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ResponseWriter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;tmpl&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;view&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Page&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;New&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Funcs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;FuncMap&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unescaped&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unescaped&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
    &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ParseFiles&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;view.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;edit.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ExecuteTemplate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;tmpl&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;view&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;StatusInternalServerError&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段代码使得模板解析的时候可以使用unescaped函数将模板变量x转换成&lt;code&gt;template.HTML&lt;/code&gt;类型，关键是如下两句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 定义函数unescaped&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;unescaped&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HTML&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 在模板对象t中注册unescaped&lt;/span&gt;
&lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Funcs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;FuncMap&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unescaped&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;unescaped&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，在模板中就可以使用unescaped函数了，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="nx"&gt;printf&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Body&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;unescaped&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="c1"&gt;//[]byte&lt;/span&gt;
&lt;span class="p"&gt;{{.&lt;/span&gt;&lt;span class="nx"&gt;Body&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nx"&gt;unescaped&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="c1"&gt;//string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实现不转义HTML标签，本质上，这两种方法是一样的，只不过一种是在字符串传入模板之前将其转换成&lt;code&gt;template.HTML&lt;/code&gt;类型，另一种是在字符串传入模板之后解析之时转换。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;template.HTML&lt;/code&gt;类型，&lt;code&gt;text/template&lt;/code&gt;还定义了&lt;code&gt;template.JS&lt;/code&gt;、&lt;code&gt;template.CSS&lt;/code&gt;等数据类型。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://golang.org/pkg/html/template/"&gt;html/template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://coderdave.com/view/how-to-unescape-text-in-a-golang-html-template"&gt;How To Unescape Text In A Golang Html Template&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Golang"></category><category term="template"></category></entry><entry><title>学在腾讯：简而美的微信后台架构</title><link href="http://youngsterxyf.github.io/2013/10/23/learning-in-tencent-backend-arch-of-weixin/" rel="alternate"></link><updated>2013-10-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-23:2013/10/23/learning-in-tencent-backend-arch-of-weixin/</id><summary type="html">&lt;p&gt;注：&lt;em&gt;公司分享讲座的一点笔记，不保证准确性。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;h4&gt;极致的业务特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;流畅的消息收发&lt;/li&gt;
&lt;li&gt;及时的通知&lt;/li&gt;
&lt;li&gt;省电&lt;/li&gt;
&lt;li&gt;省流量&lt;/li&gt;
&lt;li&gt;瘦客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;困难的后台-终端同步&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同步多样数据：账户信息、通讯录、消息、朋友圈等&lt;/li&gt;
&lt;li&gt;及时通知与同步&lt;/li&gt;
&lt;li&gt;移动网络下的可靠同步&lt;/li&gt;
&lt;li&gt;省流量与电量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方案&lt;/h2&gt;
&lt;h4&gt;极简的同步协议&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;后台与终端只需要沟通一个数字，后台即可知道终端缺失的所有数据。&lt;/li&gt;
&lt;li&gt;变更序列号/版本号：&lt;ul&gt;
&lt;li&gt;后台对用户数据的每项变更，都赋予一个单调递增的序列号，即用户的每项数据都有一个全局递增序列号。&lt;/li&gt;
&lt;li&gt;后台每次给终端发送数据都会带上所发送的所有数据的最大序列号。&lt;/li&gt;
&lt;li&gt;终端每次请求数据时都会带上已经接受到的最大序列号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;高效的通知机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ios Apple Push Network Service&lt;/li&gt;
&lt;li&gt;Android等-长连接&lt;/li&gt;
&lt;li&gt;GPRS/EDGE信令风暴优化&lt;/li&gt;
&lt;li&gt;自适应心跳间隔调节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;三层后台架构&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Arch of weixin backend" src="/assets/uploads/pics/arch-of-weixin-backend.png" /&gt;&lt;/p&gt;
&lt;h4&gt;统一的RPC框架&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据ProtocolBuffer定义生成服务器框架和客户端&lt;ul&gt;
&lt;li&gt;服务器：开发人员填充接口实现&lt;/li&gt;
&lt;li&gt;客户端： 应用方本地调用客户端提供的接口函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;屏蔽网络细节&lt;ul&gt;
&lt;li&gt;支持基于TCP/UDP的网络调用&lt;/li&gt;
&lt;li&gt;支持长短连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;丰富的功能&lt;ul&gt;
&lt;li&gt;基于sharding的SET分布&lt;/li&gt;
&lt;li&gt;基于一致性哈希的无状态存储&lt;/li&gt;
&lt;li&gt;服务透明重定向&lt;/li&gt;
&lt;li&gt;丰富的自动化监控：(1)QPS；(2)响应时间；(3)排队时间；(4)各个接口的调用频率与返回状态码分布；(5)各个服务之间的调用拓扑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;高并发的协程RPC&lt;/h4&gt;
&lt;p&gt;服务器同步的调用模型相较异步模型更容易学习、使用和调错。但一台服务器支撑的进程数和线程数是非常有限的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于用户态线程（协程）的RPC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机可以支撑数万甚至十万的用户态线程，仅受CPU和内存约束&lt;/li&gt;
&lt;li&gt;提高并发性和性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;用户态线程RPC的实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于makecontext/getcontext/swapcontext&lt;/li&gt;
&lt;li&gt;Hook Network: read/write/epoll&lt;/li&gt;
&lt;li&gt;用户态线程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;就近访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;就近访问IDC&lt;/li&gt;
&lt;li&gt;就近网络接入：覆盖各大运营商&lt;/li&gt;
&lt;li&gt;CDN：上传下载图片&lt;ul&gt;
&lt;li&gt;腾讯自建CDN&lt;/li&gt;
&lt;li&gt;AKAMAI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;多IDC分布提升用户体验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;国内复杂的网络环境&lt;/li&gt;
&lt;li&gt;超过1亿的海外用户&lt;ul&gt;
&lt;li&gt;分布在全球&lt;/li&gt;
&lt;li&gt;更为多样化的网络环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个IDC都提供完整的功能和所需访问的所有数据&lt;/li&gt;
&lt;li&gt;每个IDC有共同的数据和独立数据&lt;ul&gt;
&lt;li&gt;账户信息全球一致&lt;/li&gt;
&lt;li&gt;用户数据各自独立：(1)一个用户只属于某个IDC；(2)用户属性、关系链、消息；(3)按需共享的SNS数据-照片、评论、红心，减少网络同步带宽消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;IDC分布数据的高可靠最终一致性保证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;账户数据和SNS数据主备访问模型&lt;ul&gt;
&lt;li&gt;用户所在的IDC是主IDC&lt;/li&gt;
&lt;li&gt;其他IDC相对这个用户所在IDC都是备IDC&lt;/li&gt;
&lt;li&gt;更新由主扩散到备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;弱实时性跨IDC更新采用基于Zookeeper仲裁的主备任务队列&lt;ul&gt;
&lt;li&gt;收拢跨IDC访问接口&lt;/li&gt;
&lt;li&gt;重做保证跨IDC更新的可靠性&lt;/li&gt;
&lt;li&gt;数据序列号在重做时保证达到最终一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关系链跨IDC更新&lt;ul&gt;
&lt;li&gt;隐私控制要求实时性&lt;/li&gt;
&lt;li&gt;直接跨IDC网络调用&lt;/li&gt;
&lt;li&gt;后台批处理重试失败请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;容错和容灾机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单IDC&lt;ul&gt;
&lt;li&gt;用户按SET分布，各个SET之间独立&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高可用的异地容灾&lt;ul&gt;
&lt;li&gt;每个服务的主IDC都有一个灾备IDC&lt;/li&gt;
&lt;li&gt;挑战：终端在主备IDC切换时的无缝连接；主备间的数据一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="腾讯"></category><category term="微信"></category><category term="架构"></category></entry><entry><title>搭建高可用负载均衡组件及缓存DNS</title><link href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/" rel="alternate"></link><updated>2013-10-16T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-16:2013/10/16/high-availability-load-balancer-and-dns/</id><summary type="html">&lt;p&gt;该项工作，如题所示，主要分为两部分：高可用负载均衡组件、缓存DNS。&lt;/p&gt;
&lt;h3&gt;高可用负载均衡组件&lt;/h3&gt;
&lt;p&gt;需求：优化业务系统架构中某些关键环节，针对TCP层数据流量进行负载均衡，并保证服务的高可用。&lt;/p&gt;
&lt;p&gt;技术选型：HAProxy + Keepalived，这对组合比较常见成熟。&lt;/p&gt;
&lt;p&gt;另外，由于HAProxy的负载均衡任务可能比较多，靠人工修改配置来增删改任务不方便可靠，所以实现了一个简单的HAProxy管理系统，
以后经实际使用验证和完善会开放源码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="high availability load balancer" src="/assets/uploads/pics/high-availability-load-balancer.png" /&gt;&lt;/p&gt;
&lt;h3&gt;缓存DNS&lt;/h3&gt;
&lt;p&gt;先以www.qq.com为例，解释一下域名解析过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="resolve qq.com" src="/assets/uploads/pics/resolve-qq-com.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;1.
用户向Local DNS发起www.qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;2.
Local DNS向根服务器发起com.查询请求；&lt;/p&gt;
&lt;p&gt;3.
根服务器向Local DNS返回com.解析记录；&lt;/p&gt;
&lt;p&gt;4.
Local DNS向com.权威服务器发起qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;5.
com.权威服务器向Local DNS返回qq.com.解析记录；&lt;/p&gt;
&lt;p&gt;6.
Local DNS向qq.com.权威服务器发起www.qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;7.
qq.com.权威服务器向Local DNS返回www.qq.com.解析记录；&lt;/p&gt;
&lt;p&gt;8.
Local DNS向用户返回www.qq.com解析记录。&lt;/p&gt;
&lt;p&gt;Local DNS一般由网络运营商（如电信、网通等）提供。&lt;/p&gt;
&lt;p&gt;缓存DNS处于用户端（这是一个相对的概念）与local DNS之间，利用DNS服务器软件的缓存功能以及缓存DNS与用户端的近距离特点来加速域名解析。&lt;/p&gt;
&lt;p&gt;也可以在缓存DNS上按需求进行域名劫持。运营商为了牟利，也会在local DNS上进行域名劫持，这对于各大互联网公司对外提供的服务来说是个很大的问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在完成该工作后，我编写了一份安装配置文档，方便其他同事参考。文档见：
&lt;a href="/assets/uploads/files/high-availability-load-balancer-and-dns.pdf"&gt;HAProxy+HAProxyConsole+Keepalived+BIND安装配置文档.pdf&lt;/a&gt;。&lt;/p&gt;</summary><category term="高可用"></category><category term="负载均衡"></category><category term="HAProxy"></category><category term="Keepalived"></category><category term="HAProxyConsole"></category><category term="DNS"></category><category term="BIND"></category></entry><entry><title>运营开发规范化</title><link href="http://youngsterxyf.github.io/2013/10/15/standardization-operation-development/" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-15:2013/10/15/standardization-operation-development/</id><summary type="html">&lt;p&gt;今年3月底毕业，入职腾讯做运营开发，至今6个月有余。入职之时组内仅有1个运营开发的同事，到目前已扩充到5人，加3个实习生。&lt;/p&gt;
&lt;p&gt;入职之时的运营开发过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在办公机器（Windows）上编写代码，功能测试通过后，&lt;/li&gt;
&lt;li&gt;ssh远程连接到生产服务器（Linux），vim打开一个新文件，复制办公机器上的代码，粘贴到vim中，保存，&lt;/li&gt;
&lt;li&gt;打开浏览器测试上线的功能/效果是否正确，若不正确，&lt;/li&gt;
&lt;li&gt;直接在生产服务器上编辑代码文件，直到达到需要的功能效果，&lt;/li&gt;
&lt;li&gt;再从生产服务器上将修改后的代码复制粘贴到办公机器（也许不会有这一步，之后所有的修改都直接在生产服务器上操作）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程存在如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码没有版本控制&lt;/li&gt;
&lt;li&gt;没有与生产服务器一致的测试环境&lt;/li&gt;
&lt;li&gt;代码部署过程繁琐&lt;/li&gt;
&lt;li&gt;办公开发机器上代码很可能比生产服务器上代码还旧&lt;/li&gt;
&lt;li&gt;上面4点都会导致混乱&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外，当团队从1人扩充到多人后，不可避免地会遇到协作的问题，解决代码开发协作问题一般涉及如下几方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用代码版本控制&lt;/li&gt;
&lt;li&gt;规定版本控制的工作流&lt;/li&gt;
&lt;li&gt;编码规范&lt;/li&gt;
&lt;li&gt;项目/代码文档&lt;/li&gt;
&lt;li&gt;定期code review&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决上述问题，我陆续地做了如下工作：&lt;/p&gt;
&lt;h3&gt;搭建Gitlab服务器、测试服务器&lt;/h3&gt;
&lt;p&gt;个人认为开发工作规范化的第一点就是版本控制，基于版本控制可以完成很多自动化的任务。&lt;/p&gt;
&lt;p&gt;平时个人的代码、文档都通过Git版本控制存放在Github上，所以选择Gitlab来自建类Github平台，服务器的搭建过程见： &lt;a href="http://youngsterxyf.github.io/2013/06/18/setup-testing-server/"&gt;搭建测试服务器(源码编译方式)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;测试服务器和Gitlab服务器是同一台机器，在Git服务器端某个版本库的hooks目录下添加post-receive hook脚本，当有代码提交时，触发执行该脚本，脚本会将该版本库各个分支的代码更新到特定目录中，
然后以每个目录为root添加Nginx虚拟主机配置。这样每次代码提交后，就可以直接打开浏览器查看效果了。hook脚本代码见：&lt;a href="https://gist.github.com/youngsterxyf/6988132"&gt;post-receive.py&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;该hook脚本的实现比较暴力---任何代码提交都会检查签出所有分支代码。&lt;/p&gt;
&lt;p&gt;目前为止，Gitlab平台已得到较好的使用，但由于所要开发的运营平台涉及到一些监控数据API问题，很难有效地使用测试服务器，所以测试服务器一直没有正式使用起来。&lt;/p&gt;
&lt;h3&gt;选择一种Git工作流&lt;/h3&gt;
&lt;p&gt;若是单个使用Git，那么Git的工作流基本上就是：&lt;code&gt;git status&lt;/code&gt;，&lt;code&gt;git add xxx&lt;/code&gt;， &lt;code&gt;git commit -m "xxx"&lt;/code&gt;，&lt;code&gt;git pull&lt;/code&gt;，&lt;code&gt;git push origin master&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当涉及多人协作时，为了减少手动合并代码的工作量以及尽可能避免污染Git远程服务器版本信息，Git工作流就要复杂一些。&lt;/p&gt;
&lt;p&gt;我们的Git工作流如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="our-git-workflow" src="/assets/uploads/pics/git-workflow.png" /&gt;&lt;/p&gt;
&lt;p&gt;Git远程服务器端和办公机端版本库都保持两个共享分支：master和develop。master分支是稳定分支，其最新代码与生产服务器上的代码一致。develop是测试分支。&lt;/p&gt;
&lt;p&gt;开发人员开发新功能或fix bug时，先在本地机器从master分支创建一个非共享分支xxx，在xxx分支中编写代码；需要在测试服务器测试代码时，将xxx分支合并入develop分支，将develop分支push到远程服务器；
经测试后，确定需要上线生产服务器，则将xxx分支合并入master分支，并push远程服务器，生产服务器从master分支pull代码进行部署。&lt;/p&gt;
&lt;p&gt;这种工作流能避免“先提交的代码后上线”而导致的版本回滚问题。&lt;/p&gt;
&lt;h3&gt;生产服务器上的代码迁入版本控制&lt;/h3&gt;
&lt;p&gt;这项工作虽然工作量不大，却值得一提。因为不能影响正常的服务，也不能导致任何文件的丢失损坏，所以应该慎之又慎。&lt;/p&gt;
&lt;p&gt;我选择周末在公司完成该工作，过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Gitlab上新建一个版本库，如&lt;em&gt;xxx&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;将生产服务器上的代码打包备份一下；&lt;/li&gt;
&lt;li&gt;进入代码根目录，执行&lt;code&gt;git init&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建编写.gitignore文件，因为一些非代码文件，如图片、视频等，是不需要进入版本控制的，应告诉git忽略。注意：已进入版本控制的文件，即使在.gitignore里列出，git也不会忽略的。
由于文件比较多，目录结构比较复杂，所以可能很难一次性找到所有需要过滤的文件，可以先&lt;code&gt;git add *&lt;/code&gt;，然后通过&lt;code&gt;git status&lt;/code&gt;来查看哪些文件已被加入暂存区，如果有需要过滤的文件被加入了暂存区，则执行&lt;code&gt;git reset&lt;/code&gt;取消
暂存区内容，再次编辑.gitignore；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确认需要过滤的文件都能被.gitignore中的内容匹配后执行&lt;code&gt;git add * &amp;amp;&amp;amp; git commit -m "init"&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将本地的git版本库与Gitlab服务器端的git版本库关联起来。假设Gitlab服务器端版本库的http链接为&lt;em&gt;http://gitlab.server.com/xxx.git&lt;/em&gt;，执行&lt;code&gt;git remote add origin http://gitlab.server.com/xxx.git&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将本地版本库代码推送到远程Gitlab服务器端。执行&lt;code&gt;git push origin master&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，生产服务器上的代码就迁入版本控制了，之后代码部署，只需从Git远程服务器拉取（pull）一下就可以了。&lt;/p&gt;
&lt;p&gt;代码部署过程，原本也想通过hook方式---在代码提交进入master分支时，触发hook脚本，将master分支最新的代码拉取到生产服务器上，但一方面由于网络设定---测试服务器不能主动连接生产服务器，
另一方面谨慎起见，没有采用这种自动方式。在代码提交到Gitlab服务器端后，需要登录到生产服务器执行&lt;code&gt;git pull&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;项目/代码文档&lt;/h3&gt;
&lt;p&gt;入职一段时间后，虽然为运营平台写了几个功能模块，但对于与这几个模块关联的其他模块的实现逻辑并不清楚。对于非我实现的模块具体要解决的问题、以及各个模块的数据来源等也不清楚，也没有文档可查阅，所以着手写一份代码文档---&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;说明各个功能模块解决的问题、实现逻辑、API、相关cron脚本、数据表；&lt;/li&gt;
&lt;li&gt;说明运营平台的请求处理过程、用户身份认证方式；&lt;/li&gt;
&lt;li&gt;前端页面的构成（因为该运营平台所有页面统一使用一种iframe组合的结构）；&lt;/li&gt;
&lt;li&gt;指出代码中一些隐藏的bug、代码中的“坏味道”，并针对代码存在的问题，提出一些编程建议；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于前端页面HTML、CSS、JS，我没有过多纠结。我们前端方面的技能不咋地，前端实现依赖于BootStrap、jQuery等开源代码库。&lt;/p&gt;
&lt;p&gt;这项工作花费的较多时间，导致到后来有点赶工作，文档也写得比较粗糙。现在来看，这份文档写得很不好，只有文字叙述，没有图表，比较枯燥，当然部分原因也是该运营平台没有采用一个完整的框架，各个模块通过前端页面拼凑起来。&lt;/p&gt;
&lt;p&gt;该文档中提出的一些编程建议却有一些可取之处：&lt;/p&gt;
&lt;p&gt;1.
&lt;strong&gt;代码上线之前，务必先删除调试语句&lt;/strong&gt;，比如&lt;code&gt;common.php&lt;/code&gt;中的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;file_put_contents(&amp;#39;/tmp/cron_test_ip.txt&amp;#39;, print_r($ip, true));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调试语句对于正式上线的代码来说是多余的，会影响应用的性能，也可能带来安全问题。&lt;/p&gt;
&lt;p&gt;2.
&lt;strong&gt;清楚地理解你写下的每行代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于非函数式语言来说，每行代码都可能有一些“副作用”，如果你没有理解好你写的代码，就可能带来你无法预料的后果，也会花费你大量调试时间，所以不要轻易使用你还不是很理解的函数、类以及语言特性。&lt;/p&gt;
&lt;p&gt;3.
&lt;strong&gt;一份代码“写三遍”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编程是一个将大脑中的想法转化为可执行程序的过程，如果想法还不清楚，也就不可能写出正确的程序，即使写出的程序可执行，也可能会存在逻辑上的漏洞，成为隐藏的bug。写程序也并不是一气呵成的，而是一个反复编写调试的过程，这个过程非常关注细节，可能导致你无法从整体上把握程序的结构、性能等问题，所以在写完一个程序，程序也能执行了，你还得重新阅读思考一遍你写的程序。&lt;/p&gt;
&lt;p&gt;第一遍：仔细思考要用程序来实现的任务逻辑，避免逻辑错误、漏洞；&lt;/p&gt;
&lt;p&gt;第二遍：编写程序，旨在实现一个可执行的程序；&lt;/p&gt;
&lt;p&gt;第三遍：重新完整地阅读一遍程序，去除不必要的语句，优化代码结构，提高程序性能。&lt;/p&gt;
&lt;p&gt;4.
&lt;strong&gt;恰当处理cron脚本/API文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应将cron脚本/API文件放在恰当的目录下，在cron脚本/API文件数目较多时，应使用较为细分的目录结构对cron脚本/API文件进行归类。另外，应及时清除弃用的代码文件。&lt;/p&gt;
&lt;p&gt;5.
&lt;strong&gt;前端页面代码尽可能分离HTML、CSS、JS。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;务必不要内联引用CSS，即不要通过使用HTML标签的style属性来为标签添加CSS效果，因为这会造成大量的冗余代码，并且影响了HTML代码的简洁。&lt;/p&gt;
&lt;p&gt;最好是将HTML、CSS、JS代码分离成不同的文件，即使用外部引用JS、CSS。优点有3：1)提高HTML、JS、CSS代码各自的简洁易读性；2)能够在多个页面（甚至整个网站）之间共享JS、CSS，提高代码复用，减轻代码更新的工作量，提高网站风格的一致性；3)方便网站内容动静分离，分别对JS、CSS代码进行压缩处理，也能使用CDN来加速请求响应。&lt;/p&gt;
&lt;p&gt;退一步，也可以在HTML的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中编写CSS、JS代码。&lt;/p&gt;
&lt;p&gt;6.
&lt;strong&gt;DRY（Don't Repeat Yourself）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要复制粘贴代码。在发现相同代码在不同地方出现两次以上时，就应使用函数、类、公共文件等方式来避免重复代码的出现，提高代码的复用性，也为未来更新代码减少工作量。&lt;/p&gt;
&lt;p&gt;7.
&lt;strong&gt;尽可能避免使用依赖特定操作系统、文件系统的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;（1）尽可能避免通过绝对路径引入文件，因为当代码中出现大量绝对路径时，代码迁移或变更的工作量就会大得多，而且可能会遗漏更改，从而导致bug。可以通过在一个公共文件中为项目根目录定义常量，在需要时基于该常量来引入文件，代码迁移或变更时只需更改该变量的值就可以了。另外，如果可行，则尽可能使用相对路径。&lt;/p&gt;
&lt;p&gt;（2）尽可能避免直接调用操作系统提供的shell命令来完成任务。一方面某些特殊符号对于shell来说是有特殊意义的，如果参数中带有这些特殊符号就需要特别注意；另一方面对于代码的可移植性来说，直接调用shell命令是很大的问题。一般来说，编程语言都有一些库来支持对文件系统等对象的操作，应尽可能使用这些库来完成任务。&lt;/p&gt;
&lt;h3&gt;规范宣导&lt;/h3&gt;
&lt;p&gt;为了推行规范，需要和组内运营开发同事说明&lt;strong&gt;规范的必要性&lt;/strong&gt;、&lt;strong&gt;如何执行规范（如Git的使用、Git工作流）&lt;/strong&gt;、&lt;strong&gt;哪些东西可以从代码文档中查询&lt;/strong&gt;等，所以简单了做了个分享，ppt见：&lt;a href="/assets/uploads/files/s-o-p.pdf"&gt;规范化运营开发&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;如何推行“定期code review”&lt;/h3&gt;
&lt;p&gt;You know, i am a newcomer，在工作中很难让同事们定期花点时间坐下来review代码，so，我只好实现一个自动化工具---一个cron脚本，每周执行一次，获取一周以来的commit，为其中每个committer随机分配另一个committer一周以来的所有commit作为review任务，将任务中的commit在gitlab上的超链接发送到各自的邮箱。&lt;/p&gt;
&lt;p&gt;代码见：&lt;a href="https://gist.github.com/youngsterxyf/7002279"&gt;pack_git_commit.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码中导入的TofApi是我对公司提供的统一消息发送接口的Python封装。&lt;/p&gt;
&lt;h3&gt;如何推行“编码规范”&lt;/h3&gt;
&lt;p&gt;与“如何推行‘定期code review’”一样，我也是编写了一个自动化小工具来帮助推行编码规范---一个cron脚本，先定制git log命令参数，脚本中调用该git log命令，解析出需要的数据，对不同类型的代码文件使用不同的静态分析程序来分析每行代码不符合编码风格之处，然后将结果提交到gitlab的一个特定代码库中，并将结果的超链接发送到每个代码文件相关人员（对该文件做过增删的人）的邮箱，以提供编码风格改进参考。&lt;/p&gt;
&lt;p&gt;该工具目前支持js、php、python文件代码的分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;js代码的分析是以Google JavaScript Style Guide为标准，借助Google的closure_linter工具进行分析（我对该工具的代码进行了hack，以支持过滤正则表达式文件名表示的文件）&lt;/li&gt;
&lt;li&gt;php代码的分析是以Zend  Coding Standards（http://framework.zend.com/wiki/display/ZFDEV2/Coding+Standards） 为标准，借助phpcs进行分析&lt;/li&gt;
&lt;li&gt;python代码的分析是以PEP 8为标准，借助flake8进行分析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主代码见：&lt;a href="https://gist.github.com/youngsterxyf/7002350"&gt;codelintset.go&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于最近对golang比较感兴趣，所以主程序使用golang实现。&lt;/p&gt;
&lt;p&gt;代码中涉及的send_mail.py也是使用上面提到的TofApi的一个邮件发送脚本，template.tmpl是一个golang模板，用于生成静态分析结果，包括源码、分析结果、相关人员三个部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;这个程序还有点问题 --- git在每个commit中会记录两个时间：author date（文件增删改的时间）和committer date（commit的时间），但很有可能某个变更在commit到本地版本库后，过了很长时间才push到远程服务器。
该程序是在gitlab服务器上每天执行一次，其中git log的参数&lt;code&gt;--since&lt;/code&gt;是对committer date起作用。即使一天之内有新commit push到gitlab服务器，该程序执行定制的git log命令，结果也很可能为空，因为是commit一天之后才push的。
查了一下gitlab的API，好像也没找到commit push的时间的API，估计得自己去分析gitlab的数据库，然后读取commit push的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2013-10-22 更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;codelintset.go&lt;/em&gt;已更新为&lt;a href="https://gist.github.com/youngsterxyf/7093991"&gt;第二版&lt;/a&gt;，通过读取gitlab数据库中的相关数据来解决上述问题，并将原来需要配置的常量全部放到json文件，程序运行时会解析该json文件。这样，修改配置不需要重新编译源码。&lt;/p&gt;</summary><category term="服务器"></category><category term="Linux"></category><category term="Git"></category><category term="Golang"></category><category term="Python"></category></entry><entry><title>一项工作中涉及的几个命令</title><link href="http://youngsterxyf.github.io/2013/10/14/several-command-in-one-task/" rel="alternate"></link><updated>2013-10-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-14:2013/10/14/several-command-in-one-task/</id><summary type="html">&lt;p&gt;今天写了点shell脚本，在一些CentOS服务器上进行了一些操作，涉及如下命令：&lt;/p&gt;
&lt;h3&gt;统计特定进程个数&lt;/h3&gt;
&lt;p&gt;如统计haproxy进程的个数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps -e &lt;span class="p"&gt;|&lt;/span&gt; grep haproxy &lt;span class="p"&gt;|&lt;/span&gt; wc -l
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;获取特定进程的pid&lt;/h3&gt;
&lt;p&gt;如获取haproxy进程的pid&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps -e &lt;span class="p"&gt;|&lt;/span&gt; grep haproxy &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;一对多添加ssh信任关系&lt;/h3&gt;
&lt;p&gt;如192.168.2.1用户usernameA到192.168.2.x用户usernameB的信任关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在192.168.2.1创建自己的公钥私钥：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ssh-keygen -t rsa   &lt;span class="c"&gt;# 提示输入时，全部留空回车。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝192.168.2.1的公钥到192.168.2.x机器上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ssh-copy-id &lt;span class="s2"&gt;&amp;quot;-p 22 usernameB@192.168.2.x&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里192.168.2.x的sshd服务是开放22端口。&lt;/p&gt;
&lt;p&gt;根据提示输入usernameB的密钥后，就会将192.168.2.1上/home/usernameA/.ssh/id_rsa.pub的内容拷贝192.168.2.x的/home/usernameB/.ssh/authorized_keys文件中。&lt;/p&gt;
&lt;p&gt;以后通过&lt;code&gt;ssh -p 22 usernameB@192.168.2.x&lt;/code&gt;访问192.168.2.x时都不在需要输入usernameB的密码。&lt;/p&gt;
&lt;h3&gt;修改网卡ip&lt;/h3&gt;
&lt;p&gt;如修改网卡eth0的ip。&lt;/p&gt;
&lt;p&gt;文件/etc/sysconfig/network-scripts/ifcfg-eth0大致有如下所示内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;DEVICE=&amp;#39;eth0&amp;#39;
HWADDR=&amp;#39;&amp;#39;
NM_CONTROLLED=&amp;#39;yes&amp;#39;
ONBOOT=&amp;#39;yes&amp;#39;
IPADDR=&amp;#39;192.168.2.193&amp;#39;
NETMASK=&amp;#39;255.255.255.0&amp;#39;
GATEWAY=&amp;#39;192.168.2.1&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将IPADDR的值修改为需指定的ip，保存后，执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;service network restart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/etc/init.d/network restart
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;修改系统时间&lt;/h3&gt;
&lt;p&gt;通过命令&lt;code&gt;date&lt;/code&gt;可以查看Linux服务器当前的时间，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ date
Mon Oct 14 17:44:31 CST 2013
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令加&lt;code&gt;-s&lt;/code&gt;参数，即可修改系统的时间，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ date -s &amp;quot;Mon Oct 14 20:44:31 CST 2013&amp;quot;
Mon Oct 14 20:44:31 CST 2013
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在系统启动时，Linux系统将时间从CMOS中读到系统时间变量中，以后修改时间通过修改系统时间实现。为了保持系统时间与CMOS时间的一致性， Linux每隔一段时间会将系统时间写入CMOS。
由于该同步是每隔一段时间（大概是几分钟）进行的，在执行&lt;code&gt;date -s "xxx"&lt;/code&gt;后，如果马上重启机器，修改时间就有可能没有被写入CMOS,这就是问题的原因。如果要确保修改生效可以执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;clock -w
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考：http://www.blogjava.net/itvincent/archive/2007/08/03/134242.html&lt;/p&gt;
&lt;h3&gt;开机自启动程序设置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如为haproxy编写开机自启动shell脚本-haproxy.sh，内容如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;# chkconfig: 2345 25 9&lt;/span&gt;
&lt;span class="c"&gt;# description: haproxy is a level 4 LB&lt;/span&gt;

. /etc/rc.d/init.d/functions

&lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/haproxy/haproxy.pid
&lt;span class="nv"&gt;SBIN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/haproxy/sbin/haproxy
&lt;span class="nv"&gt;CONF&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/haproxy/conf/haproxy.conf
&lt;span class="nv"&gt;logfile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/root/app.log

restart &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;$SBIN&lt;/span&gt; -f &lt;span class="nv"&gt;$CONF&lt;/span&gt; -st &lt;span class="sb"&gt;`&lt;/span&gt;cat &lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Restart haproxy At `date`&amp;quot;&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="nv"&gt;$logfile&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

start &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c"&gt;#if [ -f $PID ]; then&lt;/span&gt;
    &lt;span class="c"&gt;#        echo &amp;quot;started already&amp;quot;&lt;/span&gt;
    &lt;span class="c"&gt;#        exit 0;&lt;/span&gt;
    &lt;span class="c"&gt;#fi&lt;/span&gt;
    &lt;span class="nv"&gt;$SBIN&lt;/span&gt; -c -f &lt;span class="nv"&gt;$CONF&lt;/span&gt;
    &lt;span class="nv"&gt;$SBIN&lt;/span&gt; -f &lt;span class="nv"&gt;$CONF&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Start haproxy Process pid:`cat &lt;/span&gt;&lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="s2"&gt;`&amp;quot;&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Start haproxy At `date`&amp;quot;&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="nv"&gt;$logfile&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

stop &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Kill haproxy Process pid:`cat &lt;/span&gt;&lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="s2"&gt;`&amp;quot;&lt;/span&gt;
        &lt;span class="nb"&gt;kill&lt;/span&gt; -SIGINT &lt;span class="sb"&gt;`&lt;/span&gt;cat &lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Stop haproxy At `date`&amp;quot;&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="nv"&gt;$logfile&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

pid &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        ps -ef&lt;span class="p"&gt;|&lt;/span&gt;grep master&lt;span class="p"&gt;|&lt;/span&gt;grep &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$SBIN&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;haproxy Pid Is:`cat &lt;/span&gt;&lt;span class="nv"&gt;$PID&lt;/span&gt;&lt;span class="s2"&gt;`&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; in 
reload&lt;span class="p"&gt;|&lt;/span&gt;restart&lt;span class="o"&gt;)&lt;/span&gt;
        pid
        restart
        pid
        &lt;span class="p"&gt;;;&lt;/span&gt;
start&lt;span class="o"&gt;)&lt;/span&gt;
        start
        &lt;span class="p"&gt;;;&lt;/span&gt;
stop&lt;span class="o"&gt;)&lt;/span&gt;
        stop
        &lt;span class="p"&gt;;;&lt;/span&gt;
check&lt;span class="p"&gt;|&lt;/span&gt;-t&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;$SBIN&lt;/span&gt; -c -f &lt;span class="nv"&gt;$CONF&lt;/span&gt;
        &lt;span class="p"&gt;;;&lt;/span&gt;
pid&lt;span class="p"&gt;|&lt;/span&gt;p&lt;span class="p"&gt;|&lt;/span&gt;-p&lt;span class="o"&gt;)&lt;/span&gt;
        pid
        &lt;span class="p"&gt;;;&lt;/span&gt;
*&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Please Use ( restart|start|stop|check|pid ) as argument&amp;quot;&lt;/span&gt;
        &lt;span class="p"&gt;;;&lt;/span&gt;
&lt;span class="k"&gt;esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制haproxy.sh到/etc/init.d/目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将haproxy加入开机启动，即设置在开机时自动执行haproxy.sh脚本：&lt;code&gt;chkconfig --add haproxy.sh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭开机启动：&lt;code&gt;chkconfig haproxy.sh off&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启开机启动：&lt;code&gt;chkconfig haproxy.sh on&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：http://blog.csdn.net/jiedushi/article/details/6767445&lt;/p&gt;</summary><category term="Linux"></category><category term="命令行"></category></entry><entry><title>从URL监控问题谈网站Web架构</title><link href="http://youngsterxyf.github.io/2013/10/12/url-monitoring-and-web-arch/" rel="alternate"></link><updated>2013-10-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-10-12:2013/10/12/url-monitoring-and-web-arch/</id><summary type="html">&lt;p&gt;之前工作中实现了一个对站点进行URL监控的功能。原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cron脚本定时从一台Nginx服务器上获得Nginx配置文件（包括upstream配置），在解析配置得到：&lt;code&gt;域名-&amp;gt;upstream名&lt;/code&gt;（可能有多个）、&lt;code&gt;upstream名-&amp;gt;属于该upstream的服务器ip列表&lt;/code&gt;，存入数据库；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户通过Web界面配置URL监控项，配置过程为：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入要监控的URL，如http://www.sample.com/test.php ，前端JS解析出域名部分www.sample.com，向后端发送AJAX请求，得到该域名相关的upstream；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;用户选择正确的那个upstream（Nginx可以将对不同URL的请求转发到不同的upstream后端机器）；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后填写监控告警信息接收人等其他配置信息，提交即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个cron脚本定时地:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从数据库中读取URL监控项数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;根据监控项中的upstream名，从数据库中读取属于该upstream的ip列表；&lt;/li&gt;
&lt;li&gt;逐个使用ip列表中的ip替换URL的域名部分，将域名部分作为HTTP请求头的HOST字段的值；&lt;/li&gt;
&lt;li&gt;使用libcurl库或curl命令发出请求（如使用curl命令：&lt;code&gt;curl -H "www.sample.com" http://192.168.1.1/test.php&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;如果响应码非200或非3xx等，则发送告警信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方式的好处是&lt;strong&gt;不仅能够检测URL指代的web页面或服务是否正常，还能检测提供该web页面或服务的每台服务器是否服务正常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;该URL监控功能基于的网站Web架构也是上了一定流量的网站通常采用的架构，大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx-frontend-forward" src="/assets/uploads/pics/nginx_frontend_forward.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/assets/uploads/pics/nginx_frontend_forward.png"&gt;高清无码大图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该Web架构中，使用一台Nginx服务器作为统一入口来接收所有请求，对请求进行规则匹配和负载均衡后转发到某台后端实际提供服务的服务器上。&lt;strong&gt;在转发请求之前，该Nginx服务器可能会因为某些原因对请求的某些参数（如请求的头部字段）进行修改&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从上图也可以看出，该URL监控方式还有一个好处：监控的请求不需要经过Nginx前端转发机。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;近几天，该URL监控功能出现了误报的问题，原因为：对于某些域名或URL的请求，在经过Nginx前端转发机时被Nginx修改了请求头HOST字段，然后才转发到后端机器，而&lt;strong&gt;后端机器Nginx虚拟主机配置的server_name字段的值是与前端转发机修改后的请求头HOST字段一致的&lt;/strong&gt;，而该URL监控功能的请求是绕过前端转发机直接向后端服务器发送请求，请求头HOST字段为URL中的域名部分，与后端服务器Nginx虚拟主机配置的server_name字段的值不一致，所以后端服务器不会接受该请求。&lt;/p&gt;
&lt;p&gt;那么怎样在保持该URL监控方式的三大好处的前提下解决该问题呢？&lt;/p&gt;
&lt;p&gt;目前我能想到的就是&lt;strong&gt;编写程序从Nginx配置文件中解析得什么样的请求被修改了头部HOST字段&lt;/strong&gt;，但这个难度又实在太大，不可行，了解Nginx的人应该知道Nginx配置可以有多灵活多复杂。&lt;/p&gt;
&lt;p&gt;换个思路想想，URL监控的目的是什么？&lt;strong&gt;是监控服务于特定URL的所有服务器都正常，还是仅监控特定URL服务是否正常？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人认为，URL监控的目的应该是&lt;strong&gt;监控特定URL服务是否正常&lt;/strong&gt;，而&lt;strong&gt;实际提供该URL服务的每台后端服务器是否工作正常，应该通过心跳检测、服务器上的进程监控程序、Nginx前端转发机负载均衡状态等来监控&lt;/strong&gt;。这样，也就绕过了上述的问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;上述问题的存在一方面也是因为网站的Web架构中有一个前端转发机，那么为什么要有这个前端转发机呢？好处是什么？弊处又是什么？若有弊处，如何解决？&lt;/p&gt;
&lt;p&gt;个人理解，好处主要有如下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;网络安全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nginx提供的负载均衡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将系统作为一个整体来看，其提供的服务可以通过GSLB基于用户ip地理信息和运营商，尽可能加速访问速度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;网络安全&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前端转发机通过防火墙、Nginx白名单等方式为所有后端服务器提供统一的安全策略；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端转发机将实际提供服务的机器与互联网隔离，后端服务器上代码和数据不会直接受到攻击和窃取。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Nginx提供的负载均衡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对于某些服务，单台后端服务器可能无法支撑负载，基于Nginx的负载均衡功能可以使用多台机器来分流请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;通过GSLB加速整个系统提供的服务&lt;/h3&gt;
&lt;p&gt;要想利用GSLB进行加速，需要为系统在每个（大）运营商的网络中都部署一台前端转发机，各个前端转发机以专线或者其他有效方式与后端服务器连接。&lt;/p&gt;
&lt;p&gt;假设所有前端转发机共享域名x.xxx.com，在记录有该域名信息的DNS服务器上对应该域名就有多个ip。该系统对外提供www.example.com、www.a.example.com、www.b.example.com等站点的服务。用户在访问这几个站点时，域名www.example.com、www.a.example.com、www.b.example.com的DNS解析过程是先将这些域名都CNAME为x.xxx.com，然后查找到x.xxx.com对应的ip返回给用户端。记录x.xxx.com的授权DNS服务器在接收到域名x.xxx.com的DNS请求后，通过与该DNS服务器关联的GSLB控制设备根据请求来自的运营商（以及地理信息等其他信息）得到访问最快的前端转发机ip返回给用户端。&lt;/p&gt;
&lt;p&gt;各个前端转发服务器通过Nginx虚拟主机配置的server_name参数和HTTP请求的头部HOST字段来区分对不同站点的请求。&lt;/p&gt;
&lt;p&gt;上述环节中，记录x.xxx.com的授权服务器如果放在某个运营商网络里，对于其他运营商网络里的用户，DNS解析过程就会比较慢，从而大大影响了访问速度。一个有效的解决方案是：该DNS服务器同时接入多个运营商网络。&lt;/p&gt;
&lt;p&gt;如果网站代码进行动静分离，静态内容通常会采用CDN方式来加速，我想CDN技术也是基于GSLB来实现的吧？&lt;/p&gt;
&lt;p&gt;对于有钱的大厂来说，按区域部署IDC后，GSLB更能显示其优势吧？！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;上图中所示的网站Web架构当然也有其弊处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx前端转发机会成为系统单点&lt;/li&gt;
&lt;li&gt;Nginx前端转发机可能会成为系统的性能瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系统单点&lt;/h3&gt;
&lt;p&gt;对于该问题，可以使用keepalived来实现双机热备。&lt;/p&gt;
&lt;h3&gt;性能瓶颈&lt;/h3&gt;
&lt;p&gt;如果真的成了性能瓶颈，可以对前端转发机Nginx的功能进行拆分，即尽可能简化前端转发机Nginx的配置，如每个虚拟主机配置为仅转发请求。在前端转发机与后端服务器之间增加一层负载均衡服务器，负载均衡、访问控制、rewrite等功能放在该层完成。演变后的系统结构图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="add_load_balance_level" src="/assets/uploads/pics/add_load_balance_level.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/assets/uploads/pics/add_load_balance_level.png"&gt;高清无码大图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外，我想只能加强服务器硬件或者将系统拆分成多个小系统了吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;欢迎拍砖！&lt;/p&gt;</summary></entry><entry><title>通过示例学习Git内部构造（译）</title><link href="http://youngsterxyf.github.io/2013/09/28/learning-git-internals-by-example/" rel="alternate"></link><updated>2013-09-28T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-09-28:2013/09/28/learning-git-internals-by-example/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://teohm.github.io/blog/2011/05/30/learning-git-internals-by-example/"&gt;Learning Git Internals by Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;状态：草稿&lt;/p&gt;
&lt;p&gt;计划修订本文，未来可能会简化一些...&lt;/p&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;p&gt;从Subversion和Mercurial切换到Git之后的几个月，我始终觉得Git在本质上是不同于Subversion和Mercurial的，但没法确切地说出区别。
我经常在Github上看到tree、parent等术语，也搞不清楚它们确切的含义。&lt;/p&gt;
&lt;p&gt;因此我决定花些时间学学Git。&lt;/p&gt;
&lt;p&gt;我会尝试概述，并阐述一路走来学到的关于Git的关键信息...但这仅是有助于我回答Git与其他源码控制工具区别的Git内部构造基本知识。&lt;/p&gt;
&lt;h2&gt;实体、引用、索引（Objects，References，The Index）&lt;/h2&gt;
&lt;p&gt;要理解Git内部构造的核心，我们应理解三个东西： &lt;strong&gt;实体&lt;/strong&gt;、&lt;strong&gt;引用&lt;/strong&gt;、 &lt;strong&gt;索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我发现这个模型非常优雅。用一个小小的图表就能完全展现，也易于理解记忆。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Big Picture" src="/assets/uploads/pics/git-internals/big-picture.png" /&gt;&lt;/p&gt;
&lt;h3&gt;实体&lt;/h3&gt;
&lt;p&gt;你提交到一个Git代码仓库中的所有文件，包括每个提交的说明信息（the commit info）都在目录 &lt;code&gt;.git/objects/&lt;/code&gt;中存储为&lt;strong&gt;实体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个实体以一个40字符长度的字符串（该实体内容的SHA1哈希值）来标识。&lt;/p&gt;
&lt;p&gt;实体有&lt;strong&gt;4类&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;blob&lt;/em&gt; - 存储文件内容。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tree&lt;/em&gt; - 存储目录结构和文件名。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;commit&lt;/em&gt; - 存储提交的说明，组成Git的提交图谱。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tag&lt;/em&gt; - 存储带注释的标签（tag）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下文的示例会阐明这些实体是如何相互关联的。&lt;/p&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;Git中，一个&lt;em&gt;分支（branch）&lt;/em&gt;、&lt;em&gt;远程分支（remote branch）&lt;/em&gt;或一个&lt;em&gt;标签（tag）&lt;/em&gt;（也称为轻量标签）仅是&lt;strong&gt;指向一个实体的一个指针&lt;/strong&gt;，这里的实体通常是一个commit实体。&lt;/p&gt;
&lt;p&gt;这些引用以文本文件的形式存储在目录&lt;code&gt;.git/refs/&lt;/code&gt;中。&lt;/p&gt;
&lt;h4&gt;符号引用（Symbolic References）&lt;/h4&gt;
&lt;p&gt;Git有一种特殊的引用，称为&lt;em&gt;符号引用&lt;/em&gt;。它并不直接指向一个实体，而是&lt;strong&gt;指向另一个引用&lt;/strong&gt;。举例来说，&lt;code&gt;.git/HEAD&lt;/code&gt;就是一个符号引用。它指向你正在工作的当前分支。&lt;/p&gt;
&lt;h3&gt;索引&lt;/h3&gt;
&lt;p&gt;索引是一个暂存区，以二进制文件的形式存储为文件&lt;code&gt;.git/index&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;git add&lt;/code&gt;一个文件，Git将该文件的信息添加到索引中。当&lt;code&gt;git commit&lt;/code&gt;，Git仅提交索引文件中列出的文件。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;我们来演练一个简单的示例，创建一个Git代码仓库，提交一些文件，看看幕后&lt;code&gt;.git&lt;/code&gt;目录中都发生了些什么。&lt;/p&gt;
&lt;h3&gt;初始化新的代码仓库&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git init canai
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="初始化代码仓库后" src="/assets/uploads/pics/git-internals/init.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建了空目录&lt;code&gt;.git/objects/&lt;/code&gt;和&lt;code&gt;.git/refs/&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;还没有索引（Index）文件。&lt;/li&gt;
&lt;li&gt;创建了符号索引文件&lt;code&gt;HEAD&lt;/code&gt;。&lt;div class="highlight"&gt;&lt;pre&gt;$ cat .git/HEAD
ref: refs/heads/master
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加新文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ echo &amp;quot;A roti canai project.&amp;quot; &amp;gt;&amp;gt; README
$ git add README
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="添加新文件后" src="/assets/uploads/pics/git-internals/new-file.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建了索引（Index）文件。它有一个SHA1哈希值指向一个blob实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git ls-files --stage
100644 5f89c6f016cad2d419e865df380595e39b1256db 0 README
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个blob实体。README文件的内容存储在该blob中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# .git/objects/5f/89c6f016cad2d419e865df380595e39b1256db
$ git cat-file blob 5f89c6
A roti canai project.
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;首次提交&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git commit -m&amp;#39;first commit&amp;#39;
[master (root-commit) d9976cf] first commit
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 README
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="首次提交后" src="/assets/uploads/pics/git-internals/first-commit.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建了分支‘master’引用，指向‘master’分支中最新的commit实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ cat .git/refs/heads/master 
d9976cfe0430557885d162927dd70186d0f521e8
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了第一个commit实体，指向代码仓库根目录tree实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# .git/objects/d9/976cfe0430557885d162927dd70186d0f521e8
$ git cat-file commit d9976cf
tree 0ff699bbafc5d17d0637bf058c924ab405b5dcfe
author Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306739524 +0800
committer Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306739524 +0800

first commit
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了tree实体。该tree代表目录“canai”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# .git/objects/0f/f699bbafc5d17d0637bf058c924ab405b5dcfe
$ git ls-tree 0ff699
100644 blob 5f89c6f016cad2d419e865df380595e39b1256db  README
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加一个修改过的文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ echo &amp;quot;Welcome everyone.&amp;quot; &amp;gt;&amp;gt; README
$ git add README
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="添加一个修改过的文件后" src="/assets/uploads/pics/git-internals/modified-file.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更新了索引（Index）文件。注意到了吗？它记录了一个新blob。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git ls-files --stage
100644 1192db4c15e019da7fc053225d09dea14bc3ac07 0 README
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的blob实体。README的整个内容被存入一个新的blob。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# .git/objects/11/92db4c15e019da7fc053225d09dea14bc3ac07
$ git cat-file blob 1192db
A roti canai project.
Welcome everyone.
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;向子目录中添加文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ mkdir doc
$ echo &amp;quot;[[TBD]] manual toc&amp;quot; &amp;gt;&amp;gt; doc/manual.txt
$ git add doc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="向子目录添加文件后" src="/assets/uploads/pics/git-internals/subdir.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更新了索引（Index）文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git ls-files --stage
100644 1192db4c15e019da7fc053225d09dea14bc3ac07 0 README
100644 ea283e4fb22719fad512405d41dffa050cd16f9a 0 doc/manual.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的blob实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# .git/objects/ea/283e4fb22719fad512405d41dffa050cd16f9a
$ git cat-file blob ea283
[[TBD]] manual toc
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第二次提交&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git commit -m&amp;#39;second commit&amp;#39;
[master 556eaf3] second commit
 2 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 doc/manual.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="第二次提交后" src="/assets/uploads/pics/git-internals/second-commit.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更新了分支“master”引用，指向该分支中最新的commit实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ cat .git/refs/heads/master 
556eaf374886d4c07a1906b9fdcaba195292b96
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了第二个commit实体。注意它的“parent”是指向首个commit实体。这样形成了一个提交图谱。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git cat-file commit 556e
tree 7729a8b15b747bce541a9752a8f10d57daf221b6
parent d9976cfe0430557885d162927dd70186d0f521e8
author Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306743598 +0800
committer Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306743598 +0800

second commit
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的代码仓库根目录tree实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git ls-tree 7729
100644 blob 1192db4c15e019da7fc053225d09dea14bc3ac07  README
040000 tree 6ff17d485bf857514f299f0bde0e2a5c932bd055  doc
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个新的子目录tree实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git ls-tree 6ff1
100644 blob ea283e4fb22719fad512405d41dffa050cd16f9a  manual.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加一个注释标签（annotated tag）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git tag -a -m&amp;#39;this is annotated tag&amp;#39; v0.1 d9976
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="添加一个注释标签后" src="/assets/uploads/pics/git-internals/annotated-tag.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建了一个标签引用，指向一个tag实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ cat .git/refs/tags/v0.1 
c758f4820f02acf20bb3f6d7f6098f25ee6ed730
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建了一个tag实体。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git cat-file tag c758
object d9976cfe0430557885d162927dd70186d0f521e8
type commit
tag v0.1
tagger Huiming Teo &amp;lt;huiming@favoritemedium.com&amp;gt; 1306744918 +0800

this is annotated tag
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;添加一个新的（轻量的）标签&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ git tag root-commit d9976
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="添加一个新的轻量标签后" src="/assets/uploads/pics/git-internals/new-tag.png" /&gt;&lt;/p&gt;
&lt;p&gt;发生了什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建了一个标签引用，指向一个commit实体。&lt;div class="highlight"&gt;&lt;pre&gt;$ cat .git/refs/tags/root-commit 
d9976cfe0430557885d162927dd70186d0f521e8
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;补充阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://book.git-scm.com/index.html"&gt;Git社区书&lt;/a&gt;“第7章：内部构造探究”&lt;/li&gt;
&lt;li&gt;&lt;a href="http://progit.org/book/ch9-0.html"&gt;Pro Git&lt;/a&gt;“第9章：Git内部构造”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;接下来做什么呢？&lt;/h2&gt;
&lt;p&gt;寻找适合分布式团队、长期项目的一个最小化git工作流。&lt;/p&gt;</summary><category term="Git"></category><category term="翻译"></category></entry><entry><title>时间的心</title><link href="http://youngsterxyf.github.io/2013/08/22/heart-of-time/" rel="alternate"></link><updated>2013-08-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-08-22:2013/08/22/heart-of-time/</id><summary type="html">&lt;p&gt;近期工作生活的一点心得：&lt;/p&gt;
&lt;h3&gt;珍惜自己的时间&lt;/h3&gt;
&lt;p&gt;乐于助人是好事，但，是需要耗费时间的，那么在助人之前就得确认帮助别人所做的事情有多大意义，是否对得起所耗费的时间精力。每个人的时间都很珍贵，应尽可能用来做有价值的事情，不要把自己的时间看得过于廉价。&lt;/p&gt;
&lt;p&gt;所以之后有人请我帮忙时，我会先问两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到什么问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要解决这个问题？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这两个问题来判断是否值得帮忙。&lt;/p&gt;
&lt;h3&gt;平常心&lt;/h3&gt;
&lt;p&gt;一心追求技术，对技术好坏有自己的“正义感”，是好事。但，不能苛求别人，更不能不停评价吐槽，否则于己于人都无益处。对别人、别人的技术水平宽容一点，把苛求留给自己，不断提高自己，努力把事情做得更好，其他的则应保持平常心。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;至于本文的题目，则纯属扯淡，故作矫情，从两个部分的标题中取出最后一词组合而成。&lt;/em&gt;&lt;/p&gt;</summary><category term="总结"></category><category term="自省"></category></entry><entry><title>Y分钟学会Python（译）</title><link href="http://youngsterxyf.github.io/2013/06/29/learn-python-in-y-minutes/" rel="alternate"></link><updated>2013-06-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-29:2013/06/29/learn-python-in-y-minutes/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://learnxinyminutes.com/docs/python/"&gt;Learn Python in Y Minutes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python由Guido Van Rossum发明于90年代初期，是目前最流行的编程语言之一，因其语法的清晰简洁我爱上了Python，其代码基本上可以
说是可执行的伪代码。&lt;/p&gt;
&lt;p&gt;非常欢迎反馈！你可以通过推特&lt;a href="https://twitter.com/louiedinh"&gt;@louiedinh&lt;/a&gt;或louiedinh AT gmail联系我。&lt;/p&gt;
&lt;p&gt;备注：本文是专门针对Python 2.7的，但应该是适用于Python 2.x的。很快我也会为Python 3写这样的一篇文章！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 单行注释以井字符开头&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot; 我们可以使用三个双引号（&amp;quot;）或单引号（&amp;#39;）&lt;/span&gt;
&lt;span class="sd"&gt;    来编写多行注释&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;


&lt;span class="c"&gt;##########################################################&lt;/span&gt;
&lt;span class="c"&gt;## 1. 基本数据类型和操作符&lt;/span&gt;
&lt;span class="c"&gt;##########################################################&lt;/span&gt;

&lt;span class="c"&gt;# 数字&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 3&lt;/span&gt;

&lt;span class="c"&gt;# 你预想的数学运算&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 2&lt;/span&gt;
&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 7&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 20&lt;/span&gt;
&lt;span class="mi"&gt;35&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 7&lt;/span&gt;

&lt;span class="c"&gt;# 除法略显诡异。整数相除会自动向下取小于结果的最大整数&lt;/span&gt;
&lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 2&lt;/span&gt;

&lt;span class="c"&gt;# 还有浮点数和浮点数除法（译注：除数和被除数两者至少一个为浮点数，结果才会是浮点数）&lt;/span&gt;
&lt;span class="mf"&gt;2.0&lt;/span&gt;     &lt;span class="c"&gt;# 这是一个浮点数&lt;/span&gt;
&lt;span class="mf"&gt;5.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;2.0&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 2.5 额...语法更明确一些&lt;/span&gt;

&lt;span class="c"&gt;# 使用括号来强制优先级&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 8&lt;/span&gt;


&lt;span class="c"&gt;# 布尔值也是基本类型数据&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="bp"&gt;False&lt;/span&gt;

&lt;span class="c"&gt;# 使用not来求反&lt;/span&gt;
&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; False&lt;/span&gt;
&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span class="c"&gt;# 相等比较使用==&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; False&lt;/span&gt;

&lt;span class="c"&gt;# 不相等比较使用!=&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; False&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span class="c"&gt;# 更多的比较方式&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; False&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span class="c"&gt;# 比较操作可以串接！&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; False&lt;/span&gt;

&lt;span class="c"&gt;# 可以使用&amp;quot;或&amp;#39;创建字符串&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;This is a string.&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;This is also a string.&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;# 字符串也可以相加！&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Hello &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;world!&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; &amp;quot;Hello world!&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 字符串可以看作是一个字符列表&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;This is a string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; &amp;#39;T&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;# None是一个对象&lt;/span&gt;
&lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; None&lt;/span&gt;


&lt;span class="c"&gt;####################################################&lt;/span&gt;
&lt;span class="c"&gt;## 2. 变量与数据容器&lt;/span&gt;
&lt;span class="c"&gt;####################################################&lt;/span&gt;

&lt;span class="c"&gt;# 打印输出非常简单&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m Python. Nice to meet you!&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 赋值之前不需要声明变量&lt;/span&gt;
&lt;span class="n"&gt;some_var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;    &lt;span class="c"&gt;# 约定使用 小写_字母_和_下划线 的命名方式&lt;/span&gt;
&lt;span class="n"&gt;some_var&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 5&lt;/span&gt;

&lt;span class="c"&gt;# 访问之前未赋值的变量会产生一个异常&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;some_other_var&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;NameError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Raises a name error&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 赋值时可以使用条件表达式&lt;/span&gt;
&lt;span class="n"&gt;some_var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="c"&gt;# 如果a大于b，则将a赋给some_var，&lt;/span&gt;
&lt;span class="c"&gt;# 否则将b赋给some_var&lt;/span&gt;

&lt;span class="c"&gt;# 列表用于存储数据序列&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="c"&gt;# 你可以一个预先填充的列表开始&lt;/span&gt;
&lt;span class="n"&gt;other_li&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;# 使用append将数据添加到列表的末尾&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;#li现在为[1]&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;#li现在为[1, 2]&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;#li现在为[1, 2, 4]&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;#li现在为[1, 2, 4, 3]&lt;/span&gt;

&lt;span class="c"&gt;# 使用pop从列表末尾删除数据&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;    &lt;span class="c"&gt;#=&amp;gt; 3，li现在为[1, 2, 4]&lt;/span&gt;
&lt;span class="c"&gt;# 把刚刚删除的数据存回来&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;# 现在li再一次为[1, 2, 4, 3]&lt;/span&gt;

&lt;span class="c"&gt;# 像访问数组一样访问列表&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 1&lt;/span&gt;
&lt;span class="c"&gt;# 看看最后一个元素&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 3&lt;/span&gt;

&lt;span class="c"&gt;# 越界访问会产生一个IndexError&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;# 抛出一个IndexError异常&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Raises an IndexError&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 可以通过分片(slice)语法来查看列表中某个区间的数据&lt;/span&gt;
&lt;span class="c"&gt;# 以数学角度来说，这是一个闭合/开放区间&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [2, 4]&lt;/span&gt;
&lt;span class="c"&gt;# 省略结束位置&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [4, 3]&lt;/span&gt;
&lt;span class="c"&gt;# 省略开始位置&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [1, 2, 4]&lt;/span&gt;

&lt;span class="c"&gt;# 使用del从列表中删除任意元素&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#li现在为[1, 2, 3]&lt;/span&gt;

&lt;span class="c"&gt;# 列表可以相加&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other_li&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [1, 3, 3, 4, 5, 6] - 注意：li和other_li并未改变&lt;/span&gt;

&lt;span class="c"&gt;# 以extend来连结列表&lt;/span&gt;
&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other_li&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 现在li为[1, 2, 3, 4, 5, 6]&lt;/span&gt;

&lt;span class="c"&gt;# 以in来检测列表中是否存在某元素&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span class="c"&gt;# 以len函数来检测列表长度&lt;/span&gt;
&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 6&lt;/span&gt;

&lt;span class="c"&gt;# 元组类似列表，但不可变&lt;/span&gt;
&lt;span class="n"&gt;tup&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tup&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 1&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;tup&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="c"&gt;# 抛出一个TypeError异常&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;TypeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Tuples cannot be mutated.&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 可以在元组上使用和列表一样的操作&lt;/span&gt;
&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 3&lt;/span&gt;
&lt;span class="n"&gt;tup&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; (1, 2, 3, 4, 5, 6)&lt;/span&gt;
&lt;span class="n"&gt;tup&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; (1, 2)&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;tup&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span class="c"&gt;# 可以将元组解包到变量&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 现在a等于1，b等于2，c等于3&lt;/span&gt;
&lt;span class="c"&gt;# 如果你省略括号，默认也会创建元组&lt;/span&gt;
&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="c"&gt;# 看看两个变量互换值有多简单&lt;/span&gt;
&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;     &lt;span class="c"&gt;#现在d为5，e为4&lt;/span&gt;


&lt;span class="c"&gt;# 字典存储映射关系&lt;/span&gt;
&lt;span class="n"&gt;empty_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="c"&gt;# 这是一个预先填充的字典&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;three&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# 以[]语法查找值&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;one&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 1&lt;/span&gt;

&lt;span class="c"&gt;# 以列表形式获取所有的键&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [&amp;quot;three&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;one&amp;quot;]&lt;/span&gt;
&lt;span class="c"&gt;# 注意 - 字典键的顺序是不确定的&lt;/span&gt;
&lt;span class="c"&gt;# 你的结果也许和上面的输出结果并不一致&lt;/span&gt;

&lt;span class="c"&gt;# 以in来检测字典中是否存在某个键&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;filled_dict&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;filled_dict&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; False&lt;/span&gt;

&lt;span class="c"&gt;# 试图使用某个不存在的键会抛出一个KeyError异常&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;four&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 抛出KeyError异常&lt;/span&gt;

&lt;span class="c"&gt;# 使用get方法来避免KeyError&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 1&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;four&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; None&lt;/span&gt;

&lt;span class="c"&gt;# get方法支持一个默认参数，不存在某个键时返回该默认参数值&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 1&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;four&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 4&lt;/span&gt;

&lt;span class="c"&gt;# setdefault方法是一种添加新的键-值对到字典的安全方式&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;five&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#filled_dict[&amp;quot;five&amp;quot;]设置为5&lt;/span&gt;
&lt;span class="n"&gt;filled_dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;five&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#filled_dict[&amp;quot;five&amp;quot;]仍为5&lt;/span&gt;


&lt;span class="c"&gt;# 集合&lt;/span&gt;
&lt;span class="n"&gt;empty_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# 以几个值初始化一个集合&lt;/span&gt;
&lt;span class="n"&gt;filled_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c"&gt;# filled_set现为set([1, 2, 3, 4, 5])&lt;/span&gt;

&lt;span class="c"&gt;# 以&amp;amp;执行集合交运算&lt;/span&gt;
&lt;span class="n"&gt;other_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;filled_set&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other_set&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; set([3, 4, 5])&lt;/span&gt;
&lt;span class="c"&gt;# 以|执行集合并运算&lt;/span&gt;
&lt;span class="n"&gt;filled_set&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;other_set&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; set([1, 2, 3, 4, 5, 6])&lt;/span&gt;
&lt;span class="c"&gt;# 以-执行集合差运算&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; set([1, 4])&lt;/span&gt;

&lt;span class="c"&gt;# 以in来检测集合中是否存在某个值&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;filled_set&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;filled_set&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; False&lt;/span&gt;


&lt;span class="c"&gt;####################################################&lt;/span&gt;
&lt;span class="c"&gt;## 3. 控制流程&lt;/span&gt;
&lt;span class="c"&gt;####################################################&lt;/span&gt;

&lt;span class="c"&gt;# 创建个变量&lt;/span&gt;
&lt;span class="n"&gt;some_var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="c"&gt;# 以下是一个if语句。缩进在Python是有重要意义的。&lt;/span&gt;
&lt;span class="c"&gt;# 打印 &amp;quot;some_var is smaller than 10&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;some_var&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some_var is totally bigger than 10.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;some_var&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some_var is smaller than 10.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some_var is indeed 10.&amp;quot;&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;For循环在列表上迭代&lt;/span&gt;
&lt;span class="sd"&gt;输出：&lt;/span&gt;
&lt;span class="sd"&gt;    dog is a mammal&lt;/span&gt;
&lt;span class="sd"&gt;    cat is a mammal&lt;/span&gt;
&lt;span class="sd"&gt;    mouse is a mammal&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;animal&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dog&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;cat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;mouse&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
    &lt;span class="c"&gt;# 可以使用%来插补格式化字符串&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; is a mammal&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;animal&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;while循环直到未满足某个条件。&lt;/span&gt;
&lt;span class="sd"&gt;输出：&lt;/span&gt;
&lt;span class="sd"&gt;    0&lt;/span&gt;
&lt;span class="sd"&gt;    1&lt;/span&gt;
&lt;span class="sd"&gt;    2&lt;/span&gt;
&lt;span class="sd"&gt;    3&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="c"&gt;# x = x + 1的一种简写&lt;/span&gt;

&lt;span class="c"&gt;# 使用try/except块来处理异常&lt;/span&gt;

&lt;span class="c"&gt;# 对Python 2.6及以上版本有效&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# 使用raise来抛出一个错误&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;This is an index error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;    &lt;span class="c"&gt;# pass就是什么都不干。通常这里用来做一些恢复工作&lt;/span&gt;

&lt;span class="c"&gt;# 对于Python 2.7及以下版本有效&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;This is an index error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="c"&gt;# 没有&amp;quot;as&amp;quot;，以逗号替代&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;


&lt;span class="c"&gt;####################################################&lt;/span&gt;
&lt;span class="c"&gt;## 4. 函数&lt;/span&gt;
&lt;span class="c"&gt;####################################################&lt;/span&gt;

&lt;span class="c"&gt;# 使用def来创建新函数&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;x is &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; and y is &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;    &lt;span class="c"&gt;# 以一个return语句来返回值&lt;/span&gt;

&lt;span class="c"&gt;# 以参数调用函数&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 11 并输出 &amp;quot;x is 5 and y is 6&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;# 另一种调用函数的方式是关键字参数&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c"&gt;# 关键字参数可以任意顺序输入&lt;/span&gt;

&lt;span class="c"&gt;# 可定义接受可变数量的位置参数的函数&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;varargs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;

&lt;span class="n"&gt;varargs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; (1, 2, 3)&lt;/span&gt;


&lt;span class="c"&gt;# 也可以定义接受可变数量关键字参数的函数&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;keyword_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;

&lt;span class="c"&gt;# 调用一下该函数看看会发生什么&lt;/span&gt;
&lt;span class="n"&gt;keyword_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;big&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;foot&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;loch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ness&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; {&amp;quot;big&amp;quot;: &amp;quot;foo&amp;quot;, &amp;quot;loch&amp;quot;: &amp;quot;ness&amp;quot;}&lt;/span&gt;

&lt;span class="c"&gt;# 也可以一次性接受两种参数&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;all_the_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;all_the_args(1, 2, a=3, b=4)输出：&lt;/span&gt;
&lt;span class="sd"&gt;    [1, 2]&lt;/span&gt;
&lt;span class="sd"&gt;    {&amp;quot;a&amp;quot;: 3, &amp;quot;b&amp;quot;: 4}&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 在调用一个函数时也可以使用*和**&lt;/span&gt;
&lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;kwargs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;#等价于foo(1, 2, 3, 4)&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c"&gt;# 等价于foo(a=3, b=4)&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;# 等价于foo(1, 2, 3, 4, a=3, b=4)&lt;/span&gt;

&lt;span class="c"&gt;# Python的函数是一等函数&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create_adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;adder&lt;/span&gt;

&lt;span class="n"&gt;add_10&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;create_adder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;add_10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; 13&lt;/span&gt;

&lt;span class="c"&gt;# 也有匿名函数&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lamda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; True&lt;/span&gt;

&lt;span class="c"&gt;# 有一些内置的高阶函数&lt;/span&gt;
&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [11, 12, 13]&lt;/span&gt;
&lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lamda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt;[6, 7]&lt;/span&gt;

&lt;span class="c"&gt;# 可以使用列表推导来实现映射和过滤&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;add_10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [11, 13, 13]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; [6, 7]&lt;/span&gt;

&lt;span class="c"&gt;####################################################&lt;/span&gt;
&lt;span class="c"&gt;## 5. 类&lt;/span&gt;
&lt;span class="c"&gt;####################################################&lt;/span&gt;

&lt;span class="c"&gt;# 创建一个子类继承自object来得到一个类&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Human&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="c"&gt;# 类属性。在该类的所有示例之间共享&lt;/span&gt;
    &lt;span class="n"&gt;species&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;H. sapiens&amp;quot;&lt;/span&gt;

    &lt;span class="c"&gt;# 基本初始化构造方法&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# 将参数赋值给实例的name属性&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="c"&gt;# 实例方法。所有示例方法都以self为第一个参数&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;say&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;: &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# 类方法由所有实例共享&lt;/span&gt;
    &lt;span class="c"&gt;# 以调用类为第一个参数进行调用&lt;/span&gt;
    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_species&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;species&lt;/span&gt;

    &lt;span class="c"&gt;# 静态方法的调用不需要一个类或实例的引用&lt;/span&gt;
    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;grunt&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;*grunt*&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 实例化一个类&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Ian&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hi&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c"&gt;# 输出&amp;quot;Ian: hi&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Joel&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c"&gt;# 输出&amp;quot;Joel: hello&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 调用类方法&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_species&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; &amp;quot;H. sapiens&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 修改共享属性&lt;/span&gt;
&lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;species&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;H. neanderthalensis&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_species&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; &amp;quot;H. neanderthalensis&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_species&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#=&amp;gt; &amp;quot;H. neanderthalensis&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 调用静态方法&lt;/span&gt;
&lt;span class="n"&gt;Human&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;grunt&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;   &lt;span class="c"&gt;#=&amp;gt; &amp;quot;*grunt*&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;进一步阅读&lt;/h3&gt;
&lt;p&gt;想要学习更多？试试&lt;a href="http://learnpythonthehardway.org/book/"&gt;笨方法学习Python&lt;/a&gt;。&lt;/p&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>FTP是90年代的，使用Git取代它来部署代码吧！（译）</title><link href="http://youngsterxyf.github.io/2013/06/24/deploy-via-git/" rel="alternate"></link><updated>2013-06-24T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-24:2013/06/24/deploy-via-git/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://coderwall.com/p/xczkaq?&amp;amp;p=1&amp;amp;q="&gt;FTP is so 90's. Let's deploy via Git instead!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，在你的服务器上创建一个目录，并在其中初始化一个空的git仓库。我喜欢使用&lt;code&gt;~/www/&lt;/code&gt;目录来存放网站代码，
因此我会这么做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir ~/www/example.com &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ~/www/example.com
git init
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着，设置你服务器上的git仓库以便很好地通过&lt;code&gt;git push&lt;/code&gt;来部署代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git config core.worktree ~/www/example.com
git config receive.denycurrentbranch ignore
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，为git设置一个post-receive钩子来检出&lt;code&gt;master&lt;/code&gt;分支，这样，你的web服务器就可以为那个分支的代码文件服务了。
（记住，&lt;code&gt;^D&lt;/code&gt;是Control+D，或任何一种你shell的&lt;a href="http://en.wikipedia.org/wiki/End-of-transmission_character"&gt;EOT字符&lt;/a&gt;）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat &amp;gt; .git/hooks/post-receive
&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;
git checkout -f
^D
chmod +x .git/hooks/post-receive
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;谨记：若需要一个构建过程，你可以在post-receive钩子中添加任何你想要添加的东西。例如，我的sinatra项目其中之一使用了如下的
post-receive钩子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;
git checkout -f
bundle install
touch ~/www/example.com/tmp/restart.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;回到你的本地机器，为代码部署准备好你的git仓库。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ~/www/dev/example.com
git remote add origin &lt;span class="se"&gt;\&lt;/span&gt;
ssh://user@example.com/home/user/www/example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于第一次推送代码到服务器，执行如下命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，任何时候你想部署本地的变更，只要简单地执行如下命令！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git push
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Git"></category><category term="翻译"></category></entry><entry><title>搭建测试服务器(源码编译方式)</title><link href="http://youngsterxyf.github.io/2013/06/18/setup-testing-server/" rel="alternate"></link><updated>2013-06-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-18:2013/06/18/setup-testing-server/</id><summary type="html">&lt;p&gt;目前工作中开发流程还比较初级，甚至连测试服务器都没有，代码的变更都是直接先在开发人员的本地机器上简单测试一下，然后直接部署到生产服务器上，这就相当于生产服务器同时充当了测试服务器的角色，虽然开发的是面向公司内部的系统，但作为一个有理想有追求的码农，是不允许这样粗糙混乱的开发流程的，所以申请了台服务器，自己搭建个测试服务器。&lt;/p&gt;
&lt;p&gt;由于公司的服务器统一使用SUSE Linux Server操作系统，并且版本较老。与Ubuntu、Centos等Linux发行版不同，SUSE Linux没有可用的软件源（不知是否与OpenSUSE的软件源兼容？），即没法使用系统的软件包管理工具。这样问题就很多了。&lt;/p&gt;
&lt;p&gt;我选择源码编译的方式来安装所有涉及的软件。也许有人会说，为什么不在网络上查找RPM包然后安装呢？那么先想一下RPM包本质上是个什么东西呢？RPM包（以及DEB包）其实就是将编译好的一些程序以一定的规则打包在一起，然后系统的包管理工具（yum、zypper）按照相同的规则（在依赖满足的情况下）将RPM包里文件复制到指定好的目录里。如果RPM包的依赖没有解决，是无法成功安装的。即使安装好了，若程序依赖的动态链接库等不存在或版本不匹配，也是无法正确运行的，比如libc库的版本过低，但明显你不能轻易替换libc库，因为系统中已安装的很多程序都依赖于libc库。那么相比源码编译方式，RPM包方式的问题更难解决。&lt;/p&gt;
&lt;p&gt;需要安装的软件有Nginx、PHP、MySQL、Memcached、Redis、Mongodb、Python2.7（系统上自带了2.4版本，版本过老）、Git、Gitlab、Ruby（Gitlab基于Ruby on Rails实现），运维工具tmux、htop，以及基础依赖库curl（libcurl）、cmake、libxml2、libxslt、openssl、pcre、readline、zlib、ic4c、libevent等。&lt;/p&gt;
&lt;p&gt;除Gitlab之外（因为Gitlab是个Web应用）的所有软件编译安装流程都类似：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;wget [下载链接]&lt;/code&gt;   # 对于https协议的链接，也许需要添加 &lt;code&gt;--no-check-certificate&lt;/code&gt; 来避免证书验证。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -xvf [软件源码压缩包(*.tar.gz/*.tar)] / unzip [软件源码压缩包(*.zip)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd [源码目录] &amp;amp;&amp;amp; ./configure [--prefix=...] [...]&lt;/code&gt;  # openssl的是./config [...]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中最重要的步骤是&lt;code&gt;./configure&lt;/code&gt;。在这一步中将指定软件的安装目录，以及其他参数（比如依赖的路径）。可以通过&lt;code&gt;./configure --help&lt;/code&gt;来查看configure的选项列表，认真阅读一下，看看自己的编译是否需要带上某些选项。&lt;/p&gt;
&lt;p&gt;软件在编译过程中可能会自动查找借助某些工具，若找不到可能就会编译失败，其查找的规则一般就是环境变量PATH。所以若发现是因为找不到某些工具软件导致编译失败，那得确认一下系统是否安装该工具，若已安装，则配置一下PATH（&lt;code&gt;export PATH=$PATH:/path/to/tool/&lt;/code&gt;或&lt;code&gt;export PATH=/path/to/tool/:$PATH&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;软件也可能依赖一些动态或静态链接库，其查找规则是&lt;code&gt;/etc/ld.so.conf&lt;/code&gt;文件中指定的查找路径。编译过程中经常会因为未找到动态链接库而失败，如果该库已存在，可能需配置一下ld.so.conf，将依赖库的路径添加到ld.so.conf中，然后执行ldconfig。&lt;/p&gt;
&lt;p&gt;很多时候编译失败了，但你并不知道编译过程尝试过去哪些路径中查找某个依赖库。直接阅读Makefile并修改不是个好主意。这时strace神器就派上用场了。&lt;strong&gt;strace is a system call tracer, i.e. a debugging tool which prints out a trace of all the system calls made by a another process/program&lt;/strong&gt;。比如：&lt;code&gt;strace make&lt;/code&gt;，就会输出大量跟踪信息。当编译因未找到依赖而中止后，回溯输出的跟踪信息，看看make过程找过哪些路径，然后将依赖文件软链接到这些路径中某一个，再重新编译。&lt;/p&gt;
&lt;p&gt;从上述4个方面可以解决大多数编译过程中的依赖问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关于编译安装路径，我个人的看法是，基础依赖库，如openssl、zlib等在configure的时候不使用--prefix选项，即使用默认的安装路径，这样其他依赖于这些基础库的软件编译过程中发生依赖缺失问题的可能性要小一些。若系统原来存在老版本的依赖库，这样的默认安装路径方式一般并不会覆盖老版本文件，所以也不用担心会导致系统中已安装的软件运行存在问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关于mysql的编译安装过程可参考：&lt;a href="http://www.linuxidc.com/linux/2011-08/40087.htm"&gt;Linux下源码编译MySQL 5.5 与安装过程全记录&lt;/a&gt;，过程较为复杂。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;PHP源码编译默认不会产生php-fpm（PHP-FPM (FastCGI Process Manager) is an alternative PHP FastCGI implementation with some additional features useful for sites of any size, especially busier sites.），从&lt;code&gt;./configure --help&lt;/code&gt;的输出中可以看到这样几行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;--enable-fpm              Enable building of the fpm SAPI executable
--with-fpm-user=USER  Set the user for php-fpm to run as. (default: nobody)
--with-fpm-group=GRP  Set the group for php-fpm to run as. For a system user, this
              should usually be set to match the fpm username (default: nobody)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样只要在configure的时候提供这几个选项就可以启用php-fpm了。&lt;/p&gt;
&lt;p&gt;为保证测试服务器上的PHP启用的扩展模块与生产服务器上的PHP一致，可通过phpinfo()函数来获知生产服务器上的PHP在configure编译的时候带了哪些选项。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/php-configure.jpg" alt="php-configure.jpg"&gt;&lt;/p&gt;
&lt;p&gt;但这样你得额外编译安装zlib、libmcrypt、libpng、freetype等库。&lt;/p&gt;
&lt;p&gt;PHP configure的选项特别多。&lt;/p&gt;
&lt;p&gt;最后我的configure命令为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./configure --prefix=/usr/local/php --enable-fpm --with-mysql=/usr/local/mysql \
        --with-mysqli=/usr/local/mysql/bin/mysql_config --with-gd --enable-sockets \
        --enable-bcmath --enable-mbstring --enable-zip --with-zlib=/usr/local/zlib \
        --with-mcrypt --with-freetype-dir=/usr --with-curl
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PHP安装完成后，可能还需编译安装一些扩展模块，比如：Redis、memcache、APC等。PHP扩展模块的编译安装流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/usr/local/php/bin/phpize&lt;/li&gt;
&lt;li&gt;./configure --with-php-config=/usr/local/php/bin/php-config [...]    # 可通过./configure --help查看该扩展configure可带的选项&lt;/li&gt;
&lt;li&gt;make &amp;amp;&amp;amp; make install&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果扩展模块最后安装的路径并不是你期望的，则可以将所有编译好的扩展模块统一复制到同一个路径之下，然后修改php.ini（如果不存在，则可在/path/to/php/lib目录下新建一个）中extension_dir一项的值为扩展模块的统一路径，并为每个新增的扩展模块添加一行&lt;code&gt;extension=xxx.so&lt;/code&gt;，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;extension=redis.so
extension=memcache.so
extension=apc.so
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后可通过phpinfo()函数来确认是否成功安装扩展。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关于Python源码编译，除了可能存在依赖问题外，默认的配置（Modules/Setup.dist）没有启用一些标准库模块，这些模块在实际中又非常基础常用。所以在configure之前需要编辑Modules/Setup.dist文件，启用某些必要的模块（只需去除某些行前&lt;code&gt;#&lt;/code&gt;符号，稍微阅读一下该文件就知道了），但某些模块又有其他依赖，从而导致Python编译失败，这样的模块可以不启用，所以可能需要多次来回尝试。在make编译结束时的输出信息中会提示哪些必要的模块没有启用，以及哪些模块已启用但编译失败了。你可以忽略这些模块，但之后Python的使用可能会存在一些问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;由于Git可以支持HTTP、GIT、HTTPS、SSH协议，会依赖libssl、libcrypto、libcurl、libmcrypt等库，libssl、libcrypto这两个库都由openssl编译产生，libcurl由curl编译产生。如果未能成功编译ssl支持，也能通过编译，只是在之后的使用中遇到HTTPS协议可能会有问题。如果使用Git遇到HTTPS协议不能成功验证证书时，可以设置&lt;code&gt;git config --global http.sslVerify false&lt;/code&gt;来避免证书验证。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Gitlab是基于Ruby on Rails实现的类Github代码托管平台。其官方的安装教程见：&lt;a href="https://github.com/gitlabhq/gitlabhq/blob/5-0-stable/doc/install/installation.md"&gt;https://github.com/gitlabhq/gitlabhq/blob/5-0-stable/doc/install/installation.md&lt;/a&gt;，不同Gitlab版本的安装过程有些不同，链接指向的是5-0-stable版本的安装教程。官方的安装教程是针对Ubuntu/Debian的，其他Linux发行版的安装过程会略有不同。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;由于我对于Ruby以及Ruby on Rails并不了解，以下内容可能有些表述不正确的地方，请注意。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;与Python的pip和easy_install一样，Ruby使用gem来管理第三方库，并通常使用bundle来管理应用的依赖问题（Ruby on Rails就使用bundle来管理依赖），bundle其实又借助了gem。&lt;/p&gt;
&lt;p&gt;与Python的pypi以及Linux发行版的软件源一样，RubyGems在世界各地也有很多镜像。为了加快gem安装第三方库的过程，国内可以选择&lt;a href="http://ruby.taobao.org/"&gt;淘宝的RubyGems镜像&lt;/a&gt;，更改镜像的方法见&lt;a href="http://ruby.taobao.org/"&gt;淘宝RubyGems镜像网站&lt;/a&gt;上的说明。&lt;/p&gt;
&lt;p&gt;对于bundle，要想修改它所使用的RubyGems镜像，可以通过编辑应用根目录中的Gemfile文件的第一行&lt;code&gt;source "http://xxxxx"&lt;/code&gt;来修改。&lt;/p&gt;
&lt;p&gt;安装Gitlab过程使用bundle安装Mysql2 gem等依赖时，可能会遇到这种类似的问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Installing mysql2 (0.3.11) with native extensions
Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是由于gem未找到mysql的一些头文件，即include目录中的文件。在Ubuntu/Debian中，可能可以通过&lt;code&gt;sudo apt-get install libmysqlclient-dev&lt;/code&gt;来解决问题（可以通过系统包管理器安装的软件的dev包，其实就是源码编译安装后include目录中的内容）。对于我所处的系统环境，只能想法子让gem能找到include目录。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;bundle install [...]&lt;/code&gt;后，找到mysql2 gem的目录，比如在我的Gitlab中路径为&lt;code&gt;gitlab/vendor/bundle/ruby/1.9.1/gems/mysql2-0.3.11&lt;/code&gt;，再查看从子目录&lt;code&gt;ext/mysql2&lt;/code&gt;中的extconf.rb文件，文件中有这样一段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;dirs = ENV[&amp;#39;PATH&amp;#39;].split(File::PATH_SEPARATOR) + %w[
/opt
/opt/local
/opt/local/mysql
/opt/local/lib/mysql5
/usr
/usr/local
/usr/local/mysql
/usr/local/mysql-*
/usr/local/lib/mysql5
].map{|dir| &amp;quot;#{dir}/bin&amp;quot; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我bundle install的时候之所以失败，是因为我把mysql安装到了/usr/local/mysql56目录，所以gem找不到mysql的include目录。直接在extconf.rb文件中添加mysql安装路径是没用的，因为每次执行bundle install都会重新生成该文件，所以我执行&lt;code&gt;cp -r /usr/local/mysql56 /usr/local/mysql&lt;/code&gt;来创建了mysql目录，应该也可以通过软链接来实现。&lt;/p&gt;
&lt;p&gt;其他某些gem依赖可能也会有这样的问题，可以通过这样类似的方式解决。&lt;/p&gt;
&lt;p&gt;Ubuntu/Debian中安装nginx后，在nginx配置目录/etc/nginx中会自动生成sites-available、sites-enabled这两个目录，这两目录的关系是这样的：在sites-available目录中为每个可能需要nginx服务的应用编写一个虚拟主机配置文件（对于nginx配置即server模块），若某个应用现在需要nginx服务，则将它的配置文件从sites-available软链接到sites-enabled，而nginx的主配置文件nginx.conf的http模块的最后通过&lt;code&gt;include sites-enabled/*&lt;/code&gt;将sites-enabled中所有的软链接配置文件包含进来。这种方式的好处在于模块化配置文件，非常灵活方便。但在SUSE中编译安装后，conf目录下并没有这两个目录，所以只能自己创建，并修改nginx.conf的http模块最后手动添加&lt;code&gt;include sites-enabled/*&lt;/code&gt;一行即可。&lt;/p&gt;
&lt;p&gt;之后在试用Gitlab时，发现无法查看代码文件中的内容，通过浏览器的开发者工具看到是个500 Server Error响应。查看gitlab/log目录中的unicorn.stderr.log日志文件，有如下错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ActionView::Template::Error (Failed to get header.):
9:   .file_content.code
10:     - unless blob.empty?
11:       %div{class: user_color_scheme_class}
12:         = raw blob.colorize(formatter: :gitlab)
13:     - else
14:       %p.nothing_here_message Empty file
app/models/tree.rb:6:in `colorize&amp;#39;
app/views/tree/blob/_text.html.haml:12:in `_app_views_tree_blob__text_html_haml__128024721089489703_57418280&amp;#39;
app/views/tree/_blob.html.haml:9:in `_app_views_tree__blob_html_haml__1829533197002461340_55995660&amp;#39;
app/views/tree/_tree.html.haml:16:in `_app_views_tree__tree_html_haml___4517474428772753218_46927720&amp;#39;
app/views/tree/show.html.haml:4:in `_app_views_tree_show_html_haml__3020201194833589280_44750920&amp;#39;
app/controllers/tree_controller.rb:17:in `show&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看网络资料可以知道这是由于代码高亮渲染的时候出了问题。Gitlab使用pygments.rb来高亮代码。pygments.rb是&lt;strong&gt;Ruby wrapper for the Python &lt;a href="http://pygments.org/"&gt;pygments syntax highlighter&lt;/a&gt;&lt;/strong&gt;。那么，高亮渲染失败可能有三种可能：(1)未找到合适的Python版本，pygments.rb依赖于Python 2.5+，(2)没有安装Python的pygments第三方库，(3)其他原因。很不幸，我遇到的是第三种可能。官方&lt;a href="https://github.com/gitlabhq/gitlab-public-wiki/wiki/Trouble-Shooting-Guide"&gt;Trouble-Shooting-Guide&lt;/a&gt;对于该问题给出&lt;a href="https://github.com/gitlabhq/gitlabhq/issues/2214#issuecomment-11137058"&gt;解决方案&lt;/a&gt;是针对第一种可能的。&lt;/p&gt;
&lt;p&gt;在pyments.rb gem目录&lt;code&gt;gitlab/vendor/bundle/ruby/1.9.1/gems/pygments.rb-0.4.2&lt;/code&gt;的子目录&lt;code&gt;lib/pygments&lt;/code&gt;中有(且仅有)一个可执行的python源码文件mentos.py，pygments.rb应该就是通过该程序文件调用Python的pygments库来高亮代码的，我尝试执行该文件，执行失败，原因是标准库json的某行代码中对象调用了encode('hex')方法失败，提示不存在hex编码。经分析查找原因，问题出在标准库模块&lt;a href="http://docs.python.org/2/library/binascii.html"&gt;binascii&lt;/a&gt;(The binascii module contains a number of methods to convert between binary and various ASCII-encoded binary representations)未编译安装。该模块需要编辑Modules/Setup.dist文件启用。启用后（可能还有其他相关模块，我是把其他很多模块一起启用了）重新编译Python就可以了。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;源码编译安装软件遇到最多的问题是依赖缺失，有时会非常繁琐。经过这次经历，我深感操作系统的软件包管理器是多么的重要，能节省我们很多很多时间和精力！&lt;/p&gt;</summary><category term="Linux"></category><category term="PHP"></category><category term="MySQL"></category><category term="Nginx"></category><category term="服务器"></category><category term="Python"></category><category term="Git"></category></entry><entry><title>PHP最佳实践（译）</title><link href="http://youngsterxyf.github.io/2013/06/01/php-best-practices/" rel="alternate"></link><updated>2013-06-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-06-01:2013/06/01/php-best-practices/</id><summary type="html">&lt;p&gt;原文： &lt;a href="https://phpbestpractices.org/"&gt;PHP Best Practices-A short, practical guide for common and confusing PHP tasks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;最后修订日期&amp;amp;维护者&lt;/h2&gt;
&lt;p&gt;本文档最后审阅于2013年3月8日。最后修改于2013年5月8日。&lt;/p&gt;
&lt;p&gt;由我，&lt;a href="https://alexcabal.com/"&gt;Alex Cabal&lt;/a&gt;，维护该文档。我编写PHP程序已有很长一段时间了，当前我
经营着&lt;a href="http://www.scribophile.com/"&gt;Scribophile，由认真作家组成的一个在线写作团体&lt;/a&gt;,
&lt;a href="http://writerfolio.com/"&gt;Writerfolio，为自由职业者提供的一个易用写作工具集&lt;/a&gt;，以及
&lt;a href="https://standardebooks.com"&gt;Standard Ebooks，一个图文并茂、无数字版权管理的公共领域电子书出版商&lt;/a&gt;。
有时我是个为吸引我的项目或客户而工作的自由职业者。&lt;/p&gt;
&lt;p&gt;如果你认为我在某些事情上能够帮到你，或者对本文档有点建议或纠正存在的错误，&lt;a href="https://alexcabal.com/contact/"&gt;请给我写封邮件&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;PHP是一门复杂的语言，经过多年折腾，使其不同版本之间高度不一致，有时还有些bug。
每个版本都有自己独有的特性、多余和怪异之处，也很难跟踪哪个版本有哪些问题。这也就
很好理解为什么有时它会遭到那么多的厌恶。&lt;/p&gt;
&lt;p&gt;尽管如此，如今它还是Web开发方面最流行的语言。因其悠久的历史，对于实现密码哈希和
数据库访问诸如此类的基本任务你能够找到很多教程。但问题在于，5个教程，你就很有可能
找到5种完全不同的完成任务的方式，那么哪种是“正确”的方式呢？其他方式有难以捉摸的bug
或者陷阱？确实很难搞明白，所以你经常要在互联网上反复查找尝试确认正确的答案。&lt;/p&gt;
&lt;p&gt;这也是PHP编程新手频繁地因为丑陋、过时、或不安全的代码而遭到责备的原因之一。如果
Google搜索的第一个结果是一篇4年前的文章，讲述一种5年前的方法，那么PHP新手们也就
很难改变经常遭受责备的现状。&lt;/p&gt;
&lt;p&gt;本文档通过为PHP中常见的令人困惑的问题和任务编辑组织一系列被认为最佳实践的基本做法，
来尝试解决上述问题。若一个低层次的任务在PHP中有多种令人困惑的实现方式，本文也会涵盖。&lt;/p&gt;
&lt;h3&gt;是什么&lt;/h3&gt;
&lt;p&gt;这是一份指南，在PHP程序员遇到一些常见低层次任务但不明确最佳做法（由于PHP可能提供
了多种解决方案）之时，为其建议最佳实践。例如：连接数据库是一个常见任务，PHP中提供了
大量可行的方案，但并不是所有的都是好的做法，因此，本文也会包含该问题。&lt;/p&gt;
&lt;p&gt;本文包含的是一系列简短的、入门性质的方案。涉及的示例在基本设定下就能够运行起来，
你研究一下应该就能把它们变为对你有用的东西。&lt;/p&gt;
&lt;p&gt;本文将指出一些我们认为是PHP中最新最好的东西。然而，这意味如果你在使用老版本的PHP，
一些用来实现这些解决方案的特性对你并不可用。&lt;/p&gt;
&lt;p&gt;这份文档会一直更新，我会尽我最大努力保持该文档与PHP的发展同步。&lt;/p&gt;
&lt;h3&gt;不是什么&lt;/h3&gt;
&lt;p&gt;本文档不是一份PHP教程。你应该在别处学习语言基础和语法。&lt;/p&gt;
&lt;p&gt;它也不是一份针对web应用常见问题，如cookie存储、缓存、编程风格、文档等的指南。&lt;/p&gt;
&lt;p&gt;它也不是一个安全指南。当本文档触碰到一些安全相关的问题时，也是希望你自己做些研究来
确保你的PHP应用的安全问题。你的代码造成的问题应该都是自己的过错。&lt;/p&gt;
&lt;p&gt;该文档也并不是在主张一种特定的编程风格、模式或者框架。&lt;/p&gt;
&lt;p&gt;也不是在主张一种特定的方式来完成高层次任务如用户注册、登录系统等。本文档只限于
PHP的悠久历史所造成的一些易混淆或不明确的低层次任务。&lt;/p&gt;
&lt;p&gt;它不是一个一劳永逸的解决方案，也不是一个唯一的方案。下面要讲述的一些方法对于你的
特定场景来说也许并不是最好的，存在很多不同的方式来达到同样的目的。特别是，高负载web
应用也许能从更加难懂的方案中获益更多。&lt;/p&gt;
&lt;h2&gt;我们在使用哪个版本的PHP？&lt;/h2&gt;
&lt;h3&gt;带Suhosin-Patch的PHP 5.3.10-1ubuntu3.6，安装在Ubuntu 12.04 LTS上。&lt;/h3&gt;
&lt;p&gt;PHP是Web世界里的百年老龟，它的壳上铭刻着一段丰富、复杂、而粗糙的历史。在一个共享
主机的环境里，它的配置可能会限制你能做的事情。&lt;/p&gt;
&lt;p&gt;为了保持清晰地叙述，我们将仅针对一个版本的PHP进行讲述。在2013年4月30日时，该版本
为&lt;strong&gt;PHP 5.3.10-1ubuntu3.6 with Suhosin-Patch&lt;/strong&gt;。若你在&lt;strong&gt;Ubuntu 12.04 LTS&lt;/strong&gt;服务器
上使用apt-get进行安装的就是该版本的PHP。&lt;/p&gt;
&lt;p&gt;你也许发现这些方案中的一些在其他或者更老版本的PHP上也能工作。如果是这样的话，就&lt;em&gt;由
你来研究在这些更老版本上潜在的难以捉摸的bug或安全问题&lt;/em&gt;。&lt;/p&gt;
&lt;h2&gt;存储密码&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://www.openwall.com/phpass/"&gt;phpass&lt;/a&gt;库来哈希和比较密码&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;经phpass 0.3测试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在存入数据库之前进行哈希保护用户密码的标准方式。许多常用的哈希算法如md5,甚至是sha1
对于密码存储都是不安全的，因为&lt;a href="http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/"&gt;骇客能够使用那些算法轻而易举地破解密码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对密码进行哈希最安全的方法是使用bcrypt算法。开源的phpass库以一个易于使用的类来提供
该功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Include the phpass library&lt;/span&gt;
&lt;span class="k"&gt;require_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;phpass-03/PasswordHash.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// Initialize the hasher without portable hashes (this is more secure)&lt;/span&gt;
&lt;span class="nv"&gt;$hasher&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;PasswordHash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Hash the password. $hashedPassword will be a 60-character string.&lt;/span&gt;
&lt;span class="nv"&gt;$hashedPassword&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$hasher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;HashPassword&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my super cool password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// You can now safely store the contents of $hashedPassword in your database!&lt;/span&gt;

&lt;span class="c1"&gt;// Check if a user has provided the correct password by comparing what they&lt;/span&gt;
&lt;span class="c1"&gt;// typed with our hash&lt;/span&gt;
&lt;span class="nv"&gt;$hasher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;CheckPassword&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;the wrong password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$hashedPassword&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// false&lt;/span&gt;

&lt;span class="nv"&gt;$hasher&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;CheckPassword&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my super cool password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$hashedPassword&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// true&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;许多资源可能推荐你在哈希之前对你的密码“加盐”。想法很好，但phpass在HashPassword()函数中已经对你的密码“加盐”了，这意味着你不需要自己“加盐”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.openwall.com/phpass/"&gt;phpass&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blogs.msdn.com/b/lixiong/archive/2011/12/25/md5-sha1-salt-and-bcrypt.aspx"&gt;为什么使用md5或sha哈希密码是不安全的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codahale.com/how-to-safely-store-a-password/"&gt;怎样安全地存储密码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;连接并查询MySQL数据库&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/book.pdo.php"&gt;PDO&lt;/a&gt;及其预处理语句功能。&lt;/h3&gt;
&lt;p&gt;在PHP中，有很多方式来连接到一个MySQL数据库。PDO（PHP数据对象）是其中最新且最健壮的一种。PDO跨多种不同类型数据库有一个一致的接口，使用面向对象的方式，支持更多的新数据库支持的特性。&lt;/p&gt;
&lt;p&gt;你应该使用PDO的预处理语句函数来帮助防范SQL注入攻击。使用函数&lt;a href="http://php.net/manual/en/pdostatement.bindvalue.php"&gt;bindValue&lt;/a&gt;来确保你的SQL免于一级SQL注入攻击。（虽然并不是100%安全的，查看进一步阅读获取更多细节。）在以前，这必须使用一些“魔术引号(magic
quotes)”函数的组合来实现。PDO使得那堆东西不再需要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Create a new connection.&lt;/span&gt;
    &lt;span class="c1"&gt;// You&amp;#39;ll probably want to replace hostname with localhost in the first parameter.&lt;/span&gt;
    &lt;span class="c1"&gt;// The PDO options we pass do the following:&lt;/span&gt;
    &lt;span class="c1"&gt;// \PDO::ATTR_ERRMODE enables exceptions for errors.  This is optional but can be handy.&lt;/span&gt;
    &lt;span class="c1"&gt;// \PDO::ATTR_PERSISTENT disables persistent connections, which can cause concurrency issues in certain cases.  See &amp;quot;Gotchas&amp;quot;.&lt;/span&gt;
    &lt;span class="c1"&gt;// \PDO::MYSQL_ATTR_INIT_COMMAND alerts the connection that we&amp;#39;ll be passing UTF-8 data.&lt;/span&gt;
    &lt;span class="c1"&gt;// This may not be required depending on your configuration, but it&amp;#39;ll save you headaches down the road&lt;/span&gt;
    &lt;span class="c1"&gt;// if you&amp;#39;re trying to store Unicode strings in your database.  See &amp;quot;Gotchas&amp;quot;.&lt;/span&gt;
    &lt;span class="nv"&gt;$link&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;   &lt;span class="s1"&gt;&amp;#39;mysql:host=your-hostname;dbname=your-db&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                        &lt;span class="s1"&gt;&amp;#39;your-username&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                        &lt;span class="s1"&gt;&amp;#39;your-password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                        &lt;span class="k"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                            &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;ATTR_ERRMODE&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;ERRMODE_EXCEPTION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                            &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;ATTR_PERSISTENT&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                            &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;MYSQL_ATTR_INIT_COMMAND&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;set names utf8mb4&amp;#39;&lt;/span&gt;
                        &lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nv"&gt;$handle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$link&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;prepare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;select Username from Users where UserId = ? or Username = ? limit ?&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// PHP bug: if you don&amp;#39;t specify PDO::PARAM_INT, PDO may enclose the argument in quotes.&lt;/span&gt;
    &lt;span class="c1"&gt;// This can mess up some MySQL queries that don&amp;#39;t expect integers to be quoted.&lt;/span&gt;
    &lt;span class="c1"&gt;// See: https://bugs.php.net/bug.php?id=44639&lt;/span&gt;
    &lt;span class="c1"&gt;// If you&amp;#39;re not sure whether the value you&amp;#39;re passing is an integer, use the is_int() function.&lt;/span&gt;
    &lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;bindValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;PARAM_INT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;bindValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Bilbo Baggins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;bindValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;PARAM_INT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// Using the fetchAll() method might be too resource-heavy if you&amp;#39;re selecting a truly massive amount of rows.&lt;/span&gt;
    &lt;span class="c1"&gt;// If that&amp;#39;s the case, you can use the fetch() method and loop through each result row one by one.&lt;/span&gt;
    &lt;span class="c1"&gt;// You can also return arrays and other things instead of objects.  See the PDO documentation for details.&lt;/span&gt;
    &lt;span class="nv"&gt;$result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;fetchAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;FETCH_OBJ&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$result&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nv"&gt;$row&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$row&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;\PDOException&lt;/span&gt; &lt;span class="nv"&gt;$ex&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$ex&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当绑定整型变量时，如果不传递PDO::PARAM_INT参数有事可能会导致PDO对数据加引号。这会
搞坏特定的MySQL查询。查看&lt;a href="https://bugs.php.net/bug.php?id=44639"&gt;该bug报告&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;未使用 `set names utf8mb4`
作为首个查询，可能会导致Unicode数据错误地存储进数据库，这依赖于你的配置。如果你
绝对有把握你的Unicode编码数据不会出问题，那你可以不管这个。&lt;/li&gt;
&lt;li&gt;启用持久连接可能会导致怪异的并发相关的问题。这不是一个PHP的问题，而是一个应用层面
的问题。只要你仔细考虑了后果，持久连接一般会是安全的。查看&lt;a href="http://stackoverflow.com/questions/3332074/what-are-the-disadvantages-of-using-persistent-connection-in-pdo"&gt;Stack
Overfilow这个问题&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使你使用了 `set names utf8mb4`
，你也得确认实际的数据库表使用的是utf8mb4字符集！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在单个execute()调用中执行多条SQL语句。只需使用分号分隔语句，但注意&lt;a href="https://bugs.php.net/bug.php?id=61207"&gt;这个bug&lt;/a&gt;，在该文档所针对的PHP版本中还没修复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.pdo.php"&gt;PHP手册：PDO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/"&gt;为什么你应该使用PHP的PDO访问数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1402017/php-pdo-vs-normal-mysql-connect"&gt;Stack Overflow: PHP PDO vs 普通的mysql_connect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection"&gt;Stack Overflow: PDO预处理语句足以防范SQL注入吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2159434/set-names-utf8-in-mysql"&gt;Stack Overflow: 在MySQL中使用SET NAMES utf8？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP标签&lt;/h2&gt;
&lt;h3&gt;使用 &lt;code&gt;&amp;lt;?php ?&amp;gt;&lt;/code&gt; 。&lt;/h3&gt;
&lt;p&gt;有几种不同的方式用来区分PHP程序块：&lt;code&gt;&amp;lt;?php ?&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;?= ?&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;, 以及&lt;code&gt;&amp;lt;%
%&amp;gt;&lt;/code&gt;。对于打字来说，更短的标签更方便些，但唯一一种在所有PHP服务器上都一定能工作的标签
是&lt;code&gt;&amp;lt;?php
?&amp;gt;&lt;/code&gt;。若你计划将你的PHP应用部署到一台上面的PHP配置你无法控制的服务器上，那么你应始终使用
&lt;code&gt;&amp;lt;?php ?&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若你仅仅是为自己编码，也能控制你将使用的PHP配置，你可能觉得短标签更方便些。但记住
&lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;可能会和XML声明冲突，并且&lt;code&gt;&amp;lt;? ?&amp;gt;&lt;/code&gt;实际上是ASP的风格。&lt;/p&gt;
&lt;p&gt;无论你选择哪一种，确保一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个纯PHP文件（例如，仅包含一个类定义的文件）中包含一个关闭&lt;code&gt;?&amp;gt;&lt;/code&gt;标签时，确保其后
不会跟着任何换行。当PHP解析器安全地吃进跟在关闭标签之后的单个换行符时，任何其他的换行
都可能被输出到浏览器，如果之后要输出某些HTTP头，那么可能会造成混淆。&lt;/li&gt;
&lt;li&gt;编写Web应用时，确保在关闭&lt;code&gt;?&amp;gt;&lt;/code&gt;标签与html的&lt;code&gt;&amp;lt;!doctype&amp;gt;&lt;/code&gt;标签之间不会留下换行。正确的HTML
文件中，&lt;code&gt;&amp;lt;!doctype&amp;gt;&lt;/code&gt;标签必须是文件中的第一样东西---在其之前的任何空格或换行都会使其
无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/200640/are-php-short-tags-acceptable-to-use"&gt;Stack Overflow: 可以使用PHP短标签吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自动加载类&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/function.spl-autoload-register.php"&gt;spl_autoload_register()&lt;/a&gt;来注册你的自动加载函数。&lt;/h3&gt;
&lt;p&gt;PHP提供了若干方式来自动加载包含还未加载的类的文件。老的方法是使用名为&lt;a href="http://php.net/manual/en/function.autoload.php"&gt;&lt;code&gt;__autoload()&lt;/code&gt;&lt;/a&gt;魔术全局函数。然而你一次仅能定义一个&lt;code&gt;__autoload()&lt;/code&gt;函数，因此如果你的程序
包含一个也使用了&lt;code&gt;__autoload()&lt;/code&gt;函数的库，就会发生冲突。&lt;/p&gt;
&lt;p&gt;处理这个问题的正确方法是唯一地命名你的自动加载函数，然后使用&lt;code&gt;spl_autoload_register()&lt;/code&gt;函数
来注册它。该函数允许定义多个&lt;code&gt;__autoload()&lt;/code&gt;这样的函数，因此你不必担心其他代码的&lt;code&gt;__autoload()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// First, define your auto-load function&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;MyAutoload&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$className&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;include_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$className&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Next, register it with PHP&lt;/span&gt;
&lt;span class="nb"&gt;spl_autoload_register&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;MyAutoload&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Try it out!&lt;/span&gt;
&lt;span class="c1"&gt;// Since we haven&amp;#39;t included a file defining the MyClass object, our&lt;/span&gt;
&lt;span class="c1"&gt;// auto-loader will kick in and include MyClass.php.&lt;/span&gt;
&lt;span class="c1"&gt;// For this example, assume the MyClass class is defined in the MyClass.php&lt;/span&gt;
&lt;span class="c1"&gt;// file.&lt;/span&gt;
&lt;span class="nv"&gt;$var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;MyClass&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/function.spl-autoload-register.php"&gt;PHP手册：spl_autoload_register()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/791899/efficient-php-auto-loading-and-naming-strategies"&gt;Stack Overflow: 高效的PHP自动加载和命名策略&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;从性能角度来看单引号和双引号&lt;/h2&gt;
&lt;h3&gt;其实并不重要。&lt;/h3&gt;
&lt;p&gt;已有很多人花费很多笔墨来讨论是使用单引号（&lt;code&gt;'&lt;/code&gt;）还是双引号（&lt;code&gt;"&lt;/code&gt;）来定义字符串。
单引号字符串不会被解析，因此放入字符串的任何东西都会以原样显示。双引号字符串会被解析，
字符串中的任何PHP变量都会被求值。另外，转义字符如换行符&lt;code&gt;\n&lt;/code&gt;和制表符&lt;code&gt;\t&lt;/code&gt;在单引号字符串中
不会被求值，但在双引号字符串中会被求值。&lt;/p&gt;
&lt;p&gt;由于双引号字符串在程序运行时要求值，从而理论上使用单引号字符串能提高性能，因为PHP
不会对单引号字符串求值。这对于一定规模的应用来说也许确实如此，但对于现实中一般的应用来说，
区别非常小以至于根本不用在意。因此对于普通应用，你选择哪种字符串并不重要。对于负载
极其高的应用来说，是有点作用的。根据你的应用的需要来做选择，但无论你选择什么，请保持一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.types.string.php"&gt;PHP手册：字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://phpbench.com/"&gt;PHP基准&lt;/a&gt;（向下滚动到引号类型(Quote Types)）&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/13620/speed-difference-in-using-inline-strings-vs-concatenation-in-php5"&gt;Stack Overflow: PHP中单引号字符串相比双引号字符串有性能优势么？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;define() vs. const&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://www.php.net/manual/en/function.define.php"&gt;define()&lt;/a&gt;，除非考虑到可读性、类常量、或关注微优化&lt;/h3&gt;
&lt;p&gt;习惯上，在PHP中是使用define()函数来定义常量。但从某个时候开始，PHP中也能够使用&lt;a href="http://php.net/manual/en/language.oop5.constants.php"&gt;const&lt;/a&gt;
关键字来声明常量了。那么当定义常量时，该使用哪种方式呢？&lt;/p&gt;
&lt;p&gt;答案在于这两种方法之间的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;define()在执行期定义常量，而const在编译期定义常量。这样const就有轻微的速度优势，
但不值得考虑这个问题，除非你在构建大规模的软件。&lt;/li&gt;
&lt;li&gt;define()将常量放入全局作用域，虽然你可以在常量名中包含命名空间。这意味着你不能
使用define()定义类常量。&lt;/li&gt;
&lt;li&gt;define()允许你在常量名和常量值中使用表达式，而const则都不允许。这使得define()
更加灵活。&lt;/li&gt;
&lt;li&gt;define()可以在if()代码块中调用，但const不行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Let&amp;#39;s see how the two methods treat namespaces&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;MiddleEarth\Creatures\Dwarves&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;GIMLI_ID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;MiddleEarth\Creatures\Elves\LEGOLAS_ID&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;echo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;\MiddleEarth\Creatures\Dwarves\GIMLI_ID&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// 1&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;\MiddleEarth\Creatures\Elves\LEGOLAS_ID&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// 2; note that we used define()&lt;/span&gt;

&lt;span class="c1"&gt;// Now let&amp;#39;s declare some bit-shifted constants representing ways to enter Mordor.&lt;/span&gt;
&lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;TRANSPORT_METHOD_SNEAKING&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// OK!&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;TRANSPORT_METHOD_WALKING&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//Compile error! const can&amp;#39;t use expressions as values&lt;/span&gt;

&lt;span class="c1"&gt;// Next, conditional constants.&lt;/span&gt;
&lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;HOBBITS_FRODO_ID&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$isGoingToMordor&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;TRANSPORT_METHOD&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;TRANSPORT_METHOD_SNEAKING&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// OK!&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;PARTY_LEADER_ID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;HOBBITS_FRODO_ID&lt;/span&gt; &lt;span class="c1"&gt;// Compile error: const can&amp;#39;t be used in an if block&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Finally, class constants&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OneRing&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="no"&gt;MELTING_POINT_DEGREES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// OK!&lt;/span&gt;
    &lt;span class="nb"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;SHOW_ELVISH_DEGREES&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Compile error: can&amp;#39;t use define() within a class&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为define()更加灵活，你应该使用它以避免一些令人头疼的事情，除非你明确地需要类
常量。使用const通常会产生更加可读的代码，但是以牺牲灵活性为代价的。&lt;/p&gt;
&lt;p&gt;无论你选择哪一种，请保持一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2447791/define-vs-const"&gt;Stack Overflow: define() vs. const&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.constants.syntax.php"&gt;PHP手册：常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1225082/define-vs-variable-in-php"&gt;Stack Overflow: define() vs. 变量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;缓存PHP opcode&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/book.apc.php"&gt;APC&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在一个标准的PHP环境中，每次访问PHP脚本时，脚本都会被编译然后执行。一次又一次地花费
时间编译相同的脚本对于大型站点会造成性能问题。&lt;/p&gt;
&lt;p&gt;解决方案是采用一个opcode缓存。opcode缓存是一个能够记下每个脚本经过编译的版本，这样
服务器就不需要浪费时间一次又一次地编译了。通常这些opcode缓存系统也能智能地检测到
一个脚本是否发生改变，因此当你升级PHP源码时，并不需要手动清空缓存。&lt;/p&gt;
&lt;p&gt;有几个PHP
opcode缓存可用，其中值得关注的有&lt;a href="http://sourceforge.net/projects/eaccelerator/"&gt;eaccelerator&lt;/a&gt;，
&lt;a href="http://xcache.lighttpd.net/"&gt;xcache&lt;/a&gt;，以及&lt;a href="http://php.net/manual/en/book.apc.php"&gt;APC&lt;/a&gt;。
APC是PHP项目官方支持的，最为活跃，也最容易安装。它也提供一个可选的类&lt;a href="http://memcached.org/"&gt;memcached&lt;/a&gt;
的持久化键-值对存储，因此你应使用它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装APC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Ubuntu 12.04上你可以通过在终端中执行以下命令来安装APC：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@localhost: sudo apt-get install php-apc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除此之外，不需要进一步的配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将APC作为一个持久化键-值存储系统来使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;APC也提供了对于你的脚本透明的类似于memcached的功能。与使用memcached相比一个大的优势是
APC是集成到PHP核心的，因此你不需要在服务器上维护另一个运行的部件，并且PHP开发者在APC
上的工作很活跃。但从另一方面来说，APC并不是一个分布式缓存，如果你需要这个特性，你就
必须使用memcached了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Store some values in the APC cache.  We can optionally pass a time-to-live, &lt;/span&gt;
&lt;span class="c1"&gt;// but in this example the values will live forever until they&amp;#39;re garbage-collected by APC.&lt;/span&gt;
&lt;span class="nb"&gt;apc_store&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;username-1532&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Frodo Baggins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;apc_store&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;username-958&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Aragorn&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;apc_store&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;username-6389&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Gandalf&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// After storing these values, any PHP script can access them, no matter when it&amp;#39;s run!&lt;/span&gt;
&lt;span class="nv"&gt;$value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;apc_fetch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;username-958&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$success&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$success&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Aragorn&lt;/span&gt;

&lt;span class="nv"&gt;$value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;apc_fetch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;username-1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$success&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// $success will be set to boolean false, because this key doesn&amp;#39;t exist.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$success&lt;/span&gt; &lt;span class="o"&gt;!==&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Note the !==, this checks for true boolean false, not &amp;quot;falsey&amp;quot; values like 0 or empty string.&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Key not found&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nb"&gt;apc_delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;username-958&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// This key will no longer be available.&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你使用的不是&lt;a href="https://phpbestpractices.org/#serving-php"&gt;PHP-FPM&lt;/a&gt;（例如你在
使用&lt;a href="http://stackoverflow.com/questions/2712825/what-is-mod-php"&gt;mod_php&lt;/a&gt;
或&lt;a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html"&gt;mod_fastcgi&lt;/a&gt;），那么
每个PHP进程都会有自己独有的APC实例，包括键-值存储。若你不注意，这可能会在你的应用
代码中造成同步问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.apc.php"&gt;PHP手册：APC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP与Memcached&lt;/h2&gt;
&lt;h3&gt;若你需要一个分布式缓存，那就使用&lt;a href="http://php.net/manual/en/book.memcached.php"&gt;Memcached&lt;/a&gt;客户端库。否则，使用APC。&lt;/h3&gt;
&lt;p&gt;缓存系统通常能够提升应用的性能。Memcached是一个受欢迎的选择，它能配合许多语言使用，
包括PHP。&lt;/p&gt;
&lt;p&gt;然而，从一个PHP脚本中访问一个Memcached服务器，你有两个不同且命名很愚蠢的客户端库选择项：
&lt;a href="http://php.net/manual/en/book.memcache.php"&gt;Memcache&lt;/a&gt;和&lt;a href="http://php.net/manual/en/book.memcached.php"&gt;Memcached&lt;/a&gt;。
它们是两个名字几乎相同的不同库，两者都可用于访问一个Memcached实例。&lt;/p&gt;
&lt;p&gt;事实证明，Memcached库对于Memcached协议的实现最好，包含了一些Mmecache库没有的有用的特性，
并且看起来Memcached库的开发也最为活跃。&lt;/p&gt;
&lt;p&gt;然而，如果不需要访问来自一组分布式服务器的一个Memcached实例，那就&lt;a href="https://phpbestpractices.org/#opcode-cache"&gt;使用APC&lt;/a&gt;。
APC得到PHP项目的支持，具备很多和Memcached相同的功能，并且能够用作opcode缓存，这能提高PHP脚本的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Memcached客户端库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安装Memcached服务器之后，需要安装Memcached客户端库。没有该库，PHP脚本就没法与
Memcached服务器通信。&lt;/p&gt;
&lt;p&gt;在Ubuntu 12.04上，你可以使用如下命令来安装Memcached客户端库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@localhost: sudo apt-get install php5-memcached
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;使用APC作为替代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;a href="https://phpbestpractices.org/#opcode-cache"&gt;opcode缓存一节&lt;/a&gt;阅读更多与使用APC作为
Memcached替代方案相关的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.memcached.php"&gt;PHP手册：Memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.apc.php"&gt;PHP手册：APC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1442411/using-memcache-vs-memcached-with-php"&gt;Stack Overflow: PHP中使用Memcache vs. Memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/815041/memcached-vs-apc-which-one-should-i-choose"&gt;Stack Overflow: Memcached vs APC，我该选择哪一个？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP与正则表达式&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/book.pcre.php"&gt;PCRE&lt;/a&gt;(&lt;code&gt;preg_*&lt;/code&gt;)家族函数&lt;/h3&gt;
&lt;p&gt;PHP有两种使用不同的方式来使用正则表达式：PCRE（Perl兼容表示法，&lt;code&gt;preg_*&lt;/code&gt;）函数
和&lt;a href="http://php.net/manual/en/book.regex.php"&gt;POSIX&lt;/a&gt;（POSIX扩展表示法，&lt;code&gt;ereg_*&lt;/code&gt;）
函数。&lt;/p&gt;
&lt;p&gt;每个函数家族各自使用一种风格稍微不同的正则表达式。幸运的是，POSIX家族函数从PHP
5.3.0开始就被弃用了。因此，你绝不应该使用POSIX家族函数编写新的代码。始终使用
PRCE家族函数，即&lt;code&gt;preg_*&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/book.pcre.php"&gt;PHP手册：PCRE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.noupe.com/php/php-regular-expressions.html"&gt;PHP正则表达式起步&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置Web服务器提供PHP服务&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/install.fpm.php"&gt;PHP-FPM&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有多种方式来配置一个web服务器以提供PHP服务。传统（并且糟糕的）的方式是使用Apache的
&lt;a href="http://stackoverflow.com/questions/2712825/what-is-mod-php"&gt;mod_php&lt;/a&gt;。Mod_php将PHP
绑定到Apache自身，但是Apache对于该模块功能的管理工作非常糟糕。一旦遇到较大的流量，
就会遭受严重的内存问题。&lt;/p&gt;
&lt;p&gt;后来两个新的可选项很快流行起来：&lt;a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html"&gt;mod_fastcgi&lt;/a&gt;
和&lt;a href="http://httpd.apache.org/mod_fcgid/"&gt;mod_fcgid&lt;/a&gt;。两者均保持一定数量的PHP执行进程，
Apache将请求发送到这些端口来处理PHP的执行。由于这些库限制了存活的PHP进程的数量，
从而大大减少了内存使用而没有影响性能。&lt;/p&gt;
&lt;p&gt;一些聪明的人创建一个fastcgi的实现，专门为真正与PHP工作良好而设计，他们称之为
&lt;a href="http://php.net/manual/en/install.fpm.php"&gt;PHP-FPM&lt;/a&gt;。PHP 5.3.0之前，为安装它，
你得跨越许多障碍，但幸运的是，PHP 5.3.3的核心包含了PHP-FPM，因此在Ubuntu 12.04上安装它非常方便。&lt;/p&gt;
&lt;p&gt;如下示例是针对Apache 2.2.22的，但PHP-FPM也能用于其他web服务器如Nginx。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装PHP-FPM和Apache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Ubuntu 12.04上你可以使用如下命令安装PHP-FPM和Apache：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@localhost: sudo apt-get install apache2-mpm-worker
libapache2-mod-fastcgi php5-fpm
user@localhost: sudo a2enmod actions alias fastcgi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意我们&lt;em&gt;必须&lt;/em&gt;使用apache2-mpm-worker，而不是apache2-mpm-prefork或apache2-mpm-threaded。&lt;/p&gt;
&lt;p&gt;接下来配置Aapache虚拟主机将PHP请求路由到PHP-FPM进程。将如下配置语句放入Apache
配置文件（在Ubuntu 12.04上默认配置文件是/etc/apache2/sites-available/default）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;VirtualHost *:80&amp;gt;
    AddHandler php5-fcgi .php
    Action php5-fcgi /php5-fcgi
    Alias /php5-fcgi /usr/lib/cgi-bin/php5-fcgi
    FastCgiExternalServer /usr/lib/cgi-bin/php5-fcgi -host 127.0.0.1:9000 -idle-timeout 120 -pass-header Authorization
&amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，重启Apache和FPM进程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@localhost: sudo service apache2 restart &amp;amp;&amp;amp; sudo service php5-fpm
restart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/install.fpm.php"&gt;PHP手册：PHP-FPM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php-fpm.org/"&gt;PHP-FPM主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://alexcabal.com/installing-apache-mod_fastcgi-php-fpm-on-ubuntu-server-maverick/"&gt;在Ubuntu服务器Maverick上安装Apache + mod_fastcgi + PHP-FPM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.joomlaperformance.com/articles/webcasts/why_mod_php_is_bad_for_performance_52_58.html"&gt;为什么mod_php的性能很糟糕&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;发送邮件&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="https://code.google.com/a/apache-extras.org/p/phpmailer/"&gt;PHPMailer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;经PHPMailer 5.1测试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;PHP提供了一个&lt;a href="http://php.net/manual/en/function.mail.php"&gt;mail()&lt;/a&gt;函数，看起来很简单易用。
不幸的是，与PHP中的很多东西一样，它的简单性是个幻象，因其虚假的表面使用它会导致
严重的安全问题。&lt;/p&gt;
&lt;p&gt;Email是一组网络协议，比PHP的历史还曲折。完全可以说发送邮件中的陷阱与PHP的mail()
函数一样多，这个可能会令你有点“不寒而栗”吧。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://code.google.com/a/apache-extras.org/p/phpmailer/"&gt;PHPMailer&lt;/a&gt;是一个流行而
成熟的开源库，为安全地发送邮件提供一个易用的接口。它关注可能陷阱，这样你可以专注
于更重要的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Include the PHPMailer library&lt;/span&gt;
&lt;span class="k"&gt;require_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;phpmailer-5.1/class.phpmailer.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Passing &amp;#39;true&amp;#39; enables exceptions.  This is optional and defaults to false.&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;PHPMailer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Send a mail from Bilbo Baggins to Gandalf the Grey&lt;/span&gt;

&lt;span class="c1"&gt;// Set up to, from, and the message body.  The body doesn&amp;#39;t have to be HTML;&lt;/span&gt;
&lt;span class="c1"&gt;// check the PHPMailer documentation for details.&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Sender&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;bbaggins@example.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;AddReplyTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;bbaggins@example.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Bilbo Baggins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;SetFrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;bbaggins@example.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Bilbo Baggins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;AddAddress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gandalf@example.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Subject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;The finest weed in the South Farthing&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;MsgHTML&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;p&amp;gt;You really must try it, Gandalf!&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;-Bilbo&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Set up our connection information.&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;IsSMTP&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;SMTPAuth&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;SMTPSecure&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ssl&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;465&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my smpt host&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Username&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my smtp username&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Password&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my smtp password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// All done!&lt;/span&gt;
&lt;span class="nv"&gt;$mailer&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;验证邮件地址&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/function.filter-var.php"&gt;filter_var()&lt;/a&gt;函数&lt;/h3&gt;
&lt;p&gt;Web应用可能需要做的一件常见任务是检测用户是否输入了一个有效的邮件地址。毫无疑问
你可以在网上找到一些声称可以解决该问题的复杂的正则表达式，但是最简单的方法是使用
PHP的内建&lt;code&gt;filter_var()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nb"&gt;filter_var&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sgamgee@example.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;FILTER_VALIDATE_EMAIL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//Returns &amp;quot;sgamgee@example.com&amp;quot;. This is a valid email address.&lt;/span&gt;

&lt;span class="nb"&gt;filter_var&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sauron@mordor&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;FILTER_VALIDATE_EMAIL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// Returns boolean false! This is *not* a valid email address.&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/function.filter-var.php"&gt;PHP手册：filter_var()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/filter.filters.php"&gt;PHP手册：过滤器的类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;净化HTML输入和输出&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;对于简单的数据净化，使用&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;函数,
复杂的数据净化则使用&lt;a href="http://htmlpurifier.org/"&gt;HTML Purifier&lt;/a&gt;库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;经HTML Purifier 4.4.0测试&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在任何wbe应用中展示用户输出时，首先对其进行“净化”去除任何潜在危险的HTML是非常必要的。
一个恶意的用户可以制作某些HTML，若被你的web应用直接输出，对查看它的人来说会很危险。&lt;/p&gt;
&lt;p&gt;虽然可以尝试使用正则表达式来净化HTML，但不要这样做。HTML是一种复杂的语言，试图
使用正则表达式来净化HTML几乎总是失败的。&lt;/p&gt;
&lt;p&gt;你可能会找到建议你使用&lt;a href="http://php.net/manual/en/function.strip-tags.php"&gt;strip_tags()&lt;/a&gt;
函数的观点。虽然strip_tags()从技术上来说是安全的，但如果输入的不合法的HTML（比如，
没有结束标签），它就成了一个“愚蠢”的函数，可能会去除比你期望的更多的内容。由于非技术用户
在通信中经常使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;字符，&lt;code&gt;strip_tags()&lt;/code&gt;也就不是一个好的选择了。&lt;/p&gt;
&lt;p&gt;如果阅读了&lt;a href="https://phpbestpractices.org/#validating-emails"&gt;验证邮件地址&lt;/a&gt;一节，
你也许也会考虑使用&lt;a href="http://php.net/manual/en/function.filter-var.php"&gt;filter_var()&lt;/a&gt;
函数。然而&lt;a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks"&gt;filter_var()函数在遇到断行时会出现问题&lt;/a&gt;，
并且需要不直观的配置以接近&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;函数的效果，
因此也不是一个好的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于简单需求的净化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的web应用仅需要完全地转义（因此可以无害地呈现，但不是完全去除）HTML，则使用
PHP的内建&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;函数。
这个函数要比HTML Purifier快得多，因此它不对HTML做任何验证---仅转义所有东西。&lt;/p&gt;
&lt;p&gt;htmlentities()不同于类似功能的函数&lt;a href="http://php.net/manual/en/function.htmlspecialchars.php"&gt;htmlspecialchars()&lt;/a&gt;，
它会编码所有适用的HTML实体，而不仅仅是一个小的子集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!&lt;/span&gt;
&lt;span class="nv"&gt;$evilHtml&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;div onclick=&amp;quot;xss();&amp;quot;&amp;gt;Mua-ha-ha!  Twiddling my evil mustache...&amp;lt;/div&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Use the ENT_QUOTES flag to make sure both single and double quotes are escaped.&lt;/span&gt;
&lt;span class="c1"&gt;// Use the UTF-8 character encoding if you&amp;#39;ve stored the text as UTF-8 (as you should have).&lt;/span&gt;
&lt;span class="c1"&gt;// See the UTF-8 section in this document for more details.&lt;/span&gt;
&lt;span class="nv"&gt;$safeHtml&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;htmlentities&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$evilHtml&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ENT_QUOTES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// $safeHtml is now fully escaped HTML.  You can output $safeHtml to your users without fear!&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;对于复杂需求的净化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于很多web应用来说，简单地转义HTML是不够的。你可能想完全去除任何HTML，或者允许
一小部分子集的HTML存在。若是如此，则使用&lt;a href="http://htmlpurifier.org/"&gt;HTML Purifier&lt;/a&gt;
库。&lt;/p&gt;
&lt;p&gt;HTML Purifier是一个经过充分测试但效率比较低的库。这就是为什么如果你的需求并不复杂
就应使用&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;，因为
它的效率要快得多。&lt;/p&gt;
&lt;p&gt;HTML Purifier相比&lt;a href="http://php.net/manual/en/function.strip-tags.php"&gt;strip_tags()&lt;/a&gt;
是有优势的，因为它在净化HTML之前会对其校验。这意味着如果用户输入无效HTML，HTML 
Purifier相比strip_tags()更能保留HTML的原意。HTML
Purifier高度可定制，允许你为HTML的一个子集建立白名单来允许这个HTML子集的实体存在
输出中。&lt;/p&gt;
&lt;p&gt;但其缺点就是相当的慢，它要求一些设置，在一个共享主机的环境里可能是不可行的。其文档
通常也复杂而不易理解。以下示例是一个基本的使用配置。查看&lt;a href="http://htmlpurifier.org/docs"&gt;文档&lt;/a&gt;
阅读HTML Purifier提供的更多更高级的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Include the HTML Purifier library&lt;/span&gt;
&lt;span class="k"&gt;require_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;htmlpurifier-4.4.0/HTMLPurifier.auto.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!&lt;/span&gt;
&lt;span class="nv"&gt;$evilHtml&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;div onclick=&amp;quot;xss();&amp;quot;&amp;gt;Mua-ha-ha!  Twiddling my evil mustache...&amp;lt;/div&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Set up the HTML Purifier object with the default configuration.&lt;/span&gt;
&lt;span class="nv"&gt;$purifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;HTMLPurifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;HTMLPurifier_Config&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;createDefault&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="nv"&gt;$safeHtml&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$purifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;purify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$evilHtml&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// $safeHtml is now sanitized.  You can output $safeHtml to your users without fear!&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以错误的字符编码使用htmlentities()会造成意想不到的输出。在调用该函数时始终确认
指定了一种字符编码，并且该编码与将被净化的字符串的编码相匹配。更多细节请查看
&lt;a href="https://phpbestpractices.org/#utf-8"&gt;UTF-8一节&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;使用htmlentities()时，始终包含ENT_QUOTES和字符编码参数。默认情况下，htmlentities()
不会对单引号编码。多愚蠢的默认做法！&lt;/li&gt;
&lt;li&gt;HTML
Purifier对于复杂的HTML效率极其的低。可以考虑设置一个缓存方案如APC来保存经过净化的结果
以备后用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://htmlpurifier.org/comparison"&gt;PHP HTML净化工具对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/3605629/php-prevent-xss-with-strip-tags"&gt;Stack Overflow: 使用strip_tags()来防止XSS？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/129677/whats-the-best-method-for-sanitizing-user-input-with-php"&gt;Stack Overflow: PHP中净化用户输入的最佳方法是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks"&gt;Stack Overflow: 断行时的FILTER_SANITIZE_SPECIAL_CHARS问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PHP与UTF-8&lt;/h2&gt;
&lt;h3&gt;没有一行式解决方案。小心、注意细节，以及一致性。&lt;/h3&gt;
&lt;p&gt;PHP中的UTF-8糟透了。原谅我的用词。&lt;/p&gt;
&lt;p&gt;目前PHP在低层次上还不支持Unicode。有几种方式可以确保UTF-8字符串能够被正确处理，
但并不容易，需要深入到web应用的所有层面，从HTML，到SQL，到PHP。我们旨在提供一个简洁、
实用的概述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP层面的UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本的&lt;a href="http://php.net/manual/en/language.operators.string.php"&gt;字符串操作&lt;/a&gt;，如串接
两个字符串、将字符串赋给变量，并不需要任何针对UTF-8的特殊东西。然而，多数
&lt;a href="http://php.net/manual/en/ref.strings.php"&gt;字符串函数&lt;/a&gt;，如&lt;a href="http://php.net/manual/en/function.strpos.php"&gt;strpos()&lt;/a&gt;
和&lt;a href="http://php.net/manual/en/function.strlen.php"&gt;strlen&lt;/a&gt;，就需要特殊的考虑。这些
函数都有一个对应的&lt;code&gt;mb_*&lt;/code&gt;函数：例如，&lt;a href="http://php.net/manual/en/function.mb-strpos.php"&gt;mb_strpos()&lt;/a&gt;
和&lt;a href="http://php.net/manual/en/function.mb-strlen.php"&gt;mb_strlen()&lt;/a&gt;。这些对应的函数
统称为&lt;a href="http://php.net/manual/en/ref.mbstring.php"&gt;多字节字符串函数&lt;/a&gt;。这些多字节字符串
函数是专门为操作Unicode字符串而设计的。&lt;/p&gt;
&lt;p&gt;当你操作Unicode字符串时，必须使用&lt;code&gt;mb_*&lt;/code&gt;函数。例如，如果你使用&lt;a href="http://php.net/manual/en/function.substr.php"&gt;substr()&lt;/a&gt;
操作一个UTF-8字符串，其结果就很可能包含一些乱码。正确的函数应该是对应的多字节函数，
&lt;a href="http://php.net/manual/en/function.mb-substr.php"&gt;mb_substr()&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;难的是始终记得使用&lt;code&gt;mb_*&lt;/code&gt;函数。即使你仅一次忘了，你的Unicode字符串在接下来的处理中
就可能产生乱码。&lt;/p&gt;
&lt;p&gt;并不是所有的字符串函数都有一个对应的&lt;code&gt;mb_*&lt;/code&gt;。如果不存在你想要的那一个，那你就只能
自认倒霉了。&lt;/p&gt;
&lt;p&gt;此外，在每个PHP脚本的顶部（或者在全局包含脚本的顶部）你都应使用
&lt;a href="http://php.net/manual/en/function.mb-internal-encoding.php"&gt;mb_internal_encoding&lt;/a&gt;
函数，如果你的脚本会输出到浏览器，那么还得紧跟其后加个&lt;a href="http://php.net/manual/en/function.mb-http-output.php"&gt;mb_http_output()&lt;/a&gt;
函数。在每个脚本中显式地定义字符串的编码在以后能为你减少很多令人头疼的事情。&lt;/p&gt;
&lt;p&gt;最后，许多操作字符串的PHP函数都有一个可选参数让你指定字符编码。若有该选项， 你应
始终显式地指明UTF-8编码。例如，&lt;a href="http://php.net/manual/en/function.htmlentities.php"&gt;htmlentities()&lt;/a&gt;
就有一个字符编码方式选项，在处理这样的字符串时应始终指定UTF-8。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL层面的UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的PHP脚本会访问MySQL，即使你遵从了前述的注意事项，你的字符串也有可能在数据库
中存储为非UTF-8字符串。&lt;/p&gt;
&lt;p&gt;确保从PHP到MySQL的字符串为UTF-8编码的，确保你的数据库以及数据表均设置为utf8mb4字符集，
并且在你的数据库中执行任何其他查询之前先执行MySQL查询`set names
utf8mb4`。这是至关重要的。示例
请查看&lt;a href="https://phpbestpractices.org/#mysql"&gt;连接并查询MySQL数据库&lt;/a&gt;一节内容。&lt;/p&gt;
&lt;p&gt;注意你必须使用`utf8mb4`字符集来获得完整的UTF-8支持，而不是`utf8`字符集！原因
请查看&lt;a href="https://phpbestpractices.org/#utf8-further-reading"&gt;进一步阅读&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器层面的UTF-8&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;a href="http://php.net/manual/en/function.mb-http-output.php"&gt;mb_http_output()&lt;/a&gt;函数
来确保你的PHP脚本输出UTF-8字符串到浏览器。并且在HTML页面的&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签块中包含
&lt;a href="http://htmlpurifier.org/docs/enduser-utf8.html"&gt;字符集&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签块&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Tell PHP that we&amp;#39;re using UTF-8 strings until the end of the script&lt;/span&gt;
&lt;span class="nb"&gt;mb_internal_encoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Tell PHP that we&amp;#39;ll be outputting UTF-8 to the browser&lt;/span&gt;
&lt;span class="nb"&gt;mb_http_output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Our UTF-8 test string&lt;/span&gt;
&lt;span class="nv"&gt;$string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Aš galiu valgyti stiklą ir jis manęs nežeidžia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Transform the string in some way with a multibyte function&lt;/span&gt;
&lt;span class="nv"&gt;$string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;mb_substr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Connect to a database to store the transformed string&lt;/span&gt;
&lt;span class="c1"&gt;// See the PDO example in this document for more information&lt;/span&gt;
&lt;span class="c1"&gt;// Note the `set names utf8mb4` commmand!&lt;/span&gt;
&lt;span class="nv"&gt;$link&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;   &lt;span class="s1"&gt;&amp;#39;mysql:host=your-hostname;dbname=your-db&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="s1"&gt;&amp;#39;your-username&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="s1"&gt;&amp;#39;your-password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="k"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                        &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;ATTR_ERRMODE&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;ERRMODE_EXCEPTION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;ATTR_PERSISTENT&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;MYSQL_ATTR_INIT_COMMAND&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;set names utf8mb4&amp;#39;&lt;/span&gt;
                    &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Store our transformed string as UTF-8 in our database&lt;/span&gt;
&lt;span class="c1"&gt;// Assume our DB and tables are in the utf8mb4 character set and collation&lt;/span&gt;
&lt;span class="nv"&gt;$handle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$link&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;prepare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;insert into Sentences (Id, Body) values (?, ?)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;bindValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;PARAM_INT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;bindValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Retrieve the string we just stored to prove it was stored correctly&lt;/span&gt;
&lt;span class="nv"&gt;$handle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$link&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;prepare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;select * from Sentences where Id = ?&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;bindValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;PARAM_INT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Store the result into an object that we&amp;#39;ll output later in our HTML&lt;/span&gt;
&lt;span class="nv"&gt;$result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;fetchAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;\PDO&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;FETCH_OBJ&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;    &amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;        &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot; /&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;        &amp;lt;title&amp;gt;UTF-8 test page&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;    &amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;    &amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
        &lt;span class="k"&gt;foreach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$result&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nv"&gt;$row&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$row&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;Body&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// This should correctly output our transformed UTF-8 string to the browser&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;    &amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/ref.mbstring.php"&gt;PHP手册：多字节字符串函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.loftdigital.com/blog/php-utf-8-cheatsheet"&gt;PHP UTF-8备忘单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible"&gt;Stack Overflow: 什么因素致使PHP不兼容Unicode？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings"&gt;Stack Overflow: PHP与MySQL之间国际化字符串的最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mathiasbynens.be/notes/mysql-utf8mb4"&gt;怎样在MySQL数据库中完整支持Unicode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;处理日期和时间&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://www.php.net/manual/en/class.datetime.php"&gt;DateTime类&lt;/a&gt;。&lt;/h3&gt;
&lt;p&gt;在PHP糟糕的老时光里，我们必须使用&lt;a href="http://www.php.net/manual/en/function.date.php"&gt;date()&lt;/a&gt;，
&lt;a href="http://www.php.net/manual/en/function.gmdate.php"&gt;gmdate()&lt;/a&gt;，
&lt;a href="http://www.php.net/manual/en/function.date-timezone-set.php"&gt;date_timezone_set()&lt;/a&gt;，
&lt;a href="http://www.php.net/manual/en/function.strtotime.php"&gt;strtotime()&lt;/a&gt;等等令人迷惑的
组合来处理日期和时间。悲哀的是现在你仍旧会找到很多在线教程在讲述这些不易使用的老式函数。&lt;/p&gt;
&lt;p&gt;幸运的是，我们正在讨论的PHP版本包含友好得多的&lt;a href="http://www.php.net/manual/en/class.datetime.php"&gt;DateTime类&lt;/a&gt;。
该类封装了老式日期函数所有功能，甚至更多，在一个易于使用的类中，并且使得时区转换更加容易。
在PHP中始终使用DateTime类来创建，比较，改变以及展示日期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="c1"&gt;// Construct a new UTC date.  Always specify UTC unless you really know what you&amp;#39;re doing!&lt;/span&gt;
&lt;span class="nv"&gt;$date&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;2011-05-04 05:00:00&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;DateTimeZone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;UTC&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// Add ten days to our initial date&lt;/span&gt;
&lt;span class="nv"&gt;$date&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;DateInterval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;P10D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;echo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$date&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Y-m-d h:i:s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// 2011-05-14 05:00:00&lt;/span&gt;

&lt;span class="c1"&gt;// Sadly we don&amp;#39;t have a Middle Earth timezone&lt;/span&gt;
&lt;span class="c1"&gt;// Convert our UTC date to the PST (or PDT, depending) time zone&lt;/span&gt;
&lt;span class="nv"&gt;$date&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;setTimezone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;DateTimeZone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;America/Los_Angeles&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// Note that if you run this line yourself, it might differ by an hour depending on daylight savings&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$date&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Y-m-d h:i:s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;// 2011-05-13 10:00:00&lt;/span&gt;

&lt;span class="nv"&gt;$later&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;2012-05-20&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;DateTimeZone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;UTC&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// Compare two dates&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$date&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;$later&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;echo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Yup, you can compare dates using these easy operators!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Find the difference between two dates&lt;/span&gt;
&lt;span class="nv"&gt;$difference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$date&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$later&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;echo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;The 2nd date is &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;$difference&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;days&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; later than 1st date.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你不指定一个时区，&lt;a href="http://www.php.net/manual/en/datetime.construct.php"&gt;DateTime::__construct()&lt;/a&gt;
就会将生成日期的时区设置为正在运行的计算机的时区。之后，这会导致大量令人头疼的事情。
&lt;strong&gt;在创建新日期时始终指定UTC时区，除非你确实清楚自己在做的事情。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果你在DateTime::__construct()中使用Unix时间戳，那么时区将始终设置为UTC而不管
第二个参数你指定了什么。&lt;/li&gt;
&lt;li&gt;向DateTime::__construct()传递零值日期（如：“0000-00-00”，常见MySQL生成该值作为
DateTime类型数据列的默认值）会产生一个无意义的日期，而不是“0000-00-00”。&lt;/li&gt;
&lt;li&gt;在32位系统上使用&lt;a href="http://www.php.net/manual/en/datetime.gettimestamp.php"&gt;DateTime::getTimestamp()&lt;/a&gt;
不会产生代表2038年之后日期的时间戳。64位系统则没有问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/book.datetime.php"&gt;PHP手册：DateTime类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5319710/accessing-dates-in-php-beyond-2038"&gt;Stack Overflow: 访问超出2038的日期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;检测一个值是否为null或false&lt;/h2&gt;
&lt;h3&gt;使用&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;===&lt;/a&gt;操作符来检测null和布尔false值。&lt;/h3&gt;
&lt;p&gt;PHP宽松的类型系统提供了许多不同的方法来检测一个变量的值。然而这也造成了很多问题。
使用&lt;code&gt;==&lt;/code&gt;来检测一个值是否为null或false，如果该值实际上是一个空字符串或0，也会误报
为false。&lt;a href="http://php.net/manual/en/function.isset.php"&gt;isset&lt;/a&gt;是检测一个变量是否有值，
而不是检测该值是否为null或false，因此在这里使用是不恰当的。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/function.is-null.php"&gt;is_null()&lt;/a&gt;函数能准确地检测一个值
是否为null，&lt;a href="http://php.net/manual/en/function.is-bool.php"&gt;is_bool&lt;/a&gt;可以检测一个值
是否是布尔值（比如false），但存在一个更好的选择：&lt;code&gt;===&lt;/code&gt;操作符。&lt;code&gt;===&lt;/code&gt;检测两个值是否同一，
这不同于PHP宽松类型世界里的&lt;em&gt;相等&lt;/em&gt;。它也比is_null()和is_bool()要快一些，并且有些人
认为这比使用函数来做比较更干净些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Is $x null?&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Oops! $x is 0, not null!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Is $y null?&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;is_null&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Great, but could be faster.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$y&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Perfect!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Does the string abc contain the character a?&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;strpos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;// GOTCHA!  strpos returns 0, indicating it wishes to return the position of the first character.&lt;/span&gt;
    &lt;span class="c1"&gt;// But PHP interpretes 0 as false, so we never reach this print statement!&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Found it!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;//Solution: use !== (the opposite of ===) to see if strpos() returns 0, or boolean false.   &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;strpos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!==&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Found it for real this time!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试一个返回0或布尔false的函数的返回值时，如strpos()，始终使用&lt;code&gt;===&lt;/code&gt;和&lt;code&gt;!==&lt;/code&gt;，否则
你就会碰到问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;PHP手册：比较操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/8228837/is-nullx-vs-x-null-in-php"&gt;Stack Overflow: is_null() vs ===&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;建议与指正&lt;/h2&gt;
&lt;p&gt;感谢阅读！如果你有些地方还不太理解，很正常，PHP是复杂的，并且充斥着陷阱。因为我也
只是一个人，所以本文档中难免存在错误。&lt;/p&gt;
&lt;p&gt;如果你想为本文档贡献建议或纠正错误之处，请使用&lt;a href="https://phpbestpractices.org/#maintainers"&gt;最后修订日期&amp;amp;维护者&lt;/a&gt;
一节中的信息联系我。&lt;/p&gt;</summary><category term="翻译"></category><category term="PHP"></category></entry><entry><title>城市的日子</title><link href="http://youngsterxyf.github.io/2013/05/19/life-of-city/" rel="alternate"></link><updated>2013-05-19T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-05-19:2013/05/19/life-of-city/</id><summary type="html">&lt;p&gt;我仍须一个人&lt;br /&gt;
面对这个城市，&lt;br /&gt;
以及如此雷同的日复日。&lt;br /&gt;
&lt;br /&gt;
电话、网络，&lt;br /&gt;
工作、技术、阅读、爱好，&lt;br /&gt;
朋友，&lt;br /&gt;
还有我的思考，&lt;br /&gt;
都改变不了，&lt;br /&gt;
这城市的日子。&lt;br /&gt;
&lt;br /&gt;
所以，&lt;br /&gt;
我想她。&lt;br /&gt;&lt;/p&gt;</summary><category term="诗歌"></category><category term="笔记"></category><category term="生活"></category></entry><entry><title>编译安装MemcacheQ</title><link href="http://youngsterxyf.github.io/2013/04/27/compile-and-install-memcacheq/" rel="alternate"></link><updated>2013-04-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-27:2013/04/27/compile-and-install-memcacheq/</id><summary type="html">&lt;p&gt;MemcacheQ是一个MemcacheDB的变种，用来提供简单的消息队列服务。（注：MemcacheDB并不是一个数据缓存解决方案，而是一个为数据持久化设计的分布式的键-值对数据存储系统，采用memcache协议，以BerkeleyDB作为存储后端，&lt;a href="http://memcachedb.org/"&gt;主页&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;MemcacheQ依赖于BerkeleyDB和libevent，所以需先编译安装这两者。&lt;/p&gt;
&lt;p&gt;1.
从&lt;a href="http://www.oracle.com/technetwork/products/berkeleydb/downloads/index.html"&gt;Oracle官网&lt;/a&gt;上下载某一版本的BerkeleyDB（这里以5.0.32版本为例）&lt;/p&gt;
&lt;p&gt;解压缩： &lt;code&gt;tar -xvf db-5.0.32.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入db-5.0.32/build_unix目录后执行： 1) &lt;code&gt;../dist/configure&lt;/code&gt; , 2) &lt;code&gt;make&lt;/code&gt; , 3) &lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，会把BerkeleyDB安装到&lt;code&gt;/usr/local/BerkeleyDB.5.3&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;2.
从&lt;a href="http://libevent.org/"&gt;libevent官网&lt;/a&gt;下载libevent, 这里以2.0.21版本为例：&lt;/p&gt;
&lt;p&gt;同样解压缩，进入libevent-2.0.21-stable/目录，执行 1) &lt;code&gt;./configure&lt;/code&gt; , 2) &lt;code&gt;make&lt;/code&gt; , 3) &lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，这样会把libevent编译好后的一些库文件放到&lt;code&gt;/usr/local/lib&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;3.
从&lt;a href="https://code.google.com/p/memcacheq/downloads/list"&gt;https://code.google.com/p/memcacheq/downloads/list&lt;/a&gt;下载memcacheq，当前版本为0.2.0。由于memcacheq的configure文件第3571行：&lt;code&gt;bdbdir="/usr/local/BerkeleyDB.4.7"&lt;/code&gt;，硬编码了依赖于BerkeleyDB 4.7版本，但在Oracle官网上已经不提供4.7版本的下载，所以需要将该处的版本4.7改为之前所编译的BerkeleyDB版本，如5.0。&lt;/p&gt;
&lt;p&gt;然后执行 1) &lt;code&gt;./configure -prefix=/usr/local/memcacheq -enable-threads&lt;/code&gt;（&lt;code&gt;-prefix&lt;/code&gt;选项指定将memcacheq安装到/usr/local/memcacheq目录下），2) &lt;code&gt;make&lt;/code&gt; , 3) &lt;code&gt;sudo make install&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;4.
在Linux上，memcacheq启动时要想成功动态链接BerkeleyDB和libevent的库文件，得先手动配置动态链接库查找路径：编辑文件&lt;code&gt;/etc/ld.so.conf&lt;/code&gt;，在末尾添加两行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/usr/local/lib
/usr/local/BerkeleyDB.5.0/lib
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保存后，在命令行执行： &lt;code&gt;ldconfig&lt;/code&gt;即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;启动memcacheq: &lt;code&gt;/usr/local/memcacheq/bin/memcacheq -d -r -H /tmp/memcacheq -N -R -v -L 1024 -B 1024 &amp;gt; /tmp/mq_error.log 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;相关选项的含义可以通过&lt;code&gt;memcacheq -h&lt;/code&gt;来查看。&lt;/p&gt;
&lt;p&gt;memcacheq默认打开的网络端口为22201，可通过命令&lt;code&gt;netstat -tlnp&lt;/code&gt;来查看。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;若想编写PHP程序来测试使用memcacheq，需要先安装配置PHP &lt;a href="http://cn2.php.net/memcache"&gt;memcache扩展模块&lt;/a&gt;，可先通过&lt;code&gt;php -m | grep memcache&lt;/code&gt;来查看是否已安装。测试程序如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$memcache_obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;memcache_connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;22201&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// push数据进入队列demoqueue1&lt;/span&gt;
&lt;span class="nv"&gt;$set_rs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;memcache_set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$memcache_obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;demoqueue1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;message body here&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;var_dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$set_rs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 从队列demoqueue1中pop出数据&lt;/span&gt;
&lt;span class="nv"&gt;$get_rs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;memcache_get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$memcache_obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;demoqueue1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;var_dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$get_rs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;memcache_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$memcache_obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://memcachedb.org/memcacheq/"&gt;http://memcachedb.org/memcacheq/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://memcachedb.org/memcacheq/INSTALL.html"&gt;http://memcachedb.org/memcacheq/INSTALL.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="笔记"></category><category term="工作"></category><category term="服务器"></category><category term="技术"></category></entry><entry><title>工作中的技术人</title><link href="http://youngsterxyf.github.io/2013/04/23/technical-person/" rel="alternate"></link><updated>2013-04-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-23:2013/04/23/technical-person/</id><summary type="html">&lt;p&gt;工作入职半个月，有些事情不太顺利，还没有正式上手工作，也许大公司的节奏便是如此，但我内心是比较急的，希望能尽快地上手做实际的工作，而不是学习和等待。&lt;/p&gt;
&lt;p&gt;这半个月里，主要是熟悉工作环境，学习了解工作相关的技术。虽说学习，但其实大部分相关技术以前都了解或使用过，只是经验还不够。&lt;/p&gt;
&lt;p&gt;第一周，除了常规的入职事宜，搭建了开发测试环境，并阅读理解工作中使用的web框架。对于这个框架，有太多的吐槽点，严格地说算不上是个框架，可能是因为写得比较早。对于框架，我认为最重要的是为多人协作完成一件事情提供实现上的规范，其次是代码复用，减少工作量。但这个框架除了一些供复用的代码，就啥都没有了。&lt;/p&gt;
&lt;p&gt;第二周，学习巩固PHP基础，一直没认真地学习过PHP，只是在实习的时候做了一些开发，稍微了解了下Yii框架和Zend框架，觉得太复杂了点。除此之外，初步了解组内的运维工作，特别是整个系统的架构。&lt;/p&gt;
&lt;p&gt;经过一番思考，基于自己的理解，昨天编写了一个玩具性质的MVC web框架原型&lt;a href="https://github.com/youngsterxyf/minibean"&gt;minibean&lt;/a&gt;，该框架以路由转发和控制器为核心，所有非静态文件请求的处理都以Application类对象为入口，按照一定规则对请求URI经路由转发找到对应的控制器类，控制器对象中调用模型与视图的类对象等。以后随着开发经验的增加以及对其他开源成熟框架的学习，会不断地完善该框架。在编写该框架的过程中，深感自己经验的不足，特别是对于Model层，以后可能会刻意阅读某些开源框架的Model层实现。&lt;/p&gt;
&lt;p&gt;目前组内开发工作还很初步，还没有一个正规的开发流程，也没有明确的开发规范。这样虽然没法从已有的工作中学习很多，但也许有机会参与到这些事情创造过程中，收获会更大。&lt;/p&gt;
&lt;p&gt;经过和老同事讨论，以后开发工作涉及的语言和工具包括：Nginx、MySQL、PHP、Redis/Memcached、SVN等，对于这些东西，我都是需要深入学习加强的（当然首先是要解决业务需求）。另外，鉴于原有的那个框架实在不怎么样，以后新的工作可能会选择Zend Framework作为开发框架。&lt;/p&gt;
&lt;p&gt;对于工作环境，我觉得不太满意的地方主要是技术氛围不太浓厚，以后有机会和大家一起建立起好的技术氛围，搞搞技术分享讨论什么的。另外，有点憋屈的是，觉着自己被小看了，老同事老觉得应届毕业生啥的不懂，所以也不急着分配具体的工作给我，老让我学习学习再学习。个人认为最好的学习方式是给个具体的需求，具体的问题让我去解决，有经验的同事只需对结果把把关就可以。当我在这过程中遇到搞不定的问题再向他们请教，以这种方式来上手熟悉工作也许更好。我个人也比较喜欢直接丢个实际的问题让我去解决。&lt;/p&gt;
&lt;p&gt;对于今后的自己，我有两点忠告：&lt;/p&gt;
&lt;p&gt;1.
时刻警惕迷失&lt;/p&gt;
&lt;p&gt;虽然工作很重要，要解决业务需求，工作所涉及的技术也应该扎实掌握，深入理解，但不能把自己局限在此，也不能让自己迷失在过于细节的地方。公司提供了一个完善的平台，但这个平台在我看来自足得有些封闭，所以需警惕，要不断地和同事，和公司外面的人交流学习。要经常自我反思，回顾自己走过的路，要让自己的大脑空闲下来花些时间整体规划即将要做的事情。&lt;/p&gt;
&lt;p&gt;2.
保持锐气&lt;/p&gt;
&lt;p&gt;初步觉着有些同事没什么工作生活技术的激情，可能是长时间工作的缘故，也可能是因为我还太年轻。但目前我还不愿意自己进入那种状态。自己以后应该更加主动积极地对待工作。我喜欢称呼自己为“技术人”，因为“技术人”不仅是搞技术的，更重要的是对技术有热情，有使命感。&lt;/p&gt;</summary><category term="工作"></category><category term="感悟"></category></entry><entry><title>Windows上安装PHP开发测试环境</title><link href="http://youngsterxyf.github.io/2013/04/15/install-php-development-environment-on-windows/" rel="alternate"></link><updated>2013-04-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-15:2013/04/15/install-php-development-environment-on-windows/</id><summary type="html">&lt;p&gt;先从HTTP请求处理流程图来看看我们所需的PHP开发测试环境包含哪些组件。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/php-development-env.jpg" alt="PHP开发测试环境"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出系统包含如下几种组件之间的交互：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx与PHP-CGI(PHP)的交互&lt;/li&gt;
&lt;li&gt;PHP-CGI(PHP)与文件系统、分布式内存对象缓存系统、数据库之间的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了PHP与文件系统之间的交互，其他几种交互均为客户端-服务器模式，以Socket方式进行连接，都需要安装配置相关组件。&lt;/p&gt;
&lt;p&gt;对于Nginx与PHP-CGI(PHP)的交互，PHP-CGI默认打开9000端口，等待Nginx转发过来的请求，所以需要在Nginx配置文件中添加类似于如下所示的虚拟主机配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;server {
    listen  8000;
    server_name localhost;

    location / {
        root    html;   # 这里为你的网站的根目录
        index   index.php index.html index.htm;
    }

    location ~ \.php$ {
        root    html;   # 这里也设置为你的网站的根目录
        fastcgi_pass    127.0.0.1:9000; # 这里设置为你的PHP-CGI监听的网络地址
        fastcgi_index   index.php;
        fastcgi_param   SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Windows上，直接双击运行php-cgi.exe文件打开PHP-CGI服务，貌似没用，可以在CMD中执行&lt;code&gt;php-cgi.exe -b 127.0.0.1:9000&lt;/code&gt;来打开服务。&lt;/p&gt;
&lt;p&gt;对于Nginx.exe，可以直接双击nginx.exe来运行，但如果要停止nginx的运行或者重新加载配置文件，则可以在CMD中执行如下相应的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;nginx -s stop   fast shutdown
nginx -s quit   graceful shutdown
nginx -s reload  changing configuration, starting new worker processes with a new configuration, graceful shutdown of old worker processes
nginx -s reopen re-opening log files
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，Nginx的虚拟主机配置信息中，root指令指定的网站根目录路径应遵从Unix的格式，而不是Windows的格式，即使用&lt;strong&gt;/&lt;/strong&gt;而不是&lt;strong&gt;\&lt;/strong&gt;来分割目录层次。&lt;/p&gt;
&lt;p&gt;Nginx与PHP的Windows版本可分别从：&lt;a href="http://nginx.org/en/download.html"&gt;Nginx for Windows&lt;/a&gt;，&lt;a href="http://windows.php.net/download/"&gt;PHP for Windows&lt;/a&gt;。无需安装，解压缩即可。PHP-CGI的可执行文件php-cgi.exe也在PHP的压缩包中。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;对于分布式内存对象系统，以Memcached和Redis为例。PHP通过扩展包与它们交互，所以需要下载相应的扩展包，并配置PHP。&lt;/p&gt;
&lt;p&gt;以PHP 5.3版本为例，可分别从&lt;a href="http://downloads.php.net/pierre/"&gt;http://downloads.php.net/pierre/&lt;/a&gt;、&lt;a href="http://blog.phpwind.me/wp-content/plugins/download-monitor/download.php?id=9"&gt;http://blog.phpwind.me/wp-content/plugins/download-monitor/download.php?id=9&lt;/a&gt;下载PHP的memcached扩展包与redis扩展包，注意扩展包对应的php版本号必须与你安装的PHP的版本号一致。&lt;/p&gt;
&lt;p&gt;解压缩后将php_memcache.dll和php_redis.dll文件复制到PHP的ext目录下。&lt;/p&gt;
&lt;p&gt;然后将PHP目录下的php.ini-development文件重命名为php.ini，打开php.ini，首先删除&lt;code&gt;;extension_dir="ext"&lt;/code&gt;一行行首的分号，然后删除&lt;code&gt;;extension=php_memcache.dll&lt;/code&gt;一行行首的分号，并在其后添加一行&lt;code&gt;extension=php_redis.dll&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于Memcached和Redis的服务器端程序，可分别从：&lt;a href="http://downloads.northscale.com/memcached-win32-1.4.4-14.zip"&gt;Memcached for Windows&lt;/a&gt;、&lt;a href="https://github.com/dmajkic/redis/downloads"&gt;Redis for Windows&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;Memcached的默认端口为11211。&lt;/p&gt;
&lt;p&gt;关于Redis的配置见：&lt;a href="http://redis.io/topics/config"&gt;http://redis.io/topics/config&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于windows下redis和php的redis扩展的安装，可进一步参考&lt;a href="http://blog.phpwind.me/?p=152"&gt;http://blog.phpwind.me/?p=152&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;PHP与MySQL之间的交互，类似于PHP与分布式内存对象系统之间的交互。只不过PHP的压缩包的ext目录下已经包含了&lt;code&gt;php_mysql.dll&lt;/code&gt;和&lt;code&gt;php_mysqli.dll&lt;/code&gt;扩展包，只需修改php.ini配置文件即可：删除&lt;code&gt;;extension=php_mysql.dll&lt;/code&gt;和&lt;code&gt;;extension=php_mysqli.dll&lt;/code&gt;两行行首的分号。&lt;/p&gt;
&lt;p&gt;MySQL的服务器端程序从MySQL官网下载，默认端口为3306。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;除了上述安装配置，你可能还需要在php.ini中启用&lt;code&gt;extension=php_mbstring.dll&lt;/code&gt;、&lt;code&gt;extension=php_soap.dll&lt;/code&gt;等扩展。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;安装配置完毕后，启动Nginx、PHP-CGI、MySQL（可选）、Redis/Memcached（可选）。在某个Nginx虚拟主机中指定的网站根目录下添加测试文件phpinfo.php，其内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class="nb"&gt;phpinfo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过浏览器访问该网页，若PHP环境配置成功，则会看到一个当前PHP环境的详细信息列表，从中可以看到当前所启动的PHP扩展，若未找到memcache、redis、mysql这几个扩展包信息，则说明未成功启用。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果你测试某些以前别人写的PHP代码，发现结果与预期的不相符，则看看是不是那些代码中使用了PHP短标记&lt;code&gt;&amp;lt;?&lt;/code&gt;和&lt;code&gt;?&amp;gt;&lt;/code&gt;。PHP默认不启用短标记，所以你需要修改php.ini，删除&lt;code&gt;;short_open_tag = On&lt;/code&gt;一行之前的分号。&lt;/p&gt;
&lt;p&gt;另外，注意Nginx虚拟主机所使用的端口不要和Windows中其他网络应用的端口冲突。&lt;/p&gt;</summary><category term="笔记"></category><category term="PHP"></category></entry><entry><title>弄清问题，再求解决</title><link href="http://youngsterxyf.github.io/2013/04/09/understand-before-solve/" rel="alternate"></link><updated>2013-04-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-04-09:2013/04/09/understand-before-solve/</id><summary type="html">&lt;p&gt;今天同事问我：是否有什么python库或工具能够将网页内容转换成图片格式的。他在做这方面的事情，还没有好的方法，因为觉得我对python比较熟悉，所以问一下。&lt;/p&gt;
&lt;p&gt;但是我从一开始我就犯错误了。其实我至少应该问一下：为什么要解决这个问题？也就是业务需求是什么？并且稍微一想这个问题其实比较含糊。现在的web页面可以很简单，也可能很复杂。那么这个问题里的“网页”是什么样的网页呢？是任何可能的网页么？目的是需要通过图片来展示网页的哪个部分的信息还是整个网页？这些问题我都没问，也没仔细考虑。&lt;/p&gt;
&lt;p&gt;在没有明确需求的情况下，我就认为是将任何形式的网页完整地转换成图片，但又没弄清如果是这种情况问题的难度有多大。&lt;/p&gt;
&lt;p&gt;在听完问题后，我就想到可能有两种方法：1. 先将网页转换成pdf，然后转换成图片，因为我对于将网页转换成pdf格式的方法有点印象；2.可能存在python实现的工具直接将网页转换成图片格式。你是否发现我的思路有个误区：问题的解决方案需要python代码实现，我假设了需要将这个功能嵌入到一个大的程序中。&lt;/p&gt;
&lt;p&gt;然后我就开始蒙头google找方案。经过一番“艰苦卓绝”的查找，发现：1.确实有如xhtml2pdf等工具能将网页转换成pdf格式，但貌似对于中文的支持不是很好；2.没有好的python库或工具能够直接将网页转换成图片格式，有的方案要收费，有的方案需要调用第三方API，而公司的数据明显是不能让第三方获得的。&lt;/p&gt;
&lt;p&gt;在查找解决方案的过程中，我也逐步意识到上述的那些问题，特别是若假设需要将任何形式的网页转换成图片格式，这个难度非常大，为什么呢？因为现在很多网页的部分内容都是由JS生成的，若你的程序只是简单地从服务器获取网页，该网页含有的JS代码并不会执行，将该网页转换成图片格式，图片所包含的信息与浏览器中展示的并不相同。所以你的程序起码需要包含一个JS解释器。OK，难度一下子就上去了。在我逐步了解其中的难度后，我开始尝试换个角度来考虑问题，反思同事所要解决的业务需求是什么。&lt;/p&gt;
&lt;p&gt;在与他的进一步沟通之后，我才知道：一些总结汇报邮件中需要添加数据统计图，而原有的数据统计图在Web监控页面中，由Raphaeljs库绘制成SVG矢量图。由于无法期望邮件的接收者是从网页版邮箱阅读邮件（他们很可能使用各种邮件客户端如Outlook查看邮件），所以发送带有JS的HTML格式的邮件是没用的。&lt;/p&gt;
&lt;p&gt;在了解业务需求后，我们就明白了其实问题本质上不是要将网页转换成图片，而是要获得&lt;strong&gt;图片格式的数据可视化结果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么问题就简单多了，可能从以下三个角度寻找解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将网页完整地转换成图片格式&lt;/li&gt;
&lt;li&gt;将网页中的SVG内容转换成图片格式&lt;/li&gt;
&lt;li&gt;使用本地的数据可视化工具将统计数据源，即Raphaeljs绘制SVG矢量图的JSON数据源绘制成图片&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种方案中第二种最佳，为什么呢？因为第一种需要做一些额外的转换工作，自己实现的难度较大，第三种方案与Web监控页面所使用的是不同的数据可视化工具，所以产生的结果一般是不相同的，除非Raphaeljs支持图片格式的输出，那么应该就可以使用nodejs来实现。&lt;/p&gt;
&lt;p&gt;经过网络查找，发现第一种方案与第二种方案都有现成的工具。&lt;/p&gt;
&lt;p&gt;第一种方案：&lt;a href="https://github.com/ariya/phantomjs"&gt;phantomjs&lt;/a&gt;可以完成，phantomjs包含了webkit，所以解释JS什么的就不再是个问题了，它有个&lt;a href="https://github.com/ariya/phantomjs/wiki/Screen-Capture"&gt;Screen Capture&lt;/a&gt;的功能模块支持将网页完整地转换成图片格式，但由于要做很多额外的工作，所以效率比较低。&lt;/p&gt;
&lt;p&gt;第二种方案是从Highcharts的&lt;a href="http://www.highcharts.com/demo/"&gt;Demo&lt;/a&gt;中挖掘出来的，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/highchartjsdemo.png" alt="highchartjs_demo"&gt;&lt;/p&gt;
&lt;p&gt;Demo中可以输出多种图片格式，通过chrome浏览器的开发者工具可以发现其实现是向服务器export.highcharts.com发送一个请求，请求中包含网页中生成的SVG矢量图数据、目标图片格式等信息，服务器对该请求进行处理后返回目标格式图片。那么服务器端是如何将SVG转换成图片格式的呢？在Highcharts的&lt;a href="http://docs.highcharts.com/"&gt;文档&lt;/a&gt;中有个名为&lt;code&gt;Export module&lt;/code&gt;的部分，其中说明了实现原理以及如何搭建这样的一个格式转换服务器。从文档可以看出这个实现方法的核心是借助了&lt;a href="http://xmlgraphics.apache.org/batik/tools/rasterizer.html"&gt;batik-rasterizer.jar&lt;/a&gt;这个Java工具包，它能将SVG转换成图片或PDF格式。&lt;/p&gt;
&lt;p&gt;从上述该问题解决方案的寻找过程可以看出，&lt;strong&gt;很多时候并不是问题有多复杂或有多难，而是我们根本没有明确业务需求，没有搞清楚真正需要解决的问题，而对模糊的问题描述自以为是地作出一些假设，然后蒙头去解决错误的问题，从而浪费了很多时间&lt;/strong&gt;。&lt;/p&gt;</summary><category term="笔记"></category><category term="工作"></category></entry><entry><title>argparse - 命令行选项与参数解析（译）</title><link href="http://youngsterxyf.github.io/2013/03/30/argparse/" rel="alternate"></link><updated>2013-03-30T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-30:2013/03/30/argparse/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://pymotw.com/2/argparse/"&gt;argparse – Command line option and argument parsing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;argparse模块作为optparse的一个替代被添加到Python2.7。argparse的实现支持一些不易于添加到optparse以及要求向后不兼容API变化的特性，因此以一个新模块添加到标准库。&lt;/p&gt;
&lt;h3&gt;与optparse相比较&lt;/h3&gt;
&lt;p&gt;argparse的API类似于optparse，甚至在很多情况下通过更新所使用的类名和方法名，使用argparse作为一个简单的替代。然而，有些地方在添加新特性时不能保持直接兼容性。&lt;/p&gt;
&lt;p&gt;你必须视情况决定是否升级已有的程序。如果你已编写了额外的代码以弥补optparse的局限，也许你想升级程序以减少你需要维护的代码量。若argparse在所有部署平台上都可用，那么新的程序应尽可能使用argparse。&lt;/p&gt;
&lt;h3&gt;设置一个解析器&lt;/h3&gt;
&lt;p&gt;使用argparse的第一步就是创建一个解析器对象，并告诉它将会有些什么参数。那么当你的程序运行时，该解析器就可以用于处理命令行参数。&lt;/p&gt;
&lt;p&gt;解析器类是 &lt;strong&gt;ArgumentParser&lt;/strong&gt; 。构造方法接收几个参数来设置用于程序帮助文本的描述信息以及其他全局的行为或设置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;This is a PyMOTW sample program&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义参数&lt;/h3&gt;
&lt;p&gt;argparse是一个全面的参数处理库。参数可以触发不同的动作，动作由 &lt;strong&gt;add_argument()&lt;/strong&gt; 方法的 &lt;em&gt;action&lt;/em&gt; 参数指定。
支持的动作包括保存参数（逐个地，或者作为列表的一部分），当解析到某参数时保存一个常量值（包括对布尔开关真/假值的特殊处理），统计某个参数出现的次数，以及调用一个回调函数。&lt;/p&gt;
&lt;p&gt;默认的动作是保存参数值。在这种情况下，如果提供一个类型，那么在存储之前会先把该参数值转换成该类型。如果提供 &lt;em&gt;dest&lt;/em&gt; 参数，参数值就保存为命令行参数解析时返回的命名空间对象中名为该 &lt;em&gt;dest&lt;/em&gt; 参数值的一个属性。&lt;/p&gt;
&lt;h3&gt;解析一个命令行&lt;/h3&gt;
&lt;p&gt;定义了所有参数之后，你就可以给 &lt;strong&gt;parse_args()&lt;/strong&gt; 传递一组参数字符串来解析命令行。默认情况下，参数是从 &lt;code&gt;sys.argv[1:]&lt;/code&gt; 中获取，但你也可以传递自己的参数列表。选项是使用GNU/POSIX语法来处理的，所以在序列中选项和参数值可以混合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parse_args()&lt;/strong&gt; 的返回值是一个&lt;strong&gt;命名空间&lt;/strong&gt;，包含传递给命令的参数。该对象将参数保存其属性，因此如果你的参数 &lt;code&gt;dest&lt;/code&gt; 是 &lt;code&gt;"myoption"&lt;/code&gt;，那么你就可以&lt;code&gt;args.myoption&lt;/code&gt; 来访问该值。&lt;/p&gt;
&lt;h3&gt;简单示例&lt;/h3&gt;
&lt;p&gt;以下简单示例带有3个不同的选项：一个布尔选项（&lt;code&gt;-a&lt;/code&gt;），一个简单的字符串选项（&lt;code&gt;-b&lt;/code&gt;），以及一个整数选项（&lt;code&gt;-c&lt;/code&gt;）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-bval&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有几种方式传递值给单字符选项。以上例子使用了两种不同的形式，&lt;code&gt;-bval&lt;/code&gt;和&lt;code&gt;-c val&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_short.py
Namespace(a=True, b=&amp;#39;val&amp;#39;, c=3)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在输出中与&lt;code&gt;'c'&lt;/code&gt;关联的值是一个整数，因为程序告诉&lt;strong&gt;ArgumentParser&lt;/strong&gt;在保存之前先转换该参数。&lt;/p&gt;
&lt;p&gt;“长”选项名字，即选项的名字多于一个字符，以相同的方式进行处理。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Example with long option names&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--noarg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--witharg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;witharg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--witharg2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;witharg2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--noarg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--witharg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;val&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--withargs=3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果也类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_long.py
Namespace(noarg=True, witharg=&amp;#39;val&amp;#39;, witharg2=3)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;argparse区别于optparse的一个地方是对非选项参数值的处理。optparse只进行选项解析，而argparse是一个全面的命令行参数解析工具，也处理非选项参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Example with non-optional arguments&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;count&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;units&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这个例子中，“count”参数是一个整数，“units”参数存储为一个字符串。其中任意一个参数若没有在命令行中提供，或给定的值不能被转换为正确的类型，就会报告一个错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_arguments.py 3 inches

Namespace(count=3, units=&amp;#39;inches&amp;#39;)

$ python argparse_arguments.py some inches

usage: argparse_arguments.py [-h] count units
argparse_arguments.py: error: argument count: invalid int value: &amp;#39;some&amp;#39;

$ python argparse_arguments.py

usage: argparse_arguments.py [-h] count units
argparse_arguments.py: error: too few arguments
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;参数动作&lt;/h3&gt;
&lt;p&gt;argparse内置6种动作可以在解析到一个参数时进行触发：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;store&lt;/code&gt;
    保存参数值，可能会先将参数值转换成另一个数据类型。若没有显式指定动作，则默认为该动作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;store_const&lt;/code&gt;
    保存一个被定义为参数规格一部分的值，而不是一个来自参数解析而来的值。这通常用于实现非布尔值的命令行标记。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;store_ture&lt;/code&gt;/&lt;code&gt;store_false&lt;/code&gt;
    保存相应的布尔值。这两个动作被用于实现布尔开关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt;
    将值保存到一个列表中。若参数重复出现，则保存多个值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append_const&lt;/code&gt;
    将一个定义在参数规格中的值保存到一个列表中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;version&lt;/code&gt;
    打印关于程序的版本信息，然后退出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;simple_value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Store a simple value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_const&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;constant_value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;value-to-store&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Store a constant value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-t&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;boolean_switch&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Set a switch to true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_false&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;boolean_switch&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Set a switch to false&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;append&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;collection&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Add repeated values to a list&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;append_const&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;const_collection&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;value-1-to-append&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Add different values to list&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;append_const&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;const_collection&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;value-2-to-append&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Add different values to list&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--version&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;version&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(prog)s&lt;/span&gt;&lt;span class="s"&gt; 1.0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;simple_value     =&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;simple_value&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;constant_value   =&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constant_value&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;boolean_switch   =&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;boolean_switch&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;collection       =&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;const_collection =&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;const_collection&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_action.py -h

usage: argparse_action.py [-h] [-s SIMPLE_VALUE] [-c] [-t] [-f]
                          [-a COLLECTION] [-A] [-B] [--version]

optional arguments:
  -h, --help       show this help message and exit
  -s SIMPLE_VALUE  Store a simple value
  -c               Store a constant value
  -t               Set a switch to true
  -f               Set a switch to false
  -a COLLECTION    Add repeated values to a list
  -A               Add different values to list
  -B               Add different values to list
  --version        show program&amp;#39;s version number and exit

$ python argparse_action.py -s value

simple_value     = value
constant_value   = None
boolean_switch   = False
collection       = []
const_collection = []

$ python argparse_action.py -c

simple_value     = None
constant_value   = value-to-store
boolean_switch   = False
collection       = []
const_collection = []

$ python argparse_action.py -t

simple_value     = None
constant_value   = None
boolean_switch   = True
collection       = []
const_collection = []

$ python argparse_action.py -f

simple_value     = None
constant_value   = None
boolean_switch   = False
collection       = []
const_collection = []

$ python argparse_action.py -a one -a two -a three

simple_value     = None
constant_value   = None
boolean_switch   = False
collection       = [&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;three&amp;#39;]
const_collection = []

$ python argparse_action.py -B -A

simple_value     = None
constant_value   = None
boolean_switch   = False
collection       = []
const_collection = [&amp;#39;value-2-to-append&amp;#39;, &amp;#39;value-1-to-append&amp;#39;]

$ python argparse_action.py --version

argparse_action.py 1.0
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;选项前缀&lt;/h3&gt;
&lt;p&gt;argparse选项的默认语法是基于Unix约定的，使用一个“-”前缀来表示命令行开关。argparse支持其他前缀，因此你可以使得你的程序遵照本地平台的默认语法（例如，在Window上使用“/”）或者遵循不同的约定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Change the option prefix charaters&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
        &lt;span class="n"&gt;prefix_chars&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-+/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_false&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Turn A off&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;+a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Turn A on&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;//noarg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;++noarg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将&lt;strong&gt;ArgumentParser&lt;/strong&gt; 方法的&lt;em&gt;prefix_chars&lt;/em&gt; 参数设置为一个字符串，该字符串包含所有允许用来表示选项的字符。需要理解的是虽然&lt;em&gt;prefix_chars&lt;/em&gt;包含允许用于开关的字符，但单个参数定义只能使用一种给定的开关语法。这让你可以对使用不同前缀的选项是否是别名（比如独立于平台的命令行语法的情况）或替代选择（例如，使用“+”表明打开一个开发，“-”则为关闭一个开关）进行显式地控制。在上述例子中，&lt;code&gt;+a&lt;/code&gt;和&lt;code&gt;-a&lt;/code&gt;是不同的参数，&lt;code&gt;//noarg&lt;/code&gt; 也可以 &lt;code&gt;++noarg&lt;/code&gt; 提供，但不是 &lt;code&gt;--noarg&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_prefix_chars.py -h

usage: argparse_prefix_chars.py [-h] [-a] [+a] [//noarg]

Change the option prefix characters

optional arguments
    -h, --help  show this help message and exit
    -a  Turn A off
    +a  Turn A on
    //noarg,++noarg

$ python argparse_prefix_chars.py +a

Namespace(a=True, noarg=False)

$ python argparse_prefix_chars.py -a

Namespace(a=False, noarg=False)

$ python argparse_prefix_chars.py //noarg

Namespace(a=None, noarg=True)

$ python argparse_prefix_chars.py ++noarg

Namespace(a=None, noarg=True)

$ python argparse_prefix_chars.py --noarg

usage: argparse_prefix_chars.py [-h] [-a] [+a] [//noarg]
argparse_prefix_chars.py: error: unrecognized arguments: --noarg
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;参数来源&lt;/h3&gt;
&lt;p&gt;目前为止所见的例子中，提供给解析器的参数列表来自于显式传递的一个列表，或隐式地从sys.argv获取的。显式传递列表在你使用argparse来处理类命令行但并不是来自命令行（比如来自一个配置文件）的指令之时比较有用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;ConfigParser&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;shlex&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;argparse_witH_shlex.ini&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;config_value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;cli&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;options&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Config: &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;config_value&lt;/span&gt;

&lt;span class="n"&gt;argument_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shlex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config_value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Arg List:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argument_list&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Results:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argument_list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;shlex使得切分存储在配置文件中的字符串非常容易。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_with_shlex.py

Config: -a -b 2
Arg List: [&amp;#39;-a&amp;#39;, &amp;#39;-b&amp;#39;, &amp;#39;2&amp;#39;]
Results: Namespace(a=True, b=&amp;#39;2&amp;#39;, c=None)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另一种自己处理配置文件的方法是使用&lt;em&gt;fromfile_prefix_chars&lt;/em&gt;指定一个包含一组要待处理参数的输入文件来告诉argparse怎样识别参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;ConfigParser&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;shlex&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;fromfile_prefix_chars&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;@&amp;#39;&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;@argparse_fromfile_prefix_chars.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该示例代码在找到一个以&lt;em&gt;@&lt;/em&gt;为前缀的参数时即停止往下读取，然后从以该参数命名的文件中查找更多的参数。例如，输入文件&lt;code&gt;argparse_fromfile_prefix_chars.txt&lt;/code&gt;包含一系列参数，一行一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-a
-b
2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么处理该文件产生的输出为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_fromfile_prefix_chars.py

Namespace(a=True, b=&amp;#39;2&amp;#39;, c=None)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;自动生成选项&lt;/h3&gt;
&lt;p&gt;经过配置argparse会自动添加选项用来生成帮助信息以及为你的应用程序显示版本信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ArgumentParser&lt;/strong&gt;的参数&lt;em&gt;add_help&lt;/em&gt; 控制帮助信息相关的选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;帮助选项（-h和--help）默认是添加的，但可以通过将&lt;em&gt;add_help&lt;/em&gt;设置为false来禁用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然&lt;code&gt;-h&lt;/code&gt;和&lt;code&gt;--help&lt;/code&gt;是事实上的请求帮助的标准选项名称，但一些应用或argparse的使用要么不需要提供帮助要么需要将这两个选项名称用于其他目标。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_with_help.py -h

usage: argparse_with_help.py [-h] [-a] [-b B] [-c C]

optional arguments:
    -h, --help  show this help message and exit
    -a
    -b B
    -c C

$ python argparse_without_help.py -h

usage: argparse_without_help.py [-a] [-b B] [-c C]
argparse_without_help.py: error: unrecognized arguments: -h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当在&lt;strong&gt;ArgumentParser&lt;/strong&gt;构造方法设置&lt;em&gt;版本&lt;/em&gt;后，就会添加版本选项（&lt;code&gt;-v&lt;/code&gt;和&lt;code&gt;--version&lt;/code&gt;）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1.0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;This is not printed&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两种形式的选项爱那个都会打印程序的版本字符串，然后立即退出程序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_with_version.py -h

usage: argparse_with_version.py [-h] [-v] [-a] [-b B] [-c C]

optional arguments:
    -h, --help  show this help message and exit
    -v, --version   show program&amp;#39;s version number and exit
    -a
    -b B
    -c C

$ python argparse_with_version.py -v

1.0
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;解析器组&lt;/h3&gt;
&lt;p&gt;argparse包含若干特性用于组织你的参数解析器，使得实现更为简单，也能提高输出帮助信息的可用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享解析器规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常常需要实现一套命令行程序，这些程序都带一组参数，只是在某些方面有特殊化。例如，如果所有程序都需要在用户进行任何实际的操作之前对用户进行认证，那么它们就都需要支持&lt;code&gt;--user&lt;/code&gt;和&lt;code&gt;--password&lt;/code&gt;选项。你可以共享的选项来定义一个“父母”解析器，然后令单个程序的解析器从该“父母”解析器继承共享选项，这样就不必显式为每个&lt;strong&gt;ArgumentParser&lt;/strong&gt;添加共享选项。&lt;/p&gt;
&lt;p&gt;第一步是以共享的参数定义建立“父母”解析器。由于“父母”解析器的后代使用者会添加相同的帮助选项，从而会引发一个异常，所以在基础解析器中我们关闭自动帮助选项生成。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来，以&lt;em&gt;父母解析器&lt;/em&gt;集创建另一个解析器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse_parent_base&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parents&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;argparse_parent_base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--local-arg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到的程序带有三个选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_uses_parent.py -h

usage: argparse_uses_parent.py [-h] [--user USER] [--password PASSWORD]
                           [--local-arg]

optional arguments:
    -h, --help           show this help message and exit
    --user USER
    --password PASSWORD
    --local-arg
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;冲突的选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前一个例子指出以相同的参数名字为一个解析器添加两个参数处理器会引发一个异常。可以通过传递一个&lt;em&gt;conflict_handler&lt;/em&gt;来改变冲突消除行为。argparse有两个内置的冲突处理器&lt;code&gt;error&lt;/code&gt;（默认）和&lt;code&gt;resolve&lt;/code&gt;，&lt;code&gt;resolve&lt;/code&gt;会基于冲突选项的添加顺序来选择一个参数处理器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conflict_handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;resolve&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Short alone&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--long-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Long and short together&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-h&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于最后一个处理器所给定的参数名已被使用，那么本例中独立选项&lt;code&gt;-b&lt;/code&gt;将被&lt;code&gt;--long-b&lt;/code&gt;的别名所覆盖。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_conflict_handler_resolve.py

usage: argparse_conflict_handler_resolve.py [-h] [-a A] [--long-b LONG_B]

optional arguments:
    -h, --help  show this help message and exit
    -a A
    --long-b LONG_B, -b LONG_B
            Long and short together
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;切换&lt;strong&gt;add_argument()&lt;/strong&gt;的调用顺序就可以启用独立的选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conflict_handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;resolve&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--long-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Long and short together&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Short alone&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在两个选项可以一起使用了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_conflict_handler_resolve2.py

usage: argparse_conflict_handler_resolve2.py [-h] [-a A] [--long-b LONG_B] [-b B]

optional arguments:
    -h, --help  show this help message and exit
    -a A
    --long-b LONG_B Long and short together
    -b B    Short alone
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参数群组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;argparse能将参数定义组合成“群组”。默认情况下是使用两个群组，一个是选项的群组，另一个是必须的与位置相关的参数群组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Short sample app&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--optional&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;positional&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;群组在输出的帮助信息中显示为分开的“与位置相关的参数”和“可选参数”两个部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_default_grouping.py

usage: argparse_default_grouping.py [-h] [--optional] positional

Short sample app

positional arguments:
    positional

optional arguments:
    -h, --help  show this help message and exit
    --optional
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可以调整群组来提高帮助信息中群组的逻辑性，这样相关选项或值能记录在一起。可以使用自定义群组来重写之前的共享选项的示例，如此在帮助信息中身份认证的选项就可以显示在一起。&lt;/p&gt;
&lt;p&gt;在基础解析器中使用&lt;strong&gt;add_argument_group()&lt;/strong&gt;来创建一个“身份认证”群组，然后逐个添加身份认证相关的选项到该群组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add_help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument_group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;authentication&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--password&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;与之前一样，程序使用基于群组的父母解析器列表作为&lt;em&gt;parents&lt;/em&gt;的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse_parent_with_group&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parents&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;argparse_parent_with_group&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--local-arg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在输出的帮助信息一起显示身份认证选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_uses_parent_with_group.py -h

usage: argparse_uses_parent_with_group.py [-h] [--user USER] [--password PASSWORD] [--local-arg]

optional arguments:
    -h, --help  show this message and exit
    --local-arg

authentication:
    --user USER
    --password PASSWORD
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;互斥选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义互斥的选项是选项分组特性的一个特例，使用&lt;strong&gt;add_mutually_exclusive_group()&lt;/strong&gt;而不是&lt;strong&gt;add_argument_group()&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_mutually_exclusive_group&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;store_true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;argparse会为你强制执行互斥性，因此一次使用仅能给出该群组的选项中的一个。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_mutually_exclusive.py -h

usage: argparse_mutually_exclusive.py [-h] [-a | -b]

optional arguments:
    -h, --help  show this help message and exit
    -a
    -b

$ python argparse_mutually_exclusive.py -a

Namespace(a=True, b=False)

$ python argparse_mutually_exclusive.py -b

Namespace(a=False, b=True)

$ python argparse_mutually_exclusive.py -a -b

usage: argparse_mutually_exclusive.py [-h] [-a | -b]
argparse_mutually_exclusive.py: error: argument -b: not allowed with argument -a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;嵌套解析器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述的父母解析器方式是在相关命令之间共享选项的方式之一。另一种方式是将多个命令组合进一个程序中，使用子解析器来处理命令行的每个部分。就像&lt;code&gt;svn&lt;/code&gt;，&lt;code&gt;hg&lt;/code&gt;，以及其他带有多个命令行行为或子命令的程序那样。&lt;/p&gt;
&lt;p&gt;一个用于处理文件系统目录的程序可能会像这样定义命令用于创建、删除、以及列出一个目录的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;subparsers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_subparsers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;commands&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# A list command&lt;/span&gt;
&lt;span class="n"&gt;list_parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subparsers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_parser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;list&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;List contents&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;list_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dirname&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Directory to list&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# A create command&lt;/span&gt;
&lt;span class="n"&gt;create_parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subparsers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_parser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;create&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Create a directory&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;create_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dirname&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;New directory to create&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;create_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--read-only&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Set permissions to prevent writing to the directory&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# A delete command&lt;/span&gt;
&lt;span class="n"&gt;delete_parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subparsers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_parser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;delete&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Remove a directory&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;delete_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dirname&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The directory to remove&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;delete_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--recursive&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Remove the contents of the directory, too&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出的帮助信息显示作为“命令”的命名子解析器能够在命令行中作为位置参数进行指定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_subparsers.py -h

usage: argparse_subparsers.py [-h] {list, create, delete} ...

positional arguments:
    {list, create, delete} commands
        list    List contents
        create  Create a directory
        delete  Remove a directory

optional arguments:
    -h, --help  show this help message and exit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每个子解析器也有自己的帮助信息，描述那个命令的参数和选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_subparsers.py create -h

usage: argparse_subparsers.py create [-h] [--read-only] dirname

positional arguments:
    dirname New directory to create

optional arguments:
    -h, --help  show this help message and exit
    --read-only Set permissions to prevent writing to the directory
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数被解析后，&lt;strong&gt;parse_args()&lt;/strong&gt;返回的&lt;strong&gt;Namespace&lt;/strong&gt;对象仅包含与指定的命令相关的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_subparsers.py delete -r foo

Namespace(dirname=&amp;#39;foo&amp;#39;, recursive=True)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;高级参数处理&lt;/h3&gt;
&lt;p&gt;至今为止的示例展示了简单的布尔标识、字符串或数字参数选项、以及位置参数。对于变长参数列表、枚举类型数据、以及常量，argparse支持复杂的参数规格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变形参列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以配置单个参数的定义使其能够匹配所解析的命令行的多个参数。根据需要或期望的参数个数，设置&lt;em&gt;nargs&lt;/em&gt;为这些标识值之一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;值  含义
N   参数的绝对个数（例如：3）
?   0或1个参数
*   0或所有参数
+   所有，并且至少一个参数
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--three&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--optional&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;?&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--all&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;all&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--one-or-more&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解析器强制执行参数计数指令，生成一个精确的语法图作为命令帮助文本的一部分。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_nargs.py -h

usage: argparse_nargs.py [-h] [--three THREE THREE THREE]
                     [--optional [OPTIONAL]] [--all [ALL [ALL ...]]]
                     [--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]]

optional arguments:
-h, --help            show this help message and exit
--three THREE THREE THREE
--optional [OPTIONAL]
--all [ALL [ALL ...]]
--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]

$ python argparse_nargs.py

Namespace(all=None, one_or_more=None, optional=None, three=None)

$ python argparse_nargs.py --three

usage: argparse_nargs.py [-h] [--three THREE THREE THREE]
                     [--optional [OPTIONAL]] [--all [ALL [ALL ...]]]
                     [--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]]
argparse_nargs.py: error: argument --three: expected 3 argument(s)

$ python argparse_nargs.py --three a b c

Namespace(all=None, one_or_more=None, optional=None, three=[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;])

$ python argparse_nargs.py --optional

Namespace(all=None, one_or_more=None, optional=None, three=None)

$ python argparse_nargs.py --optional with_value

Namespace(all=None, one_or_more=None, optional=&amp;#39;with_value&amp;#39;, three=None)

$ python argparse_nargs.py --all with multiple values

Namespace(all=[&amp;#39;with&amp;#39;, &amp;#39;multiple&amp;#39;, &amp;#39;values&amp;#39;], one_or_more=None, optional=None, three=None)

$ python argparse_nargs.py --one-or-more with_value

Namespace(all=None, one_or_more=[&amp;#39;with_value&amp;#39;], optional=None, three=None)

$ python argparse_nargs.py --one-or-more with multiple values

Namespace(all=None, one_or_more=[&amp;#39;with&amp;#39;, &amp;#39;multiple&amp;#39;, &amp;#39;values&amp;#39;], optional=None, three=None)

$ python argparse_nargs.py --one-or-more

usage: argparse_nargs.py [-h] [--three THREE THREE THREE]
                     [--optional [OPTIONAL]] [--all [ALL [ALL ...]]]
                     [--one-or-more ONE_OR_MORE [ONE_OR_MORE ...]]
argparse_nargs.py: error: argument --one-or-more: expected at least one argument
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;参数类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;argparse将所有参数值都看作是字符串，除非你告诉它将字符串转换成另一种数据类型。&lt;strong&gt;add_argument()&lt;/strong&gt;的&lt;em&gt;type&lt;/em&gt;参数以一个转换函数作为值，被&lt;strong&gt;ArgumentParser&lt;/strong&gt;用来将参数值从一个字符串转换成另一种数据类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--file&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IOError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;任何需要单个字符串参数的可调用对象都可以传递给&lt;em&gt;type&lt;/em&gt;，包含内置类型如&lt;strong&gt;int()&lt;/strong&gt;, &lt;strong&gt;float()&lt;/strong&gt;, 以及&lt;strong&gt;file()&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_type.py -i 1

Namespace(f=None, file=None, i=1)

$ python argparse_type.py -f 3.14

Namespace(f=3.14, file=None, i=None)

$ python argparse_type.py --file argparse_type.py

Namespace(f=None, file=&amp;lt;open file &amp;#39;argparse_type.py&amp;#39;, mode &amp;#39;r&amp;#39; at 0x1004de270&amp;gt;, i=None)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果类型转换失败，argparse会引发一个异常。&lt;em&gt;TypeError&lt;/em&gt;和&lt;em&gt;ValueError&lt;/em&gt;会被自动捕获，并为用户转换为一个简单的错误消息。其他异常，如下面一个例子中输入文件不存在，则其&lt;em&gt;IOError&lt;/em&gt;必须由调用者来处理。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_type.py -i a

usage: argparse_type.py [-h] [-i I] [-f F] [--file FILE]
argparse_type.py: error: argument -i: invalid int value: &amp;#39;a&amp;#39;

$ python argparse_type.py -f 3.14.15

usage: argparse_type.py [-h] [-i I] [-f F] [--file FILE]
argparse_type.py: error: argument -f: invalid float value: &amp;#39;3.14.15&amp;#39;

$ python argparse_type.py --file does_not_exist.txt

usage: argparse_type.py [-h] [-i I] [-f F] [--file FILE]
argparse_type.py: error: [Errno 2] No such file or directory: &amp;#39;does_not_exist.txt&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要想将一个输入参数限制为一个预定义集中的某个值，则使用&lt;em&gt;choices&lt;/em&gt;参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--mode&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;read-only&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;read-write&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;code&gt;--mode&lt;/code&gt;的参数值不是所允许的值中的一个，就会产生一个错误并停止执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_choices.py -h

usage: argparse_choices.py [-h] [--mode {read-only,read-write}]

optional arguments:
-h, --help            show this help message and exit
--mode {read-only,read-write}

$ python argparse_choices.py --mode read-only

Namespace(mode=&amp;#39;read-only&amp;#39;)

$ python argparse_choices.py --mode invalid

usage: argparse_choices.py [-h] [--mode {read-only,read-write}]
argparse_choices.py: error: argument --mode: invalid choice: &amp;#39;invalid&amp;#39;
(choose from &amp;#39;read-only&amp;#39;, &amp;#39;read-write&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;文件参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然&lt;strong&gt;文件&lt;/strong&gt;对象可以单个字符串参数值来实例化，但并不允许你指定访问模式。&lt;strong&gt;FileType&lt;/strong&gt;让你能够更加灵活地指定某个参数应该是个文件，包括其访问模式和缓冲区大小。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;in-file&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FileType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;rt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;out-file&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FileType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Input file:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Output file:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IOError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上例中与参数名关联的值是一个打开文件句柄。在使用完该文件后应自己负责关闭该文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_FileType.py -h

usage: argparse_FileType.py [-h] [-i in-file] [-o out-file]

optional arguments:
-h, --help   show this help message and exit
-i in-file
-o out-file

$ python argparse_FileType.py -i argparse_FileType.py -o temporary_file.\
txt

Input file: &amp;lt;open file &amp;#39;argparse_FileType.py&amp;#39;, mode &amp;#39;rt&amp;#39; at 0x1004de270&amp;gt;
Output file: &amp;lt;open file &amp;#39;temporary_file.txt&amp;#39;, mode &amp;#39;wt&amp;#39; at 0x1004de300&amp;gt;

$ python argparse_FileType.py -i no_such_file.txt

usage: argparse_FileType.py [-h] [-i in-file] [-o out-file]
argparse_FileType.py: error: argument -i: can&amp;#39;t open &amp;#39;no_such_file.txt&amp;#39;: [Errno 2] No such file or directory: &amp;#39;no_such_file.txt&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;自定义动作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了前面描述的内置动作之外，你也可以提供一个实现了Action API的对象来自定义动作。作为&lt;em&gt;action&lt;/em&gt;传递给&lt;strong&gt;add_argument()&lt;/strong&gt;的对象应接受描述所定义形参的实参，并返回一个可调用对象，作为&lt;em&gt;parser&lt;/em&gt;的实参来处理形参，&lt;em&gt;namespace&lt;/em&gt;存放解析的结果、参数值，以及触发动作的&lt;em&gt;option_string&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;argparse提供了一个&lt;strong&gt;Action&lt;/strong&gt;类作为要定义的新动作的基类。构造方法是处理参数定义的，所以你只要在子类中覆盖&lt;strong&gt;&lt;strong&gt;call&lt;/strong&gt;()&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CustomAction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;option_strings&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;required&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;option_strings&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;option_strings&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;required&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;required&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Initializing CustomAction&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;locals&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;self&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;  &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; = &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__call__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;option_string&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Processing CustomAction for &amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;  parser = &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;  values = &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;  option_string = &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;option_string&lt;/span&gt;

        &lt;span class="c"&gt;# Do some arbitrary processing of the input values&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;values&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;values&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="c"&gt;# Save the results in the namespace using the destination&lt;/span&gt;
        &lt;span class="c"&gt;# variable given to our constructor.&lt;/span&gt;
        &lt;span class="nb"&gt;setattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;namespace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;CustomAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-m&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;CustomAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;positional&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;CustomAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-m&amp;#39;&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;multi-value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;positional-value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;values&lt;/em&gt;的类型取决于&lt;em&gt;nargs&lt;/em&gt;的值。如果该参数允许多个值，则&lt;em&gt;values&lt;/em&gt;会是一个列表，即使其仅包含一个列表项。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;option_string&lt;/em&gt;的值也取决于原有的参数规范。对于位置相关的、必需的参数，&lt;em&gt;option_string&lt;/em&gt;始终为&lt;strong&gt;None&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python argparse_custom_action.py

Initializing CustomAction
    dest = &amp;#39;a&amp;#39;
    option_strings = [&amp;#39;-a&amp;#39;]
    required = False

Initializing CustomAction
    dest = &amp;#39;m&amp;#39;
    nargs = &amp;#39;*&amp;#39;
    option_strings = [&amp;#39;-m&amp;#39;]
    required = False

Initializing CustomAction
    dest = &amp;#39;positional&amp;#39;
    option_strings = []
    required = True

Processing CustomAction for &amp;quot;a&amp;quot;
    parser = 4299616464
    values = &amp;#39;value&amp;#39;
    option_string = &amp;#39;-a&amp;#39;

Processing CustomAction for &amp;quot;m&amp;quot;
    parser = 4299616464
    values = [&amp;#39;multi-value&amp;#39;]
    option_string = &amp;#39;-m&amp;#39;

Processing CustomAction for &amp;quot;positional&amp;quot;
    parser = 4299616464
    values = &amp;#39;positional-value&amp;#39;
    option_string = None

Namespace(a=&amp;#39;VALUE&amp;#39;, m=[&amp;#39;MULTI-VALUE&amp;#39;], positional=&amp;#39;POSITIONAL-VALUE&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>读文笔记：What Powers Instagram</title><link href="http://youngsterxyf.github.io/2013/03/27/what-powers-instagram/" rel="alternate"></link><updated>2013-03-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-27:2013/03/27/what-powers-instagram/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances-dozens-of"&gt;What Powers Instagram: Hundreds of Instances, Dozens of Technologies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;该文从多个方面介绍Instagram整个系统栈(stack)的组成，罗列所使用的组件。我觉得重要的不是用了哪些组件和工具，而是在构建一个系统时，应注意哪些问题，从哪些层面对系统进行优化。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;构建系统的核心原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持简单&lt;/li&gt;
&lt;li&gt;不重复造轮子&lt;/li&gt;
&lt;li&gt;尽可能使用经实践验证可靠的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OS/虚拟主机&lt;/h3&gt;
&lt;p&gt;在Amazon EC2上运行Ubuntu Linux 11.04。之前的Ubuntu版本在高流量的情况会产生各种不可预料的冻结事件（freezing episodes）。&lt;/p&gt;
&lt;h3&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;对Instagram的每个请求都会经过负载均衡机器。以前使用两台&lt;strong&gt;Nginx&lt;/strong&gt;机器，并在两者之间使用DNS轮循（Round-Robin）。
这种方法的缺点是当有机器退出使用时DNS需要花些时间来更新。后来使用Amazon的Elastic负载均衡器，并在ELB层面终止SSL（注：不太懂这个），
从而降低nginx的CPU负载。&lt;/p&gt;
&lt;h3&gt;应用服务器&lt;/h3&gt;
&lt;p&gt;Django；多个应用服务器，由于无状态，所以容易横向扩展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;a href="http://gunicorn.org/"&gt;Gunicorn&lt;/a&gt;作为WSGI服务器。曾使用mod_wsgi和Apache，但Gunicorn更容易配置，CPU负载更小。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://fabric.readthedocs.org/en/1.3.3/index.html"&gt;Fabric&lt;/a&gt;来一次性在多个虚拟主机实例上运行命令（比如部署代码）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据存储&lt;/h3&gt;
&lt;p&gt;大多数数据（用户信息、图片元数据、标签等）都存在PostgreSQL中。将数据切分到多个主机实例上（分区集群shard cluster）。&lt;/p&gt;
&lt;p&gt;使用&lt;a href="http://hoytech.com/vmtouch/"&gt;vmtouch&lt;/a&gt;来诊断与控制文件系统缓存（即哪些数据在内存中）。&lt;/p&gt;
&lt;p&gt;所有PostgreSQL实例都使用流式复制以主-副本配置方式运行，并使用EBS快照频繁备份系统。&lt;/p&gt;
&lt;p&gt;使用&lt;a href="http://pgfoundry.org/projects/pgbouncer/"&gt;Pgbouncer&lt;/a&gt;作为PostgreSQL的连接池。&lt;/p&gt;
&lt;p&gt;图片直接存储在Amazon S3上。使用Amazon CloudFront作为CDN。&lt;/p&gt;
&lt;p&gt;广泛使用&lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;，驱动主要的数据源(main feed)、活动数据源(activity feed)、会话系统（&lt;a href="https://gist.github.com/mikeyk/910392"&gt;Instagram的Django会话后端&lt;/a&gt;）。也以主-副本设置运行Redis，副本机器不断地将数据库保存到磁盘，并使用EBS快照来备份这些DB转储数据。因为Redis支持写副本，所以在多台Redis机器之间进行在线故障转移（online failover）非常容易。&lt;/p&gt;
&lt;p&gt;使用Memcached做缓存，通过pylibmc和libmemcached连接memcached。&lt;/p&gt;
&lt;h3&gt;任务队列与推送通知&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;任务队列系统：&lt;a href="http://gearman.org/"&gt;Gearman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;推送通知：&lt;a href="https://github.com/samuraisam/pyapns"&gt;pyapns&lt;/a&gt;，性价比高&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;监控&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;a href="http://munin-monitoring.org/"&gt;Munin&lt;/a&gt;为整个系统的各种指标绘制图表，如果某些指标超出了常规范围会提醒管理员。基于&lt;a href="http://samuelks.com/python-munin/"&gt;Python-Munin&lt;/a&gt;编写Munin插件为非系统级的指标绘制图表。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://pingdom.com/"&gt;Pingdom&lt;/a&gt;对服务进行外部监控。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="http://pagerduty.com/"&gt;PagerDuty&lt;/a&gt;来处理通知和事件。&lt;/li&gt;
&lt;li&gt;使用&lt;a href="https://pypi.python.org/pypi/django-sentry"&gt;Sentry&lt;/a&gt;来记录Python错误报告，这样任何时候都可以登录系统（实时地）看到系统中正在发生什么错误。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="笔记"></category></entry><entry><title>学习JavaScript - 我的经验与建议（译）</title><link href="http://youngsterxyf.github.io/2013/03/25/learning-js/" rel="alternate"></link><updated>2013-03-25T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-25:2013/03/25/learning-js/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://sivers.org/learn-js"&gt;learning JavaScript - my experience and advice&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自从我曾&lt;a href="http://sivers.org/os"&gt;几&lt;/a&gt;&lt;a href="http://sivers.org/srs"&gt;次&lt;/a&gt;&lt;a href="http://sivers.org/prog"&gt;提到&lt;/a&gt;自己在刚过去的几个月中学习了JavaScript，很多人就发email给我询问我是如何学习JavaScript的以及推荐如何学习。以下就是我的经验和最佳建议。&lt;/p&gt;
&lt;p&gt;注：我是想真正地学习JavaScript---不是捷径，或快速技巧，或元工具（meta-tools）之类让我不必要学习JavaScript的东西。我想学习、掌握、阅读、理解以及记住JavaScript这门语言，从而在以后的日子里能够理解所有其他以JavaScript编写的很酷的东西。&lt;/p&gt;
&lt;p&gt;首先---很多人可能会告诉你去阅读&lt;a href="http://shop.oreilly.com/product/9780596517748.do"&gt;Douglas Crockford的著作《JavaScript语言精粹》&lt;/a&gt;。但当我开始阅读这本书时，才发现它是如此的紧凑简洁以致我根本不知道它在说啥！&lt;/p&gt;
&lt;p&gt;你知道何时一个专家是在谈论自己的领域，就不知道如何为其他人做点简化么？感觉这本书对于那些已有20年的C、Java或C++编程经验来说非常完美，他们只需要快速概览必知的JavaScript知识点。&lt;/p&gt;
&lt;p&gt;但它真的不是要教你学习JavaScript。它不会指导你学习任何东西。因此我建议先跳过这本书。&lt;/p&gt;
&lt;p&gt;相反，从&lt;a href="http://eloquentjavascript.net/"&gt;Marijn Haverbeke的著作《JavaScript编程精解》&lt;/a&gt;开始学习吧。&lt;/p&gt;
&lt;p&gt;这本书一开始非常简单易学，简直是太简单了，这能鼓舞你，让你自信起来。你就能得意洋洋地说“这很简单嘛！”&lt;/p&gt;
&lt;p&gt;&lt;a href="http://eloquentjavascript.net/contents.html"&gt;阅读这里的在线版本&lt;/a&gt;，因为你可以直接在浏览器中测试实验。&lt;/p&gt;
&lt;p&gt;然后，在读完几个章节后，&lt;strong&gt;转而阅读&lt;/strong&gt;&lt;a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-3rd-Edition.productCd-1118222199.html"&gt;《JavaScript高级程序设计》，第三版---Nicholas Zakas著&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这是一本终极教程，花很多篇幅详细解释大量知识点，覆盖几乎所有东西。每个章节你都应花费几个小时来阅读，等你读完这本书时，你知道的也就和大多数自称JavaScript程序员的人一样多了。&lt;/p&gt;
&lt;p&gt;有趣的是，读完这本书后，我又回过头来阅读&lt;a href="http://shop.oreilly.com/product/9780596517748.do"&gt;《JavaScript语言精粹》&lt;/a&gt;，现在我能理解书中讲述的东西了。但由于&lt;a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-3rd-Edition.productCd-1118222199.html"&gt;《JavaScript高级程序设计》&lt;/a&gt;一书的内容是如此全面，所以也就覆盖了所有的“精粹”了。&lt;/p&gt;
&lt;p&gt;当然，你必须记住你正在学习的东西，因此我强烈推荐你记下学习的每个新知识点，最好是记在一个抽认卡程序中，&lt;a href="http://sivers.org/srs"&gt;就像这样&lt;/a&gt;。因为要学习很多东西，所以你必须在几周或几个月后提醒自己学习过哪些东西。&lt;/p&gt;
&lt;p&gt;如果你想阅读更多书籍来在大脑中巩固JavaScript，那继续学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/9780596806149.do"&gt;《JavaScript Cookbook》 - Shelley Powers著&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://effectivejs.com/"&gt;《JavaScript高效编程》 - David Herman著&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.manning.com/resig/"&gt;《JavaScript忍者的秘密》 - John Resig和Bear Bibeault著&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些书都非常好。你会发现自己能更快地阅读这些书，因为你已比较熟悉JavaScript。阅读的同时最好写写书中的示例程序，把玩把玩。&lt;/p&gt;
&lt;h3&gt;阅读一些真实世界的JavaScript代码&lt;/h3&gt;
&lt;p&gt;在写了上千页短小示例代码片段后，你会想看看两个非常流行而强大的JavaScript项目的源代码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://underscorejs.org/docs/underscore.html"&gt;Underscore.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://backbonejs.org/docs/backbone.html"&gt;Backbone.js&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你会发现之前的一切都是有意义的，现在你能够顺畅地阅读和理解JavaScript代码。&lt;/p&gt;
&lt;h3&gt;然后是jQuery，以及更多...&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://jquery.com/"&gt;jQuery&lt;/a&gt;绝对是无处不在的，你要想完整地学习JavaScript就必须学习它。&lt;/p&gt;
&lt;p&gt;学习了纯JavaScript冗长的处理问题的方式，你会很喜欢jQuery提供的快捷方式。&lt;/p&gt;
&lt;p&gt;我真的很喜欢&lt;a href="http://www.headfirstlabs.com/books/hfjquery/"&gt;《深入浅出jQuery》&lt;/a&gt;一书，绝对是傻瓜式书籍。这本书非常精彩地引导你学习jQuery，边学边应用你学习过的东西。&lt;/p&gt;
&lt;p&gt;如果你仍然渴望学习更多关于JavaScript的东西，那么深入学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;a href="http://shop.oreilly.com/product/0636920024309.do"&gt;《CoffeeScript小书》 - Alex MacCaw著&lt;/a&gt;学习&lt;a href="http://coffeescript.org/"&gt;CoffeeScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://javascriptissexy.com/learn-backbone-js-completely/"&gt;沿着这条路线&lt;/a&gt;学习&lt;a href="http://backbonejs.org/"&gt;Backbone.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://javascriptissexy.com/learn-node-js-completely-and-with-confidence/"&gt;沿着这条路线&lt;/a&gt;学习&lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;然后放下书，去使用JavaScript吧！&lt;/h3&gt;
&lt;p&gt;你也许会想这还用说吗，但如果我不说，有些人又会抱怨了。因此，看看你现有的网站，去应用你学会的东西。或者从头开始做个新的站点，尽可能用JavaScript来实现，即使只是一个实验性作品。&lt;/p&gt;
&lt;h3&gt;其他建议？看你的了！&lt;/h3&gt;
&lt;p&gt;好了...上述就是我的一点经验，对于结果我相当满意。&lt;/p&gt;
&lt;p&gt;也请你在此分享其他的建议或经验吧。&lt;/p&gt;</summary><category term="JavaScript"></category><category term="翻译"></category></entry><entry><title>pip install lxml编译失败问题解决</title><link href="http://youngsterxyf.github.io/2013/03/17/pip-install-lxml-problem/" rel="alternate"></link><updated>2013-03-17T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-17:2013/03/17/pip-install-lxml-problem/</id><summary type="html">&lt;p&gt;以前在遇到这个问题时，都是偷懒使用&lt;code&gt;sudo apt-get install python-lxml&lt;/code&gt;（Debian系的Linux发行版）直接安装已打包好的deb包。但一方面这样安装的不是最新的库，另一方面我希望把所有的Python第三方库都限制在virtualenv中使用，所以希望使用&lt;code&gt;pip install lxml&lt;/code&gt;，那么这个问题就必须解决了。&lt;/p&gt;
&lt;p&gt;Google了一把，在&lt;a href="http://stackoverflow.com/questions/5178416/pip-install-lxml-error"&gt;这里&lt;/a&gt;找到了解答。&lt;/p&gt;
&lt;p&gt;其实在编译失败的log里，已经有提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make sure the development packages of libxml2 and libxslt are installed
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以正确编译需先安装libxml2和libxslt这两个包。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install libxml2
sudo apt-get install libxslt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，还需安装Python开发包python-dev：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install python-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;OK，再执行&lt;code&gt;pip install lxml&lt;/code&gt;就没问题啦。&lt;/p&gt;</summary><category term="Python"></category></entry><entry><title>读书笔记：JavaScript语言精粹</title><link href="http://youngsterxyf.github.io/2013/03/14/read-js-thegoodparts/" rel="alternate"></link><updated>2013-03-14T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-14:2013/03/14/read-js-thegoodparts/</id><summary type="html">&lt;h2&gt;第2章：语法&lt;/h2&gt;
&lt;p&gt;JavaScript提供两种注释形式，一种是用&lt;code&gt;/* */&lt;/code&gt;包围的注释块，另一种是以&lt;code&gt;//&lt;/code&gt;为开头的行注释。
建议避免使用&lt;code&gt;/* */&lt;/code&gt;，而用&lt;code&gt;//&lt;/code&gt;注释代替它。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;标识符由一个字母开头，其后可选择性地加上一个或多个字母、数字或下划线。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;JavaScript只有一个数字类型。它在内部被表示为64位的浮点数。与其他大多数编程语言不同的是，它没有分离出整数类型，所以1和1.0的值相同。&lt;/p&gt;
&lt;p&gt;如果一个数字字面量有指数部分，那么这个字面量的值等于e之前的数字与10的e之后数字的次方相乘。&lt;/p&gt;
&lt;p&gt;NaN是一个数值，它表示一个不能产生正常结果的运算结果。NaN不等于任何值，包括它自己。可以用函数isNaN(number)检测NaN.&lt;/p&gt;
&lt;p&gt;Infinity表示所有大于1.79769313486231570e+308的值。&lt;/p&gt;
&lt;p&gt;JavaScript有一个对象Math，它包含一套作用于数字的方法。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;字符串字面量可以被包在一对单引号或双引号中，它可能包含0个或多个字符。\（反斜杠）是转义字符。JavaScript中的所有字符都是16位的。&lt;/p&gt;
&lt;p&gt;JavaScript没有字符类型。要表示一个字符，只需创建仅包含一个字符的字符串即可。&lt;/p&gt;
&lt;p&gt;字符串是不可变的。一旦字符串被创建，就永远无法改变它。但可以通过+运算符连接其他字符串来创建一个新字符串。两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同（===）的字符串。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;一个编译单元包含一组可执行的语句。在Web浏览器中，每个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签提供一个被编译且立即执行的编译单元。因为缺少链接器，JavaScript把它们一起抛到一个公共的全局名字空间中。&lt;/p&gt;
&lt;p&gt;当var语句被用在函数内部时，它定义的是这个函数的私有变量。（最佳实践：定义任何变量都使用var）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for in&lt;/code&gt;语句会枚举一个对象的所有属性名（键名）。通常需要检测&lt;code&gt;object.hasOwnProperty(variable)&lt;/code&gt;来确定这个属性名是该对象的成员，还是来自于原型链。&lt;/p&gt;
&lt;h2&gt;第3章：对象&lt;/h2&gt;
&lt;p&gt;JavaScript的简单数据类型包括数字、字符串、布尔值（true和false）、null值和undefined值。其他所有的值都是对象。&lt;/p&gt;
&lt;p&gt;数字、字符串和布尔值“貌似”对象，因为它们拥有方法，但它们是不可变的。JavaScript中的对象是可变的键控集合（keyed collections）。&lt;/p&gt;
&lt;p&gt;对象是属性的容器，其中每个属性都拥有名字和值。属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除undefined值之外的任何值。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;要检索对象里包含的值，可以采用在&lt;code&gt;[]&lt;/code&gt;后缀中括住一个字符串表达式的方式。如果字符串表达式是一个字符串字面量，而且它是一个合法的JavaScript标识符且不是保留字，则也可以用&lt;code&gt;.&lt;/code&gt;表示法代替。优秀考虑使用&lt;code&gt;.&lt;/code&gt;表示法，因为它更紧凑且可读性更好。&lt;/p&gt;
&lt;p&gt;如果你尝试检索一个并不存在的成员属性的值，将返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;||&lt;/code&gt;运算符可以用来填充默认值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;flight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;status&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;unknow&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尝试从undefined的成员属性中取值将会导致TypeError异常。可以通过&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;运算符来避免错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;flight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;equipment&lt;/span&gt;        &lt;span class="c1"&gt;// undefined&lt;/span&gt;
&lt;span class="nx"&gt;flight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;equipment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;model&lt;/span&gt;      &lt;span class="c1"&gt;// throw &amp;quot;TypeError&amp;quot;&lt;/span&gt;
&lt;span class="nx"&gt;flight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;equipment&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;flight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;equipment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;model&lt;/span&gt;  &lt;span class="c1"&gt;// undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;对象通过引用来传递。它们永远不会被拷贝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;stooge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;nickname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Curly&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;nick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;stooge&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;nickname&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 因为x和stooge是指向同一个对象的引用，所以nick为&amp;#39;Curly&amp;#39;&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="c1"&gt;// a、b和c每个都引用一个不同的空对象&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="c1"&gt;// a、b和c都引用同一个空对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;每个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到&lt;code&gt;Object.prototype&lt;/code&gt;这个JavaScript中标准的对象。&lt;/p&gt;
&lt;p&gt;原型连接在更新时是不起作用的。当对某个对象做出改变时，不会触及该对象的原型。原型连接只有在检索值的时候才被用到。&lt;/p&gt;
&lt;p&gt;原型关系是一种动态的关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;使用&lt;code&gt;for in&lt;/code&gt;枚举一个对象中的所有属性名时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是完全避免使用&lt;code&gt;for in&lt;/code&gt;语句，而是创建一个数组，在其中以正确的顺序包含属性名。通过使用&lt;code&gt;for&lt;/code&gt;而不是&lt;code&gt;for in&lt;/code&gt;，可以得到我们想要的属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;delete运算符可以用来删除对象的属性。它将移除对象中确定包含的属性，但不会触及原型链中的任何对象。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最小化使用全局变量的一个方法是在你的应用中只创建唯一一个全局变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;MYAPP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该变量此时变成了你的应用的容器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;MYAPP&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;stooge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;first-name&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Joe&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;last-name&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Howard&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;MYAPP&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;flight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;airline&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Oceanic&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;number&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;815&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;departure&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;IATA&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SYD&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2004-09-22 14:55&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;city&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Sydney&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nx"&gt;arrival&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;IATA&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;LAX&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2004-09-23 10:42&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;city&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Los Angeles&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第4章：函数&lt;/h2&gt;
&lt;p&gt;除了声明时定义的形式参数，每个函数在调用之时会接收两个附加的参数：this和arguments。参数this的值取决于调用的模式。在JavaScript中一共有四种调用模式：方法调用模式、函数调用模式、构造器调用模式和apply调用模式。&lt;/p&gt;
&lt;p&gt;JavaScript中，当实参（arguments）的个数与形参（parameters）的个数不匹配时不会导致运行时错误。如果实参值过多时，超出的参数值将被忽略。如果实参值过少，缺失的值将会被替换为undefined。对参数值不会进行类型检查：任何类型的值都可以被传递给参数。&lt;/p&gt;
&lt;p&gt;arguments并不是一个真正的数组。它只是一个“类似数组(array-like)”的对象。arguments拥有一个length属性，但它缺少所有的数组方法。&lt;/p&gt;
&lt;p&gt;在函数调用模式中，this被绑定到全局对象。&lt;/p&gt;
&lt;p&gt;一个函数总是会返回一个值。如果没有指定返回值，则返回undefined。&lt;/p&gt;
&lt;p&gt;如果函数以在前面加上new前缀的方式来调用(即构造函数)，且返回值不是一个对象，则返回this（该新对象）。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;JavaScript提供的异常处理机制中，一个try语句只会有一个将捕获所有异常的catch代码块。如果你的处理手段取决于异常的类型，那么异常处理器必须检查异常对象的name属性以确定异常的类型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;对于变量声明，由于JavaScript缺少块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;可以通过闭包实现对象的私有属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;myObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;increment&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;inc&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;number&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nx"&gt;inc&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="nx"&gt;getValue&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}();&lt;/span&gt;        &lt;span class="c1"&gt;//注意这里调用了匿名函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;模块是一个提供接口却隐藏状态与实现的函数或对象。通过使用函数去产生模块，几乎可以完全摒弃全局变量的使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;method&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;deentityify&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 字符实体表。映射字符实体的名字到对应的字符。&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;entity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;quot&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;lt&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;gt&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="c1"&gt;// 返回deentityify方法&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 这才是deentityify方法。它调用字符串的replace的方法，&lt;/span&gt;
    &lt;span class="c1"&gt;// 查找‘&amp;amp;’开头和‘;’结束的子字符串。如果这些字符可以在字符实体表中找到，&lt;/span&gt;
    &lt;span class="c1"&gt;// 那么就将该字符实体替换为映射表中的值。&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sr"&gt;/&amp;amp;([^&amp;amp;;]+);/g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;entity&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;r&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;string&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nx"&gt;r&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}());&lt;/span&gt;   &lt;span class="c1"&gt;// 注意这里，匿名函数已被调用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;模块模式利用了函数作用域和闭包来创建绑定对象与私有成员的关联，在上述例子中，只有deentityify方法有权访问字符实体表这个数据对象。&lt;/p&gt;
&lt;p&gt;使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;有些方法没有返回值。例如，一些设置或修改对象的某个状态却不返回任何值的方法就是典型的例子。如果让这些方法返回this而不是undefined，就可以启用级联。在一个级联中，可以在单独一条的语句中依次调用同一个对象的很多方法。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;套用(curry)允许将函数与传递给它的参数相结合去产生一个新的函数。&lt;/p&gt;
&lt;p&gt;curry方法通过创建一个保存着原始函数和被套用的参数的闭包来工作。它返回另一个函数，该函数被调用时，会返回调用原始函数的结果，并传递调用curry时的参数加上当前调用函数的所有参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;Function&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;method&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nb"&gt;Function&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;curry&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 由于arguments并非真正的数组，所以需要应用slice方法来构造常规的数组&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;slice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="nx"&gt;that&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;that&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第5章：继承&lt;/h2&gt;
&lt;p&gt;当一个函数对象被创建时，Function构造器产生的函数对象会运行类似这样的一些代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;constructor&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;新函数对象被赋予一个prototype属性，其值包含一个constructor属性且属性值为该新函数对象。该prototype对象是存放继承特征的地方。因为JavaScript语言没有提供一种方法去确定哪个函数是打算用来作构造器的，所以每个函数都会得到一个prototype对象。constructor属性没什么用，重要的是prototype对象。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;函数化构造器实现私有保护&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;spec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;that&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;People: &amp;#39;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="nx"&gt;that&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prefix&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;spec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="nx"&gt;that&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;says&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prefix&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;spec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;saying&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;that&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第6章：数组&lt;/h2&gt;
&lt;p&gt;JavaScript中，每个数组都有一个length属性。如果你用大于或等于当前length的数字作为下标来存储一个元素，那么length值会被增大以容纳新元素，不会发生数组越界错误。&lt;/p&gt;
&lt;p&gt;length属性的值是这个数组的最大整数属性名加上1.它不一定等于数组里的属性的个数。&lt;/p&gt;
&lt;p&gt;你可以直接设置length的值。设置更大的length不会给数组分配更多的空间。而把length设小将导致所有下标大于等于新length的属性被删除。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;由于JavaScript的数组其实就是对象，所以delete运算符可以用来从数组中移除元素。不幸的是，这样会在数组中留下一个空洞。这是因为排在被删除元素之后的元素保留着它们最初的属性。JavaScript的数组有一个splice方法，可以删除一些元素并将它们替换为其他的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;numbers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;zero&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;one&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;two&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;shi&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;go&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// 现在numbers为[&amp;#39;zero&amp;#39;, &amp;#39;one&amp;#39;, undefined, &amp;#39;shi&amp;#39;, &amp;#39;go&amp;#39;]&lt;/span&gt;

&lt;span class="nx"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;splice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 现在numbers为[&amp;#39;zero&amp;#39;, &amp;#39;one&amp;#39;, &amp;#39;shi&amp;#39;, &amp;#39;go&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;在JavaScript编程中，一个常见的错误是在必须使用数组时使用了对象，或者在必须使用对象时使用了数组。其实规则很简单：当属性名是小而连续的整数时，应该使用数组。否则，使用对象。&lt;/p&gt;
&lt;p&gt;由于对数组使用&lt;code&gt;typeof&lt;/code&gt;的结果为&lt;code&gt;object&lt;/code&gt;，所以需要其他方法来判别一个变量是否为数组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;is_array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[object Array]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;第7章：正则表达式&lt;/h2&gt;
&lt;p&gt;一个&lt;em&gt;正则表达式分支&lt;/em&gt;包含一个或多个&lt;em&gt;正则表达式序列&lt;/em&gt;。这些序列被|（竖线）字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它尝试按顺序依次匹配这些序列项。所以：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s2"&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;match&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sr"&gt;/in|int/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会在into中匹配，但它不会匹配int，因为in已被成功匹配了。&lt;/p&gt;
&lt;p&gt;一个&lt;em&gt;正则表达式序列&lt;/em&gt;包含一个或多个&lt;em&gt;正则表达式因子&lt;/em&gt;。每个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数。如果没有指定这个量词，那么该因子只会被匹配一次。&lt;/p&gt;
&lt;p&gt;一个&lt;em&gt;正则表达式因子&lt;/em&gt;可以是一个字符、一个由圆括号包围的组、一个字符类，或者是一个转义序列。除了控制字符和特殊字符以外，所有的字符都会被按照字面处理：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\ / [ ] ( ) { } ? + * | . ^ $&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果希望上面列出的字符按字面去匹配，那么必须要用一个\前缀来进行转义。&lt;/p&gt;
&lt;p&gt;一个未被转义的&lt;code&gt;.&lt;/code&gt;会匹配除行结束符以外的任何字符。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;正则表达式分组共有4种：&lt;/p&gt;
&lt;p&gt;1.
捕获型：一个捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获型分组都被指定了一个数字。在正则表达式中第1个捕获&lt;code&gt;(&lt;/code&gt;的是分组1，第2个捕获&lt;code&gt;(&lt;/code&gt;的是分组2。&lt;/p&gt;
&lt;p&gt;2.
非捕获型：非捕获型分组有一个&lt;code&gt;(?:&lt;/code&gt;前缀。非捕获型分组仅做简单的匹配，并不会捕获所匹配的文本。这会带来微弱的性能优势。非捕获型分组不会干扰捕获型分组的编号。&lt;/p&gt;
&lt;p&gt;3.
向前正向匹配（Positive lookahead）：向前正向匹配分组有一个&lt;code&gt;(?=&lt;/code&gt;前缀。它类似于非捕获型分组，但在这个组匹配后，文本会倒回到它开始的地方，实际上并不匹配任何东西。这不是一个好的特性。（什么意思？）&lt;/p&gt;
&lt;p&gt;4.
向前负向匹配（Negative lookahead）：向前负向匹配分组有一个&lt;code&gt;(?!&lt;/code&gt;前缀。类似于向前正向匹配分组，但只有当它匹配失败时它才继续向前进行匹配。这不是一个好的特性。&lt;/p&gt;
&lt;h2&gt;第8章：方法&lt;/h2&gt;
&lt;h3&gt;Array&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;array.concat(item...)&lt;/strong&gt;方法会产生一个新数组，它包含一份array的浅复制（shallow copy）并把一个或多个参数item附加在其后。如果参数item是一个数组，那么它的每个元素会被分别添加。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// c为[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;, &amp;#39;z&amp;#39;, true]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;array.join(separator)&lt;/strong&gt;方法把一个array构造成一个字符串。目前在大多数情况下，对字符串连接建议首选使用+运算符，因为相比join方法，+运算符的性能更高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.pop()&lt;/strong&gt;，其可以这样实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;pop&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;splice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;array.push(item...)&lt;/strong&gt;与concat方法不同的是，该方法会修改array。可以这样实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;push&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;splice&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;
            &lt;span class="nx"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;array.reverse()&lt;/strong&gt;方法反转array里的元素的顺序，并返回array本身：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;// a和b都是[&amp;#39;c&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;array.shift()&lt;/strong&gt;方法移除数组array中的第1个元素并返回该元素。如果数组array为空，则会返回undefined。shift操作通常要比pop慢得多，可以这样实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;shift&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;splice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;array.slice(start, end)&lt;/strong&gt;方法对array中的一段做浅复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.sort(comparefn)&lt;/strong&gt;方法对array中的内容进行排序。默认比较函数把要排序的元素都视为字符串。可以使用自己的比较函数来替换默认的比较函数。你的比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数，如果第2个参数应该排列在前面，则返回一个正数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.splice(start, deleteCount, item...)&lt;/strong&gt;方法从array中移除一个或多个元素，并用新的item替换它们。其返回一个包含被移除元素的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;array.unshift(item...)&lt;/strong&gt;方法像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分而不是尾部，返回array的新的length。&lt;/p&gt;
&lt;h3&gt;Function&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;function.apply(thisArg, argArray)&lt;/strong&gt;方法调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。&lt;/p&gt;
&lt;h3&gt;Number&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;number.toFixed(fractionDigits)&lt;/strong&gt;方法把number转换成一个十进制数形式的字符串。可选参数fractionDigits控制其小数点后的数字位数，必须在0～20之间，默认为0。&lt;strong&gt;number.toPrecision(precision)&lt;/strong&gt;方法的功能与其几乎相同，除了precision的值为0~21之间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;number.toString(radix)&lt;/strong&gt;方法把number转换成为一个字符串。可选参数radix控制基数，默认为10。&lt;/p&gt;
&lt;h3&gt;String&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;string.charAt(pos)&lt;/strong&gt;方法返回在string中pos位置处的字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.charCodeAt(pos)&lt;/strong&gt;方法同charAt一样，只不过返回的不是一个字符串，而是以整数形式表死的在string中pos位置处的字符的字符码位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.indexOf(searchString, position)&lt;/strong&gt;方法在string内查找另一个字符串searchString。如果找到，返回第一个匹配字符的位置，否则返回-1。可选参数position可设置从string的某个指定位置开始超找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.lastIndexOf(searchString, position)&lt;/strong&gt;方法和indexOf方法类似，只不过它是从该字符串的末尾开始查找而不是从开头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string.search(regexp)&lt;/strong&gt;方法和indexOf方法类似，只是它接受一个正则表达式对象作为参数而不是一个字符串。&lt;/p&gt;
&lt;h2&gt;第9章：代码风格&lt;/h2&gt;
&lt;p&gt;优秀的程序拥有一个前瞻性的结构，它会预见到未来所需要的可能修改，但不会让其成为过度的负担。优秀的程序也有一种清晰的表达方式。如果一个程序被表达得很好，那么我们就能更加容易地去理解它，以便成功地修改或修复它。&lt;/p&gt;
&lt;p&gt;通过在一个清晰且始终如一的风格下编写，你的程序会变得易于阅读。&lt;/p&gt;
&lt;h2&gt;附录A：糟粕&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有三种方式定义全局变量。第一种是脱离任何函数安排一个var语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种是直接添加一个属性到全局对象上。全局对象是所有全局变量的容器。在Web浏览器里，全局对象名为window：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第三种是直接使用未经声明的变量。这被称为隐式的全局变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这本来是为了方便初学者而有意让变量在使用前无须声明。JavaScript的策略是让那些忘记预先声明的变量成为全局变量，这导致查找bug非常困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于JavaScript没有块级作用域，所以最好是在每个函数的开头部分声明所有变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动插入分号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript有一个机制，它试图通过自动插入分号来修正有缺损的程序。千万不要依靠它，它可能会掩盖更为严重的错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parseInt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;parseInt是一个将字符串转换为整数的函数。它在遇到非数字时停止解析。如果该字符串的第一个字符是0,那么该字符串将被基于八进制而不是十进制来求值。幸运的是，parseInt可以接受一个基数作为参数。我建议你总是提供这个基数参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;+运算符可以用于加法运算或字符串连接。但究竟会如何执行取决于其参数的类型。如果其中一个运算数是一个空字符串，它会把另一个运算数转换成字符串并返回。如果两个运算数都是数字，则返回两者之和。否则，它把两个运算数都转换为字符串并连接起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript的对象永远不会有真的空对象，因为它们可以从原型链中取得成员元素。&lt;/p&gt;
&lt;h2&gt;附录B：鸡肋&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;==&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建议永远不要使用&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;。相反，请始终使用&lt;code&gt;===&lt;/code&gt;和&lt;code&gt;!==&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;with语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;function语句对比函数表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript既有function语句（&lt;em&gt;函数声明&lt;/em&gt;），同时也有函数表达式（匿名函数？包含赋值过程么？）。令人困惑的是两者看起来好像就是相同的。&lt;/p&gt;
&lt;p&gt;（&lt;em&gt;区分：函数声明所有代码被执行之前运行。函数表达式仅当解释器到达代码时候才运行。&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;function语句在解析时会发生被提升的情况。这意味着不管function语句被防治在哪里，它都会被移动到被定义时所在作用域的顶层。这放宽了函数必须先声明后使用的要求，而我认为这会导致混乱。在if语句中使用function语句也是被禁止的。结果表明大多数的浏览器都允许在if语句里使用function语句，但它们在解析时的处理上各不相同，从而造成了可移植性的问题。&lt;/p&gt;
&lt;p&gt;一个语句不能以一个函数表达式开头，因为官方的语法假定以单词function开头的语句是一个function语句（&lt;em&gt;这里说得我有点糊涂了啊！&lt;/em&gt;）。解决方法就是把函数表达式括在一个圆括号之中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;hidden_variable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// 这个函数可能对环境有一些影响，但不会引入新的全局变量。&lt;/span&gt;
&lt;span class="p"&gt;})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在很多语言中，void是一种类型，表示没有值。而在JavaScript中，void是一个运算符，接受一个运算数并返回undefined。这没什么用。&lt;/p&gt;
&lt;h2&gt;附录C：JSLint&lt;/h2&gt;
&lt;p&gt;（&lt;em&gt;待阅读&lt;/em&gt;）&lt;/p&gt;
&lt;h2&gt;附录E：JSON&lt;/h2&gt;
&lt;p&gt;JSON有6种类型的值：对象、数组、字符串、数字、布尔值（true和false）和特殊值null。空白（空格符、制表符、回车符和换行符）可被插到任何值的前后，从而使得JSON文本更容易被人阅读。为了减少传输和存储的成本，空白可以被省略。&lt;/p&gt;
&lt;p&gt;JSON对象是一个容纳“名/值”对的无序集合。&lt;/p&gt;
&lt;p&gt;JSON数组是一个值的有序序列。其值可以是任何类型的JSON值，包括数组和对象。&lt;/p&gt;
&lt;p&gt;JSON字符串要被包围在一对双引号之间。\字符被用于转义。&lt;/p&gt;
&lt;p&gt;JSON数字与JavaScript的数字相似。整数的首位不允许为0,因为一些语言用它来标示八进制。这种基数的混乱在数据交换格式中是不可取的。数字可以是整数、实数或科学计数。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;JSON特别易于用在Web应用中，因为JSON就是JavaScript。使用eval函数可以把一段JSON文本转化成一个有用的数据结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;myData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;myJSONText&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在JavaScript的语法中，表达式语句（Expression Statement）不允许以左花括号“{”开始，因为那会与块语句（Block Statements）产生混淆，所以在使用eval()解析JSON文本时，为了解决此问题，可以将JSON文本套上一对圆括号。圆括号早此处作为表达式的分组运算符，能对包围在其中的表达式进行求值。&lt;/p&gt;
&lt;p&gt;但使用eval来解析JSON文本可能会存在安全问题，所以应该使用JSON.parse方法来替代eval。如果文本中包含任何危险数据，JSON.parse将会抛出一个异常。&lt;/p&gt;</summary><category term="笔记"></category><category term="JavaScript"></category></entry><entry><title>JavaScript初学者应知的24条最佳实践（译）</title><link href="http://youngsterxyf.github.io/2013/03/11/js-best-practices-for-beginners/" rel="alternate"></link><updated>2013-03-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-11:2013/03/11/js-best-practices-for-beginners/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://net.tutsplus.com/tutorials/javascript-ajax/24-javascript-best-practices-for-beginners/"&gt;24 JavaScript Best Practices for Beginners&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（注：阅读原文的时候没有注意发布日期，觉得不错就翻译了，翻译到JSON.parse那一节觉得有点不对路才发现是2009年发布的文章，不过还是不错的啦。另外，文章虽说24条最佳实践，其实只有23条，不知道原作者怎么漏了一条。）&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1.优先使用===，而不是==&lt;/h3&gt;
&lt;p&gt;JavaScript使用两种相等性操作符：===|!==和==|!=。通常认为做比较的最佳实践是使用前一组操作符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"若两个操作数的类型和值相同，那么===比较的结果为真，!==比较的结果为假。" --- JavaScript语言精粹(JavaScript: The Good Parts)
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，如果使用==和!=，当比较不同类型的操作数时，你就会碰到问题啦。在这种情况下，这组操作符会尝试对操作数的值做无用的强制转换。&lt;/p&gt;
&lt;h3&gt;2.Eval就是糟糕的代名词&lt;/h3&gt;
&lt;p&gt;对于那些不熟悉JavaScript的人来说，函数"evel"让我们能够访问JavaScript编译器。我们可以通过给"eval"传递一个字符串参数来得到该字符串执行的结果。&lt;/p&gt;
&lt;p&gt;这不仅会极大地降低你的脚本的性能，也会造成一个巨大的安全隐患，因为这赋予传递进来的纯文本太多的能力。要尽可能地避免eval函数的使用。&lt;/p&gt;
&lt;h3&gt;3.不要懒手&lt;/h3&gt;
&lt;p&gt;技术上来说，你确实可能侥幸地省略多数花括号和分号。大多数浏览器都能够正确地解释如下代码片段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;someVariableExists&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，再考虑一下这段代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;someVariableExists&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
    &lt;span class="nx"&gt;anotherFunctionCall&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可能会有人认为上一段代码等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;someVariableExists&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;anotherFunctionCall&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很不幸，他错了。事实上，它的本意是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;someVariableExists&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;anotherFunctionCall&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你应该也注意到了，代码中缩进模仿了花括号的功能。毋庸置疑，这是非常恐怖的做法，无论如何都应该避免。唯一可以省略花括号的时候是在一行式的语句中，但即使这种情况，也是很有争议的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;nicely done&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;始终要想着以后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果以后的某个时候，你需要在这种if语句中增加更多的命令，那该怎么办呢？没法子，你就只能重写这块代码了。处理这个问题的底线是对于省略写法保持谨慎。&lt;/p&gt;
&lt;h3&gt;4.使用JS Lint&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.jslint.com/"&gt;JSLint&lt;/a&gt;是Douglas Crockford编写的一个调试器。简单地将你的脚本拷贝进去，它就会快速地扫描你的代码中任何明显的问题和错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"JSLint获取一份JavaScript源码，然后扫描代码。如果发现问题，就会返回一条信息描述这个问题以及这个问题在源码中的大致位置。问题虽然经常是语法错误，却不一定是。JSLint也会查看一些风格习惯以及结构问题。它并不证明你的代码是否正确，只是提供另外的一双眼睛来帮助发现问题。"---JSLint文档
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在结束脚本代码的编写之前，对其执行一次JSLint，能够保证你不会犯一些愚蠢的错误。&lt;/p&gt;
&lt;h3&gt;5.将脚本置于页面的底部&lt;/h3&gt;
&lt;p&gt;这条技巧在本系列前面的文章中也推荐过。因为它在此处也非常合适（As it's highly appropriate though），所有我将那段信息直接粘贴在这里。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/javascriptButton.png" alt="javascriptButton.png"&gt;&lt;/p&gt;
&lt;p&gt;记住---这条最佳实践的主要目标是尽可能快速地为用户加载页面。当加载一个脚本时，浏览器直到整个脚本文件全部加载完毕才能继续。因此，用户必须等上更长的时间才能注意到任何的进度。&lt;/p&gt;
&lt;p&gt;如果JS文件的目的仅仅是增加功能---例如，在点击某个按钮后---那么就将那些文件放在底部，body结束标签之前吧。这绝对是一个最佳实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;And now you know my favorite kinds of corn. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script &lt;/span&gt;&lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;path/to/file.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script &lt;/span&gt;&lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;path/to/anotherFile.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;6.在For语句之外声明变量&lt;/h3&gt;
&lt;p&gt;当执行一个冗长的"for"语句之时，仅仅让解释引擎做必须干的活吧。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;糟糕的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;someArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;container&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;innerHtml&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my number: &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意上面代码片段中的每次迭代都需要检查数组的长度，并且每次都要遍历DOM树找到"container"元素---效率多低啊！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;container&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;someArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;innerHtml&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my number: &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;感谢有位朋友留下评论展示如何进一步优化上面的代码块。&lt;/p&gt;
&lt;h3&gt;7.构建字符串的最快方式&lt;/h3&gt;
&lt;p&gt;当需要遍历一个数组或者对象之时，不要总是使用你能信手粘来的"for"语句。创造性地找个能够完成工作的最快速的方案。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;item 1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;item 2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;item 3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...];&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;"我不会以测试基准来烦你；你只须相信我（或者自己去测试一下）---这是目前为止最快的方式！"&lt;/p&gt;
&lt;p&gt;使用原生方法（比如join()），不用管抽象层面背后发生了什么，通常会比任何非原生方法快得多。 --- James Padolsey, james.padolsey.com"
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;8.减少全局变量&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;"通过将全局的东西封装进单个命名空间，能够大大降低与其他应用、部件、代码库交互混乱的概率。"--- Douglas Crockford
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;jeffrey&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;lastname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// Jeffrey -- or window.name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;更好的做法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;DudeNameSpace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Jeffrey&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;lastname&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;doSometing&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;DudeNameSpace&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// Jeffrey&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意我们是怎样将全局性的“足迹”减少为一个命名可笑的"DudeNameSpace"对象的。&lt;/p&gt;
&lt;h3&gt;9.注释你的代码&lt;/h3&gt;
&lt;p&gt;一开始看起来似乎没有必要，但请相信我，你将会想尽可能好地注释你的代码。当你几个月后再次回到项目，会发生什么呢？发现你根本没法轻松地记起当初对每一行代码的想法。或者，如果你的某个同事需要修改你的代码，那又会怎么样呢？始终，一直记着注释你代码的重要部分吧。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Cycle through array and echo out each name&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;10.拥抱渐进增强&lt;/h3&gt;
&lt;p&gt;始终考虑到如何处理JavaScript禁用的情况。也许你会想“大多数我网页的阅读器都是启用JavaScript的，因此我不担心这个问题。”然而，这会是一个巨大的错误。&lt;/p&gt;
&lt;p&gt;你曾花时间去看过关闭JavaScript后你的漂亮的滑动条是什么样么？（&lt;a href="https://addons.mozilla.org/en-US/firefox/addon/web-developer/"&gt;下载&lt;/a&gt;Web开发者工具栏以方便干这事。）也许它会完全破坏你的站点。按照以往经验，设计你的站点时应假设将会禁用JavaScript。那么，一旦你这样做了，那么开始渐进地增强你的网页布局吧！&lt;/p&gt;
&lt;h3&gt;11.不要传递字符串给"SetInterval"或"SetTimeOut"&lt;/h3&gt;
&lt;p&gt;考虑一下如下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;setInterval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;document.getElementById(&amp;#39;container&amp;#39;).innerHTML += &amp;#39;my new number: &amp;#39; + i&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3000&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段代码不仅低效，而且其行为与"eval"函数相同。永远不要传给字符串给SetInterval和SetTimeOut。相反，应传递一个函数名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;setInterval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;someFunction&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;12.不要使用"With"语句&lt;/h3&gt;
&lt;p&gt;乍一看，"With"语句似乎是个聪明的想法。基本概念是它们能够为访问深度嵌套对象提供一种简写方式。例如...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;with&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;being&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;person&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;man&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;bodyparts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;arms&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;legs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;取代如下写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;being&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;person&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;man&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;bodyparts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;arms&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;being&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;person&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;man&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;bodyparts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;legs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很不幸，经过一些测试，会发现这种简写在设置新成员时表现非常糟糕。作为替代，你应该使用var。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;being&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;person&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;man&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;bodyparts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;arms&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;legs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;13.使用{}而不是New Object()&lt;/h3&gt;
&lt;p&gt;JavaScript中有多种创建对象的方式。也许更传统的方式是使用"new"构造器，像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Jeffrey&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;lastname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;someFuncion&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，这种方式因其行为并不是我们所想的那样而被认为是“糟糕的实践。相反，我推荐你使用更健壮的对象字面方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Jeffrey&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;lastName&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Way&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;someFunction&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意如果你只是想简单地创建个空对象，{}就派上用场了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;"对象字面量使我们能够编写支持很多特性的代码，并对代码的实现者来说代码仍然相对直观。不需要直接调用构造器或维护传递给函数的参数的正确顺序，等等。" --- dyn-web.com
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;14.使用[]而不是New Array()&lt;/h3&gt;
&lt;p&gt;这同样适用于创建一个新数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过得去的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Joe&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Plumber&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Joe&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Plumber&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;"JavaScript中一个常见的错误是需要数组时使用对象或需要对象时使用数组。规则很简单：当属性名是小的连续整数时，你应该使用数组。否则，使用对象"---Douglas Crockford
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;15.一长串变量？省略"var"关键字，使用逗号替代&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;someItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;anotherItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;another string&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;oneMoreItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;one more string&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;someItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;anotherItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;another string&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;oneMoreItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;one more string&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;相当的不言自明。我不知道这里是否有任何真正的速度提升，但是它使你的代码更加简洁了。&lt;/p&gt;
&lt;h3&gt;16.始终，始终使用分号&lt;/h3&gt;
&lt;p&gt;技术上来说，大多数浏览器都允许你的省略一些分号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;someItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;something&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;话虽如此，但这是一种非常糟糕的做法，可能导致更大的问题，问题查找起来也更困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更好的写法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;someItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;something&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;18."For in"语句&lt;/h3&gt;
&lt;p&gt;遍历对象内的成员时，你也会得到方法函数。为了解决这个问题，应始终将你的代码包装在一个if语句中来过滤信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hasOwnProperty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nx"&gt;then&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="nx"&gt;something&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;引自&lt;em&gt;JavaScript: 语言精粹， Douglas Crockford著&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;19.使用Firebug的"Timer"特性来优化代码&lt;/h3&gt;
&lt;p&gt;需要一种快速简单的方法来检测一个操作花费多长时间么？使用Firebug的"timer"特性记录结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;TimeTracker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;MyTimer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;
    &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;timeEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;MyTimer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;20.阅读，阅读，再阅读&lt;/h3&gt;
&lt;p&gt;我是一个Web开发博客的超级粉丝（比如这个博客！），但吃午餐或者睡前，博客确实不是书籍的替代品。始终在你的床前桌上放一本wen开发书籍吧。如下是一些我最喜欢的JavaScript书籍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.packtpub.com/object-oriented-javascript-applications-libraries/book"&gt;面向对象的JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://oreilly.com/catalog/9780596517748/"&gt;JavaScript：语言精粹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.packtpub.com/learning-jquery-1.3/book"&gt;学习jQuery 1.3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://oreilly.com/catalog/9780596527464/"&gt;学习JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多阅读几遍。我仍旧在读！&lt;/p&gt;
&lt;h3&gt;21.自执行函数(Self-Executing Functions)&lt;/h3&gt;
&lt;p&gt;相比调用函数，当页面加载或调用父函数时，让函数自动执行会简单些。简单地将你的函数包装在圆括号内，并添加额外的一对圆括号，其本质上就调用了这个函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;jeff&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;lastName&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;way&amp;#39;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
 &lt;span class="p"&gt;})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;22.原始(raw)JavaScript代码的执行速度始终快于使用代码库&lt;/h3&gt;
&lt;p&gt;JavaScript代码库，如jQuery和Mootools，能够为你节省大量的编码时间---特别是使用AJAX操作。话虽如此，始终谨记代码库的执行速度始终是比不上原始JavaScript代码的（假设了代码的正确性）。&lt;/p&gt;
&lt;p&gt;jQuery的"each"方法用来做遍历非常赞，但使用原生"for"语句始终会快一些。&lt;/p&gt;
&lt;h3&gt;23.Crockford的JSON.Parse&lt;/h3&gt;
&lt;p&gt;虽然JavaScript 2应该有一个内置的JSON解析器，但写本文之时，我们仍旧需要自己实现。Douglas Crockford，JSON的创造者，已经实现了一个解析器供你使用。可以从&lt;a href="https://github.com/douglascrockford/JSON-js"&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;简单地导入该脚本，你就能获得一个新的JSON全局对象，用于解析你的.json文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;JSON&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;xhr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;responseText&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;container&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;innerHTML&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;li&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; : &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nx"&gt;email&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;/li&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;24.删除"Language"&lt;/h3&gt;
&lt;p&gt;几年前，在script标签内常见有"language"属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;script &lt;/span&gt;&lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;language=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;javascript&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，这个属性很早就被弃用了，所以就不要再使用了。&lt;/p&gt;
&lt;h3&gt;就这些了，同志们&lt;/h3&gt;
&lt;p&gt;现在你知道这JavaScript初学者应该知道的24条基本技巧。有机会也让我知道一下你的小贴士吧。感谢阅读。&lt;/p&gt;</summary><category term="JavaScript"></category><category term="翻译"></category></entry><entry><title>电脑重装记</title><link href="http://youngsterxyf.github.io/2013/03/09/reinstall-my-computer/" rel="alternate"></link><updated>2013-03-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-09:2013/03/09/reinstall-my-computer/</id><summary type="html">&lt;p&gt;一台电脑使用时间长了，速度就会越来越慢，也会越来越“脏”，因为经过时间的积累，电脑里多了很多的软件、文件等，这些文件和软件中很多以后是不需要的，在当时因为各种原因而下载或安装了，那么我们就会经常去清理，但对于有点洁癖的人来说，这是不够的，所以会过段时间后就会选择重装电脑，一切重新开始。当然一般都是等到无法忍受的时候，不得已而为之，为什么呢？因为电脑重装后，要想重新打造成一个令自己满意的使用环境需要花一些时间和精力，所以破旧立新也是需要勇气的。&lt;/p&gt;
&lt;p&gt;我笔记本的操作系统是Ubuntu+KDE，从安装使用到现在将近一年了，期间经过7个月的实习，所以将笔记本打造成一个开发环境和测试服务器，Nginx+PHP+Mysql+Memcached啥的都安装全了，还有其他的一些软件都不知道安装了些什么。另外，由于做兴趣项目，我主要选择Python进行开发，对于Python第三方库主要有两种安装方式：一种是使用操作系统本身的软件包管理工具，Ubuntu下即为apt-get；另一种是使用Python的包管理工具，如easy_install，pip。通过这两种方式我的系统里安装了很多大大小小的Python第三方库，也懒得去整理了，所以干脆重装，原来实习时使用的那一套开发环境和测试服务器之后也不一定用得到，并且决定之后所有的Python第三方库全部在virtualenv下安装，保持系统干净。&lt;/p&gt;
&lt;p&gt;那么仍旧装Ubuntu呢还是装其它的Linux发行版呢？如ArchLinux、Gentoo Linux。我想这应该看需求，如果你是想折腾系统或不断尝试最新的软件包的话，那当然首选Gentoo，或Archlinux。但因为我只是希望有个稳定的开发环境和使用环境，不想太多折腾，所以决定还是选择Kubuntu。&lt;/p&gt;
&lt;p&gt;重装电脑也是个繁琐的过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先需要制作安装盘，由于刻录CD/DVD啥的太麻烦，所以我一般使用&lt;a href="http://unetbootin.sourceforge.net/"&gt;UNetbootin&lt;/a&gt;制作U盘安装盘，方便得多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后就是保存各种数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器书签、扩展程序---可使用浏览器的同步功能；&lt;/li&gt;
&lt;li&gt;记录原来系统中安装的软件列表---对于Debian系的Linux，可以使用命令&lt;code&gt;dpkg --get-selections | awk '{print $1}' &amp;gt; software_list.txt&lt;/code&gt;来得到；&lt;/li&gt;
&lt;li&gt;除了使用系统软件包管理工具安装的软件，可能你还手动编译过软件或下载使用免安装的软件，如果以后会用到的话也可以一并保存；&lt;/li&gt;
&lt;li&gt;各种软件的配置文件，比如.vimrc，.bashrc，Nginx配置文件等，我是将这些配置文件像代码一样使用版本控制存放在Github上的；&lt;/li&gt;
&lt;li&gt;系统环境的各种字体配置，比如vim我使用YaHei Manaco字体，命令行终端使用Source Code Pro字体，其它的主要使用Lucida Sans Unicode字体、WenQuanYi Micro Hei、WenQuanYi Zen Hei和YaHei Consolas Hybrid字体；&lt;/li&gt;
&lt;li&gt;最后最重要的就是各种文档音频视频数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;备份好各种数据后，就可以重装了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但最耗时间的是怎么把一个刚重装好的系统重新打造成一个自己满意的使用环境，因为如果当初安装某些软件时候没做笔记而又忘了怎么折腾的话，你就又得重新查资料寻找安装方法了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述文字记录了我重装电脑之前的一些想法，以及给自己提个醒---不要忘记备份各种数据。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;安装完成后，遇到如下几个问题：&lt;/p&gt;
&lt;p&gt;1.
中文显示不太正常，使用命令&lt;code&gt;apt-cache search wenquanyi&lt;/code&gt;，找出所有文泉驿开源字体，安装即可。&lt;/p&gt;
&lt;p&gt;2.
&lt;code&gt;pip install gevent&lt;/code&gt;安装gevent，没法正常编译，只好使用&lt;code&gt;sudo apt-get install python-gevent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（&lt;em&gt;2013-03-17补&lt;/em&gt;：先&lt;code&gt;sudo apt-get install libevent-dev&lt;/code&gt;安装libevent-dev就可以正常编译了）&lt;/p&gt;
&lt;p&gt;3.
&lt;a href="https://github.com/milkbikis/powerline-shell"&gt;powerline-shell&lt;/a&gt;中的特殊字体在终端中没法正常显示，按照文档说明使用工具&lt;a href="https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher"&gt;fontpatcher&lt;/a&gt;来生成适用于powerline-shell的字体。可fontpatcher依赖于fontforge，&lt;code&gt;pip install fontforge&lt;/code&gt;却说找不到fontforge，好吧，还是&lt;code&gt;sudo apt-get install python-fontforge&lt;/code&gt;安装。然后按照普通字体的安装方式安装即可。&lt;/p&gt;
&lt;p&gt;4.
KDE的Nepomuk Semantic Desktop功能耗资源比较厉害，在System Settings -&amp;gt; Desktop Search关闭这项功能。&lt;/p&gt;
&lt;p&gt;5.
添加fcitx输入法开机自启动：&lt;code&gt;cd ~/.kde/Autostart; ln -s /usr/bin/fcitx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后附上一张重装后的桌面截图：&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/print-scr.png" alt="print-scr.png"&gt;&lt;/p&gt;</summary><category term="笔记"></category></entry><entry><title>PHP之道---PHP基础知识（译）</title><link href="http://youngsterxyf.github.io/2013/03/08/php-basics/" rel="alternate"></link><updated>2013-03-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-03-08:2013/03/08/php-basics/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://wulijun.github.com/php-the-right-way/pages/The-Basics.html"&gt;PHP: The Right Way - The Basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="http://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;比较操作符&lt;/h2&gt;
&lt;p&gt;比较操作符往往是PHP的一个被忽视的方面，这会导致很多意想不到的结果。其中的一个问题源于严格比较（布尔值为整数的比较）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 5为一个整数&lt;/span&gt;

&lt;span class="nb"&gt;var_dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 比较值；返回true&lt;/span&gt;
&lt;span class="nb"&gt;var_dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// 比较值（忽略类型）；返回true&lt;/span&gt;
&lt;span class="nb"&gt;var_dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// 比较类型/值（整数 vs. 整数）；返回true&lt;/span&gt;
&lt;span class="nb"&gt;var_dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// 比较类型/值（整数 vs. 整数）；返回false&lt;/span&gt;

&lt;span class="sd"&gt;/**&lt;/span&gt;
&lt;span class="sd"&gt;  * 严格比较&lt;/span&gt;
&lt;span class="sd"&gt;  */&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;strpos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;testing&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// 在位置0找到&amp;#39;test&amp;#39;，0被解释为布尔值&amp;#39;false&amp;#39;&lt;/span&gt;
    &lt;span class="c1"&gt;// code...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;strpos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;testing&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!==&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// true，因为做了严格比较（0 !== false）&lt;/span&gt;
    &lt;span class="c1"&gt;// code...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;比较操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/types.comparisons.php"&gt;比较列表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;条件语句&lt;/h2&gt;
&lt;h3&gt;If语句&lt;/h3&gt;
&lt;p&gt;在函数或类中使用'if/else'之时，有个常见的误解---'else'必须一起使用以声明潜在的结果。然而，如果，结果是定义返回值，则'else'是不需要的，因为'return'会结束函数，使得'else'变得毫无意义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// 不需要else分支&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/control-structures.if.php"&gt;If语句&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Switch语句&lt;/h3&gt;
&lt;p&gt;Switch语句是一种避免输入无穷尽的if和elseif的绝妙方式，但需要注意几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Switch语句仅比较值，并不关心类型（等价于'=='）&lt;/li&gt;
&lt;li&gt;逐个分支地迭代直到找到一个匹配项。如果没找到匹配项，则使用缺省(default)分支（如果定义了）&lt;/li&gt;
&lt;li&gt;若匹配项的代码体没有'break'语句，则会继续执行接下来的每个分支，直到遇到一个break/return语句&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在函数内，使用'return'可以减少'break'的使用，因为'return'能够结束函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$answer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// &amp;#39;case 2&amp;#39;和&amp;#39;case3&amp;#39;的代码体会得到执行&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;// code...&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// break用于结束switch语句&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;// code...  // 没有break，继续比较&amp;#39;case 3&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;// code...&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 当前位置在函数内，&amp;#39;return&amp;#39;会结束函数&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;// code...&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/control-structures.switch.php"&gt;Switch语句&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://phpswitch.com/"&gt;PHP switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全局命名空间&lt;/h2&gt;
&lt;p&gt;使用命名空间之时，你可能发现内置函数被你所写的函数覆盖了。推荐在全局函数的函数名之前添加一个反斜杠来修正这个问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;phptherightway&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;\fopen&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;       &lt;span class="c1"&gt;// 我们的函数名与内部函数的函数名相同。&lt;/span&gt;
                            &lt;span class="c1"&gt;// 通过添加&amp;#39;\&amp;#39;指定从全局命名空间执行函数&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;array&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;$iterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;\ArrayIterator&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;       &lt;span class="c1"&gt;// ArrayIterator是一个内置类。&lt;/span&gt;
                                            &lt;span class="c1"&gt;// 若类名之前没有一个反斜杠，解释器会试图在你的命名空间中解析它&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.namespaces.global.php"&gt;全局命名空间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/userlandnaming.rules.php"&gt;全局规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;字符串&lt;/h2&gt;
&lt;h3&gt;拼接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果代码行超过了推荐的行长度（120个字符），那么应该考虑拼接代码行&lt;/li&gt;
&lt;li&gt;为了便于阅读，最好使用拼接操作符而不是拼接赋值操作符&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在变量原本的命名空间内，当拼接使用了新行，则应该缩进&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Multi-line example&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 拼接赋值操作符(.=)&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;.=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;.=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;of what not to do&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Multi-line example&amp;#39;&lt;/span&gt;       &lt;span class="c1"&gt;// 拼接操作符(.)&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;                      &lt;span class="c1"&gt;// 缩进新行&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;of what to do&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://php.net/manual/en/language.operators.string.php"&gt;字符串操作符&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;字符串类型&lt;/h3&gt;
&lt;p&gt;字符串类型在PHP社区内是个不变的特性，但希望本节内容能够解释清楚字符串类型之间的区别以及各自的好处/用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单引号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单引号是创建字符串最简单的方式，并且通常执行速度也是最快的，因为PHP不会解析这种字符串（不解析其中是否存在变量），所以单引号最适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要解析的字符串&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将变量写为纯文本值（Writing of a variable into plain text）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;This is my string, look at how pretty it is.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;//不需要解析一个简单的字符串&lt;/span&gt;

&lt;span class="sd"&gt;/**&lt;/span&gt;
&lt;span class="sd"&gt;  * 输出:&lt;/span&gt;
&lt;span class="sd"&gt;  *&lt;/span&gt;
&lt;span class="sd"&gt;  * This is my string, look at how pretty it is.&lt;/span&gt;
&lt;span class="sd"&gt;  */&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.single"&gt;单引号&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双引号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双引号是字符串处理的瑞士军刀，但执行速度比较慢，因为字符串要经过解析。双引号最适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转义字符串&lt;/li&gt;
&lt;li&gt;内含多个变量和纯文本的字符串&lt;/li&gt;
&lt;li&gt;压缩多行拼接，提高可读性&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;phptherightway is &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;$adjective&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;    &lt;span class="c1"&gt;// 一个单引号的使用示例，&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;                                      &lt;span class="c1"&gt;// 为变量和转义字符串使用了多行拼接&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;I love learning &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;$code&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;phptherightway is &lt;/span&gt;&lt;span class="si"&gt;$adjective&lt;/span&gt;&lt;span class="s2"&gt;.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt; I love learning &lt;/span&gt;&lt;span class="si"&gt;$code&lt;/span&gt;&lt;span class="s2"&gt;!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 没有使用多行拼接，&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;                                                                  // 双引号允许我们使用可解析的字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用双引号创建的字符串中包含变量时，经常出现变量名与后面另一个字符相接触的情况，从而导致PHP不解析该变量，因为它被"伪装"起来了。为了解决这个问题，可以使用一对大括号把变量包围起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$juice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;plum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;I drank some juice made of &lt;/span&gt;&lt;span class="si"&gt;$juices&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// $juice得不到解析&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="nv"&gt;$juice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;plum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;I drank some juice made of&lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$juice&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// $juice得到解析&lt;/span&gt;

&lt;span class="sd"&gt;/**&lt;/span&gt;
&lt;span class="sd"&gt;  * 大括号内的复杂变量也能得到解析&lt;/span&gt;
&lt;span class="sd"&gt;  */&lt;/span&gt;

&lt;span class="nv"&gt;$juice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;orange&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;plum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;I drank some juice made of &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$juice&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// $juice[1]将得到解析&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.double"&gt;双引号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Nowdoc语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PHP 5.3引入了Nowdoc语法，其行为与单引号相同，除了她适用于多行字符串的使用，而不需要拼接。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;EOD&amp;#39;&lt;/span&gt;         &lt;span class="c1"&gt;// 通过&amp;lt;&amp;lt;&amp;lt;初始化&lt;/span&gt;
&lt;span class="nx"&gt;Example&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nx"&gt;string&lt;/span&gt;
&lt;span class="nx"&gt;spanning&lt;/span&gt; &lt;span class="nx"&gt;multiple&lt;/span&gt; &lt;span class="nx"&gt;lines&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;nowdoc&lt;/span&gt; &lt;span class="nx"&gt;syntax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="nx"&gt;does&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nx"&gt;EOD&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// &amp;#39;EOD&amp;#39;关闭符必须单独一行，并且处于最左边&lt;/span&gt;

&lt;span class="sd"&gt;/**&lt;/span&gt;
&lt;span class="sd"&gt;  * 输出:&lt;/span&gt;
&lt;span class="sd"&gt;  * &lt;/span&gt;
&lt;span class="sd"&gt;  * Example of string&lt;/span&gt;
&lt;span class="sd"&gt;  * spanning multiple lines&lt;/span&gt;
&lt;span class="sd"&gt;  * using nowdoc syntax.&lt;/span&gt;
&lt;span class="sd"&gt;  * $a does not parse.&lt;/span&gt;
&lt;span class="sd"&gt;  */&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.nowdoc"&gt;Nowdoc语法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Heredoc语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Heredoc语法的行为与双引号相同，除了它适用于多行字符串的使用，而不需要拼接。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Variables&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nv"&gt;$str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;EOD&lt;/span&gt;       &lt;span class="c1"&gt;// 使用&amp;lt;&amp;lt;&amp;lt;初始化&lt;/span&gt;
&lt;span class="nx"&gt;Example&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nx"&gt;string&lt;/span&gt;
&lt;span class="nx"&gt;spanning&lt;/span&gt; &lt;span class="nx"&gt;multiple&lt;/span&gt; &lt;span class="nx"&gt;lines&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;heredoc&lt;/span&gt; &lt;span class="nx"&gt;syntax&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="nx"&gt;are&lt;/span&gt; &lt;span class="nx"&gt;parsed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nx"&gt;EOD&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// &amp;#39;EOD&amp;#39;关闭符必须单独一行，且处于最左边位置&lt;/span&gt;

&lt;span class="sd"&gt;/**&lt;/span&gt;
&lt;span class="sd"&gt;  * 输出：&lt;/span&gt;
&lt;span class="sd"&gt;  *&lt;/span&gt;
&lt;span class="sd"&gt;  * Example of string&lt;/span&gt;
&lt;span class="sd"&gt;  * spanning multiple lines&lt;/span&gt;
&lt;span class="sd"&gt;  * using heredoc syntax.&lt;/span&gt;
&lt;span class="sd"&gt;  * Variables are parsed.&lt;/span&gt;
&lt;span class="sd"&gt;  */&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc"&gt;Heredoc语法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;三元操作符&lt;/h2&gt;
&lt;p&gt;三元操作符是一种压缩代码的好方式，但经常被滥用。当需要多层或嵌套使用三元操作符时，建议一行代码仅使用一次三元操作符以提高代码可读性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;yay&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;nay&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="c1"&gt;// 嵌套三元操作符&lt;/span&gt;
&lt;span class="nv"&gt;$b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;yay&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;nay&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;excessive&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;:(&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 过度嵌套，牺牲了可读性&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用三元操作符'返回'一个值需使用正确的语法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 这个例子会抛出错误&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;yay&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;nope&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 这个例子会返回&amp;#39;yay&amp;#39;&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/manual/en/language.operators.comparison.php"&gt;三元操作符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;变量声明&lt;/h2&gt;
&lt;p&gt;有时，程序员会试图通过将预定义变量声明为一个不同的名字使得代码更加"干净"。事实上，这样会让脚本的内存消耗加倍。如下例子，我们假设一个示例文本字符串包含1MB的数据，通过拷贝这个变量，脚本执行时就会增加到2MB。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="nv"&gt;$about&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A very long string of text&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 使用了2MB内存&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$about&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nx"&gt;vs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A very long string of text&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 仅使用1MB内存&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/speed/articles/optimizing-php"&gt;性能技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="PHP"></category><category term="翻译"></category></entry><entry><title>数据压缩理论简介（译）</title><link href="http://youngsterxyf.github.io/2013/02/27/A-introduction-to-compression/" rel="alternate"></link><updated>2013-02-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-02-27:2013/02/27/A-introduction-to-compression/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://imrannazar.com/An-Introduction-to-Compression"&gt;A introduction to compression&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近我在思考GIF和JPEG图片格式之间的不同：为什么某些图片存储为GIF格式所占的磁盘空间更大，而另一些图片以JPEG格式存储要占用更大的磁盘空间？事实证明，这是因为不同的图片格式使用了不同的压缩方法。&lt;/p&gt;
&lt;p&gt;压缩是一组程序的简便说法，这些程序能够将数据装进更小的存储空间中，也能将数据从压缩编码中重新取回。这是一个双向的过程：输入文件能够产生经过压缩的输出，并且算法根据压缩后的输出能够重新给你一个输入的拷贝。&lt;/p&gt;
&lt;h2&gt;冗余：行程长度编码（Run-Length Encoding）&lt;/h2&gt;
&lt;p&gt;使压缩成为可能的是冗余：事实表明大多数的数据都以某种方式重复自己。例如，在一个文档中可能多次使用同一个单词，或者一张图片的多处包含相同的颜色。一个非常简单的冗余数据片段的示例如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redundancy: Before compression&lt;/p&gt;
&lt;p&gt;AAAAABBWWWWWWWWWPPPPQZMMMMVVV&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这种情况下，冗余是明显的；整个样本中重复出现了一系列字母。压缩这种数据的一种简单方式是通过重复次数来代表重复出现的字母，从而削减了样本的总长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redundancy: After compression&lt;/p&gt;
&lt;p&gt;A5B2W9P4Q1Z1M4V3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法读取样本编码后的版本将能够完美地重现原来的数据："A" 5次，"B"
2次，等等。这个简单算法的使用非常广泛，被称为行程长度编码（RLE）：写下字符的每次行程有多长。以古老的PCX图像格式为例来说明一种广泛使用的标准RLE。
&lt;center&gt;&lt;img src="/assets/uploads/pics/compression-stripes.png" alt="compression-stripes.png"&gt;&lt;/center&gt;
&lt;center&gt;图1：条纹（&lt;a href="http://www.thisisnotparis.com/"&gt;Gottschal&lt;/a&gt;/&lt;a href="http://www.gluecksbazillus.de/"&gt;Schuster&lt;/a&gt;）&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图1中有很多单色的实心方块。这张图片宽500个像素，高190个像素；作为一张原始位图，使用一个字节来表示一个像素，那么这张图片就产生95kB的数据。PCX算法计算图片中每行像素的行程长度，为相同颜色的连续像素保存行程长度：以这种方式，图片的大小减到了52kB。&lt;/p&gt;
&lt;h2&gt;频率：哈夫曼（Huffman）编码&lt;/h2&gt;
&lt;p&gt;RLE的一个主要问题是它处理的是数据中的连续值：图1中，RLE算法对图片的每个水平行进行独立的处理，然而其实所有的行都是相同的。这个问题可以通过整体地看待数据来缓解，构建一个表来记录在整个数据集中每个值出现的次数。&lt;/p&gt;
&lt;p&gt;哈夫曼编码是一种借助这种“频率表”的方法，这种表记录着每个值出现的频率，并且为每一项分配一个编码。频率越高的项编码越短，较少出现的项也就得到长的编码。在计算中，这些编码一般是二进制编码，然后就可以组合成字节进行文件存储。&lt;/p&gt;
&lt;p&gt;使用上面的例子，一个哈夫曼编码的过程如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Huffman encoding: Before compression&lt;/p&gt;
&lt;p&gt;AAAAABBWWWWWWWWWPPPPQZMMMMVVV&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table border="1" align="center" width="40%"&gt;
  &lt;tr&gt;&lt;th&gt;值&lt;/th&gt;&lt;th&gt;频率&lt;/th&gt;&lt;th&gt;编码&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Q&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;000000&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Z&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;000001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;00001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;V&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;0001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;P&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;001&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;M&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;011&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;01&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;W&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;center&gt;
表1：频率和哈夫曼表
&lt;/center&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Huffman encoding: After compression&lt;/p&gt;
&lt;p&gt;01 01 01 01 01 00001 00001 1 1 1 1 1 1 1 1 1 001 001 001 001 000000 000001 011 011 011 011 0001 0001 0001&lt;/p&gt;
&lt;p&gt;此处省略了一行乱码，避免atom和rss报错...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用哈夫曼编码，数据从29个字符减少到10个字节。当然这没包含频率与编码表，这个表必须和压缩后的数据一起存储才有意义；本例中，频率表比压缩后的数据还要大，但在多数情况下，频率表的大小是微不足道的。&lt;/p&gt;
&lt;p&gt;当然，将RLE和哈夫曼编码结合使用是可能的，首先执行RLE，然后将压缩后的结果交给哈夫曼算法处理。对于简单的图片，这会产生特别好的结果：上面的图1通过使用GIF文件格式可以从一个95kB的位图压缩成一个4kB的文件，GIF文件格式就是结合使用了RLE，哈夫曼编码以及其他算法。&lt;/p&gt;
&lt;h2&gt;感知：有损编码&lt;/h2&gt;
&lt;p&gt;上述方法可以用于以一种能够完美重现的方式对数据进行压缩。这种压缩的用例包括文档和软件程序，对于这种用例来说，任意值的丢失或损坏都可能使得文件不再有价值。&lt;/p&gt;
&lt;p&gt;在特定情况下，对于需要处理的数据进行完美重现是不必要的：一个近似的结果就足够了。通常，这些情况出现在多媒体应用中：超出人类听觉范围的声音不需要记录，人眼无法识别的颜色与梯度的细微之处也无需重现。&lt;/p&gt;
&lt;p&gt;一个经典的示例是MPEG音频标准---通过去除高频声音相关的额外数据来降低音频文件的大小。这个标准的Layer-3规格允许多种去除数据的设定，这样渐进地从音频样本中去除更多的信息。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-mp3.gif"
alt="compression-mp3.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图2：经MPEG音频Layer-3编码的Yardım Et (&lt;a href="http://www.morveotesi.com/"&gt;Mor ve Ötesi&lt;/a&gt;, "Dünya Yalan Söylüyor")
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;上图2中，两个波形叠加在一起：红色的为原来的歌曲波形，覆盖在其上的蓝色是经充分压缩的变体。展示的样本长度为1.5秒；作为原来波形文件的一部分，这段样本存储为160kB的数据。经压缩的变体，长度相同，但仅占用48kB的空间。&lt;/p&gt;
&lt;p&gt;这是通过MPEG音频压缩算法得到的，调整歌曲的频率属性，去除超出人类听力范围（高至大约20kHz）的部分。这样，如上可见，并未显著地影响产生的波形，因此经压缩的声音不会明显地不同于原有的声音。&lt;/p&gt;
&lt;h2&gt;扔掉数据：视觉有损编码&lt;/h2&gt;
&lt;p&gt;正如声音文件的高频部分人耳无法辨别，图片也有高频部分：颜色的变化之处不足以人眼区分，或者由黑到白的渐变过程是如此的迅速导致无法看到渐变的部分。与声音处理一样，也可以从图片中去除这些高频部分；这就是JPEG图片格式的前提。&lt;/p&gt;
&lt;p&gt;JPEG应用了MPEG音频所使用算法的一种变种，从包含于图片的频率部分抽取一个二维映射；该算法继而裁剪到这个频率部分，并重新合成图片。如下所示是这个过程的一个例子。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-jpeg-sharp.gif" alt="compression-jpeg-sharp.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图3：JPEG压缩应用于一张块状图
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图3中，一张由4个16x16像素方块构成的图片，与该图片经JPEG编码后的图片进行比较。颜色或亮度上的尖锐变化被定义为高视觉频率的结果。这正是JPEG要去除的地方。结果，编码后图片的边缘比较模糊。4个方块的接触点特别模糊。&lt;/p&gt;
&lt;p&gt;但JPEG的强大之处并不是编码具有尖锐变化边沿和角落的图片，而是低视觉频率的图片；照片就是其中的一个典型例子。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-jpeg-photo.gif" alt="compression-jpeg-photo.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图4：JPEG压缩应用于一张照片
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图4中，一张安塔利亚港的300x300图片，经过JPEG编码。原来的位图为270kB，经去除尖锐边缘和颜色变化，JPEG能够产生一张22kB的图片。对于人眼而言，图片的变化很小；即使像素有所改变，图片所展示的景色也完好无损。&lt;/p&gt;
&lt;p&gt;这就是有损编码背后的主要概念：确切的数据并不重要，重要的是数据所呈现的信息。将JPEG算法用于编码软件程序是不明智的，但当数据表达了不必要的过多信息之时，有损编码就派上用场了。&lt;/p&gt;
&lt;h2&gt;感知冗余：视频编码&lt;/h2&gt;
&lt;p&gt;说到视频剪辑，通过结合无损和有损编码背后的原则，进一步压缩数据是有可能的。构建一个视频剪辑片段的最简单最幼稚的方法是合并连续的图片，作为视频帧来看待：MJPEG视频文件格式就是将一系列的JPEG图片看到独立的视频帧。&lt;/p&gt;
&lt;p&gt;这种方法忽视了视频片段中固有的数据冗余：一个给定帧中包含的大多数信息同样会包含于其前一帧中。任何特定帧中仅有一小部分是新的信息；通过计算这部分信息所处的位置，然后仅存储这部分信息数据，那么就有可能大大地缩减视频帧的数据大小。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-mpeg-diff.gif" alt="compression-mpeg-diff.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图5：连续视频帧，以及它们的不同之处（&lt;a href="http://jpl.nasa.gov/"&gt;NASA JPL&lt;/a&gt;）
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图5中，较之第一帧，视频的第二帧显示的变化非常小：仅仅航天飞机的排气羽流有显著的运动。事实上，发射塔后面的航天飞机固体助推器（SRB）(译注：见Wikipedia词条&lt;a href="http://zh.wikipedia.org/wiki/%E8%88%AA%E5%A4%A9%E9%A3%9E%E6%9C%BA%E5%9B%BA%E4%BD%93%E5%8A%A9%E6%8E%A8%E5%99%A8"&gt;航天飞机固体助推器&lt;/a&gt;)和天空在两帧之间完全没有变化。那么就不用存储图片的这些部分，可能存储一个值：“没有变化”就可以了。&lt;/p&gt;
&lt;p&gt;MPEG视频标准利用了这种内在的冗余作为算法的一部分。理论上，仅仅拍摄（a shot）的初始帧需要完整存储：拍摄的任何运动部分都可以作为与前一帧的相异之处来存储。初始帧，也称为一个内帧，存储为一张标准的JPEG图片，而后续的差异帧被称为间帧，或预测帧。&lt;/p&gt;
&lt;p&gt;实际上，MPEG视频标准是以“流”来设计的，这样就能够从拍摄（a shot）的中间开始观看视频片段。但若仅提供视频的一个内帧（I-帧），那么预测帧（P-帧）是不可能插入它们的差异的。所以，通常会把I-帧每隔一定时间插入到视频片段中，而不管拍摄的场景（a shot）是否变化。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src="/assets/uploads/pics/compression-mpeg-graph.gif" alt="compression-mpeg-graph.gif"&gt;
&lt;/center&gt;
&lt;center&gt;
图6：一个4秒的MPEG视频片段的帧大小（&lt;a href="http://news.bbc.co.uk/"&gt;BBC News&lt;/a&gt;）
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;上图6中，视频片段每间隔25帧或一秒插入I-帧。后续的每个P-帧都比I-帧小得多，由于政治家在接受采访时一般都不会频繁移动，因此不同视频帧之间的不同之处更少。&lt;/p&gt;
&lt;p&gt;图6使用的例子是一个4秒的400x224视频片段。以原始位图形式粗糙农户，生成文件的大小有26.7MB；通过结合使用有损编码和冗余的技术，MPEG视频标准能够将视频大小缩减到300kB，减小了99%。&lt;/p&gt;
&lt;h2&gt;总结：什么情况下可以有损编码&lt;/h2&gt;
&lt;p&gt;本文所列举的有损编码的例子都是应用于特殊情况的：音频，视频，图片。仅对于这些或者其他相关的东西，感知才是压缩过程中的一个重大因素。对于其他压缩目标，比如文档或软件程序，数据是什么样的就保存为什么样，非常重要。&lt;/p&gt;
&lt;p&gt;人们一直在开发更加高级的特殊压缩方法，但数据压缩的多数常见实现都是基于本文讲述的技术：去除冗余和重复信息。当存在大量冗余数据时，数据压缩会表现得非常好，所以不要试图去压缩一个已经压缩过的文件。&lt;/p&gt;</summary><category term="理论"></category><category term="翻译"></category></entry><entry><title>JavaScript：继承和原型链（译）</title><link href="http://youngsterxyf.github.io/2013/02/27/Inheritance-and-the-prototype-chain/" rel="alternate"></link><updated>2013-02-27T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-02-27:2013/02/27/Inheritance-and-the-prototype-chain/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Inheritance_and_the_prototype_chain"&gt;Inheritance and the prototype chain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于具备基于类的编程语言（如Java或C++）经验的程序员来说，JavaScript有点混乱，因为它是一种动态语言，并且不提供&lt;code&gt;class&lt;/code&gt;的实现（虽然关键字&lt;code&gt;class&lt;/code&gt;是保留的，不可用作变量名）。&lt;/p&gt;
&lt;p&gt;说到继承，JavaScript只有一种结构：对象。每个对象都有一个内部链接指向另一个对象，这个对象称为&lt;strong&gt;原型&lt;/strong&gt; (prototype)。那个原型对象也有自己的原型，如此直到某个对象以&lt;code&gt;null&lt;/code&gt;作为其原型。&lt;code&gt;null&lt;/code&gt;，根据定义，没有原型，作为这种&lt;strong&gt;原型链&lt;/strong&gt;的最后一环而存在。&lt;/p&gt;
&lt;h2&gt;以原型链实现继承&lt;/h2&gt;
&lt;h3&gt;继承属性&lt;/h3&gt;
&lt;p&gt;JavaScript对象可看作是动态地装载属性（这里指&lt;strong&gt;自有属性&lt;/strong&gt;）的"包包"，并且每个对象都有一个链指向一个原型对象。如下即为当尝试访问一个属性时发生的事情：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 假设有个对象o，其原型链如下所示：&lt;/span&gt;
&lt;span class="c1"&gt;// {a: 1, b: 2} ---&amp;gt; {b: 3, c: 4} ---&amp;gt; null&lt;/span&gt;
&lt;span class="c1"&gt;// &amp;#39;a&amp;#39;和&amp;#39;b&amp;#39;是o的自有属性。&lt;/span&gt;

&lt;span class="c1"&gt;// 本例中，someObject.[[Prototype]]指定someObject的原型。&lt;/span&gt;
&lt;span class="c1"&gt;// 这完全是一种标记符号（基于ECMAScript标准中所使用的），不可用于脚本中。&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 1&lt;/span&gt;
&lt;span class="c1"&gt;// o有一个自有属性&amp;#39;a&amp;#39;吗？是的，其值为1&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 2&lt;/span&gt;
&lt;span class="c1"&gt;// o有自有属性&amp;#39;b&amp;#39;吗？是的，其值为2&lt;/span&gt;
&lt;span class="c1"&gt;// o的原型也有一个属性&amp;#39;b&amp;#39;，但是这里不会被访问。这被称为“属性隐藏”（property shadowing）&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 4&lt;/span&gt;
&lt;span class="c1"&gt;// o有自有属性&amp;#39;c&amp;#39;吗？没有，检查它的原型&lt;/span&gt;
&lt;span class="c1"&gt;// o.[[Prototype]]有自有属性&amp;#39;c&amp;#39;吗？是的，其值为4。&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// undefined&lt;/span&gt;
&lt;span class="c1"&gt;// o有自有属性&amp;#39;d&amp;#39;吗？没有，检查其原型&lt;/span&gt;
&lt;span class="c1"&gt;// o.[[Prototype]]有自有属性&amp;#39;d&amp;#39;吗？没有，检查其原型&lt;/span&gt;
&lt;span class="c1"&gt;// o.[[Prototype]].[[Prototype]]为null，停止搜索，没有找到属性，返回undefined。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将一个属性分配给一个对象会创建一个自有属性。对于获取和设置属性的行为规则，唯一的例外是当一个继承而来的属性带有一个&lt;a href="https://developer.mozilla.org/en/docs/JavaScript/Guide/Working_with_Objects?redirectlocale=en-US&amp;amp;redirectslug=Core_JavaScript_1.5_Guide%2FWorking_with_Objects#Defining_getters_and_setters"&gt;属性值获取器或设置器&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;继承"方法"&lt;/h3&gt;
&lt;p&gt;JavaScript没有以基于类的编程语言定义方法的形式出现的"方法"。JavaScript中，任何函数都可以作为一个属性被添加到一个对象。一个继承而来的函数，操作起来与任何其他属性相同，包括如上所示的属性隐藏（在这里，称为&lt;em&gt;方法覆盖&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;当执行一个继承而来的函数时，&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/this"&gt;this&lt;/a&gt;的值指向继承对象，而不是原型对象，该函数是原型对象的自有属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c1"&gt;// 3&lt;/span&gt;
&lt;span class="c1"&gt;// 这里当调用o.m时，&amp;#39;this&amp;#39;引用o&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// p是一个继承自o的对象&lt;/span&gt;

&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 为p创建一个自有属性&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c1"&gt;// 13&lt;/span&gt;
&lt;span class="c1"&gt;// 这里调用p.m时，&amp;#39;this&amp;#39;引用p&lt;/span&gt;
&lt;span class="c1"&gt;// 因此，当p继承了o的函数m，&amp;#39;this.a&amp;#39;意味着p.a，p的自有属性&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;创建对象的不同方式，以及由此产生的原型链&lt;/h2&gt;
&lt;h3&gt;以语法结构创建对象&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// 新创建的对象o有Object.prototype作为其[[Prototype]]&lt;/span&gt;
&lt;span class="c1"&gt;// o没有名为&amp;#39;hasOwnProperty&amp;#39;的自有属性&lt;/span&gt;
&lt;span class="c1"&gt;// hasOwnProperty是Object.prototype的自有属性。因此o从Object.prototype继承了hasOwnProperty&lt;/span&gt;
&lt;span class="c1"&gt;// Object.prototype以null为其prototype。&lt;/span&gt;
&lt;span class="c1"&gt;// o ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;whadup&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;// 数组继承自Array.prototype（它具有indexOf, forEach等方法）。&lt;/span&gt;
&lt;span class="c1"&gt;// 该原型链如下所示：&lt;/span&gt;
&lt;span class="c1"&gt;// a ---&amp;gt; Array.prototype ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 函数继承自Function.prototype（它具有call，bind等方法）：&lt;/span&gt;
&lt;span class="c1"&gt;// f ---&amp;gt; Function.prototype ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用构造器&lt;/h3&gt;
&lt;p&gt;JavaScript中，"构造器""就"是一个恰好以&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/new"&gt;new操作符&lt;/a&gt;调用的函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;vertexes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[];&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;edges&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;addVertex&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;vertexes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;// g是一个带有自有属性&amp;#39;vertexes&amp;#39;和&amp;#39;edges&amp;#39;的对象。&lt;/span&gt;
&lt;span class="c1"&gt;// 执行new Graph()后，g.[[Prototype]]是Graph.prototype的值。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用Object.create&lt;/h3&gt;
&lt;p&gt;ECMAScript
5引入了一个新方法：&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create"&gt;Object.create&lt;/a&gt;。调用这个方法会创建一个新对象。这个对象的原型是该函数的第一个参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// a ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 1 (继承而来)&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// c ---&amp;gt; b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; null&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// d ---&amp;gt; null&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hasOwnProperty&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// undefined，因为d并不继承自Object.prototype&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="JavaScript"></category><category term="翻译"></category></entry><entry><title>Python格式字符串（译）</title><link href="http://youngsterxyf.github.io/2013/01/26/python-string-format/" rel="alternate"></link><updated>2013-01-26T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-26:2013/01/26/python-string-format/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://mkaz.com/solog/python-string-format"&gt;Python String Format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每次使用Python的格式字符串（string formatter），2.7及以上版本的，我都会犯错，并且有生之年，我想我都理解不了它们的文档。我非常习惯于更老的
&lt;code&gt;%&lt;/code&gt; 方法。所以着手编写自己的格式字符串手册。若你有一些其他好的示例请告知我。&lt;/p&gt;
&lt;h2&gt;格式字符串手册&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数字格式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的表格展示了使用Python的后起新秀str.format()格式化数字的多种方法，包含浮点数格式化与整数格式化示例。可使用
&lt;code&gt;print("FORMAT".format(NUMBER));&lt;/code&gt; 来运行示例，因此你可以运行：
&lt;code&gt;print("{:.2f}".format(3.1415926));&lt;/code&gt; 来得到第一个示例的输出。&lt;/p&gt;
&lt;table border="1" align="center" width="80%"&gt;
&lt;tr&gt;&lt;th width="10%"&gt;数字&lt;/th&gt;&lt;th width="10%"&gt;格式&lt;/th&gt;&lt;th width="12%"&gt;输出
&lt;/th&gt;&lt;th width="65%"&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 3.1415926 &lt;/td&gt;
    &lt;td&gt; {:.2f} &lt;/td&gt;
    &lt;td&gt; 3.14 &lt;/td&gt;
    &lt;td&gt; 保留小数点后两位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 3.1415926 &lt;/td&gt;
    &lt;td&gt; {:+.2f} &lt;/td&gt;
    &lt;td&gt; +3.14 &lt;/td&gt;
    &lt;td&gt; 带符号保留小数点后两位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; -1 &lt;/td&gt;
    &lt;td&gt; {:+.2f} &lt;/td&gt;
    &lt;td&gt; -1.00 &lt;/td&gt;
    &lt;td&gt; 带符号保留小数点后两位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 2.71828 &lt;/td&gt;
    &lt;td&gt; {:.0f} &lt;/td&gt;
    &lt;td&gt; 3 &lt;/td&gt;
    &lt;td&gt; 不带小数 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 5 &lt;/td&gt;
    &lt;td&gt; {:0&amp;gt;2d} &lt;/td&gt;
    &lt;td&gt; 05 &lt;/td&gt;
    &lt;td&gt; 数字补零 (填充左边, 宽度为2) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 5 &lt;/td&gt;
    &lt;td&gt; {:x&amp;lt;4d} &lt;/td&gt;
    &lt;td&gt; 5xxx &lt;/td&gt;
    &lt;td&gt; 数字补x (填充右边, 宽度为4) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 10 &lt;/td&gt;
    &lt;td&gt; {:x&amp;lt;4d} &lt;/td&gt;
    &lt;td&gt; 10xx &lt;/td&gt;
    &lt;td&gt; 数字补x (填充右边, 宽度为4) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 1000000 &lt;/td&gt;
    &lt;td&gt; {:,} &lt;/td&gt;
    &lt;td&gt; 1,000,000 &lt;/td&gt;
    &lt;td&gt; 以逗号分隔的数字格式 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 0.25 &lt;/td&gt;
    &lt;td&gt; {:.2%} &lt;/td&gt;
    &lt;td&gt; 25.00% &lt;/td&gt;
    &lt;td&gt; 百分比格式 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 1000000000 &lt;/td&gt;
    &lt;td&gt; {:.2e} &lt;/td&gt;
    &lt;td&gt; 1.00e+09 &lt;/td&gt;
    &lt;td&gt; 指数记法 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; {:10d} &lt;/td&gt;
    &lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;13&lt;/td&gt;
    &lt;td&gt; 右对齐 (默认, 宽度为10) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; {:&amp;lt;10d} &lt;/td&gt;
    &lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; 左对齐 (宽度为10)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 13 &lt;/td&gt;
    &lt;td&gt; {:^10d} &lt;/td&gt;
    &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;13 &lt;/td&gt;
    &lt;td&gt; 中间对齐 (宽度为10) &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;string.format()基础&lt;/h2&gt;
&lt;p&gt;如下是两个基本字符串替换的示例，符号 &lt;code&gt;{}&lt;/code&gt;
是替换变量的占位符。若没有指定格式，则直接将变量值作为字符串插入。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;so much depends upon {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a red wheel barrow&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;glazed with {} water beside the {} chickens&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rain&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;white&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你也可以使用变量的位置数值，在字符串中改变它们，进行格式化时，会更加灵活。如果搞错了顺序，你可以轻易地修正而不需要打乱所有的变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; {0} is better than {1} &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;emacs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;vim&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; {1} is better than {0} &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;emacs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;vim&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;更老的格式字符串符号"%"&lt;/h2&gt;
&lt;p&gt;Python2.6之前，格式字符串的使用方法相对更简单些，虽然其能够接收的参数数量有限制。这些方法在Python3.3中仍然有效，但已有含蓄的警告称将完全淘汰这些方法，目前还没有明确的时间进度表。[&lt;a href="http://www.python.org/dev/peps/pep-3101/"&gt;PEP-3101&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式化浮点数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14159&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; pi = &lt;/span&gt;&lt;span class="si"&gt;%1.2f&lt;/span&gt;&lt;span class="s"&gt; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;多个替换值&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;cats&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;dogs&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; and &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; living together&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;没有足够的参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用老的格式化方法，我经常犯错"TypeError: not enough arguments for formating
string"，因为我数错了替换变量的数量，编写如下这样的代码很容易漏掉变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; % (a,b,c,d,e,f,g,h,i)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于新的Python格式字符串，可以使用编号的参数，这样你就不需要统计有多少个参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; ({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}) &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;更多.format()的格式字符串方法&lt;/h2&gt;
&lt;p&gt;format()函数提供了相当多的附加特性和功能，如下是一些有用的使用.format()的技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以将新的格式字符串用作模板引擎，使用命名参数，这样就不要求有严格的顺序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;madlib&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; I {verb} the {object} off the {place} &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;verb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;took&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cheese&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;place&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;table&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;took&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;cheese&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;多次复用同一个变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;%&lt;/code&gt; 格式字符串，要求变量有严格的次序，而.format()方法允许如上所示那样任意排列参数，也允许复用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Oh {0}, {0}! wherefore art thou {0}?&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Romeo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Oh&lt;/span&gt; &lt;span class="n"&gt;Romeo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Romeo&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;wherefore&lt;/span&gt; &lt;span class="n"&gt;art&lt;/span&gt; &lt;span class="n"&gt;thou&lt;/span&gt; &lt;span class="n"&gt;Romeo&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;将数值转换为不同的进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用如下字母来将数字转换成字母代表的进制，&lt;strong&gt;d&lt;/strong&gt;ecimal，he&lt;strong&gt;x&lt;/strong&gt;，&lt;strong&gt;o&lt;/strong&gt;ctal, &lt;strong&gt;b&lt;/strong&gt;inary。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;{0:d} - {0:x} - {0:o} - {0:b} &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;10101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;将格式作为函数来使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以将.format()用作函数，这就允许在代码中将普通文本和格式区分开来。例如，你可以在程序的开头包含所有需要使用的格式，然后在后面使用。这也是一种处理国际化的好方法，国际化不仅要求不同的文本，且常常要求不同的数字格式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;## 定义格式&lt;/span&gt;
&lt;span class="n"&gt;email_f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Your email address was {email}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;

&lt;span class="c"&gt;### 在另一个地方使用&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;email_f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;email&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bob@example.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;感谢
&lt;a href="http://www.reddit.com/r/Python/comments/174e1i/python_string_format_cookbook/c82ot0h"&gt;earthboundkid&lt;/a&gt;在reddit上提供这一技巧。&lt;/p&gt;
&lt;h2&gt;其他技巧&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;转义大括号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用str.format()时，若你需要使用大括号，只要写两次就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; The {} set is often represented as { {0} } &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;empty&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;often&lt;/span&gt; &lt;span class="n"&gt;represented&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.python.org/3/library/string.html"&gt;Python String Library&lt;/a&gt; - 标准库文档&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>python周刊-第70期（译）</title><link href="http://youngsterxyf.github.io/2013/01/25/issue-70-of-python-weekly/" rel="alternate"></link><updated>2013-01-25T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-25:2013/01/25/issue-70-of-python-weekly/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://us2.campaign-archive1.com/?u=e2e180baf855ac797ef407fc7&amp;amp;id=7fc9a4c2e2&amp;amp;e=59f9a3c7e0"&gt;issue 70 of Python Weekly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章，教程和讲座(Articles, Tutorials and Talks)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jakevdp.github.com/blog/2013/01/13/hacking-super-mario-bros-with-python/"&gt;使用Python Hacking超级马里奥(Hacking Super Mario Bros. With Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This post shows how you can use matplotlib's animation tool to create animated
gifs based on Super Mario Bros in Python.&lt;/p&gt;
&lt;p&gt;该文展示如何使用matplotlib的动画工具使用Python创建超级马里奥的动画效果gif图。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tech.shift.com/post/40299429203/implementing-a-python-oauth-2-0-provider-part-2"&gt;实现一个Python OAuth 2.0 提供方 - 第2部分 - 授权服务提供方(Implementing a Python OAuth 2.0 Provider - Part2 - Authorization Provider)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Last week, the first part covered the Basics of the OAuth 2.0 Authorization
Flow. This second part will walk through how we used pyoauth2 to set up a
minimal Authorization Provider for SHIFT. This post covers setting up endpoints
for steps 2 and 5 from the overview.&lt;/p&gt;
&lt;p&gt;上周，第一部分阐述了OAuth 2.0授权的基本流程。
该第二部分将大致讲述怎样使用pyoauth2为SHIFT公司建立一个最基本的授权提供方。该文概述授权流程从第2步到第5步端到端的具体实现。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://proppy-appstats.appspot.com/#1"&gt;优化你的App Engine应用(Optimizing Your App Engine App)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this presentation, Johan Euphrosine, Google Developer Program Engineer,
   shows Datastore pattern and Anti-pattern and how to optimize your App Engine
   App with Appstats.&lt;/p&gt;
&lt;p&gt;该演讲稿中，谷歌开发者计划工程师，Johan
Euphrosine，解释了数据存储模式与反模式，以及怎样使用Appstats优化App
Engine应用。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.randalolson.com/2013/01/14/filling-in-pythons-gaps-in-statistics-packages-with-rmagic/"&gt;使用Rmagic来弥补Python统计分析工具包的缺失(Filling in Python's gaps in statistics packages with Rmagic)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rmagic is a package which allows you to run R code within the IPython
interface. This post explains how it works.&lt;/p&gt;
&lt;p&gt;Rmagic是一个允许通过IPython接口执行R代码的Python包。该文解释了Rmagic是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.twilio.com/blog/2013/01/sending-images-via-sms-with-filepicker-and-twilio.html"&gt;使用Filepicker和Twilio实现通过短信息服务发送图片(Sending Images via SMS with Filepicker and Twilio)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Filepicker.io provides APIs to connect, process, and store any piece of content
in your web application. For example if you are building an application that
needs to send files or photos to your users via SMS, then you can use
Filepicker.io with Twilio to make this happen. Let's explore how to build this.&lt;/p&gt;
&lt;p&gt;Filepicker.io提供API用于连接，处理，以及存储你的web应用中的任何内容。例如，如果你正在构建的应用需要通过短消息服务给用户发送文件或照片，那么你可以使用Filepicker.io配合Twilio来实现。该文探讨了如何构建这一功能。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://lightbird.net/larks/versi.html"&gt;Versi教程(Versi Tutorial)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Versi is a clone of the Reversi game. The goal of the game is to capture more
tiles than your enemy. You can capture the enemy's tiles by placing a new piece
on the blank tile so that one or more of enemy pieces are enclosed on a line
between your placed piece and one of your existing pieces.&lt;/p&gt;
&lt;p&gt;Versi是黑白棋游戏的克隆版本。这个游戏的目标是比你的敌人捕获更多的棋子。你可以在空白之处放置新棋子来捕获敌人的棋子，这样，一行中，在刚放置的棋子与你原来就有的棋子之间就包围了一个或多个敌人的棋子。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ganwellresource.blogspot.com/2013/01/monte-carlo-web-server-statistics-using.html"&gt;使用Pandas与Matplotlib进行蒙特卡洛法Web服务器统计分析(Monte Carlo Web-Server Statistics using Pandas and Matplotlib)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The author collected the web-server statistic-data by connecting to random web
servers and asking it for its name. He was able to maintain 80'0000 concurrent
connections on linux using tornados ioloop when he hit the limit of the
upstream-bandwidth at home.&lt;/p&gt;
&lt;p&gt;通过连接到随机选择的web服务器并请求其名称，作者收集了一些web服务器统计数据。文中说明作者使用tornado的ioloop能够维持80'0000个并发连接，直到达到家庭带宽的上限。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://maxburstein.com/blog/realtime-django-using-nodejs-and-socketio/"&gt;使用Django，Node.js以及Socket.IO等实现实时应用(Realtime Django Using Node.js and Socket.IO)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The goal of this post is to show you how to build a realtime chatroom using
Django, Redis, and Socket.IO. At a high level this post will show you how you
can convert your REST based app into a realtime web app.&lt;/p&gt;
&lt;p&gt;该文的目的是阐述如何使用Django, Redis,
    以及Socket.IO构建一个实时网络聊天室。从较高层面来看，该文将阐述如何将基于REST的应用转变为实时web应用。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://astrofrog.github.com/blog/2013/01/13/what-python-installations-are-scientists-using/"&gt;科学家们在使用哪个版本的Python解释器以及相关的库？(What Python Installations Are Scientists Using?)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This post gives you an overview of the results of a survey conducted to find
out what Python, Numpy, and Scipy versions the Scientists are using.&lt;/p&gt;
&lt;p&gt;该文概述了一个调查的结果，该调查旨在找出科学家们正在使用哪个版本的Python解释器，Numpy以及Scipy。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.slideshare.net/mpirnat/web-development-with-python-and-django"&gt;Python与Django Web开发(Web Development with Python and Django)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Slides from CodeMash 2013 Precompiler session, "Web Development with Python and
Django", including a breezy introduction to the Python programming language and
the Django web framework. The example code repository is available
&lt;a href="https://github.com/finiteloopsoftware/django-precompiler/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;来自CodeMash 2013预编译器会议的幻灯片，“Python与Django
Web开发”，生动地介绍了Python程序设计语言和Django
Web框架。示例代码库见&lt;a href="https://github.com/finiteloopsoftware/django-precompiler/"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts"&gt;可替代Bash实用脚本的Python脚本(Python Scripts as a Replacement for Bash Utility Scripts)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Instead of replacing a series of bash commands with one Python script, it often
is better to have Python do only the heavy lifting in the middle. This allows
for more modular and reusable scripts, while also tapping into the power of all
that Python offers. Using stdin as a file object allows Python to read input,
     which is piped to it from other commands, and writing to stdout allows it
     to continue passing the information through the piping system. Combining
     information like this can make for some very powerful programs.&lt;/p&gt;
&lt;p&gt;相较于使用一个Python脚本来替换一系列的bash命令，仅使用Python来完成其中的重活会更好些。这样的脚本模块化和可复用性更好，同时利用了Python的优势。将标准输入作为一个文件对象来使用，允许Python读取其他命令通过管道提供给它的输入。写到标准输出也允许Python通过管道系统继续传递信息。像这样把信息结合起来能够产生一些非常强大的程序。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythontesting.net/framework/pytest-introduction/"&gt;pytest入门(pytest introduction)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A post giving you an overview of pytest, a simple example, then throw pytest at
my markdown.py project. It also cover fixtures, test discovery, and running
unittests with pytest.&lt;/p&gt;
&lt;p&gt;该文章先概述pytest，而后给出一个简单的示例，并将pytest应用于作者的markdown.py项目。文章也涵盖了Pytest的一些测试夹具，测试发现，以及配合pytest执行unittests。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://raspberry-python.blogspot.com/2013/01/pyhacking-step-by-step.html"&gt;PyHacking攻略(PyHacking step by step)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://benplesser.com/2013/01/10/beefing-up-the-python-shell-to-build-apps-faster-and-dryer/"&gt;增强Python Shell以更快速地构建应用，同时减少重复工作(Beefing up the Python Shell to build apps faster and DRYer)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.linuxjournal.com/content/getting-started-salt-stack-other-configuration-management-system-built-python"&gt;Salt Stack起步---另一个Python实现的配置管理系统(Getting Started with Salt Stack-the Other Configuration Management System Built with Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.rootshell.be/2013/01/11/managing-apple-icloud-notes-with-python/"&gt;使用Python管理Apple iCloud笔记(Managing Apple iCloud Notes with Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youtube.com/watch?v=BZyXe3MhEyI"&gt;如何使用Python实现一个可撤销可重做的Maya命令(How to implement an undoable and redoable Maya command in Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://eli.thegreenplace.net/2013/01/16/python-paralellizing-cpu-bound-tasks-with-concurrent-futures/"&gt;Python-使用concurrent.futures并行化计算密集型任务(Python - paralellizing CPU-bound tasks with concurrent.futures)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有趣的项目，工具和库(Interesting Projects, Tools and Libraries)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/gleitz/howdoi"&gt;howdoi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Are you a hack programmer? Do you find yourself constantly Googling for how to
do basic programming tasks? Howdoi gives quick answers to many proragmming
questions via the command line.&lt;/p&gt;
&lt;p&gt;你是一个程序员新手？你发现自己经常使用Google搜索如何完成一些基本的编程任务？对于许多编程问题，Howdoi能够通过命令行快速地给出答案。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://baboon-project.org/"&gt;Baboon Project&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Do you waste your time in resolving merge conflicts with your favorite source code manager? Do you want to get rid of "Merge Hell"? Baboon is the solution for you! It's a lightweight daemon that detects merge conflicts before they actually happen. In fact, it detects them in real time.&lt;/p&gt;
&lt;p&gt;你还在浪费时间解决你喜爱的源码管理工具中的合并冲突？你想摆脱“合并地狱”么？Baboon就是这样的一个解决方案！它是一个轻量的后台程序，目标是在合并冲突真正发生之前就检测到。事实上，它能够实时检测存在的合并冲突。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://code.google.com/p/topy/"&gt;ToPy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ToPy solves the problem to obtain a 2D(or 3D, depending on the input file) solid-void (black and white) solution. The result is (a) an optimally stiff structure for minimum compliance problems, (b) an optimal distribution of two materials for heat conduction problems and (c) an optimal distribution of material for efficient mobility.&lt;/p&gt;
&lt;p&gt;ToPy旨在解决获取一个2D（或3D，根据输入文件而定）实-虚（黑和白）结构方案的问题。程序的结果是(a)最小合规问题的一个最佳刚性结构，(b)热传导问题中两种材料的一个最佳分布以及(c)有效流动性问题中材料的一个最佳分布。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/simpleai-team/simpleai"&gt;Simple AI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This lib implements many of the artificial intelligence algorithms described on the book "Artificial Intelligence, a Modern Approach", from Stuart Russel and Peter Norvig. We strongly recommend you to read the book, or at least the introductory chapters and the ones related to the components you want to use, because we won't explain the algorithms here.&lt;/p&gt;
&lt;p&gt;这个代码库实现了许多Stuart Russel和Peter Norvig所著“人工智能---一种现代方法”一书中描述的人工智能算法。我们强烈推荐你阅读这本书，或者至少是入门的章节以及与你想要使用的部分相关的章节，因为我们不会解释这些算法。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rubik/radon"&gt;Radon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Radon is a tool for Python that computes various metrics from the source code.&lt;/p&gt;
&lt;p&gt;Radon是一个为Python源码计算多种度量指标的工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/louist87/Scrappy"&gt;Scrappy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python module to rename media collections based on scrapes from thetvdb.com. CLI and GUI tools.&lt;/p&gt;
&lt;p&gt;基于从thetvdb.com网站获取的信息对媒体集进行重命名的Python模块。命令行和图形用户界面工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/rhec/pyelasticsearch"&gt;pyelasticssearch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pyelasticsearch is a clean, future-proof, high-scale API to elasticsearch.&lt;/p&gt;
&lt;p&gt;pyelasticsearch为elasticsearch(译注：一种开源的分布式搜索引擎，官网见http://www.elasticsearch.org/ )提供一个干净的、经得起时间考验的、高可扩展的API。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ubershmekel/import_or_pip"&gt;import_or_pip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A python module that lets you import a module or pip install it if it isn't found.&lt;/p&gt;
&lt;p&gt;该Python模块允许你在程序中import一个模块或者当没找到要import的模块时会使用pip自动安装。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://bitbucket.org/larsyencken/doko"&gt;doko&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A simple command-line utility (and Python module) to determine your current location.&lt;/p&gt;
&lt;p&gt;一个简单的命令行工具（以及Python模块）用于确定你当前的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书籍(Books)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/gp/product/1589482824/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;tag=pythonweekly-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1589482824"&gt;ArcGIS Python脚本编程(Python Scripting for ArcGIS)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python Scripting for ArcGIS is a guide to help experienced users of ArcGIS for Desktop get started with Python scripting. This book teaches how to write Python code that works with spatial data to automate geoprocessing tasks in ArcGIS. Readers can thus learn the skill set needed to create custom tools.&lt;/p&gt;
&lt;p&gt;ArcGIS Python脚本编程是一本帮助有经验的ArchGIS桌面用户入门Python脚本编程的指南。该书讲解了如何编写Python代码处理空间数据以自动化ArcGIS中的地理数据处理任务。因此，读者能够学习到一些用于创建定制化工具的技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即将来临的大事和在线研讨会(Upcoming Events and Webinars)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://meetup.bostonpython.com/events/77229092/"&gt;马萨诸塞州,剑桥-2013年1月-波士顿Python会议(Boston Python Meetup January 2013 - Cambridge, MA)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There will be following two presentations&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zipline - A new, BSD-licensed quantitative trading system which allows easy backtesting of investment algorithms on historical data.&lt;/li&gt;
&lt;li&gt;Hython - A lisp variant that's fully hosted on and fully interoperable (in both directions) with Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将会有以下两个报告&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zipline - 一个新的、基于BSD许可协议的量化交易系统，允许轻松地对历史数据进行投资算法的事后检验。&lt;/li&gt;
&lt;li&gt;Hython - 一个完全模仿Python语法并完全可与Python互操作（双向的）的lisp变种语言。（译注：是这个&lt;a href="https://github.com/MaskRay/Hython"&gt;hython&lt;/a&gt;么？）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.djangonyc.org/events/98408042/"&gt;纽约州，纽约-2013年1月-Django-NYC会议(Django-NYC Meetup January 2013 - New York, NY)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This month we'll be taking a look at security. Our guide will be Levi Gross from Matasano. Most of the times security talks are boring. They speak about abstract topics like SQL injection and Cross Site Scripting however, rarely do they show you these bugs in the wild (due to the legal concerns). In this talk we will take a practical look at Django's security features and limitations.&lt;/p&gt;
&lt;p&gt;本月我们将讨论安全问题。我们的指导者为来自Matasano的Levi Gross。多数时候，关于安全的演讲总是很枯燥。他们谈论SQL注入和跨网站脚本攻击一类的抽象话题，却很少向你展示在真实环境下的这些bug（考虑到法律问题）。本次演讲中我们将从实际出发看看Django的安全特性与限制。&lt;/p&gt;</summary><category term="python"></category><category term="python-weekly"></category><category term="翻译"></category></entry><entry><title>回顾12，展望13（技术篇）</title><link href="http://youngsterxyf.github.io/2013/01/22/technology-12-13/" rel="alternate"></link><updated>2013-01-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-22:2013/01/22/technology-12-13/</id><summary type="html">&lt;p&gt;终归是个搞技术的，所以怎么也得搞个总结与展望的特别篇，讲述过去一年的技术学习与成果，规划接下来一年技术学习的计划。&lt;/p&gt;
&lt;p&gt;2012年，阅读较少，写的代码较多，经过几个小项目以及实习，终于觉得自己有点攻城师的样子了，甚感欣慰，哈哈。&lt;/p&gt;
&lt;p&gt;罗列一下个人的小项目，虽然不复杂，代码量不多，代码也写得不漂亮，但自认为有那么点用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;百度音乐下载器：&lt;a href="https://github.com/youngsterxyf/Baidu_Music_Downloader"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/Baidu_Music_Downloader/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简易FTP搜索引擎：&lt;a href="https://github.com/youngsterxyf/simpleFTPsearch"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/simpleFTPsearch/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;，&lt;a href="http://202.120.40.101/services/ftpsearch/"&gt;应用&lt;/a&gt;（注：这个小项目断断续续做了一年，经历了几个版本，以及几次更新，目前看起来还不错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于Web的机器人远程控制：&lt;a href="https://github.com/youngsterxyf/WebBasedRobot"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/WebBasedRobot/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;（注：这个项目就是我那尽是水的毕业设计啦，哈哈）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在线代码高亮，分享以及运行：&lt;a href="https://github.com/youngsterxyf/colorfulCode"&gt;代码&lt;/a&gt;（注：这个项目其实很不完整的啦，代码编译与执行部分根本没做防护措施，根本没法实际使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Loven的个人静态站点：&lt;a href="https://github.com/Loven-Project/lovenworks"&gt;代码&lt;/a&gt;（注：其实绝大部分的代码都是loven自己写的啦，我主要写了实现总体动态效果的javascript程序，而且还是仿照的，不过难度比原来被仿照网站的要大很多）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;顺便说说实习做的事情，正好为G1C1做个广告，哈哈。&lt;/p&gt;
&lt;p&gt;实习主要实现&lt;a href="http://www.17gong1.com/"&gt;一起公益网&lt;/a&gt;的部分功能，最后还完成了该网站的静态化，所以现在的一起公益网是个静态网站，不需要数据库，用户也无法提交数据。&lt;/p&gt;
&lt;p&gt;后来一小段时间还维护&lt;a href="http://gong1pin.com/"&gt;公益品网&lt;/a&gt;，这网站有点意思的，欢迎大家访问看看。&lt;/p&gt;
&lt;p&gt;过去一年写的代码中，个人兴趣小项目基本都是基于Python、JS实现，实习工作主要使用PHP。&lt;/p&gt;
&lt;p&gt;除了写代码，我还迷上了翻译技术文章，markdown和restructedText格式的一些最早的翻译稿见&lt;a href="https://github.com/youngsterxyf/Translation"&gt;https://github.com/youngsterxyf/Translation&lt;/a&gt;。后来的放在基于jekyll与github
pages搭建的&lt;a href="http://youngsterxyf.github.com"&gt;博客&lt;/a&gt;&lt;s&gt;（注：近期随着Github被墙了）&lt;/s&gt;上。除了零碎的文章翻译，还开始翻译《The
AWK Programming
Language》一书，翻译稿见&lt;a href="https://awk.readthedocs.org/en/latest/"&gt;AWK程序设计语言&lt;/a&gt;，目前为止才完成第一章的翻译，再接再励！&lt;/p&gt;
&lt;p&gt;其实12年，我还是读了点书的，但觉得阅读效果不好，决心重头开始阅读，故在此不表。&lt;/p&gt;
&lt;p&gt;这样看来，12年，我虽做了些技术活，但都是些没啥技术难度的小应用，但令自己欣慰的是在学习方式上自己逐渐从死学转到实战，在应用中学习。13年希望自己挖掘一些自己感兴趣有技术深度的小项目来做。&lt;/p&gt;
&lt;h2&gt;13年技术学习计划&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;编程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编程语言对于码农来说是最重要的工具。程序员必须通过编程语言将想法转化为程序由计算机来执行。不会一种甚或多种编程语言的人称得上程序员么？不会编程的计算机从业人员是合格的么？而且，不同的项目选择不同的编程语言实现很多时候也是很关键的，所以程序员不管从实用还是从学习还是从兴趣角度，都应该多掌握几门编程语言。&lt;/p&gt;
&lt;p&gt;目前，我最喜欢也最熟悉的编程语言是Python；基本掌握的有PHP，C/C++，Java；不熟悉但能写点程序的有JavaScript，Go；简单接触过只有肤浅的感性认识的有Scheme，Ruby，Haskell等。&lt;/p&gt;
&lt;p&gt;从实用角度出发，2013年希望进一步掌握熟悉Python（甚至达到精通的程度），熟练使用PHP（工作可能需要使用），多写写C语言代码（方便进一步熟悉底层），尝试写一些Go语言程序（觉得Go简洁而强大，以后在服务器端应该大有前景），进一步了解JavaScript的特性（虽然基于各种库写了千行代码，但根本不熟悉这门语言，JS必将在web前端一统江湖啊），另外，由于要做运维工作，所以需熟悉Shell编程。&lt;/p&gt;
&lt;p&gt;从兴趣角度，以及为了更全面地理解编程语言，希望自己能掌握一门函数式语言，暂定Haskell，因为目前看来Haskell的社区很活跃，学习资料也多，Haskell也有点学术研究产物的感觉，与工程实践产物的语言相互补充，因为自己不喜欢Java，所以也不考虑基于JVM的Clojure等函数式语言，虽然它貌似很火。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;觉得以前自己过于折腾，总想找到更好的工具来使用，却不知所谓更好的多半要更熟悉才能明白，所以针对常用工具链中的每一环精通一个工具，相比同时掌握几个功能类似的工具，更为重要，回顾自己的折腾史，大浪淘尽沙，终觉着如下几个工具值得学习精通。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Linux ---
挑一个发行版深入使用学习，不同的发行版本质上大同小异，因为对于我这种层次的码农来说，Linux最重要的是命令行及其工具链，极其便于编程开发与批量任务。当然，也不必排斥Windows之流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VIM ---
虽然接触使用VIM的时间较长，但没有用心学习过，决心之后长久投入其怀抱，学好用好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git ---
天天使用Github，但由于是一个人在自娱自乐，所以只会Git的基本用法，遇到特殊情况就有些头疼了，而且我们得熟悉天天在一起的伙伴，是不？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Latex ---
虽然对于普通的文档编辑，office之流已经够用了，但对于一个有志青年，在初步认识Latex之后，大悟文档编辑也可以有更高的追求，一切复杂都抵不过纯文本的简单之美。故希望在基于office满足基本的文档编辑需求之外，自己能够有个Latex的理想追求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;理论学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2013年想进一步学习&lt;em&gt;编译原理&lt;/em&gt;、&lt;em&gt;分布式系统&lt;/em&gt;、&lt;em&gt;网络&lt;/em&gt;，特别是&lt;em&gt;编译原理&lt;/em&gt;，本科时候完全水过，根本没有正儿八经地学习。网络的话，是觉得现在的开发与应用对网络的依赖性越来越强。分布式系统，是认为任何大的系统，本质上都趋向于分布式，原理都相似。&lt;/p&gt;
&lt;p&gt;虽说理论要学习，但得以&lt;em&gt;实践&lt;/em&gt;为主导，在实践的同时加强理论学习。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;个人小项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;昨天刚看到一篇文章&lt;a href="http://www.dev.gd/20130122-the-joys-of-having-a-forever-project.html"&gt;《The joys of having a Forever
Project》&lt;/a&gt;
。确实我们应该始终有自己想做的事情，作为程序员，也就应该有自己想做的项目，这种项目或出于方便大众、节约大家的时间，或为了验证自己的理论学习，或为了实现自己的某个创意想法，原因不一而足，但一旦自己空闲的时候，就愿意为其写几行代码，那么在生活工作的劳累中你也能够感受到自身的充实圆满。&lt;/p&gt;
&lt;p&gt;关于个人小项目，目前仅有一个，就是想为自己和女朋友做个website，记录共同走过的光阴，个性化展示文字，图片，视频等。&lt;/p&gt;
&lt;p&gt;其他的以后看是否有新的想法。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;书籍阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非技术的书籍目前想阅读《历史研究》、《GEB》、《明朝那些事儿》。《历史研究》是本大部头，很早就买了，一直没静下心来；《GEB》也是本大部头，之前翻过几页，觉得不是很理解，就放下了，现在想重新拿起来读一遍；《明朝那些事儿》这书，原本并不在意，后来有次在某个桌游店翻了几页，觉着甚是不错，将历史写得生动有趣，与黄仁宇的《万历十五年》相比，虽没有那样的学术严谨性，但有趣好读是很重要的嘛。&lt;/p&gt;
&lt;p&gt;技术书籍，根据前面说明希望学习的技术，目前想阅读《C++对象模型》、《编译原理》（龙书）、《Python源码剖析》、《TCP/IP详解》（第一卷）（第二卷有点厚，估计只能翻翻，没那么多时间阅读）。分布式系统方面，估计会阅读一些经典论文。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;源码阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一直觉得自己写的代码不甚高明，不简洁也没有美感，所以想阅读一些优秀的开源项目源码，借鉴一些别人的东西。目前想阅读memcached（分布式缓存）、requests（Python的HTTP库），另外随着阅读《Python源码剖析》，也阅读一点Python的源码。&lt;/p&gt;
&lt;p&gt;希望13年，在这方面有所突破，阅读一两个不大的项目源码。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;翻译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人觉得“慢”才能有所积淀。也有话说“学习的最好方式是教别人学”。所以翻译这个事情虽然会耗费许多时间，但要想翻译得对，翻译得好理解，所谓“信达雅”，必须对文本及其相关的东西有充分的理解，才能办到。那么翻译的过程也就成了一个深入学习的过程，时间长久的“慢”的积累，就会有较大的进步。另外，翻译也能帮助别人。&lt;/p&gt;
&lt;p&gt;目前翻译任务主要有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;继续翻译《The AWK Programming Language》一书，现在才翻译了一章，所以任重而道远啊；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Requests文档；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若读到写得好且有深度的技术文章，也会翻译。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;如此看来，13年要做的事情好多啊，有点过度计划的感觉啊，哈哈。不过只要自己能够分清主次轻重缓急，应该不会有问题。&lt;/p&gt;
&lt;p&gt;希望自己每天进步一点点。&lt;/p&gt;</summary><category term="总结"></category><category term="技术"></category></entry><entry><title>回顾2012，展望2013</title><link href="http://youngsterxyf.github.io/2013/01/18/review12-lookinto13/" rel="alternate"></link><updated>2013-01-18T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-18:2013/01/18/review12-lookinto13/</id><summary type="html">&lt;p&gt;过去的一年里发生了很多事情，很大一部分原来就已在&lt;a href="http://youngsterxyf.github.io/2012/01/01/2011-summary/"&gt;2011年终-回顾与展望&lt;/a&gt;一文中提及---实习、找工作、毕业，除此之外还有：我和女朋友定亲了，总算朝着婚姻近了一步，哈哈。&lt;/p&gt;
&lt;h2&gt;实习&lt;/h2&gt;
&lt;p&gt;关于实习有太多的话想说。7个月的时间里浓缩了太多的欢乐，太欢乐了。原本以为我的读书生涯就要这么平淡无奇地结束了，没想到在这个结尾处竟然给了我个大惊喜，所谓惊喜并不是这份实习有多牛逼，而是遇到了一群欢乐的人，一群“重口味”的人，一群彪悍的人，而其中绝大部分是女人，噢，女生更恰当些。&lt;/p&gt;
&lt;p&gt;在G1C1，我快乐地写代码，上班是种享受，我想以后很可能不会再有这样的享受了。在G1C1，我逐步地发展成为一个吃货，所以毫无疑问地胖了，原本我以为自己会一直瘦下去。另外，我也黑了，因为经过了无数次地“被黑”，但她们说我应该高兴才对，她们“黑”我是因为“爱”我。关于“黑”这件事情，刚入职的时候，我是很同情wenbin的，因为见他被“黑”得体无完肤的，可我也没逃脱作为一个G1C1码农的宿命，wenbin走后，替代了他的角色，而我走后，comen则替代了我的角色，可惜之后就不会再有了。&lt;/p&gt;
&lt;p&gt;吃，是Google的特色，故在G1C1也不例外。因为G1C1不与其他部门在一起，所以没法吃食堂。但我们也不亏，老大带着我们吃遍了办公室方圆几里地叫得出名的饭店，吃饱吃好，并且一天一换。并且吃饭的场景实在不得不让码农感到幸福，男女比例经常是6：1，与“交大男女七比一，一对情侣三对基”的情形那是恰好相反，而且我们实验室甚至比七比一的情况还严重。所以我一直来回感受两种极端。又由于女生的食量多半偏小，作为男生，最后“扫盘”的工作那自然是义不容辞的，胖也就必然的结果了。&lt;/p&gt;
&lt;p&gt;因为工作内容比较多元化，所以G1C1实习生的专业背景与就读学校覆盖面很大，可以说是“一锅大杂烩”。专业不同，并没有妨碍交流，反而使工作氛围更加活跃，具备专业特色的阐述方式与内容相互碰撞交融。&lt;/p&gt;
&lt;p&gt;很想逐个介绍我所知道的G1C1er们，可苦于胸无半点墨水，只好作罢。但你们应知道，应相信，现在，以后，我都会一直念着你们，想着你们。感谢和你们一起度过的美好青春时光。&lt;/p&gt;
&lt;h2&gt;找工作&lt;/h2&gt;
&lt;p&gt;我的求职经历并不顺利，主要原因是对于求职的“求”字在认识上有所偏差。我不喜欢“求”，我认为找工作就和找对象一样，我想找你，你认可我，才行。我就这样，你不要我，拉倒。这种想法导致我并没有认真准备笔试面试。其实找工作和学校里的应试是一样一样的，所以你得做题，各种应试的题目，除了一流的公司，一般公司考的都是老题目或者类似的题目。另外，要注意找工作的目标不是向公司证明你的能力，而是拿到offer，“不择手段”地拿到offer。&lt;/p&gt;
&lt;p&gt;对自己未来几年做了基本的定位之后，我没有参加银行、国企一类公司的招聘，集中应聘技术型的私企外企大小公司，由于裸考裸面，结果多半不太理想。这里对于应聘的公司不做评价，求职的具体过程也不详述，只是真心感谢那些认可我赏识我的人，还有虽然拒了我但真心帮助我的人，谢谢你们。&lt;/p&gt;
&lt;p&gt;最后，腾讯收了我，虽然待遇和职位的工作内容不是很理想，但我想应该是个不错的机会，值得以后好好努力工作，感谢当时的几个面试官，也就是我以后的同事，当然还要特别感谢yuye同学，你也算是一个“奇葩”吧，哈哈，没有任何贬义哦。&lt;/p&gt;
&lt;p&gt;我之所以选择技术作为我的职业目标，一方面当然是因为我本来学的就是技术，但更重要的是因为做技术比较纯粹，我希望自己以后心里能一直很踏实安心。&lt;/p&gt;
&lt;h2&gt;毕业&lt;/h2&gt;
&lt;p&gt;说到毕业论文，一个字足以概括---“水”。哈哈，但幸好顺利毕业了，虽然过程很痛苦，很煎熬。现在的我无所事事，坐等毕业，哈哈。&lt;/p&gt;
&lt;p&gt;这次毕业与本科毕业有什么本质区别呢？那就是这次我是真的要结束读书的生活了，正式进入社会，需要承担的责任也是完全不相同的，并且以后我应该不会继续深造求学了。&lt;/p&gt;
&lt;p&gt;回顾十几年的读书生涯，实在难舍。&lt;/p&gt;
&lt;h2&gt;定亲&lt;/h2&gt;
&lt;p&gt;和女朋友相关的文字，我写得很少，自己也觉得有点对不住女朋友。其原因一方面是从我们认识到现在4年多的时间里，我正逐步地趋向沉默，文字表达越来越少；另一方面是我觉得幸福其实是一件挺私密的事情，不能多晒。所以，我不说并不是因为我不幸福，其实我一直幸福得偷着乐呢，哈哈。&lt;/p&gt;
&lt;p&gt;定亲的过程并没有想的那么顺利，要考虑很多问题，要和双方父母亲人沟通，特别是要和女朋友沟通，从恋爱逐步走向婚姻，会遇到很多很多现实的细节。面对现实，会产生矛盾，但没有什么大不了的，相爱的人请记住，矛盾没有什么大不了的，不要夸张了问题而放弃了情感。&lt;/p&gt;
&lt;h2&gt;谈谈自己&lt;/h2&gt;
&lt;p&gt;回顾从大一到现在的几年时间，我的变化应该算是蛮大的，我逐步地不再关注那些大层面上的事情，不去想那些形而上的问题。那些事情，那些问题，想不透，看不穿，也不会真的有解。这辈子，我们能做的其实很少很少，做些力所能及的事情也算是不浪费生命吧。也许有人认为这是“认命”了，认为我在逐渐成为一个“单向度”的人，但其实我还是想趁活着多扑腾几下的，按照自己的想法去活，只不过想法换了个方面。&lt;/p&gt;
&lt;h2&gt;未来一年&lt;/h2&gt;
&lt;p&gt;也得为这新的一年做点规划，定点目标啥的。可以从工作、健康、情感、技术等几个方面来谈吧。&lt;/p&gt;
&lt;p&gt;对于工作，我希望自己能够踏实些，逐步精通工作相关的技术，多认识一些人，对所处的技术行业有个更清晰的认识。&lt;/p&gt;
&lt;p&gt;身心健康应该始终放在第一位，要多运动锻炼，坚持跑步什么的，多出去走走，断然拒绝“宅”的习惯，特别是要多和女朋友出去玩，这个可以做个详细的计划。时间是靠自己安排的，理由也会有千万，但都不应接受其成为不注意身心健康的原因。&lt;/p&gt;
&lt;p&gt;情感方面，希望自己能够一如既往，并且更加耐心，细心，注意交流沟通。另外，要尽快完成婚姻的流程。&lt;/p&gt;
&lt;p&gt;说到技术，还是老毛病，有太多东西想学，不过现在学习方式在逐步进入良性循环，心态上也不会那么盲目了。接下来的一年里，自己必须不避重就轻，要攻关把核心技术练扎实，多写代码，多整理总结。&lt;/p&gt;
&lt;p&gt;过去的一年里，书籍阅读不多，也不见得是件坏事。不过新的一年里，应该要精读一些书，包括文史与技术类的，多思考。&lt;/p&gt;
&lt;p&gt;上述也说不上是规划，只是对自己提点要求和期望，希望自己在各方面都有所进步。&lt;/p&gt;</summary><category term="总结"></category><category term="文字"></category></entry><entry><title>可扩展的Web架构与分布式系统（译）</title><link href="http://youngsterxyf.github.io/2013/01/16/scalable-web-architecture-and-distributed-systems/" rel="alternate"></link><updated>2013-01-16T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-16:2013/01/16/scalable-web-architecture-and-distributed-systems/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.aosabook.org/en/distsys.html"&gt;Scalable Web Architecture and Distributed Systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开源软件已成为一些最大型网站的基础组件。并且随着那些网站的发展，围绕它们的架构出现了一些最佳实践与指导性原则。本章尝试阐述设计大型网站需要考虑的一些关键问题，以及一些实现这些目标的组件。&lt;/p&gt;
&lt;p&gt;本章主要侧重于Web系统，虽然其中一些内容也适用于其它分布式系统。&lt;/p&gt;
&lt;h2&gt;Web分布式系统设计原则&lt;/h2&gt;
&lt;p&gt;构建和运维一个可扩展Web站点或者应用到底意味着什么？说到底这种系统只不过是通过互联网将用户与远程资源相连接---使其可扩展的是分布于多个服务器的资源，或者对这些资源的访问。&lt;/p&gt;
&lt;p&gt;类似于生活中的大多数东西，从长远来说，构建一个web服务之前花些时间提前规划是很有帮助的。理解大型网站背后一些需要考虑的因素与权衡取舍，在创建小一些的web站点时能让你作出更明智的决策。以下是影响大规模web系统设计的一些核心原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可用性：&lt;/strong&gt;
一个网站的正常运行时间对于许多公司的声誉与运作都是至关重要的。对于一些更大的在线零售站点，几分钟的不可用都会造成数千或数百万美元的营收损失，因此系统设计得能够持续服务，并且能迅速从故障中恢复是技术和业务的最基本要求。分布式系统中的高可用性需要仔细考虑关键部件的冗余，从部分系统故障中迅速恢复，以及问题发生时优雅降级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能：&lt;/strong&gt;
对于多数站点而言，网站的性能已成为一个重要的考虑因素。网站的速度影响着使用和用户满意度，以及搜索引擎排名，与营收和是否能留住用户直接相关。因此，创建一个针对快速响应与低延迟进行优化的系统非常重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可靠性：&lt;/strong&gt;
系统必须是可靠的，这样相同数据请求才会始终返回相同的数据。数据变换或更新之后，同样的请求则应该返回新的数据。用户应该知道一点：如果东西写入了系统，或者得到存储，那么它会持久化并且肯定保持不变以便将来进行检索。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可扩展性：&lt;/strong&gt;
对于任何大型分布式系统而言，大小(size)只是需要考虑的规模(scale)问题的一个方面。同样重要的是努力去提高处理更大负载的能力，这通常被称为系统的可扩展性。可扩展性以系统的许多不同参数为参考：能够处理多少额外流量？增加存储容量有多容易？能够处理多少更多的事务？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可管理性：&lt;/strong&gt;
系统设计得易于运维是另一个重要的考虑因素。系统的可管理性等价于运维（维护和更新）的可扩展性。对于可管理性需要考虑的是：问题发生时易于诊断与理解，便于更新或修改，系统运维起来如何简单（例如：常规运维是否不会引发失败或异常？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本：&lt;/strong&gt;
成本是一个重要因素。很明显这包括硬件和软件成本，但也要考虑系统部署和维护这一方面。系统构建所花费的开发者时间，系统运行所需要的运维工作量，以及培训工作都应该考虑进去。成本是拥有系统的总成本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些原则中的每一个都为设计分布式web架构提供了决策依据。然而，它们之间也会相互不一致，这样实现一个目标的代价是牺牲另一个目标。一个基本的例子：简单地通过增加更多的服务器（可扩展性）来解决容量问题是以可管理性（你需要运维额外的一台服务器）和成本（服务器的价钱）为代价的。&lt;/p&gt;
&lt;p&gt;设计任何一种web应用，考虑这些核心原则都是非常重要的，即使明知某个设计也许会牺牲其中的一个或多个原则。&lt;/p&gt;
&lt;h2&gt;1.2. 基础概念&lt;/h2&gt;
&lt;p&gt;说到系统架构，需要考虑几个事情：什么是合适的部件，这些部件如何组合在一起，以及什么是正确的权衡取舍。在需要之前扩大投资通常不是一种明智的商业主张;然而，在设计上的一些远见在将来能够节省大量的时间和资源。&lt;/p&gt;
&lt;p&gt;本节主要阐述对于几乎所有大型web应用来说都是非常重要的一些核心因素：&lt;em&gt;服务&lt;/em&gt;，&lt;em&gt;冗余&lt;/em&gt;， &lt;em&gt;分区&lt;/em&gt;， 以及&lt;em&gt;故障处理&lt;/em&gt;。这些因素中的每一个都涉及选择与折中，特别是在上一节所描述的那些原则的上下文中。为了详细地解释这些东西，最好是从一个例子开始。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;例子：图片托管应用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可能在以前的某个时候，你在网上张贴过图片。对于托管和提供大量图片的大网站来说，构建一个性价比高、高可用、以及低延迟（快速检索）的架构是存在诸多挑战的。&lt;/p&gt;
&lt;p&gt;想象存在这样一个系统，用户可以上传图片到中央服务器，也可以通过web链接或者API请求图片，就像Flickr或Picasa一样。为了简单起见，我们假设这个应用有两个关键部分：上传（写）图片到服务器和查询图片。当然我们希望图片上传很高效，同时我们非常关注当有人请求一张图片时（例如，网页或者其他应用请求图片），系统能够快速地交付。这非常类似于web服务器或内容分发网络（CDN）边缘服务器（CDN将这种服务器用于在多个地方存储内容，这样内容就在地理/物理距离上更接近用户，从而更加快速）提供的功能。&lt;/p&gt;
&lt;p&gt;系统的另一些重要方面有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于将要存储的图片数量没有限制，因此需要考虑存储的可扩展性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图片下载/请求的延迟要低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果用户上传了某张图片，那么这张图片就得一直存在（图片数据的可靠性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统应该易于维护（可管理性）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于图片托管的利润空间不大，所以系统应有较高的性价比。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图1.1是系统的一张功能简化图。&lt;/p&gt;
&lt;p&gt;&lt;img src ="/assets/uploads/pics/imageHosting1.jpg" alt="imageHosting1.jpg"&gt;
&lt;center&gt;图1.1：图片托管应用的简化架构图&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在这个图片托管例子中，系统必须明显地快速，数据存储可靠，并且所有这些属性高度可扩展。构建该应用的一个小型版本轻而易举，也很容易搭载在单个服务器上；然而，那样本章就没多大意思了。假设我们想构建一个能够发展得和Flickr一样庞大的应用。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;服务&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;考虑可扩展的系统设计时，对功能进行解耦，然后将系统的每一部分看作能够自己提供服务，并具备明确定义的接口。实践中，人们评价以这种方式设计的系统具备面向服务器的架构（SOA）。对这类系统来说，每个服务都有自己截然不同的功能上下文，并通过一个抽象接口与该上下文之外的一切（通常是另一个服务公开的API）进行交互。&lt;/p&gt;
&lt;p&gt;将系统解构为一组相互补充的服务也就将不同组件的操作进行解耦。这种抽象有助于在服务、底层环境以及服务的消费者之间建立清晰的关系。这样明确的划分有助于隔离问题，也允许每个组件独立于其他组件进行扩展。这类面向服务的系统设计非常类似于程序设计的面向对象设计。&lt;/p&gt;
&lt;p&gt;在我们的例子中，所有上传和检索图片的请求都是在同一个服务器上处理的；然而，将这两个功能分割成两个独立的服务在系统需要扩展时非常有意义。&lt;/p&gt;
&lt;p&gt;现在假设该服务被大量使用；这种情况下很容易看到写操作对读取图片所花时间的影响有多大（因为这两个功能将竞争共享资源）。依赖于这种架构，这个影响会很大。即使上传和下载速度相同（多数IP网络不是这样的，而是以下载速度：上传速度为3：1的比例进行设计），文件读取操作通常是从缓存中读，而写操作最终是要写道磁盘（在最终一致的情况下，也许还要多次写）。即使所有东西都在内存中或者都从磁盘上读取（如SSD），数据库写操作几乎总是比读操作慢。（Pole Position，一个数据库基准测试的开源工具，&lt;a href="http://polepos.org/"&gt;http://polepos.org/&lt;/a&gt;，测试结果见&lt;a href="http://polepos.sourceforge.net/results/PolePositionClientServer.pdf"&gt;http://polepos.sourceforge.net/results/PolePositionClientServer.pdf&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;该设计的另一个潜在问题是像Apache或lighttpd这样的web服务器通常有可以维持的并发连接数量的上限（默认值为500左右，但可以更高）。在高流量下，写操作会迅速消耗完允许的并发连接数。由于读操作可以是异步的，或借助于其他性能优化方法，如gzip压缩或分块传输编码，web服务器可以在读操作之间更快速地切换服务，以及在客户端之间快速切换从而能够在每秒内服务于比连接最大值（使用Apache，将最大连接数设置为500，每秒服务数千个读操作请求并不罕见）更多的请求。另一方面，写操作倾向于在图片上传期间维持一个打开的连接，在多数家庭网络中，上传一个1MB的文件需要花费多于1秒的时间，这样web服务器仅可以处理500个这样的并发写操作。
&lt;img src ="/assets/uploads/pics/imageHosting2.png" alt="imageHosting2.png"&gt;
&lt;center&gt;图1.2：切分读写操作&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;为这类瓶颈做规划是将图片的读写操作切分成独立服务的一个很好的案例。如图1.2所示。这就允许我们单独地对两者中任意一个做扩展（因为通常读操作总是比写操作多），也有助于厘清每个点上正在发生的事情。最后，这也分离了未来的忧患，从而更易于排解故障和对读操作较慢这类问题进行扩展。&lt;/p&gt;
&lt;p&gt;这种方法的优势在于我们能够将问题独立于其他问题地进行解决---我们无需担心相同上下文中新图片的写操作和检索。这两个服务仍然基于全局图片语料，但可以通过与服务相适应的方法（例如：排队请求，或缓存常用图片---更多相关内容见下文）随意地优化它们的性能。从维护与成本的角度来看，每个服务都可以按需独立地扩展，这一点非常重要，因为如果服务是掺杂混合的，在上述场景中，一个服务会无意地影响另一个服务的性能。&lt;/p&gt;
&lt;p&gt;当然，若你有两个不同的端点，那么上述例子能够工作得很好（事实上这非常类似于多个云存储提供商的实现和内容分发网络）。虽然有很多方法可以解决这类瓶颈，但每个都有不同的权衡折中。&lt;/p&gt;
&lt;p&gt;例如，Flickr通过将用户分散到不同的数据库分片上来解决这个读/写问题，这样每个数据库分片仅能够处理一定数量的用户，并且随着用户的增加，可以添加更多的数据库分片到服务器集群中（见关于Flickr扩展工作的演示文稿：&lt;a href="http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html"&gt;http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html&lt;/a&gt;（墙外））。在第一个例子中，基于实际使用请求，扩展硬件更容易，Flickr则是随着用户群的变化进行扩展（但要求假设在用户之间的使用情况均衡，从而可以添加额外的容量）。对于前者，如果一个服务存在故障或问题，就会削弱整个系统的功能（例如，没人可以写文件），但若Flickr的一个数据库分片存在故障则仅影响使用该分片的用户。第一个例子中，对整个数据集执行操作更方便---例如，更新写操作服务以包含新的元数据或在所有图片元数据上搜索---对于Flickr的架构，需要更新或搜索每个数据库分片（或者需要创建一个搜索服务来整理元数据---事实上它们也这么做了）。&lt;/p&gt;
&lt;p&gt;对于这些系统的讨论并没有正确的答案，但回归到本章开头叙述的原则，确定系统的需求（频繁读或写或两者皆如此，并发级别，查询整个数据集，范围，排序，等等。），基准测试不同的方案选择，理解系统如何会失效，以及准备一个可靠的计划以应对故障的发生是很有用的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;冗余&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了优雅地处理故障，web架构必须具备冗余的服务和数据。例如，若某文件仅有一个拷贝存储在单个服务器上，那么失去该服务器即意味着失去了该文件。丢失数据很少是件好事，处理该问题的常见方法是创建多个或者说冗余的数据拷贝。&lt;/p&gt;
&lt;p&gt;同样的原则也可应用于服务。如果应用程序的功能有个核心组件，那么确保同时运行多个拷贝或版本能够使系统免于单点故障。&lt;/p&gt;
&lt;p&gt;在系统中创建冗余能够消除可能发生故障的单点，为了灾难恢复提供备份或备用的功能。例如，如果生产中运行着两个相同服务的实例，当其中一个发生故障或功能退化时，系统能够失效&lt;em&gt;失效转移&lt;/em&gt;到健全副本。失效备援可以自动发生或者手动介入。&lt;/p&gt;
&lt;p&gt;服务冗余的另一关键部分是创建一个&lt;em&gt;无共享(shared-nothing)的架构&lt;/em&gt;。使用这种架构，每个节点的运维工作都能独立于其它节点，也没有中心“大脑”来管理状态或协调节点的行为。这有助于提高可扩展性，因为不需要特殊的条件或了解就能添加新的节点。然而，最重要的是这种系统不会有单点故障，因此对于故障更有弹性。&lt;/p&gt;
&lt;p&gt;例如，在我们的图片服务器应用中，所有的图片都在另一处（理想情况是在不同的地理位置，从而能够应对地震或数据中心发生火灾一类的灾难）的硬件上存放着冗余的拷贝，提供图片访问的服务也是冗余的，均潜在地服务于请求（见图1.3.）（负载均衡器是使其成为可能的一种绝佳方法，将在下文详述）。
&lt;img src ="/assets/uploads/pics/imageHosting3.png" alt="imageHosting3.png"&gt;
&lt;center&gt;图1.3：具备冗余的图片托管应用&lt;/center&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;分区&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可能会存在非常大的数据集无法存放在单个服务器上。也可能某个操作需要非常多的计算资源，导致性能降低，需要增强计算能力。对于任一情形，你都有两种选择：纵向或横向扩展。&lt;/p&gt;
&lt;p&gt;纵向扩展即对单个服务器添加更多的资源。因此对于一个非常庞大的数据集来说，这意味着增加更多（或更大的）硬盘，从而单个服务器能够容纳下整个数据集。对于计算操作而言，这意味着将计算迁移到具备更快速的CPU或更大的内存空间的更大的服务器上。任一情况，都是使得单个服务器的资源能够自己解决对于更多资源的需求问题，实现纵向扩展。&lt;/p&gt;
&lt;p&gt;另一方面，横向扩展则是添加更多的节点。针对大数据集的情况，这就是使用第二个服务器来存储数据集的一部分，对于计算资源而言，这意味着将操作或负载分割到额外的节点。为了充分利用横向扩展，应将其作为系统架构的一种本质的设计原则，否则为实现横向扩展而修改系统或分割上下文会相当麻烦。&lt;/p&gt;
&lt;p&gt;说到横向扩展，一种更常见的技术是对服务进行分区，或分块。分区可以是分布式的，这样逻辑功能集之间是相互独立的；可以通过地理边界，或其他标准（如非付费用户 VS. 付费用户）来实现。这些方案的优势是可以提供更强的服务或数据存储能力。&lt;/p&gt;
&lt;p&gt;在我们的图片服务器例子中，&lt;/p&gt;</summary><category term="分布式系统"></category><category term="翻译"></category></entry><entry><title>精心挑选的数据可视化工具推荐列表（译）</title><link href="http://youngsterxyf.github.io/2013/01/15/a-carefully-selected-list-of-recommended-tools/" rel="alternate"></link><updated>2013-01-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-15:2013/01/15/a-carefully-selected-list-of-recommended-tools/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://datavisualization.ch/tools/selected-tools/"&gt;A Carefully Selected List of Recommended Tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当我和很多人谈论我们的工作时，经常被问到我们使用什么技术实现交互式和动态的数据可视化。对于实现交互式的东西，我们有一套首选的代码库、应用程序以及服务，在工作中经常使用。根据项目的需求，我们会选择最合适的工具来完成工作。有时，为构建某些有用的东西你所需要的可能就是一个非常简单的工具。在别的情况下，则可能需要一套用于解决多种问题的工具集。但是如何选择恰当的工具呢？可用的工具数都数不清，所以很多时候朋友的推荐非常有价值。&lt;/p&gt;
&lt;p&gt;这就是为什么我们要将使用得最多并且喜欢使用的工具汇集起来。我们将这个精选工具集称为&lt;strong&gt;&lt;a href="http://selection.datavisualization.ch/"&gt;selection.datavisualization.ch&lt;/a&gt;&lt;/strong&gt; 。它包含绘制地图数据的代码库，创建图表的框架，以及简化数据处理的工具。即使你不喜欢编程，也可以不用写一行代码就能使用某些应用。我们会将该工具列表看作一个动态变化的仓库，随着技术发展增删某些东西。我们希望这能帮助你为下一个工作任务找到最佳的工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://selection.datavisualization.ch"&gt;&lt;img alt="datavisualization_selection" src="http://datavisualization.ch/wp-content/uploads/2012/05/datavisualization_selection_021.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在我来回答一些你最可能会问的问题：不，该列表并没有收录所有相关工具，所以你可能没看到你个人喜欢的。是的，其中提到的某些库刚刚兴起，可能还没到可以应用于产品的时候，而另一些库也已经有了替代者，但它们仍然可以提供良好的服务。&lt;/p&gt;</summary><category term="数据可视化"></category><category term="翻译"></category></entry><entry><title>github pages构建失败问题解决</title><link href="http://youngsterxyf.github.io/2013/01/08/fix-github-pages-builds-failed/" rel="alternate"></link><updated>2013-01-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-08:2013/01/08/fix-github-pages-builds-failed/</id><summary type="html">&lt;p&gt;今天为本博客提交更新后，github
pages自动构建始终不成功。原以为是新提交中引入了错误，于是按照&lt;a href="/2013/01/08/git-cancel-commits/"&gt;Git操作：强制删除提交到远程版本库的数据与版本记录&lt;/a&gt;的方法取消了所有的更新，但依旧没用。&lt;/p&gt;
&lt;p&gt;由于构建的结果邮件中只有这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The page build failed with the following error: page build failed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于构建失败的原因一丁点都没有告诉我们，所以根本没法调试嘛。&lt;/p&gt;
&lt;p&gt;在阅读github的官方帮助文档&lt;a href="https://help.github.com/articles/pages-don-t-build-unable-to-run-jekyll"&gt;Pages don't build: "Unable to run Jekyll"&lt;/a&gt;后，决定按照其中Syntax errors部分的内容做如下尝试：&lt;/p&gt;
&lt;p&gt;首先，按照&lt;a href="https://github.com/mojombo/jekyll/wiki/install"&gt;jekyll的官方安装文档&lt;/a&gt;安装jekyll：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo gem install jekyll
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，在博客的根目录下，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;jekyll --safe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令会输出详细的信息，如果构建失败，则在输出的信息中查找错误原因，比如本博客构建失败的原因出在文章的头部添加了如下类似的标记：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;category:
    - Algorithms
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;导致之后一行的tags标记数据在构建时出错。我直接将每次执行构建 &lt;code&gt;jekyll --safe&lt;/code&gt;
提示的错误信息中相关的category标记直接删除(也许其后加个空行就可以了，没尝试过)，然后重新执行构建，依次循环，直到构建成功。然后将数据提交到远程版本库。&lt;/p&gt;
&lt;p&gt;由于jekyll本地构建时输出的信息也比较隐晦，很难一下子找到问题所在。比如提示
&lt;code&gt;Algorithms&lt;/code&gt; 元素构建出错，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Not creating a link for ref_id = &amp;quot;0&amp;quot;.Liquid Exception: undefined method `gsub&amp;#39; for [&amp;quot;Algorithms&amp;quot;]:Array in post
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但没说是哪篇文章的哪一行，没办法只好使用grep查找：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep Algorithms _posts/*
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;找出所有存在Algorithms单词的文章，然后逐个文章打开查看。&lt;/p&gt;</summary><category term="github"></category><category term="jekyll"></category></entry><entry><title>Git操作：强制删除提交到远程版本库的数据与版本记录</title><link href="http://youngsterxyf.github.io/2013/01/08/git-cancel-commits/" rel="alternate"></link><updated>2013-01-08T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-08:2013/01/08/git-cancel-commits/</id><summary type="html">&lt;p&gt;今天因为某些尚不明了的问题导致，博客的Git pages始终构建失败，于是想在远程版本库中删除前几次提交。在&lt;a href="http://www.douban.com/note/189603387/"&gt;该网页&lt;/a&gt;上找到了解决方案：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git reset --hard HEAD~2                   &lt;span class="c"&gt;# 取消当前版本之前的两次提交&lt;/span&gt;
git push origin HEAD --force              &lt;span class="c"&gt;# 强制提交到远程版本库，从而删除之前的两次提交数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Git"></category><category term="版本控制"></category></entry><entry><title>装饰器与函数式Python（译）</title><link href="http://youngsterxyf.github.io/2013/01/04/Decorators-and-Functional-Python/" rel="alternate"></link><updated>2013-01-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-04:2013/01/04/Decorators-and-Functional-Python/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://www.brianholdefehr.com/decorators-and-functional-python"&gt;Decorators and Functional Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装饰器是Python的一大特色。除了在语言中的原本用处，还帮助我们以一种有趣的方式（函数式）进行思考。&lt;/p&gt;
&lt;p&gt;我打算自底向上解释装饰器如何工作。首先解释几个话题以帮助理解装饰器。然后，深入一点探索几个简单的装饰器以及它们如何工作。最后，讨论一些更高级的使用装饰器的方式，比如：传递可选参数给装饰器或者串接几个装饰器。&lt;/p&gt;
&lt;p&gt;首先以我能想到的最简单的方式来定义Python函数是什么。基于该定义，我们可以类似的简单方式来定义装饰器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数是一个完成特定任务的可复用代码块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好的，那么装饰器又是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是一个修改其他函数的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在在装饰器的定义上进行详述，先解释一些先决条件。&lt;/p&gt;
&lt;h2&gt;函数是一等对象&lt;/h2&gt;
&lt;p&gt;Python中，所有东西都是对象。这意味着可以通过名字引用函数，以及像其他对象那样传递。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;traveling_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Here I am!&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;function_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;func&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;traveling_function&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;trav_func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;function_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;func&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;trav_func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; Here I am!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;traveling_function&lt;/code&gt; 被赋值给 &lt;code&gt;function_dict&lt;/code&gt; 字典中键 &lt;code&gt;func&lt;/code&gt; 的值，仍旧可以正常调用。&lt;/p&gt;
&lt;h2&gt;一等函数允许高阶函数&lt;/h2&gt;
&lt;p&gt;我们可以像其他对象那样传递函数。可以将函数作为值传递给字典，放在列表中，或者作为对象的属性进行赋值。那为什么不能作为参数传给另一个函数呢？当然可以！如果一个函数接受另一个函数作为其参数或者返回另一个函数，则称之为高阶函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;self_absorbed_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m an amazing function!&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;printer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;The function passed to me says: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;# Call `printer` and give it `self_absorbed_function` as an argument&lt;/span&gt;
&lt;span class="n"&gt;printer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self_absorbed_function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; The function passed to me says: I&amp;#39;m an amazing function!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在你也看到函数可以作为参数传给另一个函数，而且传给函数的函数还可以调用。这允许我们创建一些有意思的函数，例如装饰器。&lt;/p&gt;
&lt;h2&gt;装饰器基础&lt;/h2&gt;
&lt;p&gt;本质上，装饰器就是一个以另一个函数为参数的函数。大多数情况下，它们会返回所包装函数的一个修改版本。来看个我们能想到的最简单的装饰器---同一性（identity）装饰器，或许对我们理解装饰器的工作原理有所帮助。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;identity_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m a normal function.&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# `decorated_function` 是 `identity_function` 返回的函数，也就是嵌套函数 `wrapper`&lt;/span&gt;
&lt;span class="n"&gt;decorated_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;identity_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# 如下调用 `identity_function` 返回的函数&lt;/span&gt;
&lt;span class="n"&gt;decorated_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; I&amp;#39;m a normal function&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里， &lt;code&gt;identity_decorator&lt;/code&gt;
根本没有修改它包装的函数，只是简单地返回一个函数（wrapper），这个函数在被调用之时，会去调用原来作为 &lt;code&gt;identity_decorator&lt;/code&gt; 参数的函数。这是个没有用处的装饰器！&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;identity_decorator&lt;/code&gt; 的有趣之处是 &lt;code&gt;wrapper&lt;/code&gt; 能够访问变量 &lt;code&gt;func&lt;/code&gt; ，即使
&lt;code&gt;func&lt;/code&gt; 并非是它的参数。这归因于闭包。&lt;/p&gt;
&lt;h2&gt;闭包&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是一个花哨的术语，意为声明一个函数时，该函数会维持一个指向声明所处词法环境的引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上例中定义的函数 &lt;code&gt;wrapper&lt;/code&gt; 能够在其局部作用域（local scope）中访问
&lt;code&gt;func&lt;/code&gt;。这意味着在 &lt;code&gt;wrapper&lt;/code&gt; （返回并赋值给变量 &lt;code&gt;decorated_function&lt;/code&gt; ）的整个生命周期内，它都可以访问 &lt;code&gt;func&lt;/code&gt; 变量。一旦 &lt;code&gt;identity_decorator&lt;/code&gt;返回，那么访问 &lt;code&gt;func&lt;/code&gt; 的唯一方式就是通过 &lt;code&gt;decorated_function&lt;/code&gt; 。 &lt;code&gt;func&lt;/code&gt; 只作为一个变量存在于 &lt;code&gt;decorated_function&lt;/code&gt; 作用域环境的内部。&lt;/p&gt;
&lt;h2&gt;一个简单的装饰器&lt;/h2&gt;
&lt;p&gt;现在我们来创建一个确实有点用的装饰器。这个装饰器所做的就是记录它所修改的函数被调用了多少次。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;logging_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;The function I modify has been called {0} time(s)&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m a normal function.&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;modified_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;modified_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; The function I modify has been called 1 time(s).&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; I&amp;#39;m a normal function.&lt;/span&gt;

&lt;span class="n"&gt;modified_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; The function I modify has been called 2 time(s).&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; I&amp;#39;m a normal function.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们说装饰器会修改函数，这样来想对理解也是有帮助的。但如例子所见，
&lt;code&gt;logging_decorator&lt;/code&gt; 返回的是一个类似于 &lt;code&gt;a_function&lt;/code&gt;
的新函数，只是多了一个日志特性。&lt;/p&gt;
&lt;p&gt;上例中， &lt;code&gt;logging_decorator&lt;/code&gt; 不仅接受一个函数作为参数，并且返回一个函数，
&lt;code&gt;wrapper&lt;/code&gt; 。每次 &lt;code&gt;logging_decorator&lt;/code&gt; 返回的函数得到调用，它就对 &lt;code&gt;wrapper.count&lt;/code&gt; 的值加1，打印出来，然后调用 &lt;code&gt;logging_decorator&lt;/code&gt; 包装的函数。&lt;/p&gt;
&lt;p&gt;你也许正疑惑为什么我们的计数器是 &lt;code&gt;wrapper&lt;/code&gt; 的一个属性而不是一个普通的变量。难道 &lt;code&gt;wrapper&lt;/code&gt; 的闭包环境不是让我们访问在其局部作用域中声明的任意变量么？是的，但有个问题。Python中，闭包允许对其函数作用域链中任一变量的进行任意读操作，但只允许对可变对象（列表、字典、等等）进行写操作。整数在Python中是非可变对象，因此我们不能修改 &lt;code&gt;wrapper&lt;/code&gt; 内部整型变量的值。相反，我们将计数器作为 &lt;code&gt;wrapper&lt;/code&gt; 的一个属性---一个可变对象，因此可以随我们自己增大它的值。&lt;/p&gt;
&lt;h2&gt;装饰器语法&lt;/h2&gt;
&lt;p&gt;在前一个例子中，我们看到可以将一个函数作为参数传给装饰器，从而使用装饰器函数对该函数进行包装。然而，Python还有一个语法模式使得这一切更加直观，更容易阅读，一旦你熟悉了装饰器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# In the previous example, we used our decorator function by passing the&lt;/span&gt;
&lt;span class="c"&gt;# function we wanted to modify to it, and assigning the result to a variable&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m happiest when decorated.&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# Here we will make the assigned variable the same name as the wrapped function&lt;/span&gt;
&lt;span class="n"&gt;some_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# We can achieve the exact same thing with this syntax:&lt;/span&gt;

&lt;span class="nd"&gt;@logging_decorator&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m happiest when decorated&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用装饰器语法，鸟瞰其中发生的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解释器到达被装饰的函数，编译 &lt;code&gt;some_function&lt;/code&gt;，并将其命名为 'some_function'。&lt;/li&gt;
&lt;li&gt;然后将该函数传递给装饰行中指定的装饰器函数（ &lt;code&gt;logging_function&lt;/code&gt; ）。&lt;/li&gt;
&lt;li&gt;装饰器函数（通常是用来包装原函数的另一个函数）的返回值取代原来的函数（&lt;code&gt;some_function&lt;/code&gt; ），绑定到变量名 &lt;code&gt;some_function&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将这些步骤记住，让我们来更清晰地解释 &lt;code&gt;identity_decorator&lt;/code&gt; 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;identity_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c"&gt;# Everything here happens when the decorator LOADS and is passed&lt;/span&gt;
    &lt;span class="c"&gt;# the function as decribed in step 2 above&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="c"&gt;# Things here happen each time the final wrapped function gets CALLED&lt;/span&gt;
        &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;希望那些注释有助于理解。每次调用被包装的函数，仅执行装饰器返回的函数中的指令。返回函数之外的指令仅执行一次---上述步骤2中描述的：装饰器首次接收到传递给它的待包装函数之时。&lt;/p&gt;
&lt;p&gt;在观察更多的有意思的装饰器之前，我想再解释一样东西。&lt;/p&gt;
&lt;h2&gt;*args与**kwargs&lt;/h2&gt;
&lt;p&gt;以前你也许有时会把这两者相混淆了。让我们一次性地讨论它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过在形参列表中使用 &lt;code&gt;*args&lt;/code&gt; 语法，python函数能够接收可变数量的位置参数(positional arguments)。 &lt;code&gt;*args&lt;/code&gt; 会将所有没有关键字的参数放入一个参数元组中，在函数里可以访问元组中的参数。相反，将 &lt;code&gt;*args&lt;/code&gt; 用于函数调用时的实参列表之时，它会将参数元组展开成一系列的位置参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;function_with_many_arguments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;

&lt;span class="c"&gt;# `args` within the function will be a tuple of any arguments we pass&lt;/span&gt;
&lt;span class="c"&gt;# which can be used within the function like any other tuple&lt;/span&gt;
&lt;span class="n"&gt;function_with_many_arguments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; (&amp;#39;hello&amp;#39;, 123, True)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;function_with_3_parameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;num is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;boolean is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boolean&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;string is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;

&lt;span class="n"&gt;arg_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;decorators&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;# arg_list will be expanded into 3 positional arguments by the `*` symbol&lt;/span&gt;
&lt;span class="n"&gt;function_with_3_parameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arg_list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; num is 1&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; boolean is False&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt;&amp;gt; string is decorators&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重述一遍：在形参列表中， &lt;code&gt;*args&lt;/code&gt;会将一系列的参数压缩进一个名为'args'的元组，而在实参列表中， &lt;code&gt;*args&lt;/code&gt; 会将一个可迭代的参数数据结构展开为一系列的位置实参应用于函数。&lt;/p&gt;
&lt;p&gt;如你所见在实参展开的例子中， &lt;code&gt;*&lt;/code&gt; 符号可与'args'之外的名字一起使用。当压缩/展开一般的参数列表，使用 &lt;code&gt;*args&lt;/code&gt; 的形式仅仅是一种惯例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;**kwargs&lt;/code&gt; 与 &lt;code&gt;*args&lt;/code&gt; 的行为类似，但用于关键字参数而非位置参数。如果在函数的形参列表中使用 &lt;code&gt;**kwargs&lt;/code&gt; ，它会收集函数收到的所有额外关键字参数，放入一个字典中。如果用于函数的实参列表，它会将一个字典展开为一系列的关键字参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;funtion_with_many_keyword_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;

&lt;span class="n"&gt;function_with_many_keyword_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;apples&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;bananas&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;cantalopes&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; {&amp;#39;a&amp;#39;:&amp;#39;apples&amp;#39;, &amp;#39;b&amp;#39;:&amp;#39;bananas&amp;#39;, &amp;#39;c&amp;#39;:&amp;#39;cantalopes&amp;#39;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multiply_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;

&lt;span class="n"&gt;arg_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;count&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Brian&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;multiply_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;arg_dict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; BrianBrianBrian&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;既然你理解了 &lt;code&gt;*args&lt;/code&gt; 与 &lt;code&gt;**kwargs&lt;/code&gt; 的工作原理，那么我们就继续研究一个你会发现很有用的装饰器。&lt;/p&gt;
&lt;h2&gt;缓存制表（Memoization）&lt;/h2&gt;
&lt;p&gt;缓存制表是避免潜在的昂贵的重复计算的一种方法，通过缓存函数每次执行的结果来实现。这样，下一次函数以相同的参数执行，就可以从缓存中获取返回结果，不需要再次计算结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;memoize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;

&lt;span class="nd"&gt;@memoize&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;an_expensive_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可能注意到了示例代码中一个奇怪的 &lt;code&gt;@wraps&lt;/code&gt; 装饰器。在完整地讨论 &lt;code&gt;memoize&lt;/code&gt;
之前我将简要地解释这个装饰器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用装饰器的一个副作用是被包装的函数失去了本来有的 &lt;code&gt;__name__&lt;/code&gt; ， &lt;code&gt;__doc__&lt;/code&gt; ， 以及 &lt;code&gt;__module__&lt;/code&gt; 属性。 &lt;code&gt;wraps&lt;/code&gt; 函数是一个包装另一个装饰器返回的函数的装饰器，将那三个属性的值恢复为函数未装饰之时的值。例如： 如果不使用 &lt;code&gt;wraps&lt;/code&gt; 装饰器， &lt;code&gt;an_expensive_function&lt;/code&gt; 的名字（通过 &lt;code&gt;an_expensive_function.__name__&lt;/code&gt; 可以看到）将是 'wrapper' 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我认为 &lt;code&gt;memoize&lt;/code&gt; 是一个很好的装饰器用例。它服务于一个很多函数都需要的目的，通过将它创建为一个通用装饰器，我们可以将它的功能应用于任一能够从其中获益的函数。这就避免了在多种不同的场合重复实现这个功能。因为不需要重复自己，所以我们的代码更容易维护，并且更容易阅读和理解。只要读一个单词你就能立刻理解函数使用了缓存制表。&lt;/p&gt;
&lt;p&gt;需要提醒的是：缓存制表仅适用于纯函数。也就是说给定一个特定的参数设置，函数确定总会产生相同的结果。如果函数依赖于不作为参数传递的全局变量、I/O、或者其它任意可能影响返回值的东西，缓存制表会产生令人迷惑的结果！并且，一个纯函数不会有任何副作用。因此，如果你的函数会增大一个计数器，或者调用另一个对象的方法，或者其它任意不在函数的返回结果中表示的东西，当结果是从缓存中返回时，副作用操作并不会得到执行。&lt;/p&gt;
&lt;h2&gt;类的装饰器&lt;/h2&gt;
&lt;p&gt;最初，我们说装饰器是一个修改另一个函数的函数，但其实它们可以用于修改类或者方法。对类进行装饰并不常见，但某些情况下作为元类(metaclass)的一个替代，类的装饰器是一个有用的工具。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;important&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;stuff&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add_foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;klass&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;klass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;klass&lt;/span&gt;


&lt;span class="nd"&gt;@add_foo&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;brian&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;brian&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; [&amp;#39;important&amp;#39;, &amp;#39;foo&amp;#39;, &amp;#39;stuff&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，类 &lt;code&gt;Person&lt;/code&gt; 的任一对象都有一个超级重要的 &lt;code&gt;foo&lt;/code&gt;
属性！注意，因为我们装饰的是一个类，所以装饰器返回的不是一个函数，而是一个类。更新一下装饰器的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是一个修改函数、或方法、或类的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;装饰器类&lt;/h2&gt;
&lt;p&gt;事实证明我早先对你隐瞒了一些其它事情。不仅装饰器可以装饰一个类，并且装饰器也可以是一个类！对于装饰器的唯一要求就是它的返回值必须可调用(callable)。这意味着装饰器必须实现 &lt;code&gt;__call__&lt;/code&gt; 魔术方法，当你调用一个对象时，会隐式调用这个方法。函数当然是隐式设置这个方法的。我们重新将 &lt;code&gt;identity_decorator&lt;/code&gt; 创建为一个类来看看它是如何工作的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;IdentityDecorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__call__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="nd"&gt;@IdentityDecorator&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m a normal function.&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; I&amp;#39;m a normal function.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如下是上例中发生的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 &lt;code&gt;IdentityDecorator&lt;/code&gt; 装饰 &lt;code&gt;a_function&lt;/code&gt; 时，它的行为就和装饰器函数一样。这个代码片段等价于上例中的装饰器语法： &lt;code&gt;a_function = IdentityDecorator(a_function)&lt;/code&gt; 。调用（实例化）该装饰器类时，需将其装饰的函数作为一个实参传递给它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例化 &lt;code&gt;IdentityDecorator&lt;/code&gt; 之时，会以被装饰的函数作为实参调用初始化函数 &lt;code&gt;__init__&lt;/code&gt; 。本例中，初始化函数所做的事情就是将被装饰函数赋值给一个属性，这样之后就可以通过其它方法进行调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，调用 &lt;code&gt;a_function&lt;/code&gt; （实际上是返回的包装了 &lt;code&gt;a_function&lt;/code&gt; 的 &lt;code&gt;IdentityDecorator&lt;/code&gt; 对象）之时，会调用对象的 &lt;code&gt;__call__&lt;/code&gt; 方法。这仅是一个同一性装饰器，所以方法只是简单地调用了该类所装饰的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次更新一下我们对装饰器的定义！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是一个修改函数、方法或者类的可调用对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;带参数的装饰器&lt;/h2&gt;
&lt;p&gt;有时，需要根据不同的情况改变装饰器的行为。你可以通过传参来做到这一点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;argumentative_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gift&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func_wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;returned_wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
             &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I don&amp;#39;t like this &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gift&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;you gave me!&amp;quot;&lt;/span&gt;
             &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gift&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;returned_wrapper&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func_wrapper&lt;/span&gt;

&lt;span class="nd"&gt;@argumentative_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sweater&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;grateful_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gift&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I love the &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gift&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;!Thank you!&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;grateful_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; I don&amp;#39;t like this sweater you gave me!&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; I love the sweater! Thank you!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们来看看如果不使用装饰器语法这个装饰器函数是如何工作的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# If we tried to invoke without an argument:&lt;/span&gt;
&lt;span class="n"&gt;grateful_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argumentative_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grateful_function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# But when given an argument, the pattern changes to:&lt;/span&gt;
&lt;span class="n"&gt;grateful_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argumentative_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sweater&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;grateful_function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的地方是：当给定参数，首先仅以那些参数调用装饰器---被包装的函数并不在参数中。装饰器调用返回后，装饰器要包装的函数被传递给装饰器初始调用返回的函数（本例中，为 &lt;code&gt;argumentative_decorator("sweater")&lt;/code&gt; 的返回值）。&lt;/p&gt;
&lt;p&gt;逐步地：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解释器到达被装饰函数之处，编译 &lt;code&gt;grateful_function&lt;/code&gt; ，并将其绑定到名字'grateful_function'。&lt;/li&gt;
&lt;li&gt;传递参数"sweater"调用 &lt;code&gt;argumentative_decorator&lt;/code&gt; ，返回 &lt;code&gt;func_wrapper&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;以 &lt;code&gt;grateful_function&lt;/code&gt; 为参调用 &lt;code&gt;func_wrapper&lt;/code&gt; ，返回 &lt;code&gt;returned_wrapper&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;最后， &lt;code&gt;returned_wrapper&lt;/code&gt; 取代原来的函数 &lt;code&gt;grateful_function&lt;/code&gt; ，并绑定到名字'grateful_function' 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我想这一过程相比没有装饰器参数理解起来更难一点，但是如果你花些时间将其理解通透，我希望是有意义的。&lt;/p&gt;
&lt;h2&gt;带可选参数的装饰器&lt;/h2&gt;
&lt;p&gt;有多种方式让装饰器接受可选参数。根据你是想使用位置参数、关键字参数还是两者皆是，需要使用稍微不同的模式。如下我将展示一种接受一个可选关键字参数的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="n"&gt;GLOBAL_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Brian&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;GLOBAL_NAME&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;actual_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;returned_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My name is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;returned_func&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="c"&gt;# User passed in a name argument&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;waiting_for_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;actual_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;waiting_for_func&lt;/span&gt;

    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;actual_decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@print_name&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I like the name!&amp;quot;&lt;/span&gt;

&lt;span class="nd"&gt;@print_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Matt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;another_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hey, that&amp;#39;s new!&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; My name is Brian&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; I like that name!&lt;/span&gt;

&lt;span class="n"&gt;another_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; My name is Matt&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; Hey, that&amp;#39;s new!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们传递关键字参数 &lt;code&gt;name&lt;/code&gt; 给 &lt;code&gt;print_name&lt;/code&gt;
，那么它的行为就与前一个例子中的 &lt;code&gt;argumentative_decorator&lt;/code&gt; 相似。即，首先以
&lt;code&gt;name&lt;/code&gt; 为参调用 &lt;code&gt;print_name&lt;/code&gt; 。然后，将待包装的函数传递给首次调用返回的函数。&lt;/p&gt;
&lt;p&gt;如果我们没有提供 &lt;code&gt;name&lt;/code&gt; 实参， &lt;code&gt;print_name&lt;/code&gt; 的行为就与前面我们看到的不带参数的装饰器一样。装饰器仅以待包装的函数作为唯一的参数进行调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print_name&lt;/code&gt;
支持两种可能性。它会检查是否收到作为参数的被包装函数。如果没有，则返回函数
&lt;code&gt;waiting_for_func&lt;/code&gt;
，该函数可以被包装函数作为参数进行调用。如果收到被包装函数作为参数，则跳过中间步骤，直接调用 &lt;code&gt;actual_decorator&lt;/code&gt; 。&lt;/p&gt;
&lt;h2&gt;串接装饰器&lt;/h2&gt;
&lt;p&gt;现在来探索一下今天要讲的最后一个装饰器的特性：串接。你可以在任意给定的函数之上堆叠使用多个装饰器， 这种构建函数的方式与使用多重继承构建类相类似。不过最好不要疯狂使用这种特性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@print_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Sam&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@logging_decorator&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;#39;m the wrapped function!&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;some_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; My name is Sam&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; The function I modify has been called 1 time(s).&lt;/span&gt;
&lt;span class="c"&gt;# &amp;gt;&amp;gt; I&amp;#39;m the wrapped function!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当你串接使用装饰器时，它们堆叠的顺序是自底向上的。将被包装的函数 &lt;code&gt;some_function&lt;/code&gt; 经编译后传递给它之上的第一个装饰器（ &lt;code&gt;logging_decorator&lt;/code&gt; ）。然后第一个装饰器的返回值被传递给第二个装饰器。依此逐个应用链上每个装饰器。&lt;/p&gt;
&lt;p&gt;因为我们使用的两个装饰器都是 &lt;code&gt;print&lt;/code&gt;
一个值，然后执行传递给它们的函数，这意味着当调用被包装函数时，链中的最后一个装饰器 &lt;code&gt;print_name&lt;/code&gt; 打印输出中的第一行。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我认为装饰器最大的好处之一在于让你能够从更高的抽象层次进行思考。假如你开始阅读一个函数定义，看到有一个 &lt;code&gt;memoize&lt;/code&gt; 装饰器，你立刻就能明白你正在看的是一个使用缓存制表的函数。如果缓存制表的代码包含在函数体内，就会需要额外的脑力进行解析，并且会有引入误解的可能。使用装饰器也允许代码复用，从而节省时间、简化调试，并且使得重构更加容易。&lt;/p&gt;
&lt;p&gt;玩玩装饰器也是一种很好的学习函数式概念（如高阶函数与闭包）的方式。&lt;/p&gt;
&lt;p&gt;我希望本文阅读起来很愉快，并且内容翔实。&lt;/p&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>Python：字典剧本（译）</title><link href="http://youngsterxyf.github.io/2013/01/04/Python-The-Dictionary-Playbook-cn/" rel="alternate"></link><updated>2013-01-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-04:2013/01/04/Python-The-Dictionary-Playbook-cn/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://blog.amir.rachum.com/post/39501813266/python-the-dictionary-playbook"&gt;Python: The Dictionary Playbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我经常碰到关于Python中字典的各种样板代码，因此我决定在此展示一些，并分享完成相同操作的更加简洁的方式。&lt;/p&gt;
&lt;p&gt;上演： &lt;strong&gt;字典剧本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="playbook" src="/assets/uploads/pics/The_playbook.png" /&gt;&lt;/p&gt;
&lt;p&gt;1.
“你在吗？”&lt;/p&gt;
&lt;p&gt;这个相当简单，但不可错过 - 找出某个键(key)是否存在于字典中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;蹩脚的版本&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Pythonic的方式&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
“尤达测试”(译注：尤达的意思见&lt;a href="http://en.wikipedia.org/wiki/Yoda"&gt;yoda&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;对于那些掌握了“你在吗”剧本的程序员来说，这通常是另一个简单但是令人讨厌的事情。它不仅仅可用于字典数据类型，但非常普通。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;干这事，你必须不能这样&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;英语，你会说吗？&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.
“无论如何也要得到其值”&lt;/p&gt;
&lt;p&gt;这个非常流行。你有一个字典和一个键，然后想修改这个键对应的值。例如，将该值加1（比方说你正在计算某些东西）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;样板&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ket&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;巧妙的方式&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果存在该键， &lt;code&gt;dct.get(key[, default])&lt;/code&gt; 返回 &lt;code&gt;dct[key]&lt;/code&gt; ，否则返回 &lt;code&gt;default&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;更棒的方式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你使用Python 2.7，并且想统计元素的数目，可以使用&lt;a href="http://docs.python.org/2/library/collections.html#collections.Counter"&gt;Counter&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; d = [1, 1, 1, 2, 2, 3, 1, 1]
&amp;gt;&amp;gt;&amp;gt; Counter(d)
Counter({1: 5, 2: 2, 3: 1})
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里有个更完整的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; counter = Counter()
... for _ in range(10):
...     num = int(raw_input(&amp;quot;Enter a number: &amp;quot;))
...     counter.update([num]) 
...
... for key, value in counter.iteritems():
...     print &amp;quot;You have entered {}, {} times!&amp;quot;.format(key, value) 
Enter a number: 1
Enter a number: 1
Enter a number: 2
Enter a number: 3
Enter a number: 51
Enter a number: 1
Enter a number: 1
Enter a number: 1
Enter a number: 2
Enter a number: 3
You have entered 1, 5 times!
You have entered 2, 2 times!
You have entered 3, 2 times!
You have entered 51, 1 times!
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.
“创造可能”(译注：这里"make it happen"还不知道该如何翻译)&lt;/p&gt;
&lt;p&gt;有时你的字典中包含可变对象，你想初始化并修改它们。比方你要把一些数据整理存入一个字典，其值是列表（示例来自&lt;a href="http://stackoverflow.com/questions/3483520/use-cases-for-the-setdefault-dict-method/3483652#3483652"&gt;Stack Overflow上的这个解答&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;详细说明&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;以pythonic方式实现&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefault&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt;     &lt;span class="c"&gt;#key可能已经存在&lt;/span&gt;
    &lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果键存在， &lt;code&gt;setdefault(key, [])&lt;/code&gt; 返回 &lt;code&gt;dct[key]&lt;/code&gt; ，否则将键对应的值设置为 &lt;code&gt;default&lt;/code&gt; 并返回。与 &lt;code&gt;get&lt;/code&gt; 相比，当缺省值是一个你可以修改的对象时，这种方式使你不需要将修改后的值再次插入字典中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Rocking it out&lt;/em&gt; (译注：真心不知道这句该如何翻译)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 所有键都有一个缺省值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;defaultdict&lt;/code&gt; 非常赞！不言自明 —— 带有缺省值的字典。这意味这每次访问 &lt;code&gt;dct&lt;/code&gt; 中的某个键，如果不存在（通常会抛出一个 &lt;code&gt;KeyError&lt;/code&gt; 异常），则以缺省值作为其值创建该键。这就好似使用 &lt;code&gt;setdefault&lt;/code&gt; 来完成每次访问。&lt;/p&gt;
&lt;p&gt;我发现 &lt;code&gt;defaultdict&lt;/code&gt; 的一个有趣用法是实现&lt;a href="http://en.wikipedia.org/wiki/Sparse_matrix"&gt;稀疏数据结构&lt;/a&gt;。设置好 &lt;em&gt;defaultdict&lt;/em&gt; 的缺省值，以坐标（或者任何合适的东西）作为其键。我曾这样去表示多维网格，肯定比使用复杂的列表嵌套简单得多。&lt;/p&gt;
&lt;p&gt;更有意思的一个使用示例见&lt;a href="https://gist.github.com/2012250"&gt;一行代码定义树&lt;/a&gt;&lt;/p&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>一行Python代码定义树（译）</title><link href="http://youngsterxyf.github.io/2013/01/04/one-line-tree-in-Python/" rel="alternate"></link><updated>2013-01-04T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2013-01-04:2013/01/04/one-line-tree-in-Python/</id><summary type="html">&lt;p&gt;原文：&lt;a href="https://gist.github.com/2012250"&gt;One-line Tree in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Python内置的&lt;a href="http://docs.python.org/2/library/collections.html#collections.defaultdict"&gt;defaultdict&lt;/a&gt;可以轻松定义一棵树：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就这样！&lt;/p&gt;
&lt;p&gt;这段代码简单地说明一棵树是一个字典，其缺省的值（译注：与键对应的值的概念）是树。&lt;/p&gt;
&lt;p&gt;（如果你正随着我写下代码，请先确保 &lt;code&gt;from collections import defaultdict&lt;/code&gt; ）&lt;/p&gt;
&lt;p&gt;（还有：Hacker News读者@zbuc指出这种方法被称为&lt;a href="https://en.wikipedia.org/wiki/Autovivification"&gt;自动唤醒&lt;/a&gt;。Cool！）&lt;/p&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;h3&gt;JSON形式&lt;/h3&gt;
&lt;p&gt;现在我们可以创建JSON式的嵌套字典，而无需显式创建子级字典——当我们引用它们，就会神奇地自动产生：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;users&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;harold&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hrldcpr&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;handler&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;matthandlersux&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以使用 &lt;code&gt;print(json.dumps(users))&lt;/code&gt; 将这棵树作为JSON打印出来（译注：先 &lt;code&gt;import json&lt;/code&gt; ），得到如下输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;{&amp;quot;harold&amp;quot;: {&amp;quot;username&amp;quot;: &amp;quot;hrldcpr&amp;quot;}, &amp;quot;handler&amp;quot;: {&amp;quot;username&amp;quot;: &amp;quot;matthandlersux&amp;quot;}}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;无需赋值&lt;/h3&gt;
&lt;p&gt;我们甚至根本不用赋值操作就可以构建树结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;taxonomy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Felidae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Felis&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;cat&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Felidae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Panthera&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;lion&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Canidae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Canis&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dog&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Animalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Chordata&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mammalia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Carnivora&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Canidae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Canis&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;coyote&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Plantae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Solanales&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Solanaceae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Solanum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;tomato&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Plantae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Solanales&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Solanaceae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Solanum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;potato&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Plantae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Solanales&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Convolvulaceae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Ipomoea&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;sweet potato&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这次我们打印得好看些，不过需要先将其转换成标准字典：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dicts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dicts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在可以使用 &lt;code&gt;pprint(dicts(taxonomy))&lt;/code&gt; 漂亮地打印该数据结构（译注：先 &lt;code&gt;from pprint import pprint&lt;/code&gt; ）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;{&amp;#39;Animalia&amp;#39;: {&amp;#39;Chordata&amp;#39;: {&amp;#39;Mammalia&amp;#39;: {&amp;#39;Carnivora&amp;#39;: {&amp;#39;Canidae&amp;#39;: {&amp;#39;Canis&amp;#39;: {&amp;#39;coyote&amp;#39;: {},
                                                                            &amp;#39;dog&amp;#39;: {}}},
                                                      &amp;#39;Felidae&amp;#39;: {&amp;#39;Felis&amp;#39;: {&amp;#39;cat&amp;#39;: {}},
                                                                  &amp;#39;Panthera&amp;#39;: {&amp;#39;lion&amp;#39;: {}}}}}}},
 &amp;#39;Plantae&amp;#39;: {&amp;#39;Solanales&amp;#39;: {&amp;#39;Convolvulaceae&amp;#39;: {&amp;#39;Ipomoea&amp;#39;: {&amp;#39;sweet potato&amp;#39;: {}}},
                           &amp;#39;Solanaceae&amp;#39;: {&amp;#39;Solanum&amp;#39;: {&amp;#39;potato&amp;#39;: {},
                                                      &amp;#39;tomato&amp;#39;: {}}}}}}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们引用的子级结构都以字典形式存在，叶子为空字典。&lt;/p&gt;
&lt;h3&gt;迭代&lt;/h3&gt;
&lt;p&gt;迭代遍历这棵树会比较有趣，也是因为结构在引用的时候就会自动产生。&lt;/p&gt;
&lt;p&gt;例如，假设我们正在解析一个新动物的列表，添加到上面的 &lt;code&gt;taxonomy&lt;/code&gt; 中，我们希望调用如下这样的一个函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;taxonomy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Animalia,Chordata,Mammalia,Cetacea,Balaenopteridae,Balaenoptera,blue whale&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以简单地这样实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再一次我们根本没有对字典赋值，仅通过引用这些键就创建了新的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;{&amp;#39;Animalia&amp;#39;: {&amp;#39;Chordata&amp;#39;: {&amp;#39;Mammalia&amp;#39;: {&amp;#39;Carnivora&amp;#39;: {&amp;#39;Canidae&amp;#39;: {&amp;#39;Canis&amp;#39;: {&amp;#39;coyote&amp;#39;: {},
                                                                            &amp;#39;dog&amp;#39;: {}}},
                                                      &amp;#39;Felidae&amp;#39;: {&amp;#39;Felis&amp;#39;: {&amp;#39;cat&amp;#39;: {}},
                                                                  &amp;#39;Panthera&amp;#39;: {&amp;#39;lion&amp;#39;: {}}}},
                                        &amp;#39;Cetacea&amp;#39;: {&amp;#39;Balaenopteridae&amp;#39;: {&amp;#39;Balaenoptera&amp;#39;: {&amp;#39;blue whale&amp;#39;: {}}}}}}},
 &amp;#39;Plantae&amp;#39;: {&amp;#39;Solanales&amp;#39;: {&amp;#39;Convolvulaceae&amp;#39;: {&amp;#39;Ipomoea&amp;#39;: {&amp;#39;sweet potato&amp;#39;: {}}},
                           &amp;#39;Solanaceae&amp;#39;: {&amp;#39;Solanum&amp;#39;: {&amp;#39;potato&amp;#39;: {},
                                                      &amp;#39;tomato&amp;#39;: {}}}}}}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这个可能不是很有用，且需要一些令人费解的代码（见如上 &lt;code&gt;add()&lt;/code&gt; ）。但是如果你喜欢Python，我希望这个会让你觉得有趣或者值得去理解。&lt;/p&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>几个组合命令</title><link href="http://youngsterxyf.github.io/2012/12/12/several-command-line/" rel="alternate"></link><updated>2012-12-12T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-12:2012/12/12/several-command-line/</id><summary type="html">&lt;p&gt;1.
Debian系Linux下查找某个软件包(以indent为例)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;apt-cache search indent &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{if($1~/^indent$/) print $0}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;APT包管理工具也提供了类似功能的命令选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;apt-cache pkgnames &lt;span class="s1"&gt;&amp;#39;indent&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只不过这个输出仅有包名没有简介信息。&lt;/p&gt;
&lt;p&gt;2.
对当前目录下的所有C源码文件使用indent进行格式化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ls &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;\.c$&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; xargs indent
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实如下也是可以的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;indent *.c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但因为shell会对*进行展开，如果当前目录下的C源码文件数目很大时，可能会造成命令行长度过长的问题。&lt;/p&gt;</summary><category term="Linux"></category><category term="命令行"></category></entry><entry><title>高性能MySQL - 1.MySQL架构</title><link href="http://youngsterxyf.github.io/2012/12/11/high-performance-MySQL-1/" rel="alternate"></link><updated>2012-12-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-11:2012/12/11/high-performance-MySQL-1/</id><summary type="html">&lt;h2&gt;MySQL逻辑架构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="mysql-arch" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/mysql-arch.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;1.
每个客户连接在服务器进程中都拥有自己的线程，每个连接所属的查询都会在指定的某个单独线程中完成，这些线程轮流运行在某个CPU核心或CPU上。服务器负责缓存线程，因此不需要为每个新的连接重建或撤销线程。&lt;/p&gt;
&lt;p&gt;2.
MySQL会解析查询，并创建一个内部数据结构(解析树)，然后对其进行各种优化。其中包括重写查询，决定查询的读表顺序，以及选择需使用的索引等。用户可以通过特殊的关键字给优化器传递各种提示，影响它的决策过程。另外还可以请求服务器给出优化过程的各种说明，使用户可以知晓服务器是如何进行优化决策的，为用户提供一个参考基准，方便用户重写查询、架构和修改相关配置，便于应用尽可能高效地运行。&lt;/p&gt;
&lt;p&gt;优化器并不关心某个表使用哪种存储引擎，但存储引擎对服务器的查询优化过程有影响。优化器会请求存储引擎为某种具体操作提供性能与开销方面的信息，以及表内数据的统计信息。&lt;/p&gt;
&lt;p&gt;不过，在解析查询之前，服务器会"询问"查询缓存，它只能保存SELECT语句和相应的结果。如果能在缓存中找到将要执行的查询，服务器就不必重新解析、优化或重新执行查询，只需直接返回已有结果即可。&lt;/p&gt;
&lt;h2&gt;并发控制&lt;/h2&gt;
&lt;p&gt;1.
读锁(Read Lock)/写锁(Write Lock)：并发控制的概念很简单-在处理并发写或并发读时，系统会使用一套锁系统来解决问题。这种锁系统由两类锁组成，通常称之为 &lt;strong&gt;共享锁&lt;/strong&gt; (Shared Lock)和 &lt;strong&gt;排他锁&lt;/strong&gt; (Exclusive Lock)，或者叫 &lt;strong&gt;读锁&lt;/strong&gt; (Read Lock)和 &lt;strong&gt;写锁&lt;/strong&gt; (Write Lock)。&lt;/p&gt;
&lt;p&gt;2.
锁粒度(Lock Granularity)：一种提高共享资源并发性的方法就是让锁定对象更有选择性。要记住只锁定部分需修改的数据，而不是所有的资源。任何时间，在给定的资源上，被加锁的数据量越小，就可以允许更多的并发修改，只要相互之间互不冲突即可。问题是加锁也会消耗系统资源。每一种锁操作，如获得锁、检查锁是否已解除，以及释放锁等，都会增加系统的开销。所谓的锁策略，就是在锁开销和数据安全之间寻求一种平衡。为此，MySQL提供了多种选择。每种MySQL存储引擎都可以实现独有的锁策略或锁粒度。&lt;/p&gt;
&lt;p&gt;表锁(Table Lock)：开销最小的锁策略&lt;/p&gt;
&lt;p&gt;行级锁(Row Locks)：最大并发处理的锁策略&lt;/p&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;p&gt;事务是一组原子性的SQL查询语句，也可以被看作一个工作单元。如果数据库引擎能够成功地对数据库应用所有的查询语句，它就会执行所有查询，但是，如果任何一条查询语句因为崩溃或其他原因而无法执行，那么所有的语句就都不会执行。也就是说，事务内的语句要么全部执行，要么一句也不执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID&lt;/strong&gt; :&lt;/p&gt;
&lt;p&gt;原子性(Atomicity) - 一个事务必须被视为一个单独的内部"不可分"的工作单元，以确保整个事务要么全部执行，要么全部回滚。&lt;/p&gt;
&lt;p&gt;一致性(Consistency) - 数据库总是从一种一致性状态转换到另一种一致性状态。&lt;/p&gt;
&lt;p&gt;隔离性(Isolation) - 某个事务的结果只有在完成后才对其他事务可见。&lt;/p&gt;
&lt;p&gt;持久性(Durability) - 一旦一个事务提交，事务所做的数据改变将是永久的。&lt;/p&gt;
&lt;p&gt;1.
隔离级：SQL标准定义了4类隔离级，&lt;/p&gt;
&lt;p&gt;READ UNCOMMITTED(读取未提交内容) - 在READ UNCOMMITTED隔离级，所有事务都可以"看到"未提交事务的执行结果。在这种级别上，可能会产生很多问题，所以很少用于实际应用。读取未提交数据，也被称为" &lt;strong&gt;脏读&lt;/strong&gt; "(Dirty Read)。&lt;/p&gt;
&lt;p&gt;READ COMMITTED(读取提交内容) - 大多数数据库系统的默认隔离级别是READ COMMITTED(但这不是MySQL默认的！)。它满足了隔离性的早先定义。也支持所谓的" &lt;strong&gt;不可重复读&lt;/strong&gt; "(Nonrepeatable Read)。这意味着用户运行同一语句两次，看到的结果是不同的。&lt;/p&gt;
&lt;p&gt;REPEATABLE READ(可重复读) - 确保同一事务的多个实例在并发读取数据时，会"看到同样的"数据行。不过理论上，这会导致另一个问题： &lt;strong&gt;幻读&lt;/strong&gt; (Phantom Read)。简单来说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的"幻影"行。InnoDB和Falcon存储引擎通过多版本并发控制机制解决了幻读问题。（MySQL的默认事务隔离级）&lt;/p&gt;
&lt;p&gt;SERIALIZABLE(可串行化) - 最高级别的隔离级，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，SERIALIZABLE是在每个读的数据行上加锁。在这个级别，可能导致大量的超时(Timeout)现象和锁竞争(Lock Contention)现象&lt;/p&gt;
&lt;h2&gt;多版本并发控制&lt;/h2&gt;
&lt;p&gt;MVCC(Multiversion Concurrency Control)是通过及时保存在某些时刻的数据快照，而得以实现的。这意味着同一事务的多个实例，在同时运行时，无论实例运行多久，它们看到的数据视图是一致的。而同一时间，对于同一张表，不同事务看到的数据却是不同的。&lt;/p&gt;
&lt;p&gt;InnoDB通过为每个数据行增加两个隐含值的方式来实现MVCC。这两个隐含值记录了行的创建时间，以及它的过期时间(或者叫删除时间)
。每一行都存储了事件发生时的系统版本号，用来替代事件发生时的实际时间。每一次，开始一个新事务时，版本号都会自动递增。每个事务都会保存它在开始时的"当前系统版本"
的记录，而每个查询都会根据事务的版本号，检查每行数据的版本号。&lt;/p&gt;
&lt;h2&gt;MySQL的存储引擎&lt;/h2&gt;
&lt;p&gt;在文件系统中，MySQL会把每个数据库保存为数据目录下的一个子目录。当创建一个表时，MySQL会在和表名同名的、以.frm为后缀的文件中存储表的定义。因为MySQL使用文件系统来存储数据库名和表定义，大小写敏感将依赖于具体的平台。在Windows平台上，MySQL的实例(Instance)名、表名、数据库名都是大小写不敏感的; 在Unix类平台上，则是大小写敏感的。&lt;/p&gt;
&lt;p&gt;1.
&lt;strong&gt;MyISAM引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，MyISAM将每个表存为两个文件：数据文件和索引文件。两个文件的扩展名分别为.MYD和.MYI。MyISAM的格式是平台通用的，这意味着用户可以在不同架构的服务器上毫无问题地相互拷贝数据文件和索引文件。&lt;/p&gt;
&lt;p&gt;MyISAM表可以包含动态行和静态行(即固定长度行)。MySQL会根据表定义决定选用何种格式。MyISAM表的可容纳的行总数，一般只受限于数据库服务器的可用磁盘空间大小，以及操作系统允许创建的最大文件大小。&lt;/p&gt;
&lt;p&gt;MyISAM的特性：&lt;/p&gt;
&lt;p&gt;-加锁与并发 - MyISAM对整张表进行加锁，而不是行。&lt;/p&gt;
&lt;p&gt;-...&lt;/p&gt;
&lt;p&gt;2.
&lt;strong&gt;InnoDB引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB专为事务处理设计的一款存储引擎，特别是用于处理大量短期(Short-lived)事务，短期事务是指一般能正常完成，不需要回滚的事务。&lt;/p&gt;
&lt;p&gt;InnoDB将所有数据共同存储在一个或几个数据文件中，这种数据文件一般称之为 &lt;strong&gt;表空间&lt;/strong&gt; 。在MySQL 4.1版以及更新版本中，InnoDB也支持将每个表和相关索引存储为单独的分离文件。&lt;/p&gt;
&lt;p&gt;InnoDB使用MVCC机制获取高并发性能，并且实现所有四个标准隔离级别。默认隔离级别是REPEATABLE READ，在这个隔离级上，使用间隙锁策略防止"幻读"问题的产生。&lt;/p&gt;
&lt;p&gt;InnoDB表是基于 &lt;strong&gt;聚簇索引&lt;/strong&gt;
建立的，能提供一种非常快速的主键查找性能。不过，它的辅助索引(Secondary Index，也就是非主键索引)也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义很多索引，则争取尽量把主键定义得小一些。InnoDB不会压缩索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择合适的引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑的因素：事务，并发，备份，崩溃后恢复，特有特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高性能MySQL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://cupoy.iteye.com/blog/251796"&gt;什么是脏读、不可重复读、幻读&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="数据库"></category><category term="MySQL"></category></entry><entry><title>日志信息命令行实时输出</title><link href="http://youngsterxyf.github.io/2012/12/10/tail-and-xtail/" rel="alternate"></link><updated>2012-12-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-10:2012/12/10/tail-and-xtail/</id><summary type="html">&lt;p&gt;Web开发中很多时候需要边看web服务器的日志输出边调试代码。一般的做法使用tail命令输出日志文件的末尾几行日志信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;tail -10 /var/log/nginx/access.log  &lt;span class="c"&gt;# 输出末尾10行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但这样的输出是静态的。在这个命令执行之后，日志文件里新增的日志信息无法直接看到。调试的时候，一遍又一遍地使用这样的命令去查询就显得非常麻烦。那有没有办法来监听日志文件的变化，实时输出最新的日志信息呢？ &lt;strong&gt;xtail&lt;/strong&gt; 就专为这个问题而存在的。它可以监听文件或者目录(监听目录就是监听该目录下的所有文件)。比如我在写本文时，在另一个命令行窗口里执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;xtail ./
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么每次vim保存内容时，那个窗口就会产生事件输出最新的文件内容。&lt;/p&gt;
&lt;p&gt;这样在调试web程序的时候就很方便啦。&lt;/p&gt;
&lt;p&gt;其实tail本身就支持监听文件并实时命令行输出。在xtail的&lt;a href="http://www.unicom.com/sw/xtail"&gt;项目主页&lt;/a&gt;上有这样的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xtail watches the growth of files. It's like running a tail -f on a bunch of files at once. My favorite usage is:&lt;/p&gt;
&lt;p&gt;$ xtail /var/log/*&lt;/p&gt;
&lt;p&gt;You can specify both filenames and directories on the command line. If you specify a directory, it watches all the files in that directory. It will notice when new files are created (and start watching them) or when old files are deleted (and stop watching them).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从中可以看出，tail的-f选项是支持文件监听并实时输出的。tail的man page里说明如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-f, --follow[={name|descriptor}]&lt;/p&gt;
&lt;p&gt;output appended data as the file grows; -f,  --follow,  and --follow=descriptor are equivalent
&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="linux"></category><category term="命令"></category><category term="调试"></category></entry><entry><title>VMware面试题目总结</title><link href="http://youngsterxyf.github.io/2012/12/06/VMware-interview/" rel="alternate"></link><updated>2012-12-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-06:2012/12/06/VMware-interview/</id><summary type="html">&lt;p&gt;&lt;strong&gt;一面&lt;/strong&gt;中主要有三道题：&lt;/p&gt;
&lt;p&gt;1.
实现strcpy。函数原型：char&lt;em&gt; strcpy(char&lt;/em&gt; dest, const char* src)。&lt;/p&gt;
&lt;p&gt;后来发现自己实现的有问题。正确的实现应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个题目做得不好，我对自己很失望啊。&lt;/p&gt;
&lt;p&gt;2.
给2n+1个数，其中n个数均出现了2次，有1个数只出现了1次，如何找出这个数？&lt;/p&gt;
&lt;p&gt;如果用python的dict数据结构来实现会很简单，一次遍历统计每个数出现的次数就可以了。如果是这样的话，就不需要将题目限制为只有一个1个数只出现了一次了，所以肯定有更好的算法。&lt;/p&gt;
&lt;p&gt;其实更好的方法是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;findAppearOnce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;^=&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为两个相同的数异或的结果是0。&lt;/p&gt;
&lt;p&gt;3.
Linux内核态和用户态的区别？进程与线程的区别？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二面&lt;/strong&gt;主要考察英语口语和听力，不记得是否有算法题了，好像没有。英语说得结结巴巴的，幸好交流还不是很困难。&lt;/p&gt;
&lt;p&gt;除英语外，还有问题：&lt;/p&gt;
&lt;p&gt;1.
项目中遇到过的有难度的问题有哪些？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三面&lt;/strong&gt;的面试官感觉各种懂啊，根据我的简历中涉及的相关知识进行提问，各种不会，我真是弱暴了。&lt;/p&gt;
&lt;p&gt;1.
网络数据包如何从网络结点A经过路由器到达结点B？数据包的MAC header和IP eader各主要包含了什么数据？在经过路由器时发生了什么变化？&lt;/p&gt;
&lt;p&gt;2.
git merge？因为我说没用过git的merge功能，因为我github上的项目都是个人项目，所有代码都在master主干上提交的，所以面试官就没在继续问，估计是想问问merge的原理吧？&lt;/p&gt;
&lt;p&gt;3.
有三个文件，找出在三个文件中均出现过的byte。返回的结果是一个byte类型的数组。&lt;/p&gt;
&lt;p&gt;我当时的基本思路和一面中第2道题目的思路差不多，也是遍历三个文件，dict的key为byte值，value为出现过该byte的文件。但这样占的内存有点大。(后来想想，其实还好啦，byte就8位，也就256个不同的值)&lt;/p&gt;
&lt;p&gt;另一个稍微改进一点的方法是：在三个文件中均出现过的byte，也就是三个文件中byte集合的交集。所以可以选取最小的文件，以其中的byte做key，遍历第二个文件，对在1,2文件中均出现的byte设置value标记。第二个文件遍历完成后，取出做过value标记的byte(设为集合X)，然后遍历第三个文件，对在X和第三个文件中均出现的byte做标记，第三个文件遍历完成后，做过value标记的byte即为结果。但这应该不是最佳算法。还有待继续思考。&lt;/p&gt;
&lt;p&gt;更新：同学给出的方案是-使用bitmap，每个文件弄个256位的bitmap，出现的byte就在相应的位上置1，然后三个bitmap按位与一下。靠谱！&lt;/p&gt;
&lt;p&gt;4.
不使用微博的API，使用爬虫尽可能多地抓取某个人(比如李开复)的直接粉丝和间接粉丝(随便有多间接)？如何避免重复抓取相同的粉丝数据？&lt;/p&gt;
&lt;p&gt;5.
前段时间有人说对于JAVA的hash函数(应该是hashCode()方法)，一定规律的多个数都可以生成相同的hash值，对于这个问题，在应用中应该如何解决？&lt;/p&gt;
&lt;p&gt;我的思路是在hash之前，对待hash的值加盐(salt)混合再hash。&lt;/p&gt;
&lt;p&gt;6.
TCP与UDP的区别？UDP主要用于哪些方面？TCP连接3次握手，断开连接4次握手，为什么要4次握手？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;连接终止使用了四路握手过程(four-way handshake)，在这个过程中每个终端的连接都能独立地被终止。因此，一个典型的拆接过程需要每个终端都提供一对FIN和ACK。而建立连接始终是由客户端发起连接的。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.
访问某些网站时，请求结果是“连接被重置”的报告，那么连接被重置的原理是什么？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;连接被重置的本质，是因为收到了破坏连接的一个 TCP Reset 包
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;具体可参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.youxu.info/2010/03/14/west-chamber/"&gt;“西厢计划”原理小解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.google.com/p/scholarzhang/"&gt;“西厢计划”项目主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chinagfw.org/2010/05/tcpgfw.html"&gt;对TCP连接被重置解决方案的探究――跨过GFW通向自由网络的可行途径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hi.baidu.com/gmbiarxfezhmuxe/item/4ac2d1f218abbe1be3e3bd4d"&gt;简述TCP三次握手过程，并说明为什么要3次握手&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;VMware的工作环境很不错，各种Mac，屏幕超大啊(这显得我很diaosi啊)，面试官也很不错，问题也比较有水平。可惜我今天的状态实在不好，各种不会，铁定跪了。唉！diaosi的命。&lt;/p&gt;</summary><category term="VMware"></category><category term="面试"></category></entry><entry><title>博大精深的ps命令</title><link href="http://youngsterxyf.github.io/2012/12/06/profound-ps/" rel="alternate"></link><updated>2012-12-06T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-06:2012/12/06/profound-ps/</id><summary type="html">&lt;p&gt;Linux命令行里如何获取所有的进程号(pid)？&lt;/p&gt;
&lt;p&gt;1.
第一种方法是通过ps -e或者ps aux获得所有进程的信息，然后通过管道传给grep或者awk进行数据过滤，比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps -e &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
其实通过ps自身的选项就可以实现： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps -eo pid
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而且输出还是排好序的。&lt;/p&gt;
&lt;p&gt;但ps命令在输出进程信息之前先输出一行header，比如ps -e的输出header是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;PID TTY          TIME CMD
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如何去除这个header呢？当然用各种过滤方法可以实现，但ps自身的选项也可以实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps -eo pid h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps -eo pid --no-headers
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Linux"></category><category term="命令行"></category><category term="工具"></category></entry><entry><title>2012校招-sonicWALL的两道编程笔试题</title><link href="http://youngsterxyf.github.io/2012/12/05/sonicWALL-exam/" rel="alternate"></link><updated>2012-12-05T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-12-05:2012/12/05/sonicWALL-exam/</id><summary type="html">&lt;h2&gt;求二叉树中两个结点的最近公共祖先&lt;/h2&gt;
&lt;p&gt;比如：对于树&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;         A
       /
      B
    /   \
   C     D
 /   \
E     F
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;结点D，F的最近公共祖先为B&lt;/p&gt;
&lt;p&gt;实现：&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/nearest_common_ancestor.c"&gt;见源码&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;求二进制整数部分bits求反后的值&lt;/h2&gt;
&lt;p&gt;比如：对于整数0b1001101，将第2(begin)到第5(end)位(从右往左计数)上的bit求反，得到0b1110001。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;reverse_somebits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ten_to_two&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ten_to_two&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;b1001101&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ten_to_two&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverse_somebits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注：我的思路没这么简洁，感谢&lt;a href="https://github.com/tinytitan"&gt;涛总&lt;/a&gt;提供这么好的方法。&lt;/p&gt;</summary><category term="笔试"></category><category term="算法"></category></entry><entry><title>CentOS + rsync + inotify-tools实时备份配置</title><link href="http://youngsterxyf.github.io/2012/11/29/centos+rsync+inotify-tools-realtime-backup/" rel="alternate"></link><updated>2012-11-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-29:2012/11/29/centos+rsync+inotify-tools-realtime-backup/</id><summary type="html">&lt;p&gt;现实中，服务器可能会因为各种原因而crash掉，从而造成数据丢失或者服务的暂时不可用。为了提高服务的可用性以及数据的安全性，就需要对数据进行备份，以便数据恢复或者服务的动态切换(将访问请求动态重定向到备份服务器)。&lt;/p&gt;
&lt;p&gt;常见的备份方法是定时的rsync任务或者远程拷贝。但这种方式，如果定时的间隔较大，那么服务器宕掉后，还是会丢失部分数据，动态切换的服务也不是宕机前的最新状态。为了支持实时数据同步，Linux 2.6.13 内核中新引入文件系统变化通知机制inotify，一旦对文件系统有改动，就会触发相关事件任务。通过结合rsync，inotify能够很好地完成实时同步任务。&lt;/p&gt;
&lt;p&gt;主服务器：1.1.1.1
备份服务器：0.0.0.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.
主服务器，备份服务器上安装rsync:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo yum install rsync
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
主服务器上安装inotify-tools:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo yum install inotify-tools
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.
备份服务器上添加配置文件/etc/rsyncd.conf&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;readonly=no
chroot=no
uid=root
gid=root
hosts allow=1.1.1.1
hosts deny=0.0.0.0/32
max connections=10
log file=/var/log/rsyncd.log
pid file=/var/run/rsyncd.pid
lock file=/var/run/rsync.lock
auth users=tongbu
secrets file=/etc/rsync.pass

[website1]
path=/home/yongfeng/apps/website1.org/webroot/upload

[website2]
path=/home/yongfeng/apps/website2.com/webroot/upload

[website3]
path=/home/yongfeng/apps/website3.com/webroot/upload
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以及配置文件/etc/rsync.pass&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;tongbu:somesecurepassword
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;给密码文件赋权:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo chmod &lt;span class="m"&gt;400&lt;/span&gt; /etc/rsync.pass
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（注：tongbu就是用户名，与rsyncd.conf中auth users的值一致。somesecurepassword是密码，会在后面主服务器上的配置密码文件用到）&lt;/p&gt;
&lt;p&gt;4.
在备份服务器上创建需要的目录:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo mkdir -p /home/yongfeng/apps/website1.org/webroot/upload
sudo mkdir -p /home/yongfeng/apps/website2.com/webroot/upload
sudo mkdir -p /home/yongfeng/apps/website3.com/webroot/upload
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;5.
在主服务器上添加配置文件/etc/rsync-client.pass：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;somesecurepassword
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋权限:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod &lt;span class="m"&gt;600&lt;/span&gt; /etc/rsync-client.pass
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.
在主服务器上添加要执行的脚本/home/autoscript/rsyncInotify.sh:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;
src&lt;span class="o"&gt;[&lt;/span&gt;0&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/var/www/apps/website1.org/webroot/upload,website1&amp;#39;&lt;/span&gt;
src&lt;span class="o"&gt;[&lt;/span&gt;1&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/var/www/apps/website2.com/webroot/upload,website2&amp;#39;&lt;/span&gt;
src&lt;span class="o"&gt;[&lt;/span&gt;2&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/var/www/apps/website3.com/webroot/upload,website3&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; item in &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nv"&gt;fromdir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$item&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
    &lt;span class="nv"&gt;module&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$item&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;

    /usr/bin/inotifywait -mrq --timefmt &lt;span class="s1"&gt;&amp;#39;%d/%m/%y %H:%M&amp;#39;&lt;/span&gt; --format &lt;span class="s1"&gt;&amp;#39;%T%w%f&amp;#39;&lt;/span&gt; --event modify,delete,move,create,attrib &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;fromdir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;read &lt;/span&gt;file event
    &lt;span class="k"&gt;do&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$event&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;$file&lt;/span&gt;
        rsync -avz --delete --password-file&lt;span class="o"&gt;=&lt;/span&gt;/etc/rsync-client.pass &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;fromdir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; tongbu@0.0.0.0::&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;module&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*******************************&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋可执行权限:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo chmod +x rsyncInotify.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.
在备份服务器的防火墙中添加规则以允许rsync服务请求---可通过直接编辑文件/etc/sysconfig/iptables，在文件中添加一行内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-A INPUT -s 1.1.1.1 -p tcp -m tcp --dport 873 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8.
备份服务器启动rsync服务:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo /usr/bin/rsync --daemon
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;9.
主服务器启动rsync+inotify服务:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo /home/autoscript/tongbu/rsyncInotify.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;10.
在备份服务器上将rsync服务设置为开机自启动服务---直接编辑配置文件/etc/rc.d/rc.local，添加一行内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/usr/bin/rsync --daemon
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;11.
在主服务器上将rsyncInotify.sh设置为开始自启动---直接编辑配置文件/etc/rc.d/rc.local，添加一行内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/home/autoscript/tongbu/rsyncInotify.sh &amp;gt;&amp;gt; /home/autoscript/tongbu/tongbu.log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.由于rsync命令并没有提供start, stop或者restart等选项，所以想关闭rsync服务，可直接使用sudo pkill rsync杀死rsync服务进程(额，这样是不是过分了点？但我想到的最简便的方法就是这个了)&lt;/p&gt;
&lt;p&gt;2.同样rsyncInotify.sh也存在这样的问题，即使使用sudo pkill rsyncInotify.sh杀死了进程还不够，因为rsyncInotify.sh脚本中调用了inotifywait命令，所以还得sudo pkill inotifywait，否则可能会因为inotifywait进程开得太多，而无法正常运行rsyncInotify.sh。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://jasonyu.cn/post/271/"&gt;rsync+inotify实现目录实时同步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.leezhong.com/project/2010/12/13/inotify-rsync.html"&gt;inotify-rsync实时同步脚本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href="http://www.lvtao.net/html/1968.html"&gt;rsync常见错误&lt;/a&gt;&lt;/p&gt;</summary><category term="服务器"></category><category term="工具"></category><category term="Linux"></category></entry><entry><title>GoAccess用户手册（译）</title><link href="http://youngsterxyf.github.io/2012/11/29/goaccess-man-page-cn/" rel="alternate"></link><updated>2012-11-29T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-29:2012/11/29/goaccess-man-page-cn/</id><summary type="html">&lt;p&gt;原文：&lt;a href="http://goaccess.prosoftcorp.com/man"&gt;http://goaccess.prosoftcorp.com/man&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译：youngsterxyf&lt;/p&gt;
&lt;h2&gt;名称&lt;/h2&gt;
&lt;p&gt;goaccess - 快速的web日志分析器与交互式查看器&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;goaccess  [-f 输入文件]  [-c]  [-e]  [-a]&lt;/p&gt;
&lt;h2&gt;描述&lt;/h2&gt;
&lt;p&gt;goaccess是一个实时的web日志分析器，以及交互式查看器，在类Unix系统的终端(terminal)上运行，是一个基于GPL的自由软件。为需要可视化服务器报告的系统管理员提供快速而重要的HTTP统计信息。首先它会解析web日志文件，从被解析文件中收集数据，然后展示在控制台(console)或者X终端上。收集到的信息会在一个可视化/交互式的窗口中展示给用户，包括：&lt;/p&gt;
&lt;h3&gt;综合统计数字&lt;/h3&gt;
&lt;p&gt;有效请求的总数，无效请求的总数，数据分析的总时间，独立访客总数，被请求的独立文件总数，独立静态文件总数(css, ico, jpg, swf, gif, png)，独立HTTP引荐网站(URL)总数，独立404响应(资源未找到)总数，被解析日志文件的大小，总流量。&lt;/p&gt;
&lt;h3&gt;独立访客&lt;/h3&gt;
&lt;p&gt;相同IP，相同日期以及相同代理(agent)的HTTP请求被看作一个独立请求。(包括网络爬虫)。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;被访问文件&lt;/h3&gt;
&lt;p&gt;总数量基于独立请求文件。基于相同IP，相同日期以及相同代理的HTTP请求被看作一次独立访问这一前提。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;被请求静态文件&lt;/h3&gt;
&lt;p&gt;总数量基于独立请求文件。包括的文件类型：jpg，css，swf，js，gif，png等。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;引荐的URL&lt;/h3&gt;
&lt;p&gt;请求来自于引荐的URL。总数量并非基于上述前提，而是基于请求的总数目。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;404或者资源未找到&lt;/h3&gt;
&lt;p&gt;总数量基于请求总数。这部分的{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;操作系统类型&lt;/h3&gt;
&lt;p&gt;总数量基于独立访客数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;浏览器类型&lt;/h3&gt;
&lt;p&gt;总数量基于独立访客数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;主机&lt;/h3&gt;
&lt;p&gt;总数量基于请求总数。{详细视图}可用。每个IP的{详细视图}会显示该主机的额外信息，包括反向域名解析，IP的定位。&lt;/p&gt;
&lt;h3&gt;HTTP状态码&lt;/h3&gt;
&lt;p&gt;基于请求总数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;引荐的站点&lt;/h3&gt;
&lt;p&gt;这一部分仅显示主机而不是完整的URL。基于请求总数。{详细视图}可用。&lt;/p&gt;
&lt;h3&gt;关键词短语&lt;/h3&gt;
&lt;p&gt;这部分会报告Google搜索，Google缓存以及Google翻译中使用的关键词短语。总数目基于请求总数。{详细视图}可用。&lt;/p&gt;
&lt;h2&gt;命令选项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-f  输入文件&lt;/p&gt;
&lt;p&gt;输入文件的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-c&lt;/p&gt;
&lt;p&gt;提示日期和日志格式配置窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-e&lt;/p&gt;
&lt;p&gt;在主机部分不统计(排除)某IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-a&lt;/p&gt;
&lt;p&gt;为解析到的主机开启一些用户代理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义日志/日期格式&lt;/h2&gt;
&lt;p&gt;GoAccess几乎可以解析任何web日志格式。&lt;/p&gt;
&lt;p&gt;预定义选项包括：Common Log Format(CLF)，Combined Log Format(XLF/ELF)，包含虚拟主机和W3C格式(IIS)。&lt;/p&gt;
&lt;p&gt;GoAccess也允许任意自定义格式字符串。&lt;/p&gt;
&lt;p&gt;有两种方式来配置日志格式。最简单的方式是执行带-c选项的GoAccess以提示配置窗口。另外，也可以在~/.goaccessrc中配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;日期格式(date_format)&lt;/p&gt;
&lt;p&gt;空格之后的date_format变量指定了包含常规字符和特殊格式说明符的任意组合。这些字符都以百分号(%)开始。详见：&lt;a href="http://linux.die.net/man/3/strftime"&gt;http://linux.die.net/man/3/strftime&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志格式(log_format)&lt;/p&gt;
&lt;p&gt;空格之后的date_format变量指定了日志格式字符串。&lt;/p&gt;
&lt;p&gt;%d  匹配date_format变量的日期域&lt;/p&gt;
&lt;p&gt;%h  主机(客户端IP地址，IPv4或IPv6)&lt;/p&gt;
&lt;p&gt;%r  来自客户端的请求行&lt;/p&gt;
&lt;p&gt;%s  服务器返回给客户端的状态码&lt;/p&gt;
&lt;p&gt;%b  返回给客户端的对象大小&lt;/p&gt;
&lt;p&gt;%R  "Referer"HTTP请求头&lt;/p&gt;
&lt;p&gt;%u  用户代理HTTP请求头&lt;/p&gt;
&lt;p&gt;%^  忽略该域&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;交互式菜单&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;F1    主帮助页面&lt;/li&gt;
&lt;li&gt;F5    重绘主窗口&lt;/li&gt;
&lt;li&gt;q     退出程序或者当前{详细视图}(窗口)&lt;/li&gt;
&lt;li&gt;o     打开当前激活模块的详细视图&lt;/li&gt;
&lt;li&gt;c     设置或改变配色方案&lt;/li&gt;
&lt;li&gt;TAB   向前迭代模块。从当前激活模块开始。&lt;/li&gt;
&lt;li&gt;SHIFT + TAB   向后迭代模块。从当前激活模块开始。&lt;/li&gt;
&lt;li&gt;RIGHT ARROW   打开当前激活模块的详细视图&lt;/li&gt;
&lt;li&gt;0-9   激活模块，这样用户就可以使用^o^或^RIGHT ARROW^打开{详细视图}&lt;/li&gt;
&lt;li&gt;SHIFT + 0-9   激活超过10的模块&lt;/li&gt;
&lt;li&gt;s     根据日期进行独立访客排序。仅在独立访客模块(1)有效。&lt;/li&gt;
&lt;li&gt;S     根据点击数进行独立访客排序。仅在独立访客模块(1)有效。&lt;/li&gt;
&lt;li&gt;/     向前在任意{详细视图}窗口搜索输入模式(pattern)。&lt;/li&gt;
&lt;li&gt;n     在任意{详细视图}窗口中找到下一次出现的位置。&lt;/li&gt;
&lt;li&gt;t     跳到第一个条目或屏幕顶端&lt;/li&gt;
&lt;li&gt;b     跳到最后一个条目或者屏幕底部&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;最简单且最快速的用法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# goaccess -f access.log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将产生一个交互式的文本输出。&lt;/p&gt;
&lt;p&gt;生成一个HTML报告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# goaccess -f access.log -a &amp;gt; report.html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要想产生全面的统计信息，我们可以这样执行GoAccess：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# goaccess -f access.log -a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-a标志表明我们想为每个解析到的主机处理一个代理列表。-c标志将提示日期/日志格式配置窗口。仅当curses初始时。&lt;/p&gt;
&lt;p&gt;如果我们想为GoAccess增加更多的灵活性，可以使用一系列的管道。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# zcat access.log.*gz | goaccess
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# zcat access.log.* | goaccess
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另一个有用的管道是根据日期过滤web日志。&lt;/p&gt;
&lt;p&gt;如下命令将得到日志文件中2010年12月5日的所有HTTP请求：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# sed -n &amp;#39;/05\/Dec\/2010/,$ p&amp;#39; access.log | goaccess -a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果想仅解析从日期a到日期b的一个特定时限的日志，则可以：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# sed -n &amp;#39;/5\/Nov\/2010/,/5\/Dec\/2010/ p&amp;#39; access.log | goaccess -a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意这一命令依赖于sed的速度，可能需要更长的解析时间。&lt;/p&gt;
&lt;p&gt;另外，值得指出，如果想以更低的进程调度优先级运行GoAccess，可以这样执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# nice -n 19 goaccess -f access.log -a
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;注释&lt;/h2&gt;
&lt;p&gt;每个{详细视图}窗口中，条目总数目为300。&lt;/p&gt;
&lt;p&gt;以管道的方式将日志传给GoAccess会使得实时功能失效。这归因于确定标准输入的实际大小的可移植性问题。然而，未来的某个版本可能会包含这一特性。&lt;/p&gt;
&lt;h2&gt;BUGS&lt;/h2&gt;
&lt;p&gt;如果你认为你发现了一个bug，请发送一封邮件到goaccess@prosoftcorp.com。&lt;/p&gt;
&lt;h2&gt;作者&lt;/h2&gt;
&lt;p&gt;Gerardo Orellana&lt;/p&gt;
&lt;p&gt;欲知更多详情，或者新版本发布，请访问&lt;a href="http://goaccess.prosoftcorp.com"&gt;http://goaccess.prosoftcorp.com&lt;/a&gt;&lt;/p&gt;</summary><category term="翻译"></category><category term="工具"></category></entry><entry><title>pi的一种并行算法</title><link href="http://youngsterxyf.github.io/2012/11/22/pi-parallel-algorithm/" rel="alternate"></link><updated>2012-11-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-22:2012/11/22/pi-parallel-algorithm/</id><summary type="html">&lt;p&gt;我们都知道圆周率pi的值是3.141592653...，那么这个值是怎么算出来的呢？一种方式是通过某种方式算出圆的面积或者周长，然后根据公式$ S = pi \times r^2 $(或$ L = 2 \times pi \times r $)算出pi的值。但如何用计算机通过某种算法计算而得？有没有并行的算法？&lt;/p&gt;
&lt;p&gt;&lt;a href="/assets/uploads/files/mapreduce_intro.pdf"&gt;Introduction to Parallel Programming and MapReduce&lt;/a&gt;一文中介绍了一种基于概率的并行算法---假设有个正方形，里面有个內切圆。&lt;/p&gt;
&lt;p&gt;&lt;img alt="sample pic" src="/assets/uploads/pics/inscribe.png" /&gt;&lt;/p&gt;
&lt;p&gt;设内切圆的半径为$ r $，则&lt;/p&gt;
&lt;p&gt;正方形的面积为$ S_z = 4r^2 $&lt;/p&gt;
&lt;p&gt;内切圆的面积为$ S_y = pi \times r^2 $&lt;/p&gt;
&lt;p&gt;那么$ pi = \frac{ S_y }{ r^2 } = \frac{ S_y }{ S_z/4 } = \frac{ 4S_y }{ S_z } $&lt;/p&gt;
&lt;p&gt;大量生成属于正方形里的随机点(x, y)，并统计属于内切圆范围内的点的出现次数，当次数达到一定量级之后，属于内切圆范围内的点的数目与随机点的总数目的比即为$ \frac{ S_y }{ S_z } $的近似值，再乘以4即为pi的近似值。&lt;/p&gt;
&lt;p&gt;并且由于任意两个随机数的生成是相互独立的，所以可以使用多个进程/线程/多个计算机来分别计算一定量的随机数，然后把它们计算所得属于内切圆范围的点的数目相加，再根据公式计算pi值。&lt;/p&gt;
&lt;p&gt;假设r的值为单位1，则程序实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;worker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;taskNum&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c"&gt;# set r = 1&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;allcount&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;taskNum&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uniform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uniform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;acquire&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;allcount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task_all_num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;worker_num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;allcount&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt;
    &lt;span class="n"&gt;threads&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="n"&gt;allcount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;mutex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;task_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;task_all_num&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;worker_num&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;worker_num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;worker&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task_num&lt;/span&gt;&lt;span class="p"&gt;,)))&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;pi: &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;4.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;allcount&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;task_all_num&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="n"&gt;TASKALLNUM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;40000000&lt;/span&gt;
    &lt;span class="n"&gt;WORKERNUM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TASKALLNUM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WORKERNUM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;程序总共计算4千万次随机数，使用40个线程，计算得pi近似值为3.141298，由于是基于概率的，所以每次计算所得值会有差异，并且理论上来说随机数生成总次数越大，越精确。&lt;/p&gt;</summary><category term="算法"></category><category term="并行"></category><category term="Python"></category></entry><entry><title>诗歌选</title><link href="http://youngsterxyf.github.io/2012/11/20/poems/" rel="alternate"></link><updated>2012-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-20:2012/11/20/poems/</id><summary type="html">&lt;h3&gt;南乡子&lt;/h3&gt;
&lt;h4&gt;和杨元素，时移守密州&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;苏轼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;东武望余杭，云海天涯两杳茫。何日功成名遂了，还乡，醉笑陪公三万场。&lt;/p&gt;
&lt;p&gt;不用诉离觞，痛饮从来别有肠。今夜送归灯火冷，河塘，堕泪羊公却姓杨。&lt;/p&gt;
&lt;h3&gt;临江仙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;杨慎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;滚滚长江东逝水，浪花淘尽英雄。是非成败转头空，青山依旧在，几度夕阳红。&lt;/p&gt;
&lt;p&gt;白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢，古今多少事。都付笑谈中。&lt;/p&gt;
&lt;h3&gt;结结巴巴&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;伊沙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结结巴巴我的嘴&lt;br /&gt; 
二二二等残废&lt;br /&gt;
咬不住我狂狂狂奔的思维&lt;br /&gt;
还有我的腿&lt;br /&gt;
&lt;br /&gt;
你们四处流流流淌的口水&lt;br /&gt;
散着霉味&lt;br /&gt;
我我我的肺&lt;br /&gt;
多么劳累&lt;br /&gt;
&lt;br /&gt;
我要突突突围&lt;br /&gt;
你们莫莫莫名奇妙&lt;br /&gt;
的节奏&lt;br /&gt;
急待突围&lt;br /&gt;
&lt;br /&gt;
我我我的&lt;br /&gt;
我的机枪点点点射般&lt;br /&gt;
的语言&lt;br /&gt;
充满快慰&lt;br /&gt;
&lt;br /&gt;
结结巴巴我的命&lt;br /&gt;
我的命里没没没有鬼&lt;br /&gt;
你们瞧瞧瞧我&lt;br /&gt;
一脸无所谓&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;父亲和我&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;吕德安&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;父亲和我&lt;br /&gt;
我们并肩走着&lt;br /&gt;
秋雨稍歇&lt;br /&gt;
和前一阵雨&lt;br /&gt;
像隔了多年时光&lt;br /&gt;
&lt;br /&gt;
我们走在雨和雨的间歇里&lt;br /&gt;
肩头清晰地靠在一起&lt;br /&gt;
却没有一句要说的话&lt;br /&gt;
&lt;br /&gt;
我们刚从屋子里出来&lt;br /&gt;
所以没有一句要说的话&lt;br /&gt;
这是长久生活在一起&lt;br /&gt;
造成的&lt;br /&gt;
&lt;br /&gt;
滴水的声音像折下的一支细枝条&lt;br /&gt;
像过冬的梅花&lt;br /&gt;
&lt;br /&gt;
父亲的头发已经全白&lt;br /&gt;
但这近乎于一种灵魂&lt;br /&gt;
会使人不禁肃然起敬&lt;br /&gt;
&lt;br /&gt;
依然是熟悉的街道&lt;br /&gt;
熟悉的人要举手致意&lt;br /&gt;
父亲和我都怀着难言的恩情&lt;br /&gt;
安详地走着&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;假使我们不去打仗&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;田间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假使我们不去打仗&lt;br /&gt;
敌人用刺刀&lt;br /&gt;
杀死了我们&lt;br /&gt;
还要用手指着我们骨头说：&lt;br /&gt;
"看，&lt;br /&gt;
这是奴隶！"&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;相信未来&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;食指&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当蜘蛛网无情地查封了我的炉台&lt;br /&gt;
当灰烬的余烟叹息着贫困的悲哀&lt;br /&gt;
我依然固执地铺平失望的灰烬&lt;br /&gt;
用美丽的雪花写下：相信未来&lt;br /&gt;
&lt;br /&gt;
当我的紫葡萄化为深秋的露水&lt;br /&gt;
当我的鲜花依偎在别人的情怀&lt;br /&gt;
我依然固执地用凝霜的枯藤&lt;br /&gt;
在凄凉的大地上写下：相信未来&lt;br /&gt;
&lt;br /&gt;
我要用手指那涌向天边的排浪&lt;br /&gt;
我要用手掌那托住太阳的大海&lt;br /&gt;
摇曳着曙光那支温暖漂亮的笔杆&lt;br /&gt;
用孩子的笔体写下：相信未来&lt;br /&gt;
&lt;br /&gt;
我之所以坚定地相信未来&lt;br /&gt;
是我相信未来人们的眼睛&lt;br /&gt;
她有拨开历史风尘的睫毛&lt;br /&gt;
她有看透岁月篇章的瞳孔&lt;br /&gt;
&lt;br /&gt;
不管人们对于我们腐烂的皮肉&lt;br /&gt;
那些迷途的惆怅、失败的苦痛&lt;br /&gt;
是寄予感动的热泪、深切的同情&lt;br /&gt;
还是给以轻蔑的微笑、辛辣的嘲讽&lt;br /&gt;
&lt;br /&gt;
我坚信人们对于我们脊骨&lt;br /&gt;
那无数次的探索、迷途、失败和成功&lt;br /&gt;
一定会给予热情、客观、公正的评定&lt;br /&gt;
是的，我焦急地等待着他们的评定&lt;br /&gt;
&lt;br /&gt;
朋友，坚定地相信未来吧&lt;br /&gt;
相信不屈不挠的努力&lt;br /&gt;
相信战胜死亡的年轻&lt;br /&gt;
相信未来、热爱生命&lt;br /&gt;
&lt;br /&gt;
&lt;em&gt;1968年 北京&lt;/em&gt;&lt;/p&gt;</summary><category term="阅读"></category><category term="诗歌"></category></entry><entry><title>面试准备</title><link href="http://youngsterxyf.github.io/2012/11/20/prepareForInterview/" rel="alternate"></link><updated>2012-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-20:2012/11/20/prepareForInterview/</id><summary type="html">&lt;h3&gt;自我介绍&lt;/h3&gt;
&lt;p&gt;我叫夏永锋，目前是一名上海交大的硕士研究生，将于2013年3月毕业。现在作为一名web开发实习生在Google CSR部门实习。实习的工作内容主要包括：开发维护部门旗下的几个网站以及服务器日常运维。&lt;/p&gt;
&lt;p&gt;我的老家是江西省婺源县，她非常美丽，有“中国最美的乡村”的美誉。&lt;/p&gt;
&lt;p&gt;我喜欢写程序，羽毛球，长跑。我觉得编程是一种乐趣，编程是程序员的魔法。&lt;/p&gt;
&lt;p&gt;My name is Xia yongfeng, currently i am a master candidate from School of Software, Shanghai Jiaotong University. And i will graduate in 2013. Now I am a web development intern in Google CSR. The work content of the internship mainly includes the development and maintenance of some websites of our department, as well as the maintenance of web server.&lt;/p&gt;
&lt;p&gt;My hometown is WuYuan County in Jiangxi Province. She is so beautiful, resulting reputation as "China's most beautiful countryside."&lt;/p&gt;
&lt;p&gt;I love coding, badminton, long-distance running. To me, coding is a pleasure, is just for fun, coding is the magic of programmer.&lt;/p&gt;
&lt;h3&gt;为什么选择我们公司？&lt;/h3&gt;
&lt;p&gt;微软：也许它是世界上最大的软件公司，并且我喜欢微软的技术。&lt;/p&gt;
&lt;p&gt;Microsoft: Maybe it is the biggest software corporation in the world, and i like the technology from Microsoft. I think this is my reason to choose Microsoft.&lt;/p&gt;
&lt;h3&gt;选择你的一个项目介绍一下&lt;/h3&gt;
&lt;p&gt;那么就来说说我的一个个人小项目吧---简易FTP搜索引擎，这个小项目的由来是因为我们实验室有个ftp服务器，经过很多年的积累，上面的文件非常非常多，也比较乱。如果直接用ftp客户端去查找下载会非常麻烦，所以我就想能不能做个类搜索引擎，能够快速地搜索ftp上的文件，并提供下载。项目主要分成两部分---索引部分和搜索部分，索引部分由服务器端的一个python小程序实现，利用linux内核的文件系统实时监控功能，对ftp目录和文件夹进行实时索引，将索引(包含文件名和ftp下载链接)保存在berkerlyDB中。搜索部分是一个类google主页的搜索网页，用户输入查询关键字，服务器上的一个python CGI脚本接收用户输入，根据输入查询数据库，并返回结果。&lt;/p&gt;
&lt;p&gt;I like to talk about a personal small project with you --- a simple FTP search engine. Why do i choose this project？ In our lab，there is a ftp server, existing over several years, many, and more and more files/directories on the server. If we use a ftp client to look for some file and to download it, this will be a terrible thing. So i think why i don't implement a service like search engine to search ftp file and download it quickly. This project can be divided into two main parts --- indexing part and searching part. The indexing part is implemented with a short python program on the server, it use the real-time monitoring function of linux kernel to make real-time index for files and directories in ftp, and store index data(includes filename and download link) into a berkerly DB. And the searching part is a web page like google's main page. user enters keyword for searching, a python cgi script on the server receives the input, then searches the Database, then returns results.&lt;/p&gt;</summary><category term="面试"></category><category term="英语"></category></entry><entry><title>笔试题目</title><link href="http://youngsterxyf.github.io/2012/11/20/work-exam/" rel="alternate"></link><updated>2012-11-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-11-20:2012/11/20/work-exam/</id><summary type="html">&lt;h3&gt;2013-网易-校园招聘-C++开发工程师&lt;/h3&gt;
&lt;h4&gt;Fibonacci number&lt;/h4&gt;
&lt;p&gt;F(n)的值是多少？&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fabonacci" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/NumberedEquation6.gif" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规算法&lt;/strong&gt;：根据Fabonacci的定义，递归求值。时间复杂度$ O(2^n) $&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibobacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;迭代&lt;/strong&gt;：利用循环取代递归。时间复杂度O(n)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;迭代算法的变种&lt;/em&gt; ：利用python的generator，原理一样，只是应用场合不一样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;利用矩阵运算来加速的算法&lt;/strong&gt;：（还没懂）算法复杂度$ O(\log n) $&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt;

&lt;span class="n"&gt;fibonacci_matrix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ndarray&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fibonacci_matrix&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;数学方法:使用Fibonacci序列的通用公式&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sqrt&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fibonacci&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然数学方法在4种方法中速度最快，但当n越大，其计算精度偏差越大。&lt;/p&gt;
&lt;h4&gt;图的遍历&lt;/h4&gt;
&lt;p&gt;&lt;img alt="graph" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/graph-sample.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/graph.cpp"&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;大文件处理&lt;/h4&gt;
&lt;p&gt;设计算法从文件中随机取K行(内存够存储K行)，每行被取的概率相等，算法复杂度要低。(具体的记不太清楚了)&lt;/p&gt;
&lt;h4&gt;CAS(Compare And Swap)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;compare_and_swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;accum&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;newval&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;accum&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CAS方式实现的进队列操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;EnQueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//进队列&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;//取链表尾指针的快照&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CAS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//如果没有把结点链上，再试&lt;/span&gt;

    &lt;span class="n"&gt;CAS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//置尾结点&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lifesider/article/details/6582338"&gt;无锁的数据结构（Lock-Free）及CAS（Compare-and-Swap）机制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Compare-and-swap"&gt;Wikipedia---Compare-and-swap&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://coolshell.cn/articles/8239.html"&gt;无锁队列的实现&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;排序算法&lt;/h4&gt;
&lt;p&gt;不稳定排序算法可能会在相等的键值中改变记录的相对次序，但是稳定排序算法从来不会如此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;稳定的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;冒泡排序(Bubble sort) --- $ O(n^2) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入排序(Insertion sort) --- $ O(n^2) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;桶排序(Bucket sort) --- $ O(n) $，需要$O(k)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数排序(Counting sort) --- $ O(n+k) $，需要$O(n+k)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;归并排序(Merge sort) --- $ O(n \log n) $，需要$O(n)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数排序(Radix sort) --- $ O(n \times k) $，需要$O(n)$额外空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不稳定的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;选择排序(Selection sort) --- $ O(n^2) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;希尔排序(Shell sort) --- $ O(n \log n) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆排序(Heap sort) --- $ O(n \log n) $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速排序(Quick sort) --- $ O(n \log n) $&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;冒泡排序---Python&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bubbleSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;start bubble sort:&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;step&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
                &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;
                &lt;span class="n"&gt;step&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;totalstep:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;计数排序---C&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;counting_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;快速排序---Python&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; \
        &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2013-小米科技-校园招聘-笔试-软件开发工程师&lt;/h3&gt;
&lt;h4&gt;完全二叉树&lt;/h4&gt;
&lt;p&gt;深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为&lt;strong&gt;完全二叉树&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这种树的特点是:1.叶子结点只可能在层次最大的两层上出现; 2.对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。&lt;/p&gt;
&lt;p&gt;具有n个结点的完全二叉树的深度为$ [\log n]+1 $&lt;/p&gt;
&lt;h4&gt;指针的基本理解&lt;/h4&gt;
&lt;p&gt;已知int* p = &amp;amp;n，请问*p是什么？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;*p是n的值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解指针&lt;/strong&gt; ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个指针都对应一个类型。这个类型表明指针指向哪一类对象。特殊的void* 类型代表通用指针。比如说，malloc函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个指针都有一个值。特殊的NULL(0)值表示该指针没有指向任何地方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针用&amp;amp;运算符创建。（注：因为leal指令是设计用来计算存储器引用的地址的，&amp;amp;运算符的机器代码实现常常用这条指令来计算表达式的值）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组与指针紧密联系。一个数组的名字可以像一个指针变量一样使用(但是不能修改)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将指针从一个类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。例如，如果p是一个char*类型的指针，它的值是P，那么表达式(int*)p+7计算为P+28，而(int*)(p+7)计算为P+7。(回想一下，强制类型转换的优先级高于加法)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针也可以指向函数。例如，如果我们有一个函数，用下面的这个原型定义: &lt;code&gt;int fun(int x, int *p)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后，我们可以声明一个指针fp，将它赋值为这个函数，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后用以下指针来调用这个函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数指针的值是该函数机器代码表示中第一条指令的地址。&lt;/p&gt;
&lt;h4&gt;93&amp;amp;-8等于多少&lt;/h4&gt;
&lt;p&gt;11011101 &amp;amp; 11111000 = 11011000 = 88&lt;/p&gt;
&lt;h4&gt;已知(he)^2 = she，请求出s, h, e各自的值为多少？&lt;/h4&gt;
&lt;p&gt;s = 6; h = 2; e = 5;&lt;/p&gt;
&lt;h4&gt;给定二维数组a[1...100][1...65]，以行序进行存储，假设数组的基地址为10000，每个元素需要2个存储单元，请求出元素a[56][21]的存储地址。&lt;/h4&gt;
&lt;p&gt;$$ (55 \times 65 + 22) \times 2 + 10000 = 17194 $$&lt;/p&gt;
&lt;h4&gt;给定一个数组a，求数组result，其中result[i]的值为除a[i]之外的其他a的元素值的乘积(假设不会溢出)。算法的时间，空间复杂度要尽可能低。&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;getProduct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;allproduct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;allproduct&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;productResult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;productResult&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;allproduct&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;productResult&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;时间复杂度为O(n)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;getProduct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;productResult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;productResult&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;productResult&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;时间复杂度为O(n^2)&lt;/p&gt;
&lt;h4&gt;给定一个数组a，其中有3个元素出现了两次，其余元素仅出现一次。请找出其中仅出现一次的任意一个元素。算法的时间，空间复杂度要低&lt;/h4&gt;
&lt;p&gt;方法一：先排序，然后对元素依次两两比较遍历一遍排好序的数组，如果两个元素不同，则输出第一个元素，并退出循环。如果相同，则跳过下一个元素，再次开始两两比较。&lt;/p&gt;
&lt;p&gt;方法二：先找出数组a中的最大元素x，创建一个大小为x的数组temp，并所有元素初始化为-1。遍历数组a，temp[a[i]]++。再遍历temp，如果temp[i]==0，则返回i，并退出循环。&lt;/p&gt;
&lt;h4&gt;给定n个人，以及m对人之间的关联(以二维数组的方式存储)，人与人之间直接关联或间接关联形成一个朋友圈。请找出给定信息的朋友圈的个数。算法时间空间复杂度要低。并分析其时间空间复杂度。&lt;/h4&gt;
&lt;p&gt;使用 &lt;strong&gt;合并-查找算法&lt;/strong&gt; (&lt;a href="http://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86"&gt;并查集&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连通问题的快速查找算法&lt;/strong&gt;：算法的基础是一个整型数组，当且仅当第p个元素和第q个元素相等时，p和q是连通的。初始时，数组中的第i个元素的值为i，$0 \le i &amp;lt; N$。为实现p与q的合并操作，我们遍历数组，把所有名为p的元素值改为q。我们也可以选择另一种方式，把所有名为q的元素改为p。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;2013-腾讯-校园招聘-笔试-后台开发工程师&lt;/h3&gt;
&lt;h4&gt;黑盒，白盒测试的目的&lt;/h4&gt;
&lt;h4&gt;TCP三次握手包含的指令(SYN, ACK)&lt;/h4&gt;
&lt;h4&gt;完全二叉树的结点数为769,求其叶子结点数目&lt;/h4&gt;
&lt;p&gt;(769-x)*2 = 769-1 =&amp;gt; x=385&lt;/p&gt;
&lt;h4&gt;C++的四种类型转换符&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://www.bccn.net/Article/kfyy/cjj/jszl/200809/7955.html"&gt;C++中四种类型转换运算符的使用方法&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;快速排序&lt;/h4&gt;
&lt;h4&gt;有一个指针void *mPem指向一段分配好的内存空间，现在创建类A的对象a，如何使得a在其上申请内存空间？&lt;/h4&gt;
&lt;p&gt;难道真是A* a = (A*)mPem么?&lt;/p&gt;
&lt;h4&gt;虚继承与多态&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;aaa%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bbb%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;BITMAP的简单实现：使用char类型数组&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//设置第n位为1&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;矩阵向右旋转90度的实现&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxtrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;reverseMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;reverseMatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;数据结构：线性结构与非线性结构&lt;/h4&gt;
&lt;h4&gt;综合考虑等待时间和执行时间的进程调度算法？&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;高响应比优先调度算法&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;无法提高可靠性的RAID是？&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;RAID0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/zh/RAID"&gt;wikipedia-RAID&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;类型的空间占用&lt;/h4&gt;
&lt;p&gt;下列哪个占用的空间最大？&lt;/p&gt;
&lt;p&gt;A.1   B.'1'   C."1"   D.1.0&lt;/p&gt;
&lt;p&gt;答：D&lt;/p&gt;
&lt;h4&gt;union和struct结构的存储与空间占用问题(对齐)&lt;/h4&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;U3&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于类型union U3*的指针p, p-&amp;gt;c、p-&amp;gt;i[0]和p-&amp;gt;v引用的都是数据结构的起始位置。一个联合的总的大小等于它最大字段的大小。&lt;/p&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2, 4和8)的倍数。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计。例如，假设一个处理器总是从存储器中取出8个字节，则地址必须是为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个存储器操作来读或者写值了。否则，我们可能需要执行两次存储器访问，因为对象可能被分放在两个8字节存储器块中。&lt;/p&gt;
&lt;p&gt;无论数据是否对齐，IA32已经都能正确工作。不过，Intel还是建议要对齐数据以提高存储器系统的性能。Linux沿用的对齐策略是，2字节数据类型(例如short)的地址必须是2的倍数，而较大的数据类型(例如int、int*、float和double)的地址必须是4的倍数。&lt;/p&gt;
&lt;h4&gt;二叉树中序遍历&lt;/h4&gt;
&lt;h4&gt;最小堆(堆排序)&lt;/h4&gt;
&lt;p&gt;堆排序(Heap Sort)只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。&lt;/p&gt;
&lt;p&gt;堆的定义如下：n个元素的序列{K1, K2,...,Kn}当且仅当满足关系时，称之为堆:
Ki &amp;lt;= K2i 并且 Ki &amp;lt;= K2i+1  或  Ki &amp;gt;= K2i 并且 Ki &amp;gt;= K2i+1&lt;/p&gt;
&lt;p&gt;若将和此序列对应的一维数组看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于(或不小于)其左、右孩子结点的值。由此，若序列{Ki,K2,...,Kn}是堆，则堆顶元素(或完全二叉树的根)必为序列中n个元素的最小值(或最大值)。&lt;/p&gt;
&lt;p&gt;若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素中次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。&lt;/p&gt;
&lt;p&gt;由此，实现堆排序需要解决两个问题：(1)如何由一个无序序列建成一个堆？(2)如何在输出栈顶元素之后，调整剩余元素成为一个新的堆？&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/heapSort.c"&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;一个线段上，任取两点，截成三段，能组成三角形的概率&lt;/h4&gt;
&lt;p&gt;1/4 (怎么算？)&lt;/p&gt;
&lt;p&gt;思考1：线段等分成两个区间。两点属于同一区间的概率是1/2，属于不同区间且两点距离大于等于线段长度一半的概率是1/2 * 1/2，则1-1/2-1/4 = 1/4;&lt;/p&gt;
&lt;p&gt;思考2：线性规划。&lt;a href="http://zhidao.baidu.com/question/6678655"&gt;百度知道&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;哈希表&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;哈希函数的构造方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接定址法：取关键字或关键字的某个线性函数值为哈希地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字分析法：假设关键字是以r为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平方取中法：取关键字平方后的中间几位为哈希地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;折叠法：将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和(舍去进位)作为哈希地址，这方法称为折叠法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机数法：选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key)，其中random为随机函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际工作中需视不同的情况采用不同的哈希函数。通常，考虑的因素有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算哈希函数所需时间(包括硬件指令的因素)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键字的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希表的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键字的分布情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录的查找频率&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理冲突的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开放定址法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再哈希法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链地址法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立一个公共溢出区&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;程序员面试宝典&lt;/h3&gt;
&lt;h4&gt;用一个表达式，判断一个数X是否是2的N次方(2,4,8,16,...)，不可用循环语句。&lt;/h4&gt;
&lt;h4&gt;下面程序的结果是多少？&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9999&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;There are two int variables: a and b, don't use "if", "?:", "switch" or other judgement statements, find out the biggest one of the two numbers.&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;如何将a, b的值进行交换，并且不使用任何中间变量?&lt;/h4&gt;
&lt;p&gt;简而言之，用异或语句比较容易，不用担心超界的问题。&lt;/p&gt;
&lt;p&gt;如果采用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样做的缺点就是如果a, b都是比较大的两个数，a=a+b时就会超界。&lt;/p&gt;
&lt;p&gt;而采用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;无需担心超界的问题，这样就比较好&lt;/p&gt;</summary><category term="笔试"></category></entry><entry><title>Python装饰器入门（译）</title><link href="http://youngsterxyf.github.io/2012/07/30/a-primer-on-python-decorators/" rel="alternate"></link><updated>2012-07-30T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-07-30:2012/07/30/a-primer-on-python-decorators/</id><summary type="html">&lt;p&gt;原文: &lt;a href="http://www.thumbtack.com/engineering/a-primer-on-python-decorators/"&gt;A primer on Python decorators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译: &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python允许你，作为程序员，使用函数完成一些很酷的事情。在Python中，函数是&lt;a href="http://en.wikipedia.org/wiki/First-class_function"&gt;一等对象(first-class object)&lt;/a&gt;，这就意味着你可以像使用字符串，整数，或者任何其他对象一样使用函数。例如，你可以将函数赋值给变量:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; def square(n):
...     return n * n;
&amp;gt;&amp;gt;&amp;gt; square(4)
16
&amp;gt;&amp;gt;&amp;gt; alias = square
&amp;gt;&amp;gt;&amp;gt; alias(4)
16
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，一等函数的真正威力在于你可以把函数传给其他函数，或者从其他函数中返回函数。Python的内置函数map利用了这种能力：给map传个函数以及一个列表，它会依次以列表中每个元素为参数调用你传给它的那个函数，从而生成一个新的列表。如下所示的例子中应用了上面的那个square函数:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; number = [1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; map(square, numbers)
[1, 4, 9, 16, 25]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果一个函数接受其他函数作为参数，以及/或者返回一个函数，那么它就被称为&lt;a href="http://en.wikipedia.org/wiki/Higher-order_function"&gt;高阶函数&lt;/a&gt; 。虽然map函数只是简单地使用了我们传给它的函数，而没有改变这个函数，但我们也可以使用高阶函数去改变其他函数的行为。&lt;/p&gt;
&lt;p&gt;例如，假设有这样一个函数，会被调用很多次，以致运行代价非常昂贵:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; def fib(n):
...      &amp;quot;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;quot;
...      return n if n in [0, 1] else fib(n - 2) + fib(n - 1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们一般会保存计算过程中每次递归调用的结果，这样，对于函数调用树中经常出现某个n，当需要计算n对应的结果时，就不需要重复计算了。有多种方式可以做到这点。例如，我们可以将这些结果存在一个字典中，当以某个值为参数调用fib函数时，就先到这个字典去查一下其结果是否已经计算出来了。&lt;/p&gt;
&lt;p&gt;但这样的话，每次我们想要调用fib函数，都需要重复那段相同的字典检查样板式代码。相反，如果让fib函数自己在内部负责存储其结果，那么在其他代码中调用fib，就非常方便，只要简单地调用它就行了。这样一种技术被称为&lt;a href="http://en.wikipedia.org/wiki/Memoization"&gt;memoization&lt;/a&gt;(注意没有字母r的哦)。&lt;/p&gt;
&lt;p&gt;我们可以把这种memoization代码直接放入fib函数，但是Python为我们提供了另外一种更加优雅的选择。因为可以编写修改其他函数的函数，那么我们可以编写一个通用的memoization函数，以一个函数作为参数，并返回这个函数的memoization版本:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;memoize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;stored_results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;memoized&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c"&gt;# try to get the cached result&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stored_results&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c"&gt;# nothing was cached for those args. let&amp;#39;s fix that.&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stored_results&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;memoized&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如上， &lt;code&gt;memoize&lt;/code&gt; 函数以另一个函数作为参数，函数体中创建了一个字典对象用来存储函数调用的结果：键为被memoized包装后的函数的参数，值为以键为参数调用函数的返回值。 &lt;code&gt;memoize&lt;/code&gt; 函数返回一个新的函数，这个函数会首先检查在 &lt;code&gt;stored_results&lt;/code&gt; 字典中是否存在与当前参数对应的条目；如果有，对应的存储值会被返回；否则，就调用经过包装的函数，存储其返回值，并且返回给调用者。memoize返回的这种新函数常被称为"包装器"函数，因为它只是另外一个真正起作用的函数外面的一个薄层。&lt;/p&gt;
&lt;p&gt;很好，现在有了一个memoization函数，我们可以把fib函数传给它，从而得到一个经过包装的fib，这个版本的fib函数不需要重复以前那样的繁重工作:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;fib&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;memoize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过高阶函数memoize，我们获得了memoization带来的好处，并且不需要对fib函数自己做出任何改变，以免夹杂着memoization的代码而模糊了函数的实质工作。但是，你也许注意到上面的代码还算有点别扭，因为我们必须写3遍fib。由于这种模式-传递一个函数给另一个函数，然后将结果返回给与原来那个函数同名的函数变量-在使用包装器函数的代码中极为常见，Python为其提供了一种特殊的语法：装饰器:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@memoize&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里，我们说memoize函数装饰了fib函数。需要注意的是这仅是一种语法上的简便写法(译注：就是我们常说的"语法糖")。这段代码与前面的代码片段做的是同样的事情：定义一个名为fib的函数，把它传给memoize函数，将返回结果存为名为fib的函数变量。特殊的(看起来有点奇怪的)@语法只是减少了冗余。&lt;/p&gt;
&lt;p&gt;你可以将多个装饰器堆叠起来使用，它们会自底向上地逐个起作用。例如，假设我们还有另一个用来帮助调试的高阶函数:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;make_verbose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;verbose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# will print (e.g.) fib(5)&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;)&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;, &amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c"&gt;# actually call the decorated function&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;verbose&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面的两个代码片段做的是同样的事情:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@memoize&lt;/span&gt;
&lt;span class="nd"&gt;@make_verbose&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;fib&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;memoize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make_verbose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有趣的是，Python并没有限制你在@符号后只能写一个函数名：你也可以调用一个函数，从而能够高效地传递参数给装饰器。假设我们并不满足于简单的memoization，还想将函数的结果存储到&lt;a href="http://memcached.org/"&gt;memcached&lt;/a&gt;中。如果你已经写了一个 &lt;code&gt;memcached&lt;/code&gt; 装饰器函数，那么可以(例如)传递一个服务器地址给它:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@memcached&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;127.0.0.1:11211&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非装饰器语法的写法会如下展开:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;fib&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;memcached&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;127.0.0.1:11211&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python配备有一些作为装饰器使用的非常有用的函数。例如，Python有一个 &lt;code&gt;classmethod&lt;/code&gt; 函数，可以创建大致类似于java的静态方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;SOME_CLASS_CONSTANT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;

    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add_to_my_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# Here, `cls` will just be Foo, buf if you called this method on a&lt;/span&gt;
        &lt;span class="c"&gt;# subclass of Foo, `cls` would be that subclass instead.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SOME_CLASS_CONSTANT&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;

&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_to_my_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# =&amp;gt; 52&lt;/span&gt;

&lt;span class="c"&gt;# unlike in Java, you can also call a classmethod on an instance&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_to_my_constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;# =&amp;gt; 52&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;旁注：文档字符串&lt;/h2&gt;
&lt;p&gt;Python函数可以包含更多的信息，而不仅仅是代码：它们也包含有用的帮助信息，比如函数名称，文档字符串:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; def fib(n):
...     &amp;quot;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;quot;
...     return n if n in [0, 1] else fib(n - 2) + fib(n - 1)
...
&amp;gt;&amp;gt;&amp;gt; fib.__name__
&amp;#39;fib&amp;#39;
&amp;gt;&amp;gt;&amp;gt; fib.__doc__
&amp;#39;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python内置函数&lt;a href="http://docs.python.org/library/functions.html#help"&gt;help&lt;/a&gt;输出的就是这些信息。但是，当函数被包装之后，我们看到就是包装器函数的名称和文档字符串了:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; fib = memoized(fib)
&amp;gt;&amp;gt;&amp;gt; fib.__name__
&amp;#39;memoized&amp;#39;
&amp;gt;&amp;gt;&amp;gt; fib.__doc__
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那样的信息并没有什么用处。幸运的是，Python包含一个名为 &lt;code&gt;functools.wraps&lt;/code&gt; 的助手函数，能够把函数的帮助信息拷贝到其包装器函数:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;memoize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;stored_results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="nd"&gt;@functools.wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;memoized&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# (as before)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;memoized&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用装饰器帮助你编写装饰器会使很多事情令人非常满意。现在，如果使用更新过的memoize函数重试前面的代码，我们将会看到得到保留的文档:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; fib = memoized(fib)
&amp;gt;&amp;gt;&amp;gt; fib.__name__
&amp;#39;fib&amp;#39;
&amp;gt;&amp;gt;&amp;gt; fib.__doc__
&amp;#39;Recursively (i.e., dreadfully) calculate the nth Fibonacci number.&amp;#39;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>Python FAQ：Web开发（译）</title><link href="http://youngsterxyf.github.io/2012/07/30/python-faq-webdev/" rel="alternate"></link><updated>2012-07-30T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-07-30:2012/07/30/python-faq-webdev/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://me.veekun.com/blog/2012/05/05/python-faq-webdev/"&gt;Python FAQ: Webdev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://me.veekun.com/blog/2011/07/22/python-faq/"&gt;Python FAQ&lt;/a&gt;的一部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我只会PHP，那该怎么用Python来编写一个Web应用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个相当复杂的问题，甚至很容易就能写一本书来探讨Web开发与Python，以及如何关联两者，所以我很想先把这个问题放一放。但是鉴于我刚&lt;a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/"&gt;相当粗暴地捣毁了PHP&lt;/a&gt;，明智些，还是回答这个问题吧，宜早不宜迟。&lt;/p&gt;
&lt;p&gt;最直接简单的回答是：不要再读了，马上使用&lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;着手构建一样东西。然而，我觉得还有更好回答。&lt;/p&gt;
&lt;p&gt;本文并非是教程。也许将来我会写一篇，但现在已经存在大量的教程了，我认为你可以阅读那些文档。相反，本文是为新手而写的Python Web开发相关事情的概览。&lt;/p&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;p&gt;显然，你需要安装Python。确保使用Python 2，而不是3。Python 3有一些向后不兼容的改变，并非所有的库都更新过。&lt;/p&gt;
&lt;p&gt;安装Python库，可以考虑使用 &lt;code&gt;pip&lt;/code&gt; 。(如果你在使用类Unix操作系统，那么也许可以通过系统包管理器安装pip，否则使用 &lt;code&gt;easy_install pip&lt;/code&gt; ) &lt;code&gt;pip&lt;/code&gt; 是一个小巧的Python包管理器，便于安装，删除，升级，以及检查Python库。当然，尽可能使用你的系统包管理器，不行的话就用 &lt;code&gt;pip&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;pip install --user ...&lt;/code&gt; 将Python库安装到你的home目录，但更好的方式是保持库为每个项目局部可用---这样，你就可以为一个项目升级依赖项而不会破坏其他项目的依赖。(或者破坏Python编写的系统软件。我就曾干过这种事。) &lt;code&gt;virtualenv&lt;/code&gt; 使用单个命令就能助你创建一个独立的Python安装环境。&lt;/p&gt;
&lt;p&gt;当然，你已计划使用源码控制，对吧？我喜欢&lt;a href="http://www.git-scm.com/"&gt;git&lt;/a&gt; ,  但有聊胜于无，其他的也OK的。&lt;/p&gt;
&lt;h2&gt;框架&lt;/h2&gt;
&lt;p&gt;第一个障碍是如何将你代码与浏览器相关连。PHP中，最简单的方式是安装Apache并将它指向一些文件。Python中，如同更大的PHP项目，一般需要使用Web框架。&lt;/p&gt;
&lt;p&gt;框架多半有相似的工作流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装，使用 &lt;code&gt;pip&lt;/code&gt; 这样的工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个项目骨干(skeleton)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目骨干的复杂性视情况而定。对于现已不被使用的Pylons，你会得到一大堆诡异的代码，还需要为新的发布版本手动升级。Flask则简单到没有骨干。复杂性适中的是Pyramid，项目骨干不过是些通用的样板文件(boilerplate)，如果你是从零开始，那么最终会自己来写的这种样板文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置一些东西，比如数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动开发服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般是一个运行你的应用的终端程序，从而不需要一个专用的HTTP服务器。当你修改了代码，开发服务器就会自动重新装载，并且能输出栈跟踪和其他调试信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动手干吧！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，应该用什么框架呢？虽然有不计其数的可选项，但有一些明显最流行。&lt;/p&gt;
&lt;p&gt;我是&lt;a href="http://www.pylonsproject.org/"&gt;Pyramid&lt;/a&gt;的粉丝，它在极简主义与电池内置的庞然大物之间做出最佳的平衡。虽然它是从两个更老的组织良好的项目衍生而来，但在最近才成为一个竞争者。Pyramid设计良好，文档齐全，相当透明(fairly transparent)。一个简单的应用根本不需要自动生成的样板文件，允许你直接运行项目骨干，并且核心代码库扩展性非常好。有用的插件越来越多。&lt;/p&gt;
&lt;p&gt;如果需要更快地上手， &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;则足够简单了，但是可扩展性非常良好。其设计上与众不同地做了一些相当的合理的事情，且对你没有很多强迫。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bottlepy.org/docs/dev/"&gt;Bottle&lt;/a&gt;类似于Flask，但是更简单：它作为单个文件发布，没有任何依赖。是好是坏全看你自己，但这意味着Bottle中没有什么东西可以和其他框架分享的。我承认对Bottle知道的不是很多，但我曾简单地了解过(gave it a brief shot once)，对它没什么大的牢骚。&lt;/p&gt;
&lt;p&gt;另一极端上，&lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt;是为类内容管理系统和其他富内容网站而设计的巨大怪兽。它有庞大的可插部件生态系统，内置从模板到ORM的各种东西，以及大量文档和社区资源。Django常被认为是与Ruby on Rails等价的Python框架。其缺点是让它做些它不想做的事情会很别扭。( &lt;code&gt;#python&lt;/code&gt; 中许多更加愚钝的问题都是由于试图捣鼓Django而产生的)对于首次尝试Web开发来说，Django可能有些重量了。&lt;/p&gt;
&lt;p&gt;还有&lt;a href="http://www.web2py.com/"&gt;web2py&lt;/a&gt;。我，额，不太了解它。据说它会在你的模块名字空间内注入变量，这是令人讨厌的，所以如果你在意那些我认为讨厌的东西就不要用它，否则就用吧，随你自己啦。&lt;/p&gt;
&lt;p&gt;曾经有一个Apache模块 &lt;code&gt;mod_python&lt;/code&gt; ，本质上类似于 &lt;code&gt;mod_perl&lt;/code&gt; ，但很早就被抛弃了。请 &lt;strong&gt;不要&lt;/strong&gt; 使用它。&lt;/p&gt;
&lt;p&gt;最后，你也可以完全"手动"编写Python web代码，但那多半是一次令人沮丧的练习。不会更快，不会有什么教育意义，也不会有什么用。不要自找麻烦。&lt;/p&gt;
&lt;p&gt;我的建议？如果你只是想折腾捣鼓，那就从Flask入手吧，随你添加东西。如果你有想法要做一个网站，并且想旗开得胜(hit the ground running)，那就使用一个Pyramid脚手架(scaffold)，跟随它的叙述性文档进行开发。&lt;/p&gt;
&lt;h2&gt;路由选择(Routing)&lt;/h2&gt;
&lt;p&gt;PHP是根据URL执行一整个文件，Python web应用则倾向"拥有"一整个目录结构(或者甚至是整个域(domain))。因此，将特定的代码连接到特定的代码更加灵活，这种连接通常是由一个路由选择系统来处理。&lt;/p&gt;
&lt;p&gt;路由(routes)是包含可选占位符的URL，就像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/users/{name}
/companies/{id}/products
/blog/{year:\d\d\d\d}/{month:\d\d}/{day:\d\d}/{title}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可以把这样的一个路由绑定到一个函数，那么当你浏览到 &lt;code&gt;/users/eevee&lt;/code&gt; ，那个函数就会被执行，占位符则以 &lt;code&gt;dict(name=u'eevee')&lt;/code&gt; 这样的结构可供使用。&lt;/p&gt;
&lt;p&gt;一些框架(比如Pyramid)在这一步上走得更远：不是直接将路由绑定到函数，而是给路由一个名字，然后把名字绑定到函数。需要一点额外的工作，但优点是在你的应用中只需维护一个所有页面的核心列表。你也可以一个路由名和占位符值来生成一个URL---那么，之后，你就可以只在一个地方修改一下就能改变一个URL，而不需要接触其他东西，并且开发过程中打字错误会产生一个错误信息而不是一个404页面。&lt;/p&gt;
&lt;p&gt;语法和具体实现会有些不同，但每个框架都是使用这个系统的某个变种。有些有助于创建REST风格的路由或者其他常见模式，或者你可以很容易编写自己的模式。&lt;/p&gt;
&lt;h2&gt;请求周期&lt;/h2&gt;
&lt;p&gt;一次HTTP请求往往会执行某处的一个函数(由一个路由选择)，然后给函数传递一个 &lt;code&gt;request&lt;/code&gt; 对象参数。&lt;/p&gt;
&lt;p&gt;request对象的确切接口依赖于特定的框架，但是它们一般都比较类似：解析过的查询数据，一些cookie，请求消息头，等等。举例来说， &lt;code&gt;webob&lt;/code&gt; (http://www.webob.org) 的 &lt;code&gt;Request&lt;/code&gt; 对象包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.GET&lt;/code&gt; 和 &lt;code&gt;request.POST&lt;/code&gt; 是存储解析过的查询数据的"multidict"。(对于 &lt;code&gt;request.GET['foo']&lt;/code&gt; ，一个multidict返回的是单个值，但使用 &lt;code&gt;getall()&lt;/code&gt; 方法则会返回所有的值)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.params&lt;/code&gt; 是包含上面两者的一个multidict。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.cookies&lt;/code&gt; 是一个cookie的解析字典。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.headers&lt;/code&gt; 是一个HTTP请求消息头的字典，但是其键是大小写敏感的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request.is_xhr&lt;/code&gt; 返回是否存在 &lt;code&gt;X-Requested-with: XMLHttpRequest&lt;/code&gt; 消息头，以识别由jQuery这样的库设置的ajax请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;request对象的文档一般非常齐全，因此只要浏览一下你所选择的框架的文档，挑出其中重要的内容。&lt;/p&gt;
&lt;p&gt;当你的应用完成了一些非常酷的事情之后，你要让它返回一个响应消息。通常你能选择是否明确地构建一个 &lt;code&gt;Response&lt;/code&gt; 对象(包括HTTP消息头和其他可手动设置的细节)还是简单返回一块HTML代码，其他所有东西都使用默认设置。很少需要你自己创建一个响应。对于像返回JSON这样的常见工作，每个框架都有某种快捷的或辅助的装饰器。&lt;/p&gt;
&lt;h2&gt;模板&lt;/h2&gt;
&lt;p&gt;组装HTML的工作一般是由模板引擎来完成的。&lt;a href="http://www.makotemplates.org/"&gt;Mako&lt;/a&gt;和&lt;a href="http://jinja.pocoo.org/"&gt;Jiaja2&lt;/a&gt;是两个主要的竞争者。&lt;/p&gt;
&lt;p&gt;我真的喜欢Mako。真的，真的，真的。使用它吧。它使用朴素的Python作为语法，使用起来非常自然。你甚至可以在模板里编写纯粹的Python代码块，但是你得控制住，尽可能避免这样做。:)&lt;/p&gt;
&lt;p&gt;Jinja2也不错，但提醒你一下：Jinja2中，如果 &lt;code&gt;foo&lt;/code&gt; 看起来像一个字典，那么 &lt;code&gt;foo.bar&lt;/code&gt; 就会被当作 &lt;code&gt;foo['bar']&lt;/code&gt; 处理，反之亦然。恰巧我认为这并不是一个好主意，我曾遭遇过许多诡异的问题，都是模板系统中这种"特性"所造成的。(另外， &lt;code&gt;{% %}&lt;/code&gt; 这种语法真的很烦人，但这有些鸡蛋里挑骨头了)。除此之外，Jinja2是一个非常可靠的库，而你肯定会做得更糟，&lt;a href="http://www.cheetahtemplate.org/"&gt;糟得多&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这两个工具速度都很快，会自动编译成Python模块，具备优秀的可调试能力(以疯狂的做法从原来的模板源码中得到栈跟踪信息)，应该足够强大，让你想干啥就能干啥了。大致了解一下这两个，然后选一个就开始使用吧。如果你不知道或者无所谓用哪个，那就用Mako吧。&lt;/p&gt;
&lt;p&gt;(注意，虽然Flask默认使用Jinja2，但使用Mako作为替代也是&lt;a href="https://github.com/tzellman/flask-mako"&gt;相当容易&lt;/a&gt;的。)&lt;/p&gt;
&lt;p&gt;当然还有其他的竞争者：排名第三的可能是Genshi，但它令人极其费解，以至于&lt;a href="http://genshi.edgewall.org/"&gt;主页&lt;/a&gt;上一开始就用了一张流程图； Djano有自己的模板引擎，千方百计想把逻辑剔除出模板(在我看来，对其是不利的)；Bottle同样有自己的极其简单的模板，但是可能很快就会让你感到越来越痛苦；Pyramid的另一个内建模板引擎是Chameleon，将类似HTML的属性标签用于循环和其他逻辑，太TMD古怪了。&lt;/p&gt;
&lt;p&gt;也许你会喜欢其中之一；我并没有都深入使用过它们。&lt;/p&gt;
&lt;p&gt;不管你做什么，都不要使用Cheetah。 &lt;strong&gt;不要&lt;/strong&gt; 使用Cheetah。它邪恶可憎。不要再提到它。&lt;/p&gt;
&lt;h2&gt;模板中的逻辑&lt;/h2&gt;
&lt;p&gt;也许你以前没用过模板，那你不可避免地会遭遇这个问题---一些复杂的表现代码是应该用Python实现，还是放在模板中实现。&lt;/p&gt;
&lt;p&gt;这是无聊的老生常谈，但我想说：就像许多程序设计中的架构决策，归结起来就是要尽可能减少以后因为它而对自己的厌恶感。尽可能保持模板简单，如果不行的话，也不用勉强。谨记你始终可以在简单的Python模块中编写简单的Python函数，然后导入它。一个强大的模板语言对于你的问题可能内建了创造性的解决方案，所以当你在想办法的时候可以先浏览一下文档。&lt;/p&gt;
&lt;h2&gt;Unicode&lt;/h2&gt;
&lt;p&gt;Unicode很烂。这是众所周知的事实。(我在说谎。编码(encoding)处理得很烂。Unicode很伟大。这个问题比较复杂，之后我会写到。)&lt;/p&gt;
&lt;p&gt;Python(2)有两种"字符串"类型： &lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;unicode&lt;/code&gt; 。这是一个巧妙的谎言。事实是：一个 &lt;code&gt;str&lt;/code&gt; 并不真的是一个字符串。它只是一串字节。有时恰巧看起来像一个字符串，但事实上只是一个二进制表示，就像 &lt;code&gt;85 00 00 00&lt;/code&gt; 是数字133的常见二进制表示。一个真正的数字是 &lt;code&gt;int&lt;/code&gt; 类型的，一个真正的字符串是 &lt;code&gt;unicode&lt;/code&gt; 类型的。&lt;/p&gt;
&lt;p&gt;这个问题很复杂，值得单独写一篇文章来解释(迟早我会写的)，但现在可以有些快速的笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;你的程序只需要担心真正的字符串(也就是 &lt;code&gt;unicode&lt;/code&gt; 类型的)。字符串进入你的程序时需要解码，离开时需要编码，但是幸运的是，大多数的web框架都会为你做这事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你可以使用 &lt;code&gt;u&lt;/code&gt; 前缀来创建一个 &lt;code&gt;unicode&lt;/code&gt; 的字面字符串，e.g.， &lt;code&gt;u'foo'&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你可以在文件的顶部添加 &lt;code&gt;from __future__ import unicode_literals&lt;/code&gt; 使得文件中的所有字面字符串默认为 &lt;code&gt;unicode&lt;/code&gt; 。如果你确实需要一个 &lt;code&gt;str&lt;/code&gt; 类型字符串，那就使用 &lt;code&gt;b&lt;/code&gt; 前缀吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你想在Python源码中使用非ASCII字符，在顶部添加 &lt;code&gt;#encoding: utf8&lt;/code&gt; 魔术注释。（当然是假定你的源码保存为UTF-8编码的，这样做绝对更好。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;永远&lt;/strong&gt; 不要通过剥离非ASCII字符来解决Unicode问题！这是对很多人的无礼；想象一下当你尝试去使用一个网站，因为某个程序员懒得弄清楚如何处理英文字母，所以不允许你使用英文字母，你会是什么感受？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际上，对于撼动编码问题，重音字母和亚洲字符功不可没。将一些非ASCII字符的莫名其妙的话粘贴到你的网站表单中，看看会发生什么。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;XSS(跨站脚本攻击)&lt;/h2&gt;
&lt;p&gt;实际上，现在的每项相关技术都内建某种形式的自动HTML转义过滤器。理念是：对于这样的一个模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;p&amp;gt;Hello, ${name}!&amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当给定 &lt;code&gt;name = '&amp;lt;b&amp;gt;'&lt;/code&gt; ，将安全地打印出 &lt;code&gt;Hello, &amp;amp;lt;b&amp;amp;gt;!&lt;/code&gt; 。这意味着，大多数时候，你并不需要担心XSS。&lt;/p&gt;
&lt;p&gt;大多数时候，如果没有别的，你必须核对所使用框架和模板引擎的文档，确保自动HTML转义过滤功能默认开启，如果不是，则开启它。(随便说一下：对于Pyramid，Django和Flask，你能轻松获得此项功能。如果你的模板文件具备一个处理HTML的扩展，Bottle则也能自动做到。)&lt;/p&gt;
&lt;p&gt;那么，棘手的地方就是知道何时以及如何关闭它。如果你在Python代码中构建了某种复杂的HTML，且不想完全转义它，那么仅仅使得转义行为失效是个蹩脚的解决方案。任何转义失效的地方都可能发生注入。幸运的是，许多框架(至少有Pyramid和Flask)使用了&lt;a href="http://pypi.python.org/pypi/MarkupSafe"&gt;markupsafe&lt;/a&gt;库，它能智能地帮助避免这个问题。&lt;/p&gt;
&lt;p&gt;markupsafe提供一个单一的类， &lt;code&gt;Markup&lt;/code&gt; ，继承自 &lt;code&gt;unicode&lt;/code&gt; . &lt;code&gt;Markup(u'Hello!')&lt;/code&gt; ，会产生一个行为上相当像字符串的对象。类方法 &lt;code&gt;Markup.escape&lt;/code&gt; 工作方式相同，但会转义经过包裹的字符串中的任意HTML字符。&lt;/p&gt;
&lt;p&gt;这里有两个鬼祟的花招。第一：一个 &lt;code&gt;Markup&lt;/code&gt; 对象不会被转义两次。请看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; s = u&amp;#39;&amp;lt;b&amp;gt;oh noo xss&amp;lt;/b&amp;gt;&amp;#39;
&amp;gt;&amp;gt;&amp;gt; Markup.escape(s)
Markup(u&amp;#39;&amp;amp;lt;b&amp;amp;gt;oh noo xss&amp;amp;lt;/b&amp;amp;gt;&amp;#39;)
&amp;gt;&amp;gt; Markup.escape(Markup.escape(s))
Markup(u&amp;#39;&amp;amp;lt;b&amp;amp;gt;oh noo xss&amp;amp;lt;/b&amp;amp;gt;&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此，一旦创建了一个 &lt;code&gt;Markup&lt;/code&gt; 对象，就可将它用于你的模板，过滤器不会管它---即使它包含HTML。&lt;/p&gt;
&lt;p&gt;另一个把戏是， &lt;code&gt;Markup&lt;/code&gt; 对象重载了所有string的方法，并且自动转义所有的参数。这意味着在Python里，你可以这么干：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; user_input = u&amp;#39;&amp;lt;script&amp;gt;alert(&amp;quot;pwn&amp;quot;);&amp;lt;/script&amp;gt;&amp;#39;
&amp;gt;&amp;gt;&amp;gt; Markup(u&amp;#39;&amp;lt;p&amp;gt;Hello, %s!&amp;lt;/p&amp;gt;&amp;#39;) % user_input
Markup(u&amp;#39;&amp;lt;p&amp;gt;Hello, &amp;amp;lt;script&amp;amp;gt;alert(&amp;amp;#34;pwn&amp;amp;#34;);&amp;amp;lt;/script&amp;amp;gt;!&amp;lt;/p&amp;gt;&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此你可以相当安全地构建一些复杂的HTML代码，而不用太担心转义不够或者过分转义。&lt;/p&gt;
&lt;p&gt;当然，这并不完美。主要问题是你需要将 &lt;code&gt;Markup().join(...)&lt;/code&gt; 用于一些其他的 &lt;code&gt;Markup&lt;/code&gt; 对象，而不是 &lt;code&gt;''.join(...)&lt;/code&gt; 。并且某些操作，比如分片(slicing)，分割(splitting)，以及正则表达式，有可能产生没有意义的结果。 &lt;strong&gt;绝对&lt;/strong&gt; 不要试图分解一个 &lt;code&gt;Markup&lt;/code&gt; 对象或者任何其他HTML字符串；如果实在需要的话，那就使用一个真正的解析器，比如 &lt;code&gt;lxml&lt;/code&gt; ，但是大多数时候，你可以在将普通字符串包裹进HTML之前，对它做任何你需要的转换。&lt;/p&gt;
&lt;h2&gt;表单&lt;/h2&gt;
&lt;p&gt;我厌恶所有处理表单的库。每个单一的库。它们都把作者的疯狂命名方式强加到我的表单。我甚至不喜欢PHP使用 &lt;code&gt;foo[]&lt;/code&gt; 作为字段名称的行为；这有多丑陋啊。&lt;/p&gt;
&lt;p&gt;至今让我讨厌程度最低的是&lt;a href="http://wtforms.simplecodes.com/docs/dev/"&gt;wtform&lt;/a&gt;；它强加的设计上的限制相当少，并且使用起来非常简单。它甚至内建支持配合markupsafe。主要的缺陷是要想去除那些设计上的缺陷比较困难(每个表单元素都有一个与名字相匹配的 &lt;code&gt;id&lt;/code&gt; 属性)，并且实现一种新的字段会有点复杂。&lt;/p&gt;
&lt;p&gt;对于其他的我没法多说些什么，唉。&lt;a href="http://www.formencode.org/en/latest/index.html"&gt;FormEncode&lt;/a&gt;是一个东西。Pyramid的维护者还拥有&lt;a href="http://docs.pylonsproject.org/projects/deform/en/latest/index.html"&gt;deform&lt;/a&gt; 。它们都做了一些愚蠢的事情，也许确实是因为太挑剔了，我才这样烦扰。货比三家吧。&lt;/p&gt;
&lt;p&gt;无论你做啥，都要确保你使用东西不会使得你的项目变得太大。比表单处理库更让我厌恶的一件事是手动编写验证码。&lt;/p&gt;
&lt;h2&gt;"净化(Santizing)"&lt;/h2&gt;
&lt;p&gt;关于PHP界共同趋势的笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要&lt;/strong&gt; "净化(sanitize)"。&lt;/p&gt;
&lt;p&gt;这个词语本身没有什么意义。不存在某种你可以用于任意字符串并使之"安全"的方法。这种想法就是我一直遇到银行网站的联系表单告诉我不能使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 字符的原因；某些傻瓜企业开发者并不知道如何处理数据，所以他强迫所有数据必须简单易懂。&lt;/p&gt;
&lt;p&gt;不要成了一个白痴。&lt;/p&gt;
&lt;p&gt;大多数时候，"净化"是指使得用户输入安全地嵌入HTML，传递给SQL，或者作为命令行参数使用。你根本不需要改变原有数据就能做到所有这些事情。对于HTML，上面提到有一些过滤器，比如markupsafe。对于SQL，有界限参数和ORM。对于执行命令，你应该完全避免使用shell，仅仅将参数作为列表传递(参见 &lt;code&gt;subprocess&lt;/code&gt; (&lt;a href="http://docs.python.org/library/subprocess.html"&gt;http://docs.python.org/library/subprocess.html&lt;/a&gt;))。&lt;/p&gt;
&lt;p&gt;这些就是语言障碍(language barrier)的所有问题：HTML，SQL，以及shell都是结构化语言，你不能把一些莫名的垃圾数据倒给它们，还希望最好的结果。你不会使用字符串连结来创建JSON，所以也别用来执行 &lt;code&gt;convert&lt;/code&gt; (译注：这里的convert应该是用于图片格式转换的convert命令)。使用理解底层结构的工具。&lt;/p&gt;
&lt;p&gt;这并不是说你应该从不修改或过滤用户输入，而是你应该尽可能地避免它，并且当你做的时候应该极其小心。以常见的密码为例，为什么一般都禁止在密码中使用空格或者要将密码限制为16个字符？并没有明确的理由；仅仅是做了的一件事情。&lt;/p&gt;
&lt;p&gt;我仍然被这个问题所困扰：不让我输入 &lt;code&gt;&amp;lt;&lt;/code&gt; 的那个地方还坚持要我输入16个数字的字符串作为我的信用卡号。这就很难一目了然地证实我的输入是否正确---此外，在我的信用卡上的号码中间是有空格的呀！为什么不剔除空格和连字符？&lt;/p&gt;
&lt;p&gt;仔细思考你正在做的事情以及你正试图解决什么问题。人们会使用从右到左的Uniode字符对你的站点做一些愚蠢的事情么？你想阻止他们？没有理由要强迫每个人都使用ASCII；Unicode有&lt;a href="http://www.fileformat.info/info/unicode/category/index.htm"&gt;类别之分&lt;/a&gt;，你可以仅过滤怪异类别的字符。但更好的做法是，修改你的网站，使得说希伯来语的人都能使用它。:)&lt;/p&gt;
&lt;h2&gt;调试&lt;/h2&gt;
&lt;p&gt;如果你有幸(例如，使用Pyramid)，那么当你的程序崩溃时，你会有一个交互式的调试器，允许你检查程序的实时状态。你可以运行任意的Python代码，观察变量的状态，审核堆栈，以及耍着玩。&lt;/p&gt;
&lt;p&gt;如果你不幸，也不用担心；你还可以使用&lt;a href="http://werkzeug.pocoo.org/docs/debug/"&gt;werkzeug调试器&lt;/a&gt;。它相当易于使用；它能包裹任何WSGI应用，然后捕捉异常。(看到没有？WSGI妙得很。)&lt;/p&gt;
&lt;p&gt;只是当你部署应用的时候，要确保关闭调试，否则就会为别人所用；"任意Python代码"意味着任何看到调试屏幕的人都可以做你能在你的电脑做的任何事情。&lt;/p&gt;
&lt;h2&gt;数据库&lt;/h2&gt;
&lt;p&gt;一罐子的蠕虫啊。这话有些武断(This is as opinionated as I'm going to get.)。&lt;/p&gt;
&lt;p&gt;其一：你应该使用ORM。它是尝试将数据表映射到Python类，数据行映射到对象，查询映射到方法的物件。结果更加简单明了，通常更加容易理解，并且有时甚至正确率更高。&lt;/p&gt;
&lt;p&gt;你应该使用的ORM是&lt;a href="http://www.sqlalchemy.org/"&gt;SQLAlchemy&lt;/a&gt;。Pyramid对它有内建支持；如果你使用的框架没有内置支持，SQLAlchemy这么受欢迎，框架文档肯定有说明如何与它相连。如果你在使用Django，它有自己的ORM，虽然没有SQLAlchemy这么好，但要想把Django自带的ORM替换掉非常麻烦，不值得，除非你有迫切的需求。&lt;/p&gt;
&lt;p&gt;许多贬低ORM的人会告诉你ORM会产生糟糕的SQL。是的，糟糕的ORM确实会，但优秀的ORM，比如SQLAlchemy，对于SQL，和你理解得一样好。如果你懂SQL，SQLAlchemy会非常适合你；如果你不懂SQL，SQLAlchemy至少能帮你避免很多编写糟糕SQL的尴尬。记住你总是可以察看执行过的查询；SQLAlchemy可以把它们全部记录下来，并且各种调试工具栏会显示查询执行时间列表。(另外，留心那些执行多次的相同查询，这标示需要预先加载。)&lt;/p&gt;
&lt;p&gt;接下来，使用事务(transaction)。希望你不要对这个有太多的顾虑；如果一个框架集成了SQLAlchemy，它很可能会为你做这事。理念是：当开始一个请求，则开始一个事务，如果发生异常，事务会自动回滚。这是你一开始就想要的行为。这是使用数据库的一半(不对，是1/4)原因。&lt;/p&gt;
&lt;p&gt;还有一件事：既然本文中我所说的都是关于尝试新事物，那么 &lt;strong&gt;不要使用MySQL&lt;/strong&gt; 。在我能想到的任何意义上，MySQL都是数据库中的PHP(the PHP of databases)。考虑一下&lt;a href="http://www.postgresql.org/"&gt;PostgreSQL&lt;/a&gt;，它搭建起来并不会更难，使用起来更友好，也不会让你做在日期栏中存储字符串那样的蠢事。(在我看来，最友好的事情之一是PostgreSQL可以使用你的Unix用户帐号登录，不需要密码)。唯一的有人曾经反对使用Postgres的理由是它"不能扩展"。请放心，我还没看到这种情况的实际例子，总之，当访问者超过百万的时候，你才需要担心这个问题。&lt;/p&gt;
&lt;h2&gt;会话(Sessions)&lt;/h2&gt;
&lt;p&gt;每个框架都支持会话。看起来我们也熟悉：一个会话标识存储于cookie中，并且在后端你能魔法般地得到一个字典，可以往其中存储任意数据。随你怎么用。但尽量不要把它当作垃圾场。这事实证明数据库非常适合存储数据，你明白的。&lt;/p&gt;
&lt;p&gt;额外的特性包括：对CSRF(译注：Cross Site Request Forgery，跨站请求伪造)保护的一等(first-class)支持，以及信息提示(Pyramid，Flask，Django)。去阅读文档吧。&lt;/p&gt;
&lt;p&gt;提醒一句：如果你使用Beaker会话(Pyramid采用这个独立的库)，繁琐的东西会逐渐积累。默认情况下是为每个会话在磁盘上创建一个文件，但是如果使用数据库支持会话，你将得到一个存储了大量会话的数据表，并且这个数据表只增不减。这是一个非常糟糕却不明显的问题，主要的修复方法是手工操作。深表遗憾。&lt;/p&gt;
&lt;h2&gt;部署&lt;/h2&gt;
&lt;p&gt;啊哈，你明白我的意思的，部署有很多种方式，应该花更多的时间来讲述，但这里我没法花那么多的时间。&lt;/p&gt;
&lt;p&gt;如果可能，还是宁愿花些钱吧。提供服务肯定是要有代价的。如果你有自己的专用(虚拟的或者不是)机器随你摆弄，那么这是部署应用最简单的方式---手头有台服务器是件很酷的事情。你可以每月花费$20而获得一个基本的&lt;a href="http://www.linode.com/?r=c5316aa7d1cfce6f5fe611bb455ef1548cc1946c"&gt;Linode&lt;/a&gt;，还存在更便宜的托管服务提供商(但是没那么酷了)。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.heroku.com/"&gt;Heroku&lt;/a&gt;也是值得选择的，其收费等级中有一个免费级，只提供一个工作进程(worker，译注：Heroku官网解释"A worker dyno is a single background process running your code and processing jobs from a queue.")(类似于最低级Linode)，但是每个额外的工作进程都需要你另外支付$36/每月。(可以同时处理的请求数目正比于你持有的工作进程数目。具体需要多少工作进程则要看你的应用以及你如何运行它。)优点是你的应用会被部署得很专业。Heroku现在还支持多个应用副本。&lt;/p&gt;
&lt;p&gt;正如他们所说，部署是个很好的问题：因为这意味着你确实构建了有用的东西。那么在我努力写一篇关于部署选项的文章之时，你赶紧去构建某个应用吧。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Web是复杂的，涉及很多活动件(moving parts)。聪明的人们已经为你解决了很多问题。去捣鼓吧。&lt;/p&gt;
&lt;p&gt;希望本文足够让你开始Web开发了！&lt;/p&gt;
&lt;p&gt;一如既往，我并不知道自己做得怎么样，所以请你告诉怎样做得更好。&lt;/p&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>关于技术的学习方法</title><link href="http://youngsterxyf.github.io/2012/05/11/about-method-of-learning-technology/" rel="alternate"></link><updated>2012-05-11T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-05-11:2012/05/11/about-method-of-learning-technology/</id><summary type="html">&lt;p&gt;关于学习，时间短与效果好始终是一对矛盾的统一体。&lt;/p&gt;
&lt;p&gt;很多时候，要想在最短的时间内完成一件事情，最好的方法就是依葫芦画瓢，但这样的话，即使完成了事情，也只是知其然而不知其所以然，长久来看，对于学习者的能力不会有多大的提高。&lt;/p&gt;
&lt;p&gt;从长远来看，要想自己基础扎实，能力强，那就得一步一步的来，从基础知识开始，一点一点的搞懂，但这种方式需要花费很多时间，短时间内效果不明显。而且，可能效果没有预期的那么好。&lt;/p&gt;
&lt;p&gt;那么，如果做个权衡呢？&lt;/p&gt;
&lt;p&gt;我想，也许最好的学习方式是：先依葫芦画瓢地实践，获得一些直观感受，最好还有一些疑问。在实践完成之后，在整理自己的疑问，以及实践中涉及的知识要点，通过查阅图书或者网络资料，逐个知识点巩固，逐个解决疑问，并整理成文。这个整理总结的过程可能需要较长的时间。&lt;/p&gt;
&lt;p&gt;这种方式的优势在于：1.能让你快速地完成事情；2.实践中用到的知识多半会在以后的实践中经常用到，掌握的就是一些最重要的东西，而不会学习一些很少使用的深奥偏门知识。&lt;/p&gt;</summary><category term="技术"></category><category term="学习方法"></category></entry><entry><title>ubuntu12.04+ngnix+php-fastcgi+mysql+memcached网站开发测试环境搭建</title><link href="http://youngsterxyf.github.io/2012/05/10/ubuntu12.04-nginx-php-factcgi-mysql-memcached/" rel="alternate"></link><updated>2012-05-10T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-05-10:2012/05/10/ubuntu12.04-nginx-php-factcgi-mysql-memcached/</id><summary type="html">&lt;p&gt;1.
安装必要的软件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install nginx php5-cli php5-cgi spawn-fcgi psmisc mysql-server &lt;span class="se"&gt;\&lt;/span&gt;
mysql-client php5-mysql memcached php5-memcache php5-curl php5-gd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
打开浏览器访问: 127.0.0.1。就能看到表示nginx安装成功的页面。但这时访问php文件页面还不行。
（注：ngnix的配置文件目录为/etc/ngnix/，默认网站根目录为/usr/share/ngnix/www/；php配置文件目录为/etc/php5/）&lt;/p&gt;
&lt;p&gt;3.
编辑文件/etc/ngnix/sites-available/default，内容如下(可以先把原文件备份一下)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;server {
    #listen   80; ## listen for ipv4; this line is default and implied
    #listen   [::]:80 default ipv6only=on; ## listen for ipv6

    root /usr/share/nginx/www;
    server_name localhost;

    location / {

        index   index.html index.htm;
    }

    location ~ \.php$ {

        fastcgi_pass    localhost:9000;
        fastcgi_index   index.php;
        fastcgi_param   SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include         fastcgi_params;
        try_files $uri $uri/ /index.html;
    }

    error_page 404 /404.html;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.
修改文件/etc/php5/cgi/php.ini。去除&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;#cgi.fix_pathinfo=1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一行前面的&lt;code&gt;#&lt;/code&gt;。具体信息请看php.ini的相关注释。&lt;/p&gt;
&lt;p&gt;5.
创建文件/usr/bin/php-fastcgi :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;FASTCGI_USER&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;www-data
&lt;span class="nv"&gt;FASTCGI_GROUP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;www-data

&lt;span class="nv"&gt;ADDRESS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;127.0.0.1
&lt;span class="nv"&gt;PORT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;9000

&lt;span class="nv"&gt;PIDFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/run/php-fastcgi/php-fastcgi.pid
&lt;span class="nv"&gt;CHILDREN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;6

&lt;span class="nv"&gt;PHP5&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/bin/php5-cgi
/usr/bin/spawn-fcgi -a &lt;span class="nv"&gt;$ADDRESS&lt;/span&gt; -p &lt;span class="nv"&gt;$PORT&lt;/span&gt; -P &lt;span class="nv"&gt;$PIDFILE&lt;/span&gt; -C &lt;span class="nv"&gt;$CHILDREN&lt;/span&gt; -u &lt;span class="nv"&gt;$FASTCGI_USER&lt;/span&gt; -g &lt;span class="nv"&gt;$FASTCGI_GROUP&lt;/span&gt; -f &lt;span class="nv"&gt;$PHP5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.
设置/usr/bin/php-fastcgi为可执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo chmod +x /usr/bin/php-fastcgi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.
创建文件/etc/init.d/php-fastcgi：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;PHP_SCRIPT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr/bin/php-fastcgi

&lt;span class="nv"&gt;FASTCGI_USER&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;www-data
&lt;span class="nv"&gt;FASTCGI_GROUP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;www-data

&lt;span class="nv"&gt;PID_DIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/run/php-fastcgi
&lt;span class="nv"&gt;PID_FILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/run/php-fastcgi/php-fastcgi.pid
&lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; in
    start&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; ! -d &lt;span class="nv"&gt;$PID_DIR&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;
        &lt;span class="k"&gt;then&lt;/span&gt;
            mkdir &lt;span class="nv"&gt;$PID_DIR&lt;/span&gt;
            chown &lt;span class="nv"&gt;$FASTCGI_USER&lt;/span&gt;:&lt;span class="nv"&gt;$FASTCGI_GROUP&lt;/span&gt; &lt;span class="nv"&gt;$PID_DIR&lt;/span&gt;
            chmod &lt;span class="m"&gt;0770&lt;/span&gt; &lt;span class="nv"&gt;$PID_DIR&lt;/span&gt;
        &lt;span class="k"&gt;fi&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; -r &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;
        &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;php-fastcgi already running with PID `cat &lt;/span&gt;&lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;&lt;span class="s2"&gt;`&amp;quot;&lt;/span&gt;
            &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="nv"&gt;$PHP_SCRIPT&lt;/span&gt;
            &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$?&lt;/span&gt;
        &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="p"&gt;;;&lt;/span&gt;
    stop&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; -r &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;
        &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="sb"&gt;`&lt;/span&gt;cat &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
            rm &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;
            &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$?&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Could not find PID file &lt;/span&gt;&lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
            &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
        &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="p"&gt;;;&lt;/span&gt;
    restart&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; -r &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;
        &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="sb"&gt;`&lt;/span&gt;cat &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
            rm &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;
            &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$?&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Could not find PID file &lt;/span&gt;&lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;fi&lt;/span&gt;
        &lt;span class="nv"&gt;$PHP_SCRIPT&lt;/span&gt;
        &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$?&lt;/span&gt;
    &lt;span class="p"&gt;;;&lt;/span&gt;
    status&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; -r &lt;span class="nv"&gt;$PID_FILE&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;
        &lt;span class="k"&gt;then&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;php-fastcgi running with PID `cat &lt;/span&gt;&lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;&lt;span class="s2"&gt;`&amp;quot;&lt;/span&gt;
            &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$?&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Could not find PID file &lt;/span&gt;&lt;span class="nv"&gt;$PID_FILE&lt;/span&gt;&lt;span class="s2"&gt;, php-fastcgi does not appear to be running&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="p"&gt;;;&lt;/span&gt;
    *&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Usage: php-fastcgi {start|stop|restart|status}&amp;quot;&lt;/span&gt;
        &lt;span class="nv"&gt;RET_VAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1
    &lt;span class="p"&gt;;;&lt;/span&gt;
&lt;span class="k"&gt;esac&lt;/span&gt;
&lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="nv"&gt;$RET_VAL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8.
添加可执行权限，以及设置为开机启动&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo chmod +x /etc/init.d/php-fastcgi
sudo update-rc.d php-fastcgi defaults
sudo /etc/init.d/php-fastcgi start
sudo /etc/init.d/nginx start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;9.
创建文件/usr/share/nginx/www/test.php, 内容如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class="nb"&gt;phpinfo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="cp"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;10.
打开浏览器访问127.0.0.1/test.php，就能看到关于php信息的表格页面了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://library.linode.com/web-servers/nginx/php-fastcgi/ubuntu-10.04-lucid"&gt;Nginx and PHP-FastCGI on Ubuntu 10.04 LTS (Lucid)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Nginx"></category><category term="PHP"></category></entry><entry><title>Python对象创建过程（译）</title><link href="http://youngsterxyf.github.io/2012/04/26/python-object-creation-sequence/" rel="alternate"></link><updated>2012-04-26T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-04-26:2012/04/26/python-object-creation-sequence/</id><summary type="html">&lt;p&gt;原文： &lt;a href="http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"&gt;Python object creation sequence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[本文讨论的Python版本为3.x]&lt;/p&gt;
&lt;p&gt;本文旨在探究Python中新对象的创建过程。正如我在&lt;a href="http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work"&gt;前一篇文章&lt;/a&gt;中所解释的，对象的创建只是调用可调用对象的一种特例。考虑这样的一段Python代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当j = Joe()被执行时发生了什么呢？Python把它看作对可调用的Joe的一次调用，并且将它路由到内部函数 &lt;code&gt;PyObject_Call&lt;/code&gt; ，将Joe作为PyObject_Call的第一个参数。 &lt;code&gt;PyObject_Call&lt;/code&gt; 根据其第一个参数的类型抽取这个参数类型的 &lt;code&gt;tp_call&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;那么，Joe的类型是什么呢？无论何时我们定义一个新的Python类(class)，它的类型都是 &lt;code&gt;type&lt;/code&gt; ，除非我们明确地为它指定一个 &lt;a href="http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;metaclass&lt;/a&gt;。因此，当 &lt;code&gt;PyObject_Call&lt;/code&gt; 试图查看Joe的类型，将得到类型 &lt;code&gt;type&lt;/code&gt; ，然后选择 &lt;code&gt;type&lt;/code&gt; 的 &lt;code&gt;tp_call&lt;/code&gt; 属性。换句话说，就是调用 &lt;code&gt;Objects/typeobject.c&lt;/code&gt; 文件中的函数 &lt;code&gt;type_call&lt;/code&gt; [1]。&lt;/p&gt;
&lt;p&gt;这是一个有趣并且短小的函数，所以我将它整个地粘贴到这里：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;type_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyTypeObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;kwds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;to_new&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;PyErr_Format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyExc_TypeError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="s"&gt;&amp;quot;cannot create &amp;#39;%.100s&amp;#39; instances&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tp_name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tp_new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kwds&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Ugly exception: when the call was type(something),&lt;/span&gt;
&lt;span class="cm"&gt;            don&amp;#39;t call tp_init on the result. */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;PyType_Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class="n"&gt;PyTuple_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;PyTuple_GET_SIZE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwds&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyDict_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;PyDict_Size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="cm"&gt;/* If the returned object is not an instance of type,&lt;/span&gt;
&lt;span class="cm"&gt;            it won&amp;#39;t be initialized. */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;PyType_IsSubtype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Py_TYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Py_TYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tp_init&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tp_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kwds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Py_DECREF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在我们的例子中传给 &lt;code&gt;type_call&lt;/code&gt; 的参数是什么呢？第一个是Joe自己---它是如何表示的呢？好吧，Joe是一个类(class)，因此它是一个 &lt;em&gt;类型(type)&lt;/em&gt; (&lt;a href="http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/"&gt;Python3中所有类都是类型&lt;/a&gt;)。而类型在CPython虚拟机内部是通过 &lt;code&gt;PyTypeObject&lt;/code&gt; 对象来表示的[2]。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type_call&lt;/code&gt; 首先调用给定类型的 &lt;code&gt;tp_new&lt;/code&gt; 属性。然后，检测一个特殊的情况(为简单起见可忽视先)以确保 &lt;code&gt;tp_new&lt;/code&gt; 返回的是预期类型的对象，然后调用 &lt;code&gt;tp_init&lt;/code&gt; 。如果返回的是一个不同类型的对象，则不将其初始化。&lt;/p&gt;
&lt;p&gt;从Python代码来看，就是发生了这些事情：如果你的类中定义了特殊方法 &lt;code&gt;__new__&lt;/code&gt; ，当创建类的一个新实例时，首先调用这个特殊方法。这个方法必须返回某个对象。通常，返回的即是预期类型的对象，但是并非必须如此。所需类型的对象对其自身调用 &lt;code&gt;__init__&lt;/code&gt; 。示例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__new__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__new__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;__new__ called. got new obj id=0x&lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;__init__ called (self=0x&lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="s"&gt;) with arg=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;

&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;__new__ called. got new obj id=0x7f88e7218290
__init__ called (self=0x7f88e7218290) with arg=12
&amp;lt;class &amp;#39;__main__.Joe&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;自定义过程&lt;/h2&gt;
&lt;p&gt;如上所示，Joe的类型为 &lt;code&gt;type&lt;/code&gt; ，所以调用函数 &lt;code&gt;type_call&lt;/code&gt; 定义Joe实例的创建过程。可以通过为Joe指定一个自定义的类型来改变这个过程---换句话来说，这种自定义的类型就是一个metaclass。让我们修改前面的示例来为Joe指定一个自定义的metaclass：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MetaJoe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__call__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;MetaJoe.__call__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;metaclass&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;MetaJoe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__new__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__new__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;__new__ called. got new obj id=0x&lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;__init__ called (self=0x&lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="s"&gt;) with arg=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;

&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Joe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在Joe的类型不是 &lt;code&gt;type&lt;/code&gt; ，而是 &lt;code&gt;MetaJoe&lt;/code&gt; 。因此，当 &lt;code&gt;PyObject_Call&lt;/code&gt; 为 &lt;code&gt;j = Joe(12)&lt;/code&gt; 选择要执行的调用函数，它选择的是 &lt;code&gt;MetaJoe.__call__&lt;/code&gt; 。后者先打印一条关于自己的提示，然后返回None，所以我们根本不要期望调用Joe的方法 &lt;code&gt;__new__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;事实上，输出是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;MetaJoe.__call__
&amp;lt;class &amp;#39;NoneType&amp;#39;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;更深的挖掘 - tp_new&lt;/h2&gt;
&lt;p&gt;很好，现在我们对于对象创建过程有了一个更好的理解，但是这一问题的一个关键部分还没有得到解释。虽然我们几乎总会为类定义方法 &lt;code&gt;__init__&lt;/code&gt; ，但却很少定义 &lt;code&gt;__new__&lt;/code&gt; [3]。此外，快速浏览一下代码就能明显地发现从某种程度上 &lt;code&gt;__new__&lt;/code&gt; 更为重要。这个方法是被用来创建对象的。每个实例仅调用它一次。另一方面，调用 &lt;code&gt;__init__&lt;/code&gt; 时已经得到了一个构造好的对象，且 &lt;code&gt;__init__&lt;/code&gt; 可能根本不会被调用；而且它也可以被调用多次。&lt;/p&gt;
&lt;p&gt;在我们的例子中，传递给 &lt;code&gt;type_call&lt;/code&gt; 的参数type是Joe，而Joe并没有自定义的 &lt;code&gt;__new__&lt;/code&gt; 方法，那么 &lt;code&gt;type-&amp;gt;tp_new&lt;/code&gt; 的工作将交予基本类型(the base type)的结构成员(slot) &lt;code&gt;tp_new&lt;/code&gt; 。Joe(&lt;a href="http://eli.thegreenplace.net/2012/04/03/the-fundamental-types-of-python-a-diagram/"&gt;以及所有其他的Python对象&lt;/a&gt; ，除了object自己)的基本类型是object。CPython内部是通过Objects/typeobject.c中的object_new函数来实现object.tp_new结构成员的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;object_new&lt;/code&gt; 实际上非常简单：先检查某些参数，核实正尝试实例化的类型不是&lt;a href="http://docs.python.org/dev/library/abc.html"&gt;抽象&lt;/a&gt;的，然后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tp_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;tp_alloc&lt;/code&gt; 是CPython内部类型对象的一个低层次结构成员，不可以在Python代码中直接访问它，但是C扩展开发人员应该对它比较熟悉。C扩展程序中的自定义类型(custom type)可能会重载这个结构成员从而为自己的实例提供一个自定义的内存分配方案。然而，大多数的C扩展类型会将其实例的内存分配工作交予 &lt;code&gt;PyType_GenericAlloc&lt;/code&gt; 函数完成。&lt;/p&gt;
&lt;p&gt;这个函数是CPython的公共C API的一部分，也恰好将它赋值给了object的结构成员 &lt;code&gt;tp_alloc&lt;/code&gt; (在Objects/typeobject.c中定义)。它先算出新对象需要多少内存空间[4]，从CPython的内存分配器中分配一个内存块，将分配得的所有内存单元都初始化为0，然后仅初始化基本的PyObject域(类型与引用计数)，做些垃圾收集簿记(GC bookkeeping)的工作并返回。其结果是一个刚分配的实例。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;为了避免只见树木不见森林，让我们一起回顾一下文章开始的那个问题。当CPython执行j = Joe()时发生了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;&gt; 由于Joe没有明确的metaclass，type就是它的类型，因此调用type的tp_call接口，即是，type_call。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;&gt; 由于Joe没有明确的基类(base class)，它的基类(base)就是object(译注:意思就是Joe继承自object)，因此，调用object_new。&lt;br /&gt;
&gt;&gt; 由于Joe是一个Python代码定义的类，它没有自定义的tp_alloc接口。因此，object_new调用PyType_GenericAlloc。&lt;br /&gt;
&gt;&gt; PyType_GenericAlloc分配并初始化一块足够大的内存空间用来存储Joe。
&gt;&gt; 然后type_call继续执行并在刚创建对象上调用Joe.&lt;strong&gt;init&lt;/strong&gt;。
&gt;&gt; 由于Joe没有定义__init__，所以调用它的基类的__init__，即object_init。&lt;br /&gt;
&gt;&gt; object_init啥事都没干。
&gt;&gt; 从type_call返回新的对象并将其绑定到名字j。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上，就是创建一个类的对象的乏味的流程，这个类没有自定义的metaclass，没有明确的基类，也没有定义它自己的__new__和__init__方法。然而，本文应该已经解释清楚了如何插入自定义功能从而改变对象创建过程。正如你所见的，Python灵活得令人惊讶，几乎可以自定义上述过程的每个步骤，甚至对于Python代码实现的用户定义的类型也是如此。C扩展中实现的类型可以进行更多的自定义，比如：用于创建类型实例的确切的内存分配策略。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;[1] type的PyTypeObject结构定义即为Objects/typeobject.c中的PyType_Type。你可以看到type_call被赋值给了它的结构成员tp_call。&lt;/p&gt;
&lt;p&gt;[2] 以后的文章会解说:当创建一个新类时这是怎么实现的。&lt;/p&gt;
&lt;p&gt;[3] 甚至当在类中明确地重载了__new__，我们也几乎可以肯定实际的对象创建被推迟到基类的__new__。&lt;/p&gt;
&lt;p&gt;[4] 任何类型的PyObject头部都有这个信息。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;译注:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;sequence直译成"序列，顺序"，可能会导致不容易理解文章的意思，所以翻译成" &lt;strong&gt;过程&lt;/strong&gt; "更合适一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPython中用C语言的结构(struct)来定义对象(类型也是对象)，一个对象所具有的方法或者属性都是结构的成员，所以把slot翻译成" &lt;strong&gt;结构成员&lt;/strong&gt; "应该比较合适。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Python"></category><category term="翻译"></category></entry><entry><title>关于指针的一道笔试题</title><link href="http://youngsterxyf.github.io/2012/04/20/an-exercise-about-pointer/" rel="alternate"></link><updated>2012-04-20T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-04-20:2012/04/20/an-exercise-about-pointer/</id><summary type="html">&lt;p&gt;同学找实习，遇到这样一道笔试题:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;***&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这题还是有点小意思的。遇到这种题，脑子一定要清楚，注意分析。&lt;/p&gt;
&lt;p&gt;对于int *a[2][3]应该这么理解：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a是个数组，有两个元素；元素也是数组，其有3个元素，每个元素是指向int类型的指针。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针的长度固定为4个字节，C语言的int类型也是4个字节。&lt;/p&gt;
&lt;p&gt;这样一分析，这题就简单了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sizeof(a)意思是求a数组的长度，数组的长度=数组元素的个数*元素的长度，所以sizeof(a) = 2 * 3 * 4 = 24个字节
sizeof(*a)中的*a是指a的第一个元素，所以sizeof(*a)就是求a数组的第一个元素的长度，即sizeof(*a) = 3 * 4 = 12个字节
sizeof(**a)则是求a的第一个元素(也是数组)的第一个元素(是指向int类型的指针)的长度，所以sizeof(**a) = 4个字节(即为一个指针的长度)
sizeof(***a)，因为**a是一个指针类型，那么***a即为*(**a)，那为指针指向的值，这里为int类型，所以sizeof(***a) = 4个字节(int类型的长度)
&lt;/pre&gt;&lt;/div&gt;</summary><category term="笔试"></category><category term="C/C++"></category></entry><entry><title>学习的"道"与"术"</title><link href="http://youngsterxyf.github.io/2012/03/31/dao-and-shu-about-learning/" rel="alternate"></link><updated>2012-03-31T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-03-31:2012/03/31/dao-and-shu-about-learning/</id><summary type="html">&lt;p&gt;读研以来，一直觉得自己的学习方法不够高效。试图将要学习的东西进行分类，然后以不同的方法学习之。那么该如何分类呢？我觉得以"道"与"术"区分之比较合适。&lt;/p&gt;
&lt;p&gt;何为"道 "？汉语辞典中有两条解释：&lt;strong&gt;1.指法则、规律；2.学术或宗教的思想体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;何为"术"？：&lt;strong&gt;技艺&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字面理解，“术”更为具体，是完成一件事情的具体过程。而“道”者则是指导实践的思想，是能够举一反三的事物规律。&lt;/p&gt;
&lt;p&gt;那么是否“道”比“术”更重要呢？我想未必。任何理论，任何“道”都最终来源于“术”的实践过程，也最终需要在“术”上得到实施，才能体现其价值。“道”与“术”两者相辅相成。那么在我们学习一门学问的过程中，就存在一个“道”与“术”何者为先的问题，即从“道”还是“术”入手学习？&lt;/p&gt;
&lt;p&gt;孟岩说过这么一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我主张,在具备基础之后,学习任何新东西,都要抓住主线,突出重点。对于关键理论的学习,要集中精力,速战速决。而旁枝末节和非本质性的知识内容,完全可以留给实践去零敲碎打。
原因是这样的,任何一个高级的知识内容,其中都只有一小部分是有思想创新、有重大影响的,而其它很多东西都是琐碎的、非本质的。因此,集中学习时必须把握住真正重要那部分,把其它东西留给实践。对于重点知识,只有集中学习其理论,才能确保体系性、连贯性、正确性,而对于那些旁枝末节,只有边干边学能够让你了解它们的真实价值是大是小,才能让你留下更生动的印象。如果你把精力用错了地方,比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧,而对于真正重要的、思想性东西放在平时零敲碎打,那么肯定是事倍功半,甚至适得其反。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然这段话并没有明确区分学习的“道”与“术”，以及何者为先的问题。但却大致说明了何为正确的学习方法。&lt;/p&gt;
&lt;p&gt;从“道”与“术”的角度来理解，那关键的，核心的，创新的部分即为“道”，“大道”。而那细节的则是“术”的部分，是需要长时间的实践的，也许只有在实践中遇到的细节才是有意义的。&lt;/p&gt;
&lt;p&gt;但那“具备基础之后”的“基础”是什么呢？我想应该是：1.明确问题是什么。这一点是再怎么强调都不为过的。要解决一个问题却没有真正明确问题到底是什么，那你努力多半是白费的。2.这东西是用来干什么用的，是用来解决什么问题的？对于工科学生来说，学习新东西的时候，这一点是需要首先明确的，只有明确了“干什么用的”，才能抓住学习的重点，提高学习的效率。3. 与以前的类似的东西相比，其区别是什么？一样东西，一种理论其价值往往在于对前人的突破，这突破的地方才是我们真正要掌握的。在学习一样东西之前，不妨多问问自己为什么要学这个，这东西对自己有多大的提升？不断地重复学习类似的东西，多半是没有意义的。&lt;/p&gt;
&lt;p&gt;具备了基础之后，对于关键理论的学习，是不是只要抱着书本，理论对理论的学习就行呢？我想这是万万不可的。特别是对于着重于实践性的学问，比如编程，理论对理论地学习，只会让你吃力不讨好。绝大多数的创新理论，核心理论，都不是一下子就能理解的，特别是当你对这一领域的学问并不熟悉的情况下，它需要在反复的实践中逐步地加深理解。&lt;/p&gt;
&lt;p&gt;那么对于关键内容的学习，我觉得这样学习会比较合适：先快速地，在尽可能短的时间内把关键内容浑沦吞枣地过一遍，能理解多少是多少，目的是为了获得一个理论的一个Big Picture，明确理论的各个部分之间的大致关系。然后对于每个部分，以及部分之间的关系，逐个地通过实践来验证你的理解，但这个实践过程并不属于“术”，因为它不是为了技艺，而只是为了验证自己对理论的理解。这一验证过程结束之后，你应该就能够对关键理论有个整体的正确的理解了。&lt;/p&gt;
&lt;p&gt;然后，你就放开手去干吧，去解决那些现实中的问题！&lt;/p&gt;
&lt;p&gt;也许，你会说，不用这么复杂吧？是的，如果你只是为了解决一个实际的问题，而这个问题也存在相近的解决方案，你不想也不需要弄懂这个问题，好吧，那你就直接去找解决方案吧。但你解决这个问题之后，你学到了什么呢？当你再次遇到一个本质上一样的问题的时候，你还是能快速地解决么？没有真正弄懂问题，没有弄懂问题背后的知识，那你就准备着为类似的问题重复地去寻找解决方案吧。恩，看起来有点傻哦。&lt;/p&gt;</summary><category term="学习方法"></category></entry><entry><title>Python学习路线(针对具备一定编程经验者)</title><link href="http://youngsterxyf.github.io/2012/02/21/the-path-of-learning-python/" rel="alternate"></link><updated>2012-02-21T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-02-21:2012/02/21/the-path-of-learning-python/</id><summary type="html">&lt;p&gt;相比C,C++,JAVA等编程语言，Python是易学的。但要想深入地理解Python，并熟练地编写Python风格的Python代码。我想还是有一长段路程要走的。下面即是我的一点经验总结，主要是为了整理自己学习的思路。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花1-2天的时间阅读一本好的Python入门书籍，并在亲手实践书中的代码。推荐入门书籍：《A byte of Python》(中文翻译《简明Python教程》)或《Practical Programming:An Introduction to Computer Science Using Python》(中文翻译《Python实践教程》)或者其他的比较薄的入门书籍。&lt;/li&gt;
&lt;li&gt;抛开书籍，用Python去写一切你想写的程序。这时最好的参考文档即为：(1).Python命令解释器中的help(),dir()辅助方法；(2).Python官网文档：&lt;a href="http://docs.python.org/"&gt;http://docs.python.org/&lt;/a&gt; 。遇到不清楚的地方就用这两个方法查，再不行就去google一下。&lt;/li&gt;
&lt;li&gt;两三个月之后，积累一点的代码量，再重新找本讲解比较详细的书，重新梳理一下自己对Python的理解，纠正自己实践中一些不好的方式。推荐书籍：《Beginning Python: From Novice to Professional》(中文翻译《Python基础教程》)，《Learning Python》(中文翻译《Python学习手册》)，《Dive into Python》，《Core Python Programming》等。另外，也应该在编码的过程中重复地去查阅Python标准函数库，标准库里已有模块实现的功能就不要自己实现。&lt;/li&gt;
&lt;li&gt;之后，根据实际需要，去了解使用一下Python的各个方面的函数库(比如http://docs.python.org/modindex.html中罗列出来的，以及matplotlib, numpy等用于科学计算，图形图像处理的)，特别是诸多的Web框架(django, web2py, cherrypy, tornado等)，可以先从简单的开始。如果是对Python的底层实现感兴趣，那么就该去看看Python源码，阅读一下《Python源码剖析》; 如果对文本处理感兴趣，可以阅读一下《Text processing in Python》等； 如果对网络感兴趣，可以阅读《Foundations of Python Network Programming》，尝试实现一个简单的web server ...&lt;/li&gt;
&lt;li&gt;Python相关的开源函数库非常非常的多，各个方面的都有，所以学习者应该尝试着去用它们，了解它们，而不是啥都要自己来实现。因为Python擅长的就是快速开发，而且站在前人的肩膀上，我们才能站得更高，看得更远。当然如果你想加深自己对某个方面的理解，也可以尝试去实现一些简单的模块。&lt;/li&gt;
&lt;li&gt;总之一句话：学习Python的关键就是用！而且是要多用别人的。动手实践才是王道！那么多优秀的开源函数库不要浪费了！&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Python"></category></entry><entry><title>Linux命令习题</title><link href="http://youngsterxyf.github.io/2012/02/15/Linux-Command-Excercise/" rel="alternate"></link><updated>2012-02-15T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-02-15:2012/02/15/Linux-Command-Excercise/</id><summary type="html">&lt;p&gt;For each of the outputs listed below, find one sequence of commands connected by pipes that produces the output. For each problem, turn in the command sequence that you used to generate the requested output. (Do NOT turn in the output itself.)&lt;/p&gt;
&lt;p&gt;1.
A listing of all processes that you are currently running on the machine you are using, sorted by the command name in alphabetical order (i.e. a process running acroread should be listed before a process running bash). The output should consist only of the processes you are running, and nothing else (i.e. if you are running 6 processes, the output should only have 6 lines). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ps -e --sort cmd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
he number of words in the file /usr/share/dict/words (*) which start with the letter a.&lt;/p&gt;
&lt;p&gt;* Note: On some Unix/Linux systems, the dictionary has the filename /usr/dict/words&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cat /usr/share/words &lt;span class="p"&gt;|&lt;/span&gt; grep ^a.* &lt;span class="p"&gt;|&lt;/span&gt; wc -l
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.
A "long" listing of the smallest 5 files in the /etc directory whose name contains the string ".conf", sorted by increasing file size. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ls -lSrp &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="o"&gt;[&lt;/span&gt;^/&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="se"&gt;\.&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;conf&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt; head -n 5
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Linux"></category></entry><entry><title>2011年终-回顾与展望</title><link href="http://youngsterxyf.github.io/2012/01/01/2011-summary/" rel="alternate"></link><updated>2012-01-01T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2012-01-01:2012/01/01/2011-summary/</id><summary type="html">&lt;p&gt;昨晚实验室聚餐，和师兄们喝醉了，明年的这个时候，我也就和他们一样将要毕业。时间，总是往前看觉得很漫长，可回过头去看看，一年也就是瞬间的事情。&lt;/p&gt;
&lt;p&gt;2011，我从研一走向研二，2012，我将从研二走向研三，继而毕业，工作。&lt;/p&gt;
&lt;p&gt;回顾过去一年，于我自己而言，过得很平淡，也许是大学以来最平淡的一年，只能说也许，因为对于2011，我记不得太多的事情。&lt;/p&gt;
&lt;p&gt;这一年里，我，一个技术男，比以前更宅，话也相对少了很多，直接表现为QQ空间或者校内上的文字写得很少。很少和别人谈论自己，因为我觉得纠结于那个“小我”是件很“小青年”的事情。人与人之间不可避免的隔膜导致了个人的事情不管多大在别人眼里都是微不足道的，在别人的心里掀不起半点波澜，说过了也就忘了。所以那些关于自己的，还是放在心里比较好，毋须说些没意义的。&lt;/p&gt;
&lt;p&gt;这一年里，我想得挺多，但真正做了或者说做好的却很少。这是件严重的事情。特别在技术上，东看西看，东学西学，眼界确实开阔很多，也养成了较为良好的技术趣味。但从技术能力上来说，真不好说，我都不知道自己有几斤几两。&lt;/p&gt;
&lt;p&gt;这一年里，最大的收获，也许是对“学习”的重新认识，以及试图从“学知识”向“做事情”转变(这里的“做事情”特指“解决实际问题”)，以前的自己太喜欢太沉迷于学东西，而忽略了自主地做事情。“生有涯，而知无涯”的无奈是必须面对的，对于有限的人生来说，知识必须对自己有用才值得学，特别是技术相关的知识，那怎么知道哪些知识对自己有用呢？得“边用边学”，需要用的时候再学。所以应多做事情，应找实际的问题，尝试去解决，在解决问题的过程中学习。解决实际问题才是根本，才是目的，而不是学习。学生时代习惯了学，习惯了边学边用，但对于研究生，对于以后的工作来说，光顾着学是没用的，而且一味的学也是非常难以深入的，要对某个方面有个深入的理解，必须通过做事情，发现问题，解决问题。&lt;/p&gt;
&lt;p&gt;这一转变过程让我非常纠结，而且到目前为止还算不上成功。可能对于很多人来说，这个过程可能很简单，但对于我来说，好奇心强，喜欢学东西的来说，确实极其艰难的。每做一件事情，都很可能陷入学习的状态，而不会及时地适可而止。&lt;/p&gt;
&lt;p&gt;这一过程希望在2012年有个很好的进展。&lt;/p&gt;
&lt;p&gt;这一年里，我逐步意识到自己存在的另一个大问题---不够自信，其外在表现为和别人一起时，极其容易将自己的观点让位于别人的观点，即使我并不认为自己的观点存在什么问题，或者别人的观点比我的更正确。我只是不想凌驾于别人之上，不想让自己影响到别人。这听起来似乎不关乎自信，但我想本质上是的。“不够自信”这看起来也似乎不是什么大问题，但我想对于一个成年人，特别是一个男人，自信是非常重要的，对于事业也是件非常重要的事情。以前自己活得太谨慎，不喜欢在公共场合表现自己，觉得提高自己的内在修为才是重要的。但其实活在社会中，适时适当地表现自己，表达自己的观点，坚持自己的看法是非常重要的。有个词叫“内圣外王”，以后我得更加注重“外王”，内外兼修。&lt;/p&gt;
&lt;p&gt;这一年里，我活得又很随性(和“活得谨慎”矛盾而共存)，不太注意自己的言行，脏话口头禅也比较多，虽然在我看来，我的脏话全是在表达一种情绪，仅此而已。但我想在别人来看，其感受也许并不是这样的。我们年轻人还是要注意自己的形象的，呵呵。另外，尽量少评论别人，特别是别人的缺点。&lt;/p&gt;
&lt;p&gt;这一年里，我很懒散，自己都有些看不过去了，“这样的日子，再好的，没有了”，我想不是件好事情。能够自我安慰点是还读了点书，整理一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社科文艺类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;佛祖在一号线&lt;/li&gt;
&lt;li&gt;书虫小札&lt;/li&gt;
&lt;li&gt;复杂性思想导论&lt;/li&gt;
&lt;li&gt;人生&lt;/li&gt;
&lt;li&gt;给研究生的学术建议&lt;/li&gt;
&lt;li&gt;边城&lt;/li&gt;
&lt;li&gt;朱镕基答记者问&lt;/li&gt;
&lt;li&gt;窗里窗外&lt;/li&gt;
&lt;li&gt;联大八年&lt;/li&gt;
&lt;li&gt;笑谈大先生&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技术类&lt;/strong&gt; (部分是按需选取章节阅读)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shell脚本学习指南&lt;/li&gt;
&lt;li&gt;Linux内核设计与实现&lt;/li&gt;
&lt;li&gt;鸟哥的Linux私房菜&lt;/li&gt;
&lt;li&gt;PHP和MySQL Web开发（原书第3版）&lt;/li&gt;
&lt;li&gt;分布式处理实践&lt;/li&gt;
&lt;li&gt;Java Collections&lt;/li&gt;
&lt;li&gt;可爱的Python&lt;/li&gt;
&lt;li&gt;浪潮之巅 &lt;/li&gt;
&lt;li&gt;CSS Web设计快速上手&lt;/li&gt;
&lt;li&gt;编程人生&lt;/li&gt;
&lt;li&gt;C陷阱与缺陷&lt;/li&gt;
&lt;li&gt;调试九法&lt;/li&gt;
&lt;li&gt;黑客与画家&lt;/li&gt;
&lt;li&gt;Python UNIX 和Linux 系统管理指南&lt;/li&gt;
&lt;li&gt;版本控制之道&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较而言，数量上不算少，也不算多，但主要问题还是质量上，觉得自己有些浑沦吞枣，读得太匆忙。这是以后的阅读需要注意的，克制焦躁的心理，慢慢阅读消化。&lt;/p&gt;
&lt;p&gt;新的一年，具体来说，我需要面对的几件大事情，大致包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小论文&lt;/li&gt;
&lt;li&gt;实习&lt;/li&gt;
&lt;li&gt;毕业论文，包括答辩&lt;/li&gt;
&lt;li&gt;找工作&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2012年底，我将要毕业了(虽然，形式上是2013年毕业)，我就要工作了，这也许是和高考相当的一件大事，希望自己能够举重若轻，踏实准备，顺利应对。(再具体点是不是应该说多多coding，多做事情！哈哈)&lt;/p&gt;</summary><category term="总结"></category></entry><entry><title>《Classic Shell Scripting》：ls, locate, type, find, df, du, diff, patch</title><link href="http://youngsterxyf.github.io/2011/12/23/classic-shell-scripting-ls-locate-and-so-on/" rel="alternate"></link><updated>2011-12-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-23:2011/12/23/classic-shell-scripting-ls-locate-and-so-on/</id><summary type="html">&lt;h4&gt;一.ls&lt;/h4&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ls [ options ] [ file(s) ]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;列出文件目录的内容
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-1 : 数字1.强制为单栏输出。在交互式模式下，ls一般会以适于当前窗口的最小宽度，使用多个列
-a : 显示所有文件，包括隐藏文件(文件名以点号起始的文件)
-d : 显示与目录本身相关的信息，而非它们包含的文件的信息。
-F : 使用特殊结尾字符，标记特定的文件类型
-g : 仅适用于组：省略所有者名称(隐含-l，小写L选项)
-i : 列出inode编号
-L : 紧接着符号性连接，列出它们指向的文件
-l : 小写的L。以冗长形式列出，带有类型，权限保护，所有者，组，字节计数，最后修改时间和文件名
-r : 倒置默认的排序顺序
-R : 递归列出，下延进入每个子目录
-S : 按照由大到小的文件大小计数排序。仅GNU版本支持
-s : 以块(与系统有关)为单位，列出文件的大小
-t : 按照最后修改时间戳排序
--full-time : 显示完整的时间戳，仅GNU版本支持
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;二.locate&lt;/h4&gt;
&lt;p&gt;locate将文件系统里的所有文件名压缩成数据库，以迅速找到匹配类Shell通配字符的文件名，不必实际查找整个庞大的目录结构&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;locate gcc-3.3.tar
locate &lt;span class="s1"&gt;&amp;#39;*gcc-3.3*.tar*&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;三.type&lt;/h4&gt;
&lt;p&gt;偶尔你也可能会想知道，调用一个没有路径的命令时，它在文件系统的位置如何。Bourne-Shell家族里的type命令可以告诉你：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;type &lt;/span&gt;gcc             &lt;span class="c"&gt;#gcc在哪？&lt;/span&gt;
&lt;span class="nb"&gt;type type&lt;/span&gt;            &lt;span class="c"&gt;#type是什么？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;请注意:type是Shell内置命令，所以它认得别名与函数。&lt;/p&gt;
&lt;h4&gt;四.find&lt;/h4&gt;
&lt;p&gt;假定你想选择大于某个大小的文件，或是三天前修改过，属于你的文件，或者拥有三个或三个以上直接链接的文件，就会需要UNIX工具集里最强力的find命令。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;find [ files-or-directories ] [ options ]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;寻找与指定名称模式匹配或具有给定属性的文件
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-atime n : 选定n天前访问的文件
-ctime n : 选定n天前改过inode的文件
-follow : 接着符号性连接
-group g : 选定组g内的文件(g为用户组ID名称或数字)
-links n : 选定拥有n个直接链接的文件
-ls : 产生类似ls冗长形式的列表，而不是只有文件名
-mtime n : 选定n天前修改过的文件
-name &amp;#39;pattern&amp;#39; : 选定文件名与Shell通配字符模式匹配的文件(通配字符模会使用括号框起来，可避免Shell解释)
-perm mask : 选定与指定八进制权限掩码匹配的文件
-prune : 不向下递归到目录树状结构里
-size n : 选择大小为n的文件
-type t : 选定类型t的文件，类型是单一字母:d为目录，f为文件，l为符号性连接
-user u : 选定用户u拥有的文件(u为用户ID名称或编号)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;警告&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;find输出的是未排序的结果
find提供额外的选项，可对选定的文件执行任意操作。由于这是一个潜在的危险，我们不建议使用这类选项。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;find不同于ls与Shell的地方是：它没有隐藏文件的概念，也就是说：就算是点号开头的文件名，find还是能找到它。&lt;/p&gt;
&lt;p&gt;另一点不同于ls的是：find不排序文件名。它只是以它读到目录的顺序依次显示，事实上这个排序应是随机的。因此，你可能得在find命令后，通过管道加入sort步骤。&lt;/p&gt;
&lt;p&gt;-size选项必须接上一个数字参数。默认值是以512字节为单位的大小，不过很多find实例，允许在数字之后加上c表示字符(字节)，或k表示kilobyte(KB)。如果数字未带有正负号，则指的是必须确实匹配于该文件大小。如果为负，则只有小于该数字(绝对值)的文件大小是匹配的。否则，带有正号，则只有大于该容量的文件才匹配。-links,-atime,-ctime,-mtime选项类似。&lt;/p&gt;
&lt;h4&gt;五.df&lt;/h4&gt;
&lt;p&gt;df(disk free，磁盘可用空间)提供单行摘要，一行显示一个加载的文件系统的已使用的和可用的空间。大部分现代实现都支持-k选项，也就是强制使用kilobyte单位，以及-l(小写L)选项，仅显示本地文件系统，排除网络挂载的文件系统。&lt;/p&gt;
&lt;p&gt;df的输出是未排序的。&lt;/p&gt;
&lt;h4&gt;六.du&lt;/h4&gt;
&lt;p&gt;df会摘要文件系统的可用空间，但它并不会告诉你某个特定的目录树需要多少空间，这是du(disk usage，磁盘用量)的工作。du就像df一样，有两个常见的选项实现：-k(kilobyte单位)与-s(摘要)。&lt;/p&gt;
&lt;p&gt;du会针对每个文件或目录参数---如果无提供这类参数则为当前目录，产生一个输出行。&lt;/p&gt;
&lt;h4&gt;七.diff and patch&lt;/h4&gt;
&lt;p&gt;如果你想知道两个相似的文件有何不同，可使用diff。&lt;/p&gt;
&lt;p&gt;使用diff的惯例是：将旧文件作为第一个参数。&lt;/p&gt;
&lt;p&gt;有时，与diff系出同门的diff3也是相当好用的工具，它的任务与diff稍有不同：diff3比较的是三个文件，例如基本版与由两个不同的人所做出来的两个修改文件，它还会产生一个ed命令的脚本，让用户将两组修改文件合并到基本版里。&lt;/p&gt;
&lt;p&gt;patch工具程序可利用diff的输出，结合原始文件，以重建另一个文件。因为相异的部分，通常比原始文件小很多，软件开发人员常会通过email交换相异处的列表，再使用patch应用它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;diff -c test.[12] &amp;gt; test.dif   #将相异处的相关内文，存储到test.dif
patch &amp;lt; test.dif               #应用不同之处
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;patch尽可能套用不同之处，然后报告失败的部分，由你自行手动处理。&lt;/p&gt;
&lt;p&gt;虽然patch可使用diff的一般输出，但较通用的方式应是使用diff的-c选项，以取得上下文差异处。这么做会产生较详细冗长的报告，让patch知道文件名，允许它验证变更位置，并回复不匹配之处。&lt;/p&gt;</summary><category term="Linux"></category><category term="Shell"></category></entry><entry><title>ArchLinux上安装Consolas字体</title><link href="http://youngsterxyf.github.io/2011/12/23/install-Consolas-font-on-ArchLinux/" rel="alternate"></link><updated>2011-12-23T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-23:2011/12/23/install-Consolas-font-on-ArchLinux/</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从&lt;a href="http://www.iplaysoft.com/consolas.html"&gt;http://www.iplaysoft.com/consolas.html&lt;/a&gt;下载Consolas字体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo mkdir -p /usr/share/fonts/yahei
sudo cp YaHei.Consolas.1.11b.ttf /usr/share/fonts/yahei/
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改变权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo chmod &lt;span class="m"&gt;644&lt;/span&gt; /usr/share/fonts/yahei/YaHei.Consolas.1.11b.ttf
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /usr/share/fonts/yahei/
sudo mkfontscale
sudo mkfontdir
sudo &lt;span class="nb"&gt;fc&lt;/span&gt;-cache -fv
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Linux"></category><category term="字体"></category></entry><entry><title>《Classic Shell Scripting》：文件描述符处理</title><link href="http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-file-descriptors/" rel="alternate"></link><updated>2011-12-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-22:2011/12/22/classic-shell-scripting-file-descriptors/</id><summary type="html">&lt;p&gt;在系统内部，UNIX是以一个小的整数数字，称为文件描述符(file descriptors)，表示每个进程打开的文件。数字由零开始，至多到系统定义的打开文件数目的限制。传统上，Shell允许你直接处理至多10个打开文件：文件描述符从0至9（POSIX标准将是否可以处理大于9的文件描述符，保留给各实现自行定义，bash可以，但ksh则否）&lt;/p&gt;
&lt;p&gt;文件描述符0,1与2，各自对应到标准输入，标准输出以及标准错误输出。最常见的操作便是变更这三个文件描述符其中一个的位置，不过也可能处理其他的变动。首先来看的是：将程序的标准输出传送到一个文件，并将起标准错误信息传到另一个文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make 1&amp;gt; results 2&amp;gt; ERRS
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的命令是将make的标准输出(文件描述符为1)传给results,并将标准错误输出(文件描述符为2)传给ERRS。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make 1&amp;gt; results 2&amp;gt; /dev/null
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;1&amp;gt; results&lt;/code&gt;里的1其实没有必要，供输出重定向的默认文件描述符是标准输出：也就是文件描述符1。下个例子会将输出与错误信息送给相同的文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make &amp;gt; results 2&amp;gt;&amp;amp;1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需特别留意的一点是:在命令行上，这4个字符2&amp;gt;&amp;amp;1必须连在一起，中间不能有任何空格。&lt;/p&gt;
&lt;p&gt;在此，顺序格外重要，Shell处理重定向时，由左至右。&lt;/p&gt;</summary><category term="Linux"></category><category term="Shell"></category></entry><entry><title>《Classic Shell Scripting》：sed and cut</title><link href="http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-sed-and-cut/" rel="alternate"></link><updated>2011-12-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-22:2011/12/22/classic-shell-scripting-sed-and-cut/</id><summary type="html">&lt;h4&gt;一. sed&lt;/h4&gt;
&lt;p&gt;一般来说，执行文本替换的正确程序应该是sed --- 流编辑器(Stream Editor)。sed的设计就是用来以批处理的方式而不是交互的方式来编辑文件。当你知道要做好几个变更 --- 不管是对一个还是数个文件时，比较简单的方式是将这些变更部分写到一个编辑中的脚本里，再将此脚本应用到所有需要修改的文件。
你可能会常在管道中间使用sed，以执行替换操作。做法是使用s命令 --- 要求正则表达式寻找，用替代文本替换匹配的文本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sed &lt;span class="s1"&gt;&amp;#39;s/:.*//&amp;#39;&lt;/span&gt; /etc/passwd       &lt;span class="c"&gt;#删除第一个冒号之后的所有东西&lt;/span&gt;
sort -u                          &lt;span class="c"&gt;#排序列表并删除重复部分&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这里，/字符扮演定界符(delimiter)的角色，从而分隔正则表达式与替代文本。在本例中，替代文本是空的，实际上会有效地删除匹配的文本。虽然/是最常用的定界符，但任何可显示的字符都能作为定界符。在处理文件名称，通常都会以标点符号字符作为定界符(例如分号，冒号或逗点)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;find /home/tolstoy -type d -print    &lt;span class="c"&gt;#寻找所有目录&lt;/span&gt;
sed &lt;span class="s1"&gt;&amp;#39;s;/home/tolstoy/;/home/lt/;&amp;#39;&lt;/span&gt;    &lt;span class="c"&gt;#修改名称；&lt;/span&gt;
sed &lt;span class="s1"&gt;&amp;#39;s/^/mkdir /&amp;#39;&lt;/span&gt;                    &lt;span class="c"&gt;#插入mkdir命令&lt;/span&gt;
sh -x                                 &lt;span class="c"&gt;#以Shell跟踪模式执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sed [-n] &amp;#39;editing command&amp;#39; [file ...]
sed [-n] -e &amp;#39;editing command&amp;#39; ... [file ...]
sed [-n] -f script-file ... [file ...]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-e &amp;#39;editing command&amp;#39; : 将editing command应用于输入数据上。当有多个命令需要应用时，就必须使用-e了。
-f script-file : 自script-file中读取编辑命令。当有多个命令需要执行时，此选项相当有用。
-n : 不是每个最后已修改结果行都正常打印，而是显示以p指定(处理过)的行。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;行为模式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;读取每个输入文件的每一行，假如没有文件的话，则是标准输入。以每一行来说，sed会执行每一个应用到输入行的editing command。结果会写到标准输出(默认状态下，或是显示地使用p命令及-n选项)。若无-e或-f选项，则sed会把第一个参数看作是要使用的editing command。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;”&lt;/p&gt;
&lt;h4&gt;二. cut&lt;/h4&gt;
&lt;p&gt;cut命令是用来剪下文本文件里的数据，文本文件可以是字段类型或是字符类型。后一种数据类型在遇到需要从文件里剪下特定的列时，特别方便。请注意：一个制表符在此被视为单个字符。&lt;/p&gt;
&lt;p&gt;举例来说，下面的命令可显示系统上每个用户的登录名称及其全名:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cut -d : -f 1,5 /etc/passwd     &lt;span class="c"&gt;#取出字段&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面的命令取出命令ls -l的输出结果中的文件权限字段:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ls -l &lt;span class="p"&gt;|&lt;/span&gt; cut -c 1-10
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;"&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cut -c list [ file ...]
cut -f list [ -d delim ] [ file ...]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;从输入文件中选择一个或多个字段或者一组字符，配合管道，可再做进一步处理。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-c list ： 以字符为主，执行剪下的操作。list为字符编号或一段范围的列表(以逗点隔开)，例如1,3,5-12,42。
-d delim : 通过-f选项，使用delim作为定界符。默认的定界符为制表字符(Tab)
-f list : 以字段为主，做剪下操作。list为字段编号或一段范围的列表(以逗点隔开)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;"&lt;/p&gt;</summary><category term="Linux"></category><category term="Shell"></category></entry><entry><title>《Classic Shell Scripting》：sort, uniq, wc, head, tail</title><link href="http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-sort-uniq-wc-head-tail/" rel="alternate"></link><updated>2011-12-22T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-22:2011/12/22/classic-shell-scripting-sort-uniq-wc-head-tail/</id><summary type="html">&lt;h4&gt;一.sort&lt;/h4&gt;
&lt;p&gt;就像awk,cut与join一样，sort将输入看作具有多条记录的数据流，而记录是由可变宽度的字段组成，记录是以换行符作为定界符，字段的定界符则是空白字符或是用户指定的单个字符。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sort [ options ] [ file(s)]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;将输入行按照键值字段与数据类型选项以及locale排序
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-b : 忽略开头的空白
-c : 检查输入是否已正确地排序。如输入未经排序，但退出码(exit code)为非零值，则不会有任何输出
-d : 字典顺序，仅文字数字与空白才有意义
-g : 一般数值，以浮点数字类型比较字段
-f : 将混用的字母都看作相同大小写，也就是以不管字母大小写的方式排序。
-i : 忽略无法打印的字符
-k : 定义排序键值字段
-m : 将已排序的输入文件，合并为一个排序后的输出数据流
-n : 以整数类型比较字段
-o outfile : 将输出写到指定的文件，而非标准输出。如果该文件为输入文件之一，则sort在进行排序与写到输出文件之前，会先将它复制到一个临时的文件。
-r : 倒置排序的顺序为由大到小，而非默认的由小到大。
-t char : 使用单个字符char作为默认的字段分隔字符，取代默认的空白字符
-u : 只有惟一的记录：丢弃所有具有相同键值的记录，只留其中的第一条。只有键值字段是重要的，也就是说，被丢弃的记录其他部分可能是不同值。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;行为模式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sort会读取指定的文件，如果未给定文件，则读取标准输入，再将排序好的数据写至标准输出。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;举例如下&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sort -t: -k1,1 /etc/passwd    &lt;span class="c"&gt;#以用户名称排序&lt;/span&gt;
sort -t: -k3nr /etc/passwd    &lt;span class="c"&gt;#反向UID的排序&lt;/span&gt;
sort -t: -k4n -k3n /etc/passwd   &lt;span class="c"&gt;#先以GID排序，再以UID排序&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;sort排序算法并不稳定，幸好GNU实现了coreutils弥补不足，它可以通过--stable选项补救此问题。&lt;/p&gt;
&lt;h4&gt;二.uniq&lt;/h4&gt;
&lt;p&gt;uniq常用于管道中，用来删除已使用sort排序完成的重复记录：sort ... | uniq | ...&lt;/p&gt;
&lt;p&gt;范例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sort latin-numbers &lt;span class="p"&gt;|&lt;/span&gt; uniq     &lt;span class="c"&gt;#显示唯一的，排序后的记录，重复则仅取唯一行。&lt;/span&gt;
sort latin-numbers &lt;span class="p"&gt;|&lt;/span&gt; uniq -c  &lt;span class="c"&gt;#计数唯一的，排序后的记录&lt;/span&gt;
sort latin-numbers &lt;span class="p"&gt;|&lt;/span&gt; uniq -d  &lt;span class="c"&gt;#仅显示重复的记录&lt;/span&gt;
sort latin-numbers &lt;span class="p"&gt;|&lt;/span&gt; uniq -u  &lt;span class="c"&gt;#仅显示未重复的记录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;三.wc&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;Testing one two three &lt;span class="p"&gt;|&lt;/span&gt; wc -c  &lt;span class="c"&gt;#计算字节数&lt;/span&gt;
&lt;span class="nb"&gt;echo &lt;/span&gt;Testing one two three &lt;span class="p"&gt;|&lt;/span&gt; wc -l  &lt;span class="c"&gt;#计算行数&lt;/span&gt;
&lt;span class="nb"&gt;echo &lt;/span&gt;Testing one two three &lt;span class="p"&gt;|&lt;/span&gt; wc -w  &lt;span class="c"&gt;#计算字数/单词数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-c选项原本是表示字符数，但因为有多字节字符集的编码存在---像UTF-8，因此在当前系统上，字节数已不再等于字符数了，也因此，POSIX出现了-m选项，用以计算多字节字符，对8位字符数据而言，它等同于-c。&lt;/p&gt;
&lt;p&gt;虽然wc最常处理的是来自于管道的输入数据，但它也接受命令行的文件参数，可以生成一行一个结果: wc /etc/passwd /etc/group&lt;/p&gt;
&lt;h4&gt;四.head and tail&lt;/h4&gt;
&lt;p&gt;有时，你会需要从文本文件里把几行字---多半是靠近开头或结尾的几行，提取出来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;head [-n] n [ file(s) ]    #取出文件的前n行
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样功能的命令有:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;awk &amp;#39;FNR &amp;lt;= n&amp;#39; [ file(s) ]
sed [-e] nq    [ file(s) ]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;tail&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;tail [-n] n [ file(s) ]   #取出文件的后n行
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Linux"></category><category term="Shell"></category></entry><entry><title>《Classic Shell Scripting》第一、二章阅读笔记</title><link href="http://youngsterxyf.github.io/2011/12/09/classic-shell-scripting-1-2/" rel="alternate"></link><updated>2011-12-09T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-09:2011/12/09/classic-shell-scripting-1-2/</id><summary type="html">&lt;h4&gt;第一章：背景知识&lt;/h4&gt;
&lt;p&gt;软件工具的原则&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;一次做好一件事

处理文本行，不要处理二进制数据

使用正则表达式：正则表达式(regular expression)是很强的文本处理机制。了解它的运作模式并加以使用，可适度简化编写命令脚本的工作。

默认使用标准输入/输出：在未明确指定文件名的情况下，程序默认会从它的标准输入读取数据，将数据写到它的标准输出，至于错误信息则会传送到标准错误输出。以这样的方式来编写程序，可以轻松地让它们称为数据过滤器(filter)。

避免喋喋不休

输出格式必须与可接受的输入格式一致：专业的工具程序认为遵循某种格式的输入数据，例如标题行之后接着数据行，或在行上使用某种字段分隔符等，所产生的输出也应遵循与输入一致的规则。这么做的好处是，容易将一个程序的执行结果交给另一个程序处理。

让工具去做困难的部分：虽然UNIX程序并非完全符合你的需求，但是现有的工具或许已经可以为你完成90%的工作。接下来，若有需要，你可以编写一个功能特定的小型程序来完成剩下的工作。

构建特定工具前，先想想：你所要做的事情，是否有其他人也需要做？这个特殊的工作是否有可能是某个一般问题的一个特例？如果是的话，请针对一般问题来编写程序。
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;第二章：入门&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Shell脚本最常用于系统管理工作，或是用于结合现有的程序以完成小型的，特定的工作。一旦你找出完成工作的方法，可以把用到的命令串在一起，放进一个独立的程序或脚本里，此后只要直接执行该程序便能完成工作。&lt;/li&gt;
&lt;li&gt;使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象。缺点是：它们的效率通常不如编译型语言。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell的基本元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令与参数&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;简单的echo输出&lt;/li&gt;
&lt;li&gt;华丽的printf输出&lt;/li&gt;
&lt;li&gt;基本的I/O重定向&lt;ul&gt;
&lt;li&gt;重定向与管道&lt;/li&gt;
&lt;li&gt;特殊文件:/dev/null与/dev/tty&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本命令查找&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行中，分号(;)可用来分隔同一行里的多条命令。Shell会依次执行这些命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Shell识别三种命令：内建命令，Shell函数以及外部命令：&lt;ol&gt;
&lt;li&gt;内建命令就是由Shell本身所执行的命令。有些命令是由于其必要性才内建的，例如cd用来改变目录，read会将来自用户(或文件)的输入数据传给Shell变量。另一种内建命令的存在则是为了效率，其中最典型的就是test命令，编写脚本时会经常用到它。另外还有I/O命令，例如echo与printf。&lt;/li&gt;
&lt;li&gt;Shell函数是功能健全的一系列程序代码，以Shell语言写成，它们可以像命令那样引用。 ？？？&lt;/li&gt;
&lt;li&gt;外部命令就是由Shell的副本(新的进程)所执行的命令，基本的过程如下：&lt;ol&gt;
&lt;li&gt;建立一个新的进程。此进程即为Shell的一个副本。&lt;/li&gt;
&lt;li&gt;在新的进程里，在PATH变量内所列出的目录中，寻找特定的命令。&lt;/li&gt;
&lt;li&gt;在新的进程里，以所找到的新程序取代执行中的Shell程序并执行。&lt;/li&gt;
&lt;li&gt;程序完成后，最初的Shell会接着从终端读取下一条命令，或执行脚本里的下一条命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Shell变量名称的开头是一个字母或下划线符号，后面可以接着任意长度的字母，数字或下划线符号。&lt;/li&gt;
&lt;li&gt;重定向与管道:&lt;ul&gt;
&lt;li&gt;以&amp;lt;改变标准输入&lt;/li&gt;
&lt;li&gt;以&amp;gt;改变标准输出，&amp;gt;重定向符(redirector)在目的文件不存在时，会新建一个。然而，如果目的文件存在，它就会直接覆盖掉，原本的数据都会丢失&lt;/li&gt;
&lt;li&gt;以&amp;gt;&amp;gt;改变标准输出附加到文件,如同&amp;gt;，如果目的文件不存在，&amp;gt;&amp;gt;重定向符便会新建一个。然而，如果目的文件存在，它不会直接覆盖掉文件，而是将程序产生的数据附加到文件结尾处。&lt;/li&gt;
&lt;li&gt;以|建立管道，管道可以使得执行速度比使用临时文件快上十倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tr命令&lt;/li&gt;
&lt;li&gt;构造管道时，应该试着让每个阶段的数据量变得更少。换句话说，如果你有两个要完成的步骤与先后次序无关，你可以把会让数据量变少的那一个步骤放在管道的前面。这么做可以提升脚本的整体性能，因为UNIX只需要在两个程序间移动少的数据量，每个程序要做的事情也比较少，例如：使用sort排序之前，先以grep找出相关的行，这样可以让sort少做些事。&lt;/li&gt;
&lt;li&gt;特殊文件/dev/null与/dev/tty&lt;/li&gt;
&lt;li&gt;简单的执行跟踪:&lt;ul&gt;
&lt;li&gt;两种方法：&lt;ol&gt;
&lt;li&gt;使用"sh -x scriptname"来执行脚本scriptname；&lt;/li&gt;
&lt;li&gt;在脚本中需要跟踪的命令片段前加一句set -x打开执行跟踪的功能，然后在这个命令片段后再用set +x命令关闭它。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Shell"></category></entry><entry><title>Linux添加定时任务</title><link href="http://youngsterxyf.github.io/2011/12/07/cron-usage/" rel="alternate"></link><updated>2011-12-07T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-07:2011/12/07/cron-usage/</id><summary type="html">&lt;p&gt;在Linux下如果希望某个任务定时地执行，一般是使用cron服务器，将任务添加到cron任务列表中。&lt;/p&gt;
&lt;h4&gt;启动，关闭，重启cron(需超级用户权限)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/etc/init.d/cron start
/etc/init.d/cron stop
/etc/init.d/cron restart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注:archlinux下为/etc/rc.d/crond start|stop|restart&lt;/p&gt;
&lt;h4&gt;查看用户设置的定时任务列表&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;crontab [-u xxx] -l       #  xxx为用户名
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;编辑用户的定时任务列表(超级用户权限)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;crontab -u xxx -e
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;删除用户的定时任务列表(超级用户权限)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;crontab -u xxx -r
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;定时任务的编辑规则&lt;/h4&gt;
&lt;p&gt;cron的定时任务由两部分组成：（1）设置的时间（2）该时间下要执行的任务命令。&lt;/p&gt;
&lt;p&gt;时间分5个部分，依次为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;minute              0-59
hour                0-23 
day of month        1-31
month               1-12
day of week         0-7 (0 or 7 is Sun, or use names)
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;示例（每天临晨2点备份数据库）&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;0 2 * * * mysqldump -hhostname -uusername -ppassword databasename &amp;gt; backupfile.sql
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;使设置生效&lt;/h4&gt;
&lt;p&gt;设置完成后，重启cron即可使设置的计划任务定时执行了&lt;/p&gt;
&lt;h3&gt;详细内容参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://fanqiang.chinaunix.net/system/linux/2005-06-13/3306.shtml"&gt;http://fanqiang.chinaunix.net/system/linux/2005-06-13/3306.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fanqiang.chinaunix.net/adm/storage/2005-03-23/2985.shtml"&gt;http://fanqiang.chinaunix.net/adm/storage/2005-03-23/2985.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://now-code.com/archives/196"&gt;http://now-code.com/archives/196&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category></entry><entry><title>Linux添加sudo用户权限</title><link href="http://youngsterxyf.github.io/2011/12/07/linux-add-sudo-user/" rel="alternate"></link><updated>2011-12-07T00:00:00+08:00</updated><author><name>youngsterxyf</name></author><id>tag:youngsterxyf.github.io,2011-12-07:2011/12/07/linux-add-sudo-user/</id><summary type="html">&lt;p&gt;Linux中很多命令需要使用超级用户权限，在这些命令前添加sudo然后直接执行是很方便的。&lt;/p&gt;
&lt;p&gt;那么就先要将自己的用户名添加到sudoers中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用su命令切换到超级用户(在提示后输入root的密码)&lt;/li&gt;
&lt;li&gt;使用visudo命令(编辑/etc/sudoers文件)，也可以直接使用编辑器编辑&lt;/li&gt;
&lt;li&gt;找到root ALL=(ALL) ALL 这一行，在其下面一行添加xxx ALL=(ALL) ALL，其中xxx为你的用户名&lt;/li&gt;
&lt;li&gt;保存即可起效&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category></entry></feed>