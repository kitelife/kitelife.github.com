<!DOCTYPE html>
<html lang="zh">
<head>

        <title>Yii源码阅读笔记 - Model层实现</title>
        <meta charset="utf-8" />
        <link href="http://youngsterxyf.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="有趣的技术 Full Atom Feed" />
        <link href="http://youngsterxyf.github.io/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="有趣的技术 Full RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../../../../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/pygment.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/hgxs/FZZJ-HGXSJW.css" />

        <script src="../../../../theme/js/libs/jquery-1.9.1.min.js"></script>
        <script src="../../../../theme/js/libs/modernizr-2.6.2.min.js"></script>
            <script>
              var _hmt = _hmt || [];
              (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?5c5d8c3fe75afeff117777b9236b96ec";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
              })();
            </script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
</head>

<body id="index" class="home">
    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1 style='font-family: "FZZJ-HGXSJW";'><a href="../../../..">有趣的技术 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>

              <ul class="columns" style='font-family: "FZZJ-HGXSJW";'>
                <li><a href="../../../..">主 页</a></li>

                <li><a href="/archives.html">归 档</a></li>
                <li><a href="/pages/tech-share.html">技术分享</a></li>
                <li><a href="/pages/translation.html">技术翻译</a></li>
                <li><a href="/pages/tools.html">工具集</a></li>
                <li><a href="/pages/links.html">链 接</a></li>
                <li><a href="/pages/aboutme.html">关于我</a></li>
                <li><a href="/pages/2020.html">2020</a></li>
                <li><a href="/feeds/rss.xml">RSS</a></li>

              </ul>
            </div>

<section id="content" class="body">
   <div class="row">
        <div class="columns">
            <header>
              <h2 class="entry-title">
                <a href="../../../../2014/11/14/read-yii-code-4/" rel="bookmark" title="Permalink to Yii源码阅读笔记 - Model层实现">Yii源码阅读笔记 - Model层实现</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2014-11-14T00:00:00+08:00">
                2014-11-14 Fri
              </abbr>
              <address class="vcard author">
                By <a class="url fn" href="../../../../author/youngsterxyf.html">youngsterxyf</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <h3>概述</h3>
<p>Yii中，对Model层的使用，有两种方式：</p>
<ol>
<li>通过类CDbConnection和CDbCommand来操作</li>
<li>使用ORM形式：编写model类继承自抽象类CActiveRecord</li>
</ol>
<p>第1种方式的示例如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code><span style="color: #0000ff">&lt;?php</span>
$connection = Yii::app()-&gt;db;  <span style="color: #008000">// 或者Yii::app()-&gt;getComponent(&#39;db&#39;);</span>
$queryResult = $connection-&gt;createCommand($sql)-&gt;queryRow();
</code></pre></div>


<p>第2种方式中编写的model类可能需要实现方法<code>getDbConnection</code>、<code>model</code>、<code>tableName</code>。</p>
<p>在实现上，第2种方式是基于第1种方式的，即第2种方式的抽象程度更高。Yii没有屏蔽第1种方式，这样能让开发者按需选择。
但我个人并不喜欢这样，两种方式同时存在，会导致应用的model实现稍显混乱。</p>
<h3>分析</h3>
<p>Yii框架model层的入口为CDbConnection类，该类有很多public的属性可供配置，如<code>connectionString</code>、<code>username</code>、<code>password</code>等。</p>
<p>根据<a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/">Yii源码阅读笔记 - 组件集成</a>一文可知，组件初始化时会调用init方法。
类CDbConnection的init类实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function init()
{
    parent::init();
    // 属性autoConnect默认为true
    if($this-&gt;autoConnect)
        $this-&gt;setActive(true);
}
</code></pre></div>


<p>其中调用的setActive方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function setActive($value)
{
    // 当$value为true，而_active为false（表示数据库连接未打开），则打开数据库连接
    // 当$value为false, 而_active为true（表示数据库连接已打开），则关闭数据库连接
    if($value!=$this-&gt;_active)
    {
        if($value)
            $this-&gt;open();
        else
            $this-&gt;close();
    }
}
</code></pre></div>


<p>方法open实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Opens DB connection if it is currently not
 * @throws CException if connection fails
 */
protected function open()
{
    if($this-&gt;_pdo===null)
    {
        // 所以需要配置connectionString
        if(empty($this-&gt;connectionString))
            throw new CDbException(&#39;CDbConnection.connectionString cannot be empty.&#39;);
        try
        {
            Yii::trace(&#39;Opening DB connection&#39;,&#39;system.db.CDbConnection&#39;);
            // 基于PDO类建立数据库连接（对于某些数据库不使用PDO）
            $this-&gt;_pdo=$this-&gt;createPdoInstance();
            // 设置数据库连接的一些属性，如字符编码等
            $this-&gt;initConnection($this-&gt;_pdo);
            // 标志位设置为已打开
            $this-&gt;_active=true;
        }
        catch(PDOException $e)
        {
            // 省略
        }
    }
}
</code></pre></div>


<p>方法close实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Closes the currently active DB connection.
 * It does nothing if the connection is already closed.
 */
protected function close()
{
    Yii::trace(&#39;Closing DB connection&#39;,&#39;system.db.CDbConnection&#39;);
    $this-&gt;_pdo=null;
    $this-&gt;_active=false;
    $this-&gt;_schema=null;
}
</code></pre></div>


<p>open方法中调用的方法createPdoInstance实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Creates the PDO instance.
 * When some functionalities are missing in the pdo driver, we may use
 * an adapter class to provide them.
 * @throws CDbException when failed to open DB connection
 * @return PDO the pdo instance
 */
protected function createPdoInstance()
{
    // 属性pdoClass默认为PDO
    $pdoClass=$this-&gt;pdoClass;
    if(($pos=strpos($this-&gt;connectionString,&#39;:&#39;))!==false)
    {
        // 取出数据库驱动类型
        $driver=strtolower(substr($this-&gt;connectionString,0,$pos));
        if($driver===&#39;mssql&#39; || $driver===&#39;dblib&#39;)
            $pdoClass=&#39;CMssqlPdoAdapter&#39;;
        elseif($driver===&#39;sqlsrv&#39;)
            $pdoClass=&#39;CMssqlSqlsrvPdoAdapter&#39;;
    }

    if(!class_exists($pdoClass))
        throw new CDbException(Yii::t(&#39;yii&#39;,&#39;CDbConnection is unable to find PDO class &quot;{className}&quot;. Make sure PDO is installed correctly.&#39;,
            array(&#39;{className}&#39;=&gt;$pdoClass)));

    // 实例化类PDO，可能失败
    @$instance=new $pdoClass($this-&gt;connectionString,$this-&gt;username,$this-&gt;password,$this-&gt;_attributes);

    if(!$instance)
        throw new CDbException(Yii::t(&#39;yii&#39;,&#39;CDbConnection failed to open the DB connection.&#39;));

    return $instance;
}
</code></pre></div>


<p>从中可以看出，对于MySQL数据库而言，方法createPdoInstance返回的是一个PDO对象，赋值给CDbConnection对象的_pdo属性。</p>
<p>方法initConnection的实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Initializes the open db connection.
 * This method is invoked right after the db connection is established.
 * The default implementation is to set the charset for MySQL and PostgreSQL database connections.
 * @param PDO $pdo the PDO instance
 */
protected function initConnection($pdo)
{
    // 设置数据库连接的一些属性
    $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    if($this-&gt;emulatePrepare!==null &amp;&amp; constant(&#39;PDO::ATTR_EMULATE_PREPARES&#39;))
        $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,$this-&gt;emulatePrepare);
    if($this-&gt;charset!==null)
    {
        $driver=strtolower($pdo-&gt;getAttribute(PDO::ATTR_DRIVER_NAME));
        if(in_array($driver,array(&#39;pgsql&#39;,&#39;mysql&#39;,&#39;mysqli&#39;)))
            $pdo-&gt;exec(&#39;SET NAMES &#39;.$pdo-&gt;quote($this-&gt;charset));
    }
    // 执行一些初始化的SQL语句
    // public $initSQLs : array list of SQL statements that should be executed right after the DB connection is established.
    if($this-&gt;initSQLs!==null)
    {
        foreach($this-&gt;initSQLs as $sql)
            $pdo-&gt;exec($sql);
    }
}
</code></pre></div>


<hr>
<p>由于第2种方式是基于第1中方式实现的，所以我们先看看第1种方式的实现。</p>
<p>类CDbConnection中方法createCommand的实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function createCommand($query=null)
{
    $this-&gt;setActive(true);
    return new CDbCommand($this,$query);
}
</code></pre></div>


<p>其中实例化的类CDbCommand的构造方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Constructor.
 * @param CDbConnection $connection the database connection
 * @param mixed $query the DB query to be executed. This can be either
 * a string representing a SQL statement, or an array whose name-value pairs
 * will be used to set the corresponding properties of the created command object.
 *
 * For example, you can pass in either &lt;code&gt;&#39;SELECT * FROM tbl_user&#39;&lt;/code&gt;
 * or &lt;code&gt;array(&#39;select&#39;=&gt;&#39;*&#39;, &#39;from&#39;=&gt;&#39;tbl_user&#39;)&lt;/code&gt;. They are equivalent
 * in terms of the final query result.
 *
 * When passing the query as an array, the following properties are commonly set:
 * {@link select}, {@link distinct}, {@link from}, {@link where}, {@link join},
 * {@link group}, {@link having}, {@link order}, {@link limit}, {@link offset} and
 * {@link union}. Please refer to the setter of each of these properties for details
 * about valid property values. This feature has been available since version 1.1.6.
 *
 * Since 1.1.7 it is possible to use a specific mode of data fetching by setting
 * {@link setFetchMode FetchMode}. See {@link http://www.php.net/manual/en/function.PDOStatement-setFetchMode.php}
 * for more details.
 */
public function __construct(CDbConnection $connection,$query=null)
{
    $this-&gt;_connection=$connection;
    if(is_array($query))
    {
        foreach($query as $name=&gt;$value)
            $this-&gt;$name=$value;
    }
    else
        $this-&gt;setText($query);
}
</code></pre></div>


<p>可以看到参数$query并不是必须提供，如果提供，则$query参数值可以是字符串也可以是数组。如果是字符串也就是一个原生的SQL语句（可能有参数需要填充），如果是数组，
则可以为CDbCommand对象的select、distinct、from等属性赋值。</p>
<p>方法setText实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Specifies the SQL statement to be executed.
 * Any previous execution will be terminated or cancel.
 * @param string $value the SQL statement to be executed
 * @return CDbCommand this command instance
 */
public function setText($value)
{
    if($this-&gt;_connection-&gt;tablePrefix!==null &amp;&amp; $value!=&#39;&#39;)
        $this-&gt;_text=preg_replace(&#39;/{{(.*?)}}/&#39;,$this-&gt;_connection-&gt;tablePrefix.&#39;\1&#39;,$value);
    else
        $this-&gt;_text=$value;
    // 因为是要新执行一条语句，所以需要重置状态，将属性_statement置为null。
    $this-&gt;cancel();
    return $this;
}
</code></pre></div>


<p>如果调用类CDbConnection的createCommand方法时提供了<code>$query</code>参数值，则在得到CDbCommand对象后，即可调用CDbCommand对象的execute方法（对于增、删、改操作）或query、queryAll、queryRow等方法（对于查询操作）来执行数据库操作。</p>
<p>如果调用createCommand时未提供<code>$query</code>参数值，则有3种方式来完成数据库操作：</p>
<ol>
<li>
<p>对于普通的数据库查询操作，得到CDbCommand对象后，链式调用方法select、from、where等（之所以能够链式调用，是因为这些方法的最后都返回了对象本身），并且链式调用的最后调用query一类方法来执行数据库操作。</p>
</li>
<li>
<p>对于会对数据表结构或数据产生变更的操作，得到CDbCommand对象后，可以直接调用方法insert、update、delete、createTable等来执行操作。</p>
</li>
<li>
<p>可以在得到CDbCommand对象后，调用方法setText来设置待执行的SQL语句，setText方法的$value参数类型应为字符串。如果调用setText方法前$value参数类型是关联数组，则可以先调用方法buildQuery从关联数组生成一个SQL语句字符串，再调用setText方法；或者直接调用setSelect、setFrom、setWhere等方法来设置SQL语句的各个组成部分。最后调用execute方法或query一类方法。可以看出相比传递<code>$query</code>参数，这种方式只不过是显式地设置SQL语句。通常这是不推荐的（搞这么麻烦，何必呢？呵呵）。</p>
</li>
</ol>
<p>这样一看，类CDbCommand的实现稍显混乱。本意上额外的第3种方式应该是提供给类CActiveRecord使用的，所以不建议使用。</p>
<p>接下来看看方法execute方法及query一类（仅以方法query、queryAll为例）方法的实现：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Executes the SQL statement.
 * This method is meant only for executing non-query SQL statement.
 * No result set will be returned.
 * @param array $params input parameters (name=&gt;value) for the SQL execution. This is an alternative
 * to {@link bindParam} and {@link bindValue}. If you have multiple input parameters, passing
 * them in this way can improve the performance. Note that if you pass parameters in this way,
 * you cannot bind parameters or values using {@link bindParam} or {@link bindValue}, and vice versa.
 * Please also note that all values are treated as strings in this case, if you need them to be handled as
 * their real data types, you have to use {@link bindParam} or {@link bindValue} instead.
 * @return integer number of rows affected by the execution.
 * @throws CDbException execution failed
 */
public function execute($params=array())
{
    if($this-&gt;_connection-&gt;enableParamLogging &amp;&amp; ($pars=array_merge($this-&gt;_paramLog,$params))!==array())
    {
        $p=array();
        foreach($pars as $name=&gt;$value)
            $p[$name]=$name.&#39;=&#39;.var_export($value,true);
        $par=&#39;. Bound with &#39; .implode(&#39;, &#39;,$p);
    }
    else
        $par=&#39;&#39;;
    Yii::trace(&#39;Executing SQL: &#39;.$this-&gt;getText().$par,&#39;system.db.CDbCommand&#39;);
    try
    {
        if($this-&gt;_connection-&gt;enableProfiling)
            Yii::beginProfile(&#39;system.db.CDbCommand.execute(&#39;.$this-&gt;getText().$par.&#39;)&#39;,&#39;system.db.CDbCommand.execute&#39;);

        // 以通过setText设置的SQL语句为参数间接调用PDO对象的prepare方法，并将返回的PDOStatement对象赋值给当前CDbCommand对象的_statement属性。
        $this-&gt;prepare();
        if($params===array())
            // 无参执行
            $this-&gt;_statement-&gt;execute();
        else
            // 带参执行
            $this-&gt;_statement-&gt;execute($params);
        // 操作影响的数据表行数
        $n=$this-&gt;_statement-&gt;rowCount();

        if($this-&gt;_connection-&gt;enableProfiling)
            Yii::endProfile(&#39;system.db.CDbCommand.execute(&#39;.$this-&gt;getText().$par.&#39;)&#39;,&#39;system.db.CDbCommand.execute&#39;);

        return $n;
    }
    catch(Exception $e)
    {
        // 省略
    }
}

public function query($params=array())
{
    return $this-&gt;queryInternal(&#39;&#39;,0,$params);
}

public function queryAll($fetchAssociative=true,$params=array())
{
    return $this-&gt;queryInternal(&#39;fetchAll&#39;,$fetchAssociative ? $this-&gt;_fetchMode : PDO::FETCH_NUM, $params);
}
</code></pre></div>


<p>可以看到query一类方法都是间接调用方法queryInternal来完成操作的。queryInternal方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>private function queryInternal($method,$mode,$params=array())
{
    $params=array_merge($this-&gt;params,$params);

    if($this-&gt;_connection-&gt;enableParamLogging &amp;&amp; ($pars=array_merge($this-&gt;_paramLog,$params))!==array())
    {
        $p=array();
        foreach($pars as $name=&gt;$value)
            $p[$name]=$name.&#39;=&#39;.var_export($value,true);
        $par=&#39;. Bound with &#39;.implode(&#39;, &#39;,$p);
    }
    else
        $par=&#39;&#39;;

    Yii::trace(&#39;Querying SQL: &#39;.$this-&gt;getText().$par,&#39;system.db.CDbCommand&#39;);

    // 先尝试从缓存中读取查询结果
    // 这里涉及CDbConnection类的三个属性queryCachingCount、queryCachingDuration、queryCacheID
    // 另外对于方法query（调用queryInternal时提供的method参数为空字符串）的操作不会缓存
    if($this-&gt;_connection-&gt;queryCachingCount&gt;0 &amp;&amp; $method!==&#39;&#39;
            &amp;&amp; $this-&gt;_connection-&gt;queryCachingDuration&gt;0
            &amp;&amp; $this-&gt;_connection-&gt;queryCacheID!==false
            &amp;&amp; ($cache=Yii::app()-&gt;getComponent($this-&gt;_connection-&gt;queryCacheID))!==null)
    {
        $this-&gt;_connection-&gt;queryCachingCount--;
        $cacheKey=&#39;yii:dbquery&#39;.$this-&gt;_connection-&gt;connectionString.&#39;:&#39;.$this-&gt;_connection-&gt;username;
        $cacheKey.=&#39;:&#39;.$this-&gt;getText().&#39;:&#39;.serialize(array_merge($this-&gt;_paramLog,$params));
        if(($result=$cache-&gt;get($cacheKey))!==false)
        {
            Yii::trace(&#39;Query result found in cache&#39;,&#39;system.db.CDbCommand&#39;);
            return $result[0];
        }
    }

    try
    {
        if($this-&gt;_connection-&gt;enableProfiling)
            Yii::beginProfile(&#39;system.db.CDbCommand.query(&#39;.$this-&gt;getText().$par.&#39;)&#39;,&#39;system.db.CDbCommand.query&#39;);

        $this-&gt;prepare();
        if($params===array())
            $this-&gt;_statement-&gt;execute();
        else
            $this-&gt;_statement-&gt;execute($params);

        // $method对应PDOStatement的结果获取方法，如果未提供$method，自然无法直接通过PDOStatement获取查询结果。
        if($method===&#39;&#39;)
            // 这个细看一下
            $result=new CDbDataReader($this);
        else
        {
            $mode=(array)$mode;
            call_user_func_array(array($this-&gt;_statement, &#39;setFetchMode&#39;), $mode);
            // 调用PDOStatement对应的方法
            $result=$this-&gt;_statement-&gt;$method();
            $this-&gt;_statement-&gt;closeCursor();
        }

        if($this-&gt;_connection-&gt;enableProfiling)
            Yii::endProfile(&#39;system.db.CDbCommand.query(&#39;.$this-&gt;getText().$par.&#39;)&#39;,&#39;system.db.CDbCommand.query&#39;);

        // 如果设置了$cache和$cacheKey
        // 将查询结果存入缓存
        if(isset($cache,$cacheKey))
            $cache-&gt;set($cacheKey, array($result), $this-&gt;_connection-&gt;queryCachingDuration, $this-&gt;_connection-&gt;queryCachingDependency);

        return $result;
    }
    catch(Exception $e)
    {
        // 省略
    }
}
</code></pre></div>


<p>可以看到query方法调用queryInternal时，结果是通过CDbDataReader对象来获取的。类CDbDataReader的构造方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function __construct(CDbCommand $command)
{
    $this-&gt;_statement=$command-&gt;getPdoStatement();
    $this-&gt;_statement-&gt;setFetchMode(PDO::FETCH_ASSOC);
}
</code></pre></div>


<p>得到CDbDataReader对象，即可通过它的read一类方法<strong>迭代</strong>获取查询结果。这些方法实际上是调用PDOStatement的fetch一类方法来获取结果的。</p>
<hr>
<p>再来看看Yii框架Model层的第2种使用方式。</p>
<p>CActiveRecord的用法是，对于数据库的每个数据表，创建一个model类，如UserModel，这个类继承自CActiveRecord类。model类名可以和数据表名一致，也可以不一致，如果不一致，则需要重写CActiveRecord类的tableName方法，标明该model类对应的数据表名。方法tableName默认的实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
* Returns the name of the associated database table.
* By default this method returns the class name as the table name.
* You may override this method if the table is not named after this convention.
* @return string the table name
*/
public function tableName()
{
    return get_class($this);
}
</code></pre></div>


<p>假设UserModel类对应的数据表名为User，则应如下重写tableName：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function tableName()
{
    return &#39;User&#39;;
}
</code></pre></div>


<p>使用CActiveRecord方式，若想向数据表中插入一条新纪录，则需要实例化当前model类。以UserModel类为例，若想向User表中插入一条新纪录，则需要先实例化UserModel，得到一个对象，然后对该对象的属性进行赋值指明对应数据表新记录每个字段的值。对象的属性名即数据表的字段名，赋值完毕，调用save或insert即向数据表中存入该新纪录。</p>
<p>CActiveRecord类的构造方法如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function __construct($scenario=&#39;insert&#39;)
{
    if($scenario===null) // internally used by populateRecord() and model()
        return;

    $this-&gt;setScenario($scenario);
    $this-&gt;setIsNewRecord(true);
    $this-&gt;_attributes=$this-&gt;getMetaData()-&gt;attributeDefaults;

    $this-&gt;init();

    $this-&gt;attachBehaviors($this-&gt;behaviors());
    $this-&gt;afterConstruct();
}
</code></pre></div>


<p>$scenario='insert'，表示新实例化的对象处于待插入数据表的状态，在调用save等方法时，会检测该状态。在新实例化的对象插入到数据表后，该状态立即会变为"update"，表示之后对该对象的数据库写入操作，属于update操作。</p>
<p>CActiveRecord类的save方法的实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function save($runValidation=true,$attributes=null)
{
    // 若需要则对某些属性做校验
    if(!$runValidation || $this-&gt;validate($attributes))
        // 如果是新纪录，则插入，否则更新
        return $this-&gt;getIsNewRecord() ? $this-&gt;insert($attributes) : $this-&gt;update($attributes);
    else
        return false;
}
</code></pre></div>


<p>而insert、update方法的实现如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function insert($attributes=null)
{
    if(!$this-&gt;getIsNewRecord())
        throw new CDbException(Yii::t(&#39;yii&#39;,&#39;The active record cannot be inserted to database because it is not new.&#39;));
    if($this-&gt;beforeSave())
    {
        Yii::trace(get_class($this).&#39;.insert()&#39;,&#39;system.db.ar.CActiveRecord&#39;);
        // ...
        $builder=$this-&gt;getCommandBuilder();
        // ...
        $table=$this-&gt;getMetaData()-&gt;tableSchema;
        $command=$builder-&gt;createInsertCommand($table,$this-&gt;getAttributes($attributes));
        if($command-&gt;execute())
        {
            $primaryKey=$table-&gt;primaryKey;
            if($table-&gt;sequenceName!==null)
            {
                if(is_string($primaryKey) &amp;&amp; $this-&gt;$primaryKey===null)
                    $this-&gt;$primaryKey=$builder-&gt;getLastInsertID($table);
                elseif(is_array($primaryKey))
                {
                    foreach($primaryKey as $pk)
                    {
                        if($this-&gt;$pk===null)
                        {
                            $this-&gt;$pk=$builder-&gt;getLastInsertID($table);
                            break;
                        }
                    }
                }
            }
            $this-&gt;_pk=$this-&gt;getPrimaryKey();
            $this-&gt;afterSave();
            $this-&gt;setIsNewRecord(false);
            $this-&gt;setScenario(&#39;update&#39;);
            return true;
        }
    }
    return false;
}

public function update($attributes=null)
{
    if($this-&gt;getIsNewRecord())
        throw new CDbException(Yii::t(&#39;yii&#39;,&#39;The active record cannot be updated because it is new.&#39;));
    if($this-&gt;beforeSave())
    {
        Yii::trace(get_class($this).&#39;.update()&#39;,&#39;system.db.ar.CActiveRecord&#39;);
        if($this-&gt;_pk===null)
            $this-&gt;_pk=$this-&gt;getPrimaryKey();
        // 间接调用updateByPk来完成操作
        $this-&gt;updateByPk($this-&gt;getOldPrimaryKey(),$this-&gt;getAttributes($attributes));
        $this-&gt;_pk=$this-&gt;getPrimaryKey();
        $this-&gt;afterSave();
        return true;
    }
    else
        return false;
}
</code></pre></div>


<p>insert方法中调用的getCommandBuilder方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function getCommandBuilder()
{
    return $this-&gt;getDbConnection()-&gt;getSchema()-&gt;getCommandBuilder();
}
</code></pre></div>


<p>其中getDbConnection方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function getDbConnection()
{
    if(self::$db!==null)
        return self::$db;
    else
    {
        self::$db=Yii::app()-&gt;getDb();
        if(self::$db instanceof CDbConnection)
            return self::$db;
        else
            throw new CDbException(Yii::t(&#39;yii&#39;,&#39;Active Record requires a &quot;db&quot; CDbConnection application component.&#39;));
    }
}
</code></pre></div>


<p>Yii中默认的DB组件名为db，所以如果你使用的是默认的db数据库，那么不用重写这个方法。否则，需要重写该方法，指明需要使用的数据库连接。</p>
<p>getDbConnection方法返回的是一个CDbConnection对象，其getSchema方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function getSchema()
{
    if($this-&gt;_schema!==null)
        return $this-&gt;_schema;
    else
    {
        // 返回数据库配置信息connectionString字段中的数据库驱动类型，如mysql
        $driver=$this-&gt;getDriverName();
        /*
            driverMap属性的定义：
            public $driverMap=array(
              &#39;pgsql&#39;=&gt;&#39;CPgsqlSchema&#39;,    // PostgreSQL
              &#39;mysqli&#39;=&gt;&#39;CMysqlSchema&#39;,   // MySQL
              &#39;mysql&#39;=&gt;&#39;CMysqlSchema&#39;,    // MySQL
              &#39;sqlite&#39;=&gt;&#39;CSqliteSchema&#39;,  // sqlite 3
              &#39;sqlite2&#39;=&gt;&#39;CSqliteSchema&#39;, // sqlite 2
              &#39;mssql&#39;=&gt;&#39;CMssqlSchema&#39;,    // Mssql driver on windows hosts
              &#39;dblib&#39;=&gt;&#39;CMssqlSchema&#39;,    // dblib drivers on linux (and maybe others os) hosts
              &#39;sqlsrv&#39;=&gt;&#39;CMssqlSchema&#39;,   // Mssql
              &#39;oci&#39;=&gt;&#39;COciSchema&#39;,        // Oracle driver
           );
        */
        if(isset($this-&gt;driverMap[$driver]))
            // 加载对应的数据库驱动组件
            return $this-&gt;_schema=Yii::createComponent($this-&gt;driverMap[$driver], $this);
        else
            throw new CDbException(Yii::t(&#39;yii&#39;,&#39;CDbConnection does not support reading schema for {driver} database.&#39;,
                array(&#39;{driver}&#39;=&gt;$driver)));
    }
}
</code></pre></div>


<p>以mysql的CMysqlSchema为例，<code>Yii::createComponent($this-&gt;driverMap[$driver], $this)</code>一句会实例化yii/framework/db/schema/mysql/CMysqlSchema.php中定义的CMysqlSchema类。该类自身无构造方法，继承自抽象类CDbSchema，CDbSchema的构造方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function __construct($conn)
{
    // 保存着当前CDbConnection数据库连接对象
    $this-&gt;_connection=$conn;
    foreach($conn-&gt;schemaCachingExclude as $name)
        $this-&gt;_cacheExclude[$name]=true;
}
</code></pre></div>


<p>得到CMysqlSchema对象后，调用其getCommandBuilder方法，该方法定义于类CDbSchema中，实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function getCommandBuilder()
{
    if($this-&gt;_builder!==null)
        return $this-&gt;_builder;
    else
        return $this-&gt;_builder=$this-&gt;createCommandBuilder();
}
</code></pre></div>


<p>其中调用的方法createCommandBuilder实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>protected function createCommandBuilder()
{
    return new CDbCommandBuilder($this);
}
</code></pre></div>


<p>实例化的CDbCommandBuilder类的构造方法如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function __construct($schema)
{
    $this-&gt;_schema=$schema;
    $this-&gt;_connection=$schema-&gt;getDbConnection();
}
</code></pre></div>


<p>这样insert方法中调用的getCommandBuilder最终返回了一个CDbCommandBuilder对象。</p>
<p>而insert方法中<code>$table=$this-&gt;getMetaData()-&gt;tableSchema</code>一句调用的getMetaData方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function getMetaData()
{
    $className=get_class($this);
    if(!array_key_exists($className,self::$_md))
    {
        self::$_md[$className]=null; // preventing recursive invokes of {@link getMetaData()} via {@link __get()}
        self::$_md[$className]=new CActiveRecordMetaData($this);
    }
    return self::$_md[$className];
}
</code></pre></div>


<p>其中实例化的类CActiveRecordMetaData，构造方法如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function __construct($model)
{
    // 当前model类名
    $this-&gt;_modelClassName=get_class($model);

    // 得到表名
    $tableName=$model-&gt;tableName();

    // 调用_schema（以mysql为例，其值为CMysqlSchema对象）的getTable方法
    if(($table=$model-&gt;getDbConnection()-&gt;getSchema()-&gt;getTable($tableName))===null)
        throw new CDbException(Yii::t(&#39;yii&#39;,&#39;The table &quot;{table}&quot; for active record class &quot;{class}&quot; cannot be found in the database.&#39;,
            array(&#39;{class}&#39;=&gt;$this-&gt;_modelClassName,&#39;{table}&#39;=&gt;$tableName)));
    if($table-&gt;primaryKey===null)
    {
        $table-&gt;primaryKey=$model-&gt;primaryKey();
        if(is_string($table-&gt;primaryKey) &amp;&amp; isset($table-&gt;columns[$table-&gt;primaryKey]))
            $table-&gt;columns[$table-&gt;primaryKey]-&gt;isPrimaryKey=true;
        elseif(is_array($table-&gt;primaryKey))
        {
            foreach($table-&gt;primaryKey as $name)
            {
                if(isset($table-&gt;columns[$name]))
                    $table-&gt;columns[$name]-&gt;isPrimaryKey=true;
            }
        }
    }
    // 将数据表结构信息存于属性tableSchema
    $this-&gt;tableSchema=$table;
    $this-&gt;columns=$table-&gt;columns;

    foreach($table-&gt;columns as $name=&gt;$column)
    {
        if(!$column-&gt;isPrimaryKey &amp;&amp; $column-&gt;defaultValue!==null)
            $this-&gt;attributeDefaults[$name]=$column-&gt;defaultValue;
    }

    foreach($model-&gt;relations() as $name=&gt;$config)
    {
        $this-&gt;addRelation($name,$config);
    }
}
</code></pre></div>


<p>其中调用的getTable方法，定义于抽象类CDbSchema中，实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function getTable($name,$refresh=false)
{
    if($refresh===false &amp;&amp; isset($this-&gt;_tables[$name]))
        return $this-&gt;_tables[$name];
    else
    {
        if($this-&gt;_connection-&gt;tablePrefix!==null &amp;&amp; strpos($name,&#39;{{&#39;)!==false)
            $realName=preg_replace(&#39;/\{\{(.*?)\}\}/&#39;,$this-&gt;_connection-&gt;tablePrefix.&#39;$1&#39;,$name);
        else
            $realName=$name;

        // temporarily disable query caching
        if($this-&gt;_connection-&gt;queryCachingDuration&gt;0)
        {
            $qcDuration=$this-&gt;_connection-&gt;queryCachingDuration;
            $this-&gt;_connection-&gt;queryCachingDuration=0;
        }

        // 先尝试从缓存中取数据表结构信息
        // CDbConnection类的schemaCachingDuration属性默认为0，如果不配置该属性，那么就不会使用缓存，那么每次增、删、改、查操作都需要loadTable，
        // 对数据库的压力，以及性能影响是不是很大？！但如果加了缓存，那么当对数据表的结构做变更时会不会有问题？
        if(!isset($this-&gt;_cacheExclude[$name]) &amp;&amp; ($duration=$this-&gt;_connection-&gt;schemaCachingDuration)&gt;0 &amp;&amp; $this-&gt;_connection-&gt;schemaCacheID!==false &amp;&amp; ($cache=Yii::app()-&gt;getComponent($this-&gt;_connection-&gt;schemaCacheID))!==null)
        {
            $key=&#39;yii:dbschema&#39;.$this-&gt;_connection-&gt;connectionString.&#39;:&#39;.$this-&gt;_connection-&gt;username.&#39;:&#39;.$name;
            $table=$cache-&gt;get($key);
            // 没取到或者需要刷新缓存，则从数据库获取，并更新缓存
            if($refresh===true || $table===false)
            {
                $table=$this-&gt;loadTable($realName);
                if($table!==null)
                    $cache-&gt;set($key,$table,$duration);
            }
            $this-&gt;_tables[$name]=$table;
        }
        else
            // 直接从数据库获取数据表结构信息
            $this-&gt;_tables[$name]=$table=$this-&gt;loadTable($realName);

        if(isset($qcDuration))  // re-enable query caching
            $this-&gt;_connection-&gt;queryCachingDuration=$qcDuration;

        return $table;
    }
}
</code></pre></div>


<p>其中调用的loadTable方法最终是通过执行SQL语句：</p>
<ul>
<li><code>'SHOW FULL COLUMNS FROM '.$table-&gt;rawName</code></li>
<li><code>'SHOW CREATE TABLE '.$table-&gt;rawName</code></li>
</ul>
<p>来获取数据表信息，并将信息存于一个CMysqlColumnSchema对象中（以mysql为例）。</p>
<p>insert方法中<code>$command=$builder-&gt;createInsertCommand($table,$this-&gt;getAttributes($attributes))</code>一句createInsertCommand方法定义于CDbCommandBuilder类中，实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function createInsertCommand($table,$data)
{
    $this-&gt;ensureTable($table);
    $fields=array();
    $values=array();
    $placeholders=array();
    $i=0;
    foreach($data as $name=&gt;$value)
    {
        if(($column=$table-&gt;getColumn($name))!==null &amp;&amp; ($value!==null || $column-&gt;allowNull))
        {
            $fields[]=$column-&gt;rawName;
            if($value instanceof CDbExpression)
            {
                $placeholders[]=$value-&gt;expression;
                foreach($value-&gt;params as $n=&gt;$v)
                    $values[$n]=$v;
            }
            else
            {
                $placeholders[]=self::PARAM_PREFIX.$i;
                $values[self::PARAM_PREFIX.$i]=$column-&gt;typecast($value);
                $i++;
            }
        }
    }
    if($fields===array())
    {
        $pks=is_array($table-&gt;primaryKey) ? $table-&gt;primaryKey : array($table-&gt;primaryKey);
        foreach($pks as $pk)
        {
            $fields[]=$table-&gt;getColumn($pk)-&gt;rawName;
            $placeholders[]=$this-&gt;getIntegerPrimaryKeyDefaultValue();
        }
    }
    $sql=&quot;INSERT INTO {$table-&gt;rawName} (&quot;.implode(&#39;, &#39;,$fields).&#39;) VALUES (&#39;.implode(&#39;, &#39;,$placeholders).&#39;)&#39;;
    $command=$this-&gt;_connection-&gt;createCommand($sql);

    foreach($values as $name=&gt;$value)
        $command-&gt;bindValue($name,$value);

    return $command;
}
</code></pre></div>


<p>另外还有与update、delete等操作对应的方法createUpdateCommand、createDeleteCommand等。</p>
<p>update方法与insert方法的逻辑基本是一致的。</p>
<p>CActiveRecord中所有数据库增、删、改、查操作，在构建出目标sql语句后，都是调用CDbConnection类的方法createCommand来得到一个CDbCommand类的对象，最后调用该对象的execute、query、queryAll等方法来完成查询获取结果。</p>
<hr>
<p>对于model类实例对象的属性赋值，依赖于CActiveRecord类的方法__set，实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function __set($name,$value)
{
    if($this-&gt;setAttribute($name,$value)===false)
    {
        if(isset($this-&gt;getMetaData()-&gt;relations[$name]))
            $this-&gt;_related[$name]=$value;
        else
            parent::__set($name,$value);
    }
}
</code></pre></div>


<p>其中调用的setAttribute方法的实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function setAttribute($name,$value)
{
    if(property_exists($this,$name))
        $this-&gt;$name=$value;
    elseif(isset($this-&gt;getMetaData()-&gt;columns[$name]))
        $this-&gt;_attributes[$name]=$value;
    else
        return false;
    return true;
}
</code></pre></div>


<hr>
<p>基于CActiveRecord类，如果想进行读取操作，那么子类需要重写model方法。CActiveRecord类的model方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Returns the static model of the specified AR class.
 * The model returned is a static instance of the AR class.
 * It is provided for invoking class-level methods (something similar to static class methods.)
 *
 * EVERY derived AR class must override this method as follows,
 * &lt;pre&gt;
 * public static function model($className=__CLASS__)
 * {
 *     return parent::model($className);
 * }
 * &lt;/pre&gt;
 *
 * @param string $className active record class name.
 * @return CActiveRecord active record model instance.
 */
public static function model($className=__CLASS__)
{
    if(isset(self::$_models[$className]))
        return self::$_models[$className];
    else
    {
        $model=self::$_models[$className]=new $className(null);
        $model-&gt;attachBehaviors($model-&gt;behaviors());
        return $model;
    }
}
</code></pre></div>


<p>根据该方法的注释可知道，所有的子类必须如下重写model方法：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public static function model($className = __CLASS__)
{
    return parent::model($className);
}
</code></pre></div>


<p>为什么必须重写model方法呢？因为<code>__CLASS__</code>指的并不是当前对象所属的类，而是方法定义所在的类。</p>
<p>隔壁的哥们告诉我，在 PHP 5.3 之后，如果CActiveRecord的model方法如下实现，就可以不用这样使用需要重写了。</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public static function model()
{
    $className = get_called_class();
    if(isset(self::$_models[$className]))
        return self::$_models[$className];
    else
    {
        $model=self::$_models[$className]=new $className(null);
        $model-&gt;attachBehaviors($model-&gt;behaviors());
        return $model;
    }
}
</code></pre></div>


<p>在得到$model后，就可以调用对象的query、find、findAll、findByPk、findAllByPk、findByAttributes、findAllByAttributes、findBySql、findAllBySql等方法来查询数据。其中find、findAll、findByPk、findAllByPk、findByAttributes、findAllByAttributes最终是通过调用query方法来实现查询的。query方法的第一个参数是一个CDbCriteria类实例对象，这就意味着调用query方法来实现查询的方法需要根据参数实例化一个CDbCriteria类对象。如find方法实现如下：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>/**
 * Finds a single active record with the specified condition.
 * @param mixed $condition query condition or criteria.
 * If a string, it is treated as query condition (the WHERE clause);
 * If an array, it is treated as the initial values for constructing a {@link CDbCriteria} object;
 * Otherwise, it should be an instance of {@link CDbCriteria}.
 * @param array $params parameters to be bound to an SQL statement.
 * This is only used when the first parameter is a string (query condition).
 * In other cases, please use {@link CDbCriteria::params} to set parameters.
 * @return CActiveRecord the record found. Null if no record is found.
 */
public function find($condition=&#39;&#39;,$params=array())
{
    Yii::trace(get_class($this).&#39;.find()&#39;,&#39;system.db.ar.CActiveRecord&#39;);
    // 实例化一个CDbCriteria对象
    $criteria=$this-&gt;getCommandBuilder()-&gt;createCriteria($condition,$params);
    return $this-&gt;query($criteria);
}
</code></pre></div>


<p>而query方法的实现如下所示：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>protected function query($criteria,$all=false)
{
    $this-&gt;beforeFind();
    $this-&gt;applyScopes($criteria);

    if(empty($criteria-&gt;with))
    {
        if(!$all)
            $criteria-&gt;limit=1;
        // createFindCommand在上面提过
        $command=$this-&gt;getCommandBuilder()-&gt;createFindCommand($this-&gt;getTableSchema(),$criteria,$this-&gt;getTableAlias());
        return $all ? $this-&gt;populateRecords($command-&gt;queryAll(), true, $criteria-&gt;index) : $this-&gt;populateRecord($command-&gt;queryRow());
    }
    else
    {
        $finder=$this-&gt;getActiveFinder($criteria-&gt;with);
        return $finder-&gt;query($criteria,$all);
    }
}
</code></pre></div>


<hr>
<p>对于查询操作，很多时候需要多表关联查询。那么基于CActiveRecord如何实现多表关联查询（隐式自动地）呢？</p>
<p>CActiveRecord类有个方法relations()：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function relations()
{
    return array();
}
</code></pre></div>


<p>这个方法的注释非常长，说明如何通过该方法声明当前model对应的数据表有哪些关联数据表，是何种关联关系。继承自CActiveRecord类的model类若想使用隐式的多表关联查询，则需要重写该方法。</p>
<p>举例来说，有数据表UserContacts、Users，UserContacts中有外键字段user_id关联到Users。如果基于CActiveRecord在查询UserContacts记录时，需要便捷地获取关联Users的记录。那么可以在UserContacts数据表对应的model类中，这样重写relations方法：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function relations()
{
    return array(
            &#39;user&#39; =&gt; array(self::BELONGS_TO, &#39;Users&#39;, &#39;user_id&#39;),
    );
}
</code></pre></div>


<p>那么在得到一条记录对象（$uc）时，通过调用$uc-&gt;user，即可得到与该UserContacts记录关联的Users记录。不过这条关联记录的获取可能是在调用$uc-&gt;user时才去查询数据库的。</p>
<p>若想提前将关联记录查询出来准备好，则可以再调用find、findAll等查询方法之前先调用with方法，如<code>self::model()-&gt;with('user')-&gt;find(array('usercontact_id' =&gt; 1))</code>，或者这样调用find方法<code>self::model()-&gt;find(array('usercontact_id' =&gt; 1, 'with' =&gt; 'user'))</code>。</p>
<p>那么在调用<code>$uc-&gt;user</code>时，如何知道user是一个关联项，而不是一个当前对象的属性？如果当前对象对应的数据表已有一个名为user的字段，是否会屏蔽掉关联项？且看CActiveRecord类的__get方法：</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><code>public function __get($name)
{
    // 先查看当前model类对应的数据表是否有名为$name的字段
    if(isset($this-&gt;_attributes[$name]))
        return $this-&gt;_attributes[$name];
    elseif(isset($this-&gt;getMetaData()-&gt;columns[$name]))
        return null;
    // 查看是否有名为$name的关联项
    elseif(isset($this-&gt;_related[$name]))
        return $this-&gt;_related[$name];
    elseif(isset($this-&gt;getMetaData()-&gt;relations[$name]))
        return $this-&gt;getRelated($name);
    else
        return parent::__get($name);
}
</code></pre></div>


<hr>
<p><em>注：本文为草稿状态</em></p>
            </div><!-- /.entry-content -->
            <div class="comments">
              <div id="gitalk-container"></div>
              <script type="text/javascript">
                const gitalk = new Gitalk({
                  clientID: '58fb3102b498bfbcb14f',
                  clientSecret: 'dd9788d7bbd9cbca1e75c9ba4db92f96dbf20180',
                  repo: 'youngsterxyf.github.com',
                  owner: 'youngsterxyf',
                  admin: ['youngsterxyf'],
                  id: location.pathname,      // Ensure uniqueness and length less than 50
                  distractionFreeMode: false  // Facebook-like distraction free mode
                });
                gitalk.render('gitalk-container');
              </script>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "2014/11/14/read-yii-code-4/";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://xiayfblackwhite.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>
        </div><!-- /.twelve.columns -->
 </div><!-- /.row -->
</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">


        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="http://github.com/youngsterxyf" target="_blank">Github</a></div></li>

                <li><div class="btn twitter"><a href="https://twitter.com/youngsterxyf" target="_blank">Twitter</a></div></li>

                <li><div class="btn warning"><a href="http://weibo.com/u/1855563263" target="_blank">Weibo</a></div></li>

                <li><div class="btn douban"><a href="http://www.douban.com/people/youngster21/" target="_blank">Douban</a></div></li>



              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'xiayfblackwhite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../../../../theme/js/libs/gumby.min.js"></script>
  <script src="../../../../theme/js/plugins.js"></script>
  <script src="../../../../theme/js/main.js"></script>
  <link rel="stylesheet" type="text/css" href="../../../../theme/emoji/css/basic/emojify.min.css" />
  <script src="../../../../theme/emoji/js/emojify.min.js"></script>
  <script>
    emojify.setConfig({
        img_dir : '../../../../theme/emoji/images/basic'
    });
    emojify.run();
</script>
</body>
</html>