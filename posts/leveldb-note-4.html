<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta property="og:title" content="BitPacking">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://blog.xiayf.cn/">
    <meta property="og:site_name" content="BitPacking">
    <meta property="og:description" content="ç²¾è¿›ï¼Œæ±‚è¯¸å·±èº«">

    <title>BitPacking</title>
    <meta name="description" content="ç²¾è¿›ï¼Œæ±‚è¯¸å·±èº«">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <link rel="stylesheet" href="/static/main.css">
    <link rel="canonical" href="https://blog.xiayf.cn/">
    
    <link crossorigin="" rel="shortcut icon" type="image/x-icon" href="/assets/bits_small.ico">
    
</head>

<body>
<header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="/">BitPacking</a>
        <nav class="site-nav">
            <a href="#" class="menu-icon">
                <svg viewBox="0 0 18 15">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </a>
            <div class="trigger">
                
                <a class="page-link" href="/pages/about.html">å…³äºæˆ‘</a>
                
                <a class="page-link" href="/pages/works.html">ä½œå“</a>
                
                <a class="page-link" href="/rss.xml">RSS</a>
                
            </div>
        </nav>
    </div>
</header>

<div class="page-content">
    <div class="wrapper">
        
<div class="post">
    <header class="post-header">
        <h1 class="post-title">è¯»ç ï¼šLevelDB - å¢åˆ æ”¹æŸ¥</h1>
        <p class="post-meta">2024-11-20</p>
    </header>
    <article class="post-content">
        <h2>9ã€å¢åˆ æ”¹æŸ¥</h2>
<img src='../assets/leveldb/lsm.png' title='lsm' alt='lsm' width='800'/>
<h3>9.1 å¢åˆ æ”¹</h3>
<p class="text-align-justify">å¯¹äº leveldbï¼ˆlsm-tree å­˜å‚¨ç»“æ„ï¼‰æ¥è¯´ï¼Œå¢æ”¹æ“ä½œç»Ÿä¸€ä¸º put æ“ä½œï¼ˆæ”¹ä¹Ÿæ˜¯æ’å…¥ä¸€æ¡æ–°è®°å½•ï¼‰ï¼Œput æ“ä½œå’Œåˆ é™¤æ“ä½œåˆç»Ÿä¸€ä¸º write æ“ä½œï¼ˆåˆ é™¤æ˜¯å€¼ä¸ºç©ºçš„å†™å…¥æ“ä½œï¼‰ã€‚write æ“ä½œè¿‡ç¨‹ä¸º</p>
<ul><li>1ã€å…ˆå°†æ“ä½œè®°å½•ï¼ˆåŒ…æ‹¬åŸå§‹é”®å€¼ï¼‰å†™åˆ° WAL log æ–‡ä»¶</li>
<li>2ã€å°†æ“ä½œè®°å½•åˆ°å†…å­˜ä¸­å¯å˜ Memtable çš„è·³è¡¨ç»“æ„ä¸­</li></ul>
<p class="text-align-justify">å†™å…¥è¿‡ç¨‹éå¸¸ç®€å•ï¼Œæ‰€ä»¥ leveldb çš„å†™å…¥ååå¯ä»¥éå¸¸é«˜ã€‚ä¸è¿‡æœ‰3ä¸ªæ€§èƒ½è°ƒä¼˜ç‚¹å¯ä»¥æ³¨æ„ä¸€ä¸‹ï¼š</p>
<ul><li>1ã€å†™å…¥æ“ä½œå¯ä»¥æŒ‡å®šæ˜¯åŒæ­¥çš„ï¼ˆsyncï¼‰æˆ–è€…å¼‚æ­¥çš„ï¼Œè¿™é‡Œè¯´çš„<u>åŒæ­¥å¼‚æ­¥æ˜¯é’ˆå¯¹ WAL log æ–‡ä»¶å†™å…¥è€Œè¨€çš„</u>ï¼Œéœ€è¦åœ¨ååæ€§èƒ½å’Œæ•°æ®ä¸€è‡´æ€§ä¹‹é—´åšå¥½å¹³è¡¡ï¼š
<ul><li>å¦‚æœå†™å…¥æ“ä½œæŒ‡å®šä¸ºåŒæ­¥ï¼Œé‚£ä¹ˆå°†æ“ä½œè®°å½•åˆ° WAL log æ–‡ä»¶åï¼Œè¿˜è¦<u>ç¡®ä¿æ–‡ä»¶å†…å®¹æŒä¹…åŒ–åˆ°ç£ç›˜</u>ï¼Œè¿™ä¸ªæŒä¹…åŒ–æ“ä½œå¯¹ leveldb çš„å†™å…¥ååå½±å“ä¼šæ¯”è¾ƒå¤§ã€‚</li>
<li>å¦‚æœå†™å…¥æ“ä½œæŒ‡å®šä¸º<u>éåŒæ­¥ï¼Œé‚£ä¹ˆå¯¹ WAL log çš„æ–‡ä»¶å†™å…¥ï¼Œå®é™…åªæ˜¯å†™åˆ°å†…æ ¸çš„æ–‡ä»¶ç¼“å†²åŒº</u>ã€‚å¦‚æœå†™å…¥æ“ä½œè®°å½•åˆ°å¯å˜ Memtable å¹¶è¿”å›å†™å…¥æˆåŠŸçŠ¶æ€ç»™è°ƒç”¨æ–¹åï¼Œå†…æ ¸ç¼“å†²åŒºå†…å®¹åˆ·å‡ºåˆ°ç£ç›˜ä¹‹å‰ï¼Œç³»ç»Ÿ crash æˆ–è€…æœºå™¨æ‰ç”µéƒ½ä¼šå¯¼è‡´å†™å…¥æ•°æ®ä¸¢å¤±ï¼Œå­˜åœ¨å…ˆå†™åè¯»çš„ä¸€è‡´æ€§é—®é¢˜ã€‚</li></ul></li>
<li>2ã€leveldb çš„å®ç°ä¸­ï¼Œå¯å˜ Memtable å¯¹è±¡å’Œä¸å¯å˜ Memtable å¯¹è±¡å‡åªæœ‰ä¸€ä¸ªï¼Œå¹¶ä¸” Memtable å¯¹è±¡çš„å†…å­˜å ç”¨å­˜åœ¨ä¸Šé™é˜ˆå€¼ï¼Œä¸€æ—¦å¯å˜ Memtable å†™æ»¡ä¸”ä¸å¯å˜ Memtable è¿˜å­˜åœ¨ï¼ˆè¿˜æ²¡æ¥å¾—åŠ minor compaction æˆ $level_0$ æ•°æ®æ–‡ä»¶ï¼‰ï¼Œé‚£ä¹ˆå†™å…¥å°±ä¼šè¢«é˜»å¡ï¼ˆè¯¦æƒ…è§[[## 2ã€å†™å…¥ç¼“å†²ä¸æ”’æ‰¹]] éƒ¨åˆ†è§£è¯´ï¼‰ï¼Œé‚£ä¹ˆï¼š
<ul><li>å¯ä»¥é€‚å½“è°ƒå¤§ Memtable å†…å­˜å ç”¨çš„ä¸Šé™é˜ˆå€¼ï¼Œä½†ä¹Ÿä¸èƒ½è°ƒå¾—å¾ˆå¤§ï¼Œå› ä¸ºè¿™ä¼šå¯¼è‡´ compaction å‹åŠ›ä¼šæ¯”è¾ƒå¤§ï¼Œé—´æ¥å½±å“è¯»/æ£€ç´¢çš„æ€§èƒ½ï¼š
<ul><li>å¦‚æœ $level_0$ æ–‡ä»¶å¾ˆå¤šï¼Œæ¥ä¸åŠ major compactionï¼Œè€Œè¿™äº›æ–‡ä»¶çš„ key åŒºé—´åˆå­˜åœ¨é‡åˆï¼Œå°±å¯èƒ½éœ€è¦æ£€ç´¢å¤šä¸ª $level_0$ æ–‡ä»¶ã€‚</li>
<li>major compaction æ¶‰åŠè¾ƒå¤šçš„æ–‡ä»¶ç£ç›˜ I/Oï¼Œä»è€Œå¯èƒ½å½±å“æ£€ç´¢æ—¶çš„æ–‡ä»¶è¯»å–ã€‚</li></ul></li>
<li>â€œä¸å¯å˜ Memtable å¯¹è±¡å‡åªæœ‰ä¸€ä¸ªâ€ å¦‚æœè°ƒæ•´ leveldb å®ç°æ”¯æŒå­˜åœ¨å¤šä¸ª ä¸å¯å˜ Memtable å¯¹è±¡ï¼Œå¯èƒ½å­˜åœ¨ä¼˜åŒ–ç©ºé—´ï¼›compaction ç›®å‰æ˜¯å•çº¿ç¨‹å¤„ç†çš„ï¼Œå¦‚æœè°ƒæ•´æˆæŸç§å¤šçº¿ç¨‹å®ç°ï¼Œå¯èƒ½ä¹Ÿå­˜åœ¨ä¼˜åŒ–ç©ºé—´ï¼Œä¸è¿‡å®ç°èµ·æ¥åº”è¯¥è¦å¤æ‚å¾—å¤šï¼Œå¹¶ä¸”ç£ç›˜ I/O ä¹Ÿå®¹æ˜“æˆä¸ºæ£€ç´¢æ€§èƒ½é€€åŒ–çš„å› ç´ ã€‚</li></ul></li></ul>
<img src='../assets/leveldb/IO-buffering.png' title='IO-buffering' alt='IO-buffering' width='800'/>
<blockquote><p class="text-align-justify">å›¾ç‰‡æ‘˜è‡ªã€ŠThe Linux Programming Interfaceã€‹ä¸€ä¹¦ 244 é¡µã€‚</p>
<p class="text-align-justify"></p>
<p class="text-align-justify">å¯¹äº WAL log éåŒæ­¥å†™å…¥ï¼Œleveldb ä¼šå°†å†…å®¹å…ˆå†™åˆ°ä¸€å—ç”¨æˆ·æ€å†…å­˜ç¼“å†²åŒºä¸­ï¼Œå¦‚æœç¼“å†²åŒºæ»¡ï¼Œåˆ™å…ˆè°ƒç”¨ <code>write</code> ç³»ç»Ÿè°ƒç”¨å°†ç”¨æˆ·æ€ç¼“å†²åŒºå†…å®¹å†™åˆ°å†…æ ¸ç¼“å†²åŒºï¼ˆKernel buffer cacheï¼‰ï¼Œå°†å†…å®¹çš„å‰©ä½™éƒ¨åˆ†ç»§ç»­å†™åˆ°ç”¨æˆ·æ€å†…å­˜ç¼“å†²åŒºåï¼Œå°±è¿”å›ï¼›</p>
<p class="text-align-justify">å¦‚æœæ˜¯åŒæ­¥å†™å…¥ï¼Œåˆ™ä¼šå†å°†ç”¨æˆ·æ€ç¼“å†²åŒºå†…å®¹ <code>write</code> åˆ°å†…æ ¸ç¼“å†²åŒºåï¼Œå†è°ƒç”¨ <code>fsync</code> ç³»ç»Ÿè°ƒç”¨ï¼Œå°†å†…æ ¸ç¼“å†²åŒºå†…å®¹åˆ·åˆ°ç£ç›˜ã€‚</p></blockquote>
<h3>9.2 æŸ¥/èŒƒå›´æ‰«æ</h3>
<h4>9.2.1 å¿«ç…§/snapshot</h4>
<p class="text-align-justify">leveldb ä¸­æ¯ä¸ª Put/Delete æ“ä½œéƒ½è¢«åˆ†é…äº†ä¸€ä¸ªåºåˆ—å·ï¼ˆSequenceNumï¼‰ï¼Œè¿™ä¸ªåºåˆ—å·æ˜¯ä¸€ç§â€œLamport æ—¶é’Ÿâ€ æˆ–è€…è¯´ â€œé€»è¾‘æ—¶é—´æˆ³â€ã€‚</p>
<p class="text-align-justify">leveldb æ”¯æŒå¯¹æ•°æ®åº“åšä¸€ä¸ªå¿«ç…§ï¼Œè¿™ä¸ªå¿«ç…§æ“ä½œéå¸¸è½»é‡ - å°±æ˜¯æœ€æ–°åˆ†é…åˆ†é…åºåˆ—å·ï¼ˆLastSequenceï¼‰ã€‚è¿™ä¸ªå¿«ç…§çš„å«ä¹‰ï¼šåºåˆ—å·å°äºç­‰äºLastSequenceçš„æ“ä½œéƒ½å±äºè¿™ä¸ªå¿«ç…§çš„ï¼Œå¤§äº LastSequence çš„æ“ä½œåˆ™ä¸å±äºè¿™ä¸ªå¿«ç…§ï¼Œæ˜¯åœ¨è¿™ä¸ªå¿«ç…§å‘ç”Ÿä¹‹åå‘ç”Ÿçš„ã€‚</p>
<pre class="language-cpp"><code>const Snapshot* DBImpl::GetSnapshot() {  
  MutexLock l(&amp;mutex_);  
  return snapshots_.New(versions_-&gt;LastSequence());  
}

// Abstract handle to particular state of a DB.  
// A Snapshot is an immutable object and can therefore be safely  
// accessed from multiple threads without any external synchronization.  
class LEVELDB_EXPORT Snapshot {  
 protected:  
  virtual ~Snapshot();  
};

// Snapshots are kept in a doubly-linked list in the DB.  
// Each SnapshotImpl corresponds to a particular sequence number.  
class SnapshotImpl : public Snapshot {  
 public:  
  SnapshotImpl(SequenceNumber sequence_number)  
      : sequence_number_(sequence_number) {}  
  
  SequenceNumber sequence_number() const { return sequence_number_; }  
  
 private:   
  // SnapshotImpl is kept in a doubly-linked circular list. The SnapshotList  
  // implementation operates on the next/previous fields directly.  SnapshotImpl* prev_;  
  SnapshotImpl* next_;  
  
  const SequenceNumber sequence_number_;
};</code></pre>
<p class="text-align-justify"><code>DBImpl</code> å¯¹è±¡çš„ <code>snapshots_</code> å­—æ®µä¸Šç»´æŠ¤ç€å¿«ç…§çš„é“¾è¡¨ï¼Œæ˜¯é¿å… compaction è¿‡ç¨‹æ¸…é™¤æ‰äº†å¿«ç…§ä¾èµ–çš„é”®å€¼æ•°æ®ã€‚æ¯”å¦‚ï¼Œå‡è®¾ä¸€æ¬¡å¿«ç…§çš„åºåˆ—å·ä¸º 123456ï¼Œå¯¹äº UK å­˜åœ¨åºåˆ—å· 123455 å’Œ åºåˆ—å· 123457 ä¸¤æ¬¡æ“ä½œï¼Œå¯¹äºè¿™æ¬¡å¿«ç…§è€Œè¨€ï¼Œåºåˆ—å· 123457 çš„æ“ä½œæ˜¯ä¸å¯è§çš„ï¼Œè¿™ä¸ªå¿«ç…§å­˜åœ¨æœŸé—´çš„ compaction è¿‡ç¨‹éƒ½éœ€è¦åŒæ—¶ä¿ç•™ UK çš„è¿™ä¸¤æ¬¡æ“ä½œã€‚è¿™ä¸ªå¿«ç…§é‡Šæ”¾ä¹‹åï¼Œcompaction å°±å¯ä»¥æŠŠåºåˆ—å· 123455 çš„æ“ä½œæ¸…é™¤æ‰ã€‚</p>
<p class="text-align-justify">å› æ­¤ï¼Œå¿«ç…§æœ¬èº«è™½ç„¶å¾ˆè½»é‡ï¼Œä¸è¿‡å¦‚æœé•¿æ—¶é—´ä¸é‡Šæ”¾ï¼Œä¼šå¯¼è‡´ç£ç›˜ç©ºé—´å ç”¨è†¨èƒ€ï¼Œå¯¹æ£€ç´¢æ€§èƒ½ä¹Ÿä¼šæœ‰ä¸€å®šçš„å½±å“ã€‚</p>
<h4>9.2.2 ç‚¹æŸ¥</h4>
<p class="text-align-justify">æŒ‡å®š key è¿›è¡Œç‚¹æŸ¥çš„é€»è¾‘é¡ºåºä¸ºï¼š</p>
<ul><li>1ã€ä»å¯å˜ Memtable çš„è·³è¡¨ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°å°±è¿”å›ç»™è°ƒç”¨æ–¹ï¼ˆå¦‚æœæ‰¾åˆ°çš„æ˜¯éåˆ é™¤è®°å½•ï¼Œåˆ™è¿”å›åºåˆ—å·æœ€å¤§çš„é‚£ä¸ªè®°å½•çš„å€¼ï¼Œä¸”è¿”å›çŠ¶æ€ä¸ºé»˜è®¤å€¼â€œæ‰¾åˆ°â€ï¼Œå¦‚æœæ‰¾åˆ°çš„æ˜¯åˆ é™¤è®°å½•ï¼Œåˆ™ä¿ç•™è¿”å›å€¼ä¸ºç©ºï¼Œè¿”å›çŠ¶æ€ä¸ºâ€œæœªæ‰¾åˆ°â€ï¼‰</li>
<li>2ã€1 ä¸­æ²¡æ‰¾åˆ°ï¼Œåˆ™ç»§ç»­ä»ä¸å¯å˜ Memtable çš„è·³è¡¨ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°å°±è¿”å›ç»™è°ƒç”¨æ–¹</li>
<li>2ã€2 ä¸­æ²¡æ‰¾åˆ°ï¼Œåˆ™ä» $level_0$ å¼€å§‹ä¾æ¬¡é€å±‚åœ¨æ•°æ®æ–‡ä»¶ä¸­æŸ¥æ‰¾ï¼Œ
<ul><li>å› ä¸º $level_0$ æ•°æ®æ–‡ä»¶çš„ key åŒºé—´å¯ä»¥å­˜åœ¨é‡åˆï¼Œæ‰€ä»¥åœ¨ $level_0$ å±‚æ£€ç´¢å¯èƒ½ä¼šæ¶‰åŠå¤šä¸ªæ•°æ®æ–‡ä»¶</li>
<li>$level_1$~$level_n$ æ•°æ®æ–‡ä»¶çš„ key åŒºé—´ä¸ä¼šé‡åˆï¼Œæ‰€ä»¥æ ¹æ®æœ€æ–°ç‰ˆæœ¬ç»´æŠ¤çš„å¯¹åº”å±‚æ•°æ®æ–‡ä»¶å…ƒä¿¡æ¯åˆ—è¡¨æ‰¾åˆ°ç›®æ ‡æ•°æ®æ–‡ä»¶å³å¯ï¼Œå¦‚æœæ²¡æ‰¾åˆ°ï¼Œåˆ™åˆ°ä¸‹ä¸€å±‚ç»§ç»­æ£€ç´¢</li>
<li>æ‰¾åˆ°ç›®æ ‡æ•°æ®æ–‡ä»¶åï¼Œå…ˆå¯¹ç´¢å¼•å—äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°ç›®æ ‡æ•°æ®å—ï¼Œå¦‚æœç›®æ ‡æ•°æ®è¡¨æ˜¯ç»è¿‡å‹ç¼©çš„ï¼Œåˆ™éœ€è¦å…ˆç»è¿‡è§£å‹ï¼Œç„¶åæ ¹æ®æ•°æ®å—ä¸­çš„é‡ç½®ä½ç‚¹åˆ—è¡¨ä¿¡æ¯ï¼Œä¾æ¬¡è¿›è¡Œ delta è§£ç éå†</li></ul></li></ul>
<p class="text-align-justify">ç‚¹æŸ¥æ“ä½œï¼Œå¯ä»¥æŒ‡å®šä¸€ä¸ªä¹‹å‰è·å–çš„å¿«ç…§ä¿¡æ¯ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šï¼Œåˆ™é»˜è®¤ä½¿ç”¨æœ€æ–°åˆ†é…çš„åºåˆ—å·ä½œä¸ºå¿«ç…§ï¼Œå®é™…æŸ¥æ‰¾è¿‡ç¨‹ä¼š<u>å°†å¿«ç…§ä¸­çš„åºåˆ—å·å’Œå­˜å‚¨è®°å½•ä¸­çš„åºåˆ—å·è¿›è¡Œæ¯”è¾ƒï¼Œåºåˆ—å·å¤§äºå¿«ç…§åºåˆ—å·çš„è®°å½•éƒ½ä¼šè¢«å¿½ç•¥</u>ã€‚</p>
<p class="text-align-justify">æŸ¥æ‰¾é”®ï¼ˆLookupKeyï¼‰çš„ç¼–ç æ–¹å¼ï¼š</p>
<img src='../assets/leveldb/lookup-key-encode.png' title='lookup-key-encode' alt='lookup-key-encode' width='600'/>
<p class="text-align-justify">ä¸ Memtable ä¸­è·³è¡¨èŠ‚ç‚¹ä¸­çš„ Key çš„ç¼–ç çš„åŒºåˆ«ä»…åœ¨äºä¸åŒ…å« value çš„é•¿åº¦å’Œ value å€¼ã€‚</p>
<pre class="language-cpp"><code>// A helper class useful for DBImpl::Get()  
class LookupKey {
public:
  // Initialize *this for looking up user_key at a snapshot with  
  // the specified sequence number.  
  LookupKey(const Slice&amp; user_key, SequenceNumber sequence);

  // Return a key suitable for lookup in a MemTable.  
  Slice memtable_key() const { return Slice(start_, end_ - start_); }

  // Return an internal key (suitable for passing to an internal iterator)  
  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }

  // Return the user key  
  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }

private:
  // We construct a char array of the form:  
  //    klength  varint32               &lt;-- start_  
  //    userkey  char[klength]          &lt;-- kstart_  
  //    tag      uint64  
  //                                    &lt;-- end_  
  // The array is a suitable MemTable key.  
  // The suffix starting with &quot;userkey&quot; can be used as an InternalKey.  
  const char* start_;  
  const char* kstart_;  
  const char* end_;  
  char space_[200];  // Avoid allocation for short keys
}

LookupKey::LookupKey(const Slice&amp; user_key, SequenceNumber s) {  
  size_t usize = user_key.size();  
  size_t needed = usize + 13;  // A conservative estimate  
  char* dst;  
  if (needed &lt;= sizeof(space_)) {  
    dst = space_;  
  } else {  
    dst = new char[needed];  
  }  
  start_ = dst;  
  dst = EncodeVarint32(dst, usize + 8);  
  kstart_ = dst;  
  std::memcpy(dst, user_key.data(), usize);  
  dst += usize;  
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));  
  dst += 8;  
  end_ = dst;  
}

static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {  
  assert(seq &lt;= kMaxSequenceNumber);  
  assert(t &lt;= kValueTypeForSeek);  
  return (seq &lt;&lt; 8) | t;  
}</code></pre>
<h4>9.2.3 å…¨åº“/èŒƒå›´æœ‰åºæ‰«æï¼ˆéå†ï¼‰</h4>
<pre class="language-cpp"><code>class DB {
public:
 // Return a heap-allocated iterator over the contents of the database.  
 // The result of NewIterator() is initially invalid (caller must  
 // call one of the Seek methods on the iterator before using it).  
 //  
 // Caller should delete the iterator when it is no longer needed.  
 // The returned iterator should be deleted before this db is deleted.  
 virtual Iterator* NewIterator(const ReadOptions&amp; options) = 0; // æ¥å£
}

// å®ç°
Iterator* DBImpl::NewIterator(const ReadOptions&amp; options) {  
  SequenceNumber latest_snapshot;  
  uint32_t seed;  
  Iterator* iter = NewInternalIterator(options, &amp;latest_snapshot, &amp;seed);  
  return NewDBIterator(this, user_comparator(), iter,  
                       (options.snapshot != nullptr  
                            ? static_cast&lt;const SnapshotImpl*&gt;(options.snapshot)  
                                  -&gt;sequence_number()  
                            : latest_snapshot),  
                       seed);  
}

// è¿­ä»£å™¨æ¥å£å®šä¹‰
class Iterator {
public:
  // An iterator is either positioned at a key/value pair, or  
  // not valid.  This method returns true iff the iterator is valid.  
  virtual bool Valid() const = 0;

  // Position at the first key in the source.  The iterator is Valid()  
  // after this call iff the source is not empty.  
  virtual void SeekToFirst() = 0;

  // Position at the last key in the source.  The iterator is  
  // Valid() after this call iff the source is not empty.  
  virtual void SeekToLast() = 0;

  // Position at the first key in the source that is at or past target.  
  // The iterator is Valid() after this call iff the source contains  
  // an entry that comes at or past target.  
  virtual void Seek(const Slice&amp; target) = 0;

  // Moves to the next entry in the source.  After this call, Valid() is  
  // true iff the iterator was not positioned at the last entry in the source.  
  // REQUIRES: Valid()  
  virtual void Next() = 0;  
  
  // Moves to the previous entry in the source.  After this call, Valid() is  
  // true iff the iterator was not positioned at the first entry in source.  
  // REQUIRES: Valid()  
  virtual void Prev() = 0;  
  
  // Return the key for the current entry.  The underlying storage for  
  // the returned slice is valid only until the next modification of  
  // the iterator.  
  // REQUIRES: Valid()  
  virtual Slice key() const = 0;  
  
  // Return the value for the current entry.  The underlying storage for  
  // the returned slice is valid only until the next modification of  
  // the iterator.  
  // REQUIRES: Valid() 
  virtual Slice value() const = 0;
}</code></pre>
<p class="text-align-justify">æœ‰åºéå†æ¥å£çš„ä½¿ç”¨æ–¹å¼ä¸ºï¼š</p>
<ul><li>1ã€è°ƒç”¨ NewIterator æ¥å£è·å¾—è¿­ä»£å™¨å¯¹è±¡æŒ‡é’ˆ - <code>Iterator* iter</code>ï¼Œ<code>options</code> å‚æ•°ä¸­å¯ä»¥æŒ‡å®šå¿«ç…§ï¼Œå¦‚æœæœªæŒ‡å®šï¼Œåˆ™é»˜è®¤ä»¥æœ€æ–°åˆ†é…çš„åºåˆ—å·ä¸ºå¿«ç…§ã€‚</li>
<li>2ã€è°ƒç”¨ è¿­ä»£å™¨å¯¹è±¡æŒ‡é’ˆ çš„ Seek ç›¸å…³æ¥å£ï¼Œåˆå§‹åŒ–éå†èµ·å§‹ä½ç½®çŠ¶æ€ï¼š
<ul><li>SeekToFirstï¼šä¸æŒ‡å®šèµ·å§‹ keyï¼Œä»å¤´éƒ¨é¡ºåºéå†ï¼ˆä¸æ–­è°ƒç”¨ Nextï¼‰</li>
<li>SeekToLastï¼šä¸æŒ‡å®šèµ·å§‹ keyï¼Œä»å°¾éƒ¨é€†åºéå†ï¼ˆä¸æ–­è°ƒç”¨ Prevï¼‰</li>
<li>Seekï¼šæŒ‡å®šèµ·å§‹ keyï¼Œä»èµ·å§‹ key å¼€å§‹é¡ºåºéå†ï¼ˆä¸æ–­è°ƒç”¨ Nextï¼‰</li></ul></li>
<li>3ã€è°ƒç”¨æ–¹æ ¹æ®è¿­ä»£å™¨çš„ <code>Valid()</code> æ–¹æ³•è¿”å›åˆ¤æ–­æ˜¯å¦éå†ç»“æŸï¼Œæˆ–è€…æ ¹æ®æœ€æ–°éå†åˆ°çš„ key å€¼åšåˆ¤æ–­æ˜¯å¦è¦ç»“æŸéå†ã€‚</li></ul>
<p class="text-align-justify">æœ‰åºï¼ˆé¡ºåºï¼‰éå†çš„å®ç°é€»è¾‘ç±»ä¼¼äº compaction è¿‡ç¨‹çš„ N è·¯å½’å¹¶ç®—æ³•ï¼Œåªä¸è¿‡ compaction æ¶‰åŠçš„ level å±‚ å’Œ level+1 å±‚è¾“å…¥æ•°æ®æ–‡ä»¶çš„ N è·¯å½’å¹¶æ’åºï¼Œè€Œæœ‰åºéå†åˆ™æ¶µç›–â€œå¯å˜ memtableâ€/â€œä¸å¯å˜ memtableâ€/â€œ$level_0$~$level_n$ æ‰€æœ‰å±‚æ•°æ®æ–‡ä»¶â€æ•°æ®åº“å®Œæ•´çŠ¶æ€ï¼š</p>
<ul><li>1ã€å…ˆé’ˆå¯¹å„éƒ¨åˆ†æ•°æ®åˆ›å»ºå„è‡ªçš„è¿­ä»£å™¨ï¼š
<ul><li>â€œå¯å˜ memtableâ€ ä¸€ä¸ªè¿­ä»£å™¨</li>
<li>â€œä¸å¯å˜ memtableâ€ ä¸€ä¸ªè¿­ä»£å™¨</li>
<li>$level_0$ å±‚ï¼Œå› ä¸ºä¸åŒæ–‡ä»¶çš„ key åŒºé—´å¯èƒ½ä¼šé‡åˆï¼Œæ‰€ä»¥ä¸€ä¸ªæ–‡ä»¶ä¸€ä¸ªè¿­ä»£å™¨</li>
<li>$level_1$~$level_n$ å±‚ï¼Œå› ä¸ºä¸åŒæ–‡ä»¶çš„ key åŒºé—´ä¸ä¼šé‡åˆï¼Œæ‰€ä»¥ä¸€å±‚ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒåŒä¸€å±‚çš„æ•°æ®æ–‡ä»¶æŒ‰ç…§ key åŒºé—´ä»å°åˆ°å¤§æ’åºåä¾æ¬¡éå†å³å¯</li></ul></li>
<li>2ã€SeekToFirst / Seek çš„é€»è¾‘ï¼Œå³æ˜¯è®©å„ä¸ªè¿­ä»£å™¨å…ˆå„è‡ªè¿›è¡Œ SeekToFirst / Seekï¼Œç„¶åå¯¹è¿™äº›è¿­ä»£å™¨çš„è¯»åˆ°çš„é¦–ä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œè·å¾—æœ€å°çš„é‚£ä¸ªè®°å½•</li>
<li>3ã€Next çš„é€»è¾‘ï¼Œè®©ä¸Šæ¬¡å–å¾—æœ€å°å…ƒç´ çš„é‚£ä¸ªè¿­ä»£å™¨å…ˆ Next ä¸€æ¬¡ï¼Œç„¶åå¯¹è¿™äº›è¿­ä»£å™¨çš„è¯»åˆ°çš„é¦–ä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œè·å¾—æœ€å°çš„é‚£ä¸ªè®°å½•</li>
<li>4ã€å¯¹äº 2/3 ä¸­å–åˆ°çš„æœ€å°è®°å½•ï¼Œå› ä¸ºå­˜åœ¨å¿«ç…§çº¦æŸä»¥åŠåŒä¸€ä¸ª key å¯èƒ½å­˜åœ¨å¤šæ¬¡å†™å…¥ï¼ˆPut æˆ– Deleteï¼‰ï¼Œæ‰€ä»¥éœ€è¦ï¼š
<ul><li>è·³è¿‡åºåˆ—å·å¤§äºå¿«ç…§åºåˆ—å·çš„è®°å½•</li>
<li>åŒä¸€ä¸ª keyï¼šå¦‚æœæœ€åä¸€æ¬¡å†™å…¥æ˜¯ Delete æ“ä½œï¼Œåˆ™è·³è¿‡è¯¥ key çš„æ‰€æœ‰è®°å½•ï¼›å¦‚æœæœ€åä¸€æ¬¡å†™å…¥æ˜¯ Put æ“ä½œï¼Œåˆ™è·³è¿‡æœ€åä¸€æ¬¡ä¹‹å‰çš„æ‰€æœ‰è®°å½•ï¼›ä»è€Œç¡®ä¿åŒä¸€ä¸ª key åªä¼šéå†è¿”å›æœ€æ–°æœ‰æ•ˆçš„è®°å½•ã€‚</li></ul></li></ul>
<img src='../assets/leveldb/db-iterator.png' title='leveldb-db-iterator' alt='leveldb-db-iterator' width='830'/>
<h3>9.4 è¡¨ç¼“å­˜ & å—ç¼“å­˜</h3>
<p class="text-align-justify">å¤šçº¿ç¨‹å¹¶å‘å¯¹ leveldb æ•°æ®åº“æ£€ç´¢ï¼ˆç‚¹æŸ¥/æœ‰åºéå†ï¼‰æ—¶ï¼Œæœ‰ä¸€äº›æ•°æ®æ–‡ä»¶ä¼šè¢«é¢‘ç¹è®¿é—®ï¼ˆå¤šçº¿ç¨‹ä¹‹é—´ä»¥åŠæ—¶åºä¸Šï¼‰ï¼Œå°†è¿™äº›æ–‡ä»¶çš„å¥æŸ„ä»¥åŠæ•°æ®ç´¢å¼•ç­‰å…ƒä¿¡æ¯ç¼“å­˜èµ·æ¥è¿›è¡Œå¤ç”¨ï¼Œå¯ä»¥æé«˜æ£€ç´¢æ€§èƒ½ï¼Œé™ä½èµ„æºæ¶ˆè€—ã€‚</p>
<p class="text-align-justify">å¦å¤–ï¼ŒæŒ‰ç…§ ldb æ–‡ä»¶â€œå—â€æ ¼å¼ï¼Œæ•°æ®å—å†…å®¹å†™å…¥æ–‡ä»¶ä¹‹å‰å¯ä»¥å…ˆè¿›è¡Œå‹ç¼©ï¼Œå¯èƒ½å­˜åœ¨ä¸€äº›çƒ­ç‚¹æ•°æ®å—ï¼Œå¦‚æœæ¯æ¬¡æ£€ç´¢éƒ½æ ¹æ®ç´¢å¼•<u>ä»æ–‡ä»¶ä¸­è¯»å–æ•°æ®å—å¹¶è§£å‹</u>å†åšè¿›ä¸€æ­¥æŸ¥æ‰¾ï¼Œå¯¹æ€§èƒ½å’Œèµ„æºå¼€é”€å½±å“ä¼šæ¯”è¾ƒå¤§ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥åœ¨æ•°æ®å—çº§åˆ«åšç¼“å­˜ã€‚</p>
<h4>9.4.1 TableCache - è¡¨ç¼“å­˜</h4>
<p class="text-align-justify">leveldb ä¸­å­˜åœ¨ä¸¤ç±»è¡¨/Tableï¼Œé€»è¾‘å«ä¹‰æ˜¯ä¸€è‡´ï¼Œä¸è¿‡æŒ‡ä»£çš„ä¸œè¥¿ä¸ä¸€æ ·ï¼š</p>
<ul><li>MemTable ä¸­çš„è·³è¡¨</li>
<li>ä¸€ä¸ª ldb æ•°æ®æ–‡ä»¶æ‰“å¼€åå…³è”çš„å†…å­˜å¯¹è±¡ï¼Œæ–¹ä¾¿æ£€ç´¢</li></ul>
<p class="text-align-justify">TableCache æ˜¯å¯¹â€œä¸€ä¸ª ldb æ•°æ®æ–‡ä»¶æ‰“å¼€åå…³è”çš„å†…å­˜å¯¹è±¡â€è¿›è¡Œç¼“å­˜ - ç¼“å­˜çš„é”®ä¸º ldb æ•°æ®æ–‡ä»¶çš„ idï¼Œå€¼ä¸º ldb æ•°æ®æ–‡ä»¶çš„ Table å¯¹è±¡ã€‚å®é™…çš„ç¼“å­˜å®ç°é‡‡ç”¨åˆ†ç‰‡/åˆ†æ®µ LRU ç¼“å­˜ï¼Œæå‡å¹¶å‘æ’å…¥/æ·˜æ±°èƒ½åŠ›ã€‚</p>
<p class="text-align-justify">leveldb å®ä¾‹åœ¨ç‰ˆæœ¬ä¿¡æ¯ä¸­ç»´æŠ¤äº†æ‰€æœ‰ level ldb æ•°æ®æ–‡ä»¶çš„å…ƒä¿¡æ¯ - key åŒºé—´æœ€å¤§å€¼æœ€å°å€¼ã€æ•°æ®æ–‡ä»¶çš„ id ç­‰ã€‚æ£€ç´¢æ—¶ï¼Œ</p>
<ul><li>1ã€å…ˆæ ¹æ® key åŒ¹é…åˆ°ç›®æ ‡æ•°æ®æ–‡ä»¶çš„å…ƒä¿¡æ¯</li>
<li>2ã€æ ¹æ®å…ƒä¿¡æ¯ä¸­çš„æ•°æ®æ–‡ä»¶ idï¼Œå» TableCache ä¸­æŸ¥æ‰¾å¯¹åº”çš„ Table å¯¹è±¡ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å…ˆæ‰“å¼€æ•°æ®æ–‡ä»¶ï¼Œè¯»å–è§£æ footer / index / meta / meta index è¿™äº›ç´¢å¼•ä¿¡æ¯ï¼Œå‡†å¤‡å¥½ Table å¯¹è±¡ï¼Œç¼“å­˜åˆ° TableCache ä¸­</li>
<li>3ã€åŸºäº Table å¯¹è±¡ç»§ç»­è¿›è¡Œæ•°æ®æ–‡ä»¶å†…çš„æ£€ç´¢æµç¨‹</li></ul>
<img src='/images/13668317937842427369.svg' title='13668317937842427369' alt='13668317937842427369'/>
<p class="text-align-justify">leveldb é»˜è®¤å‚æ•°æ”¯æŒç¼“å­˜ 990 ä¸ª Tableï¼ŒShardedLRUCache é»˜è®¤åˆ†ç‰‡æ•°ä¸º 16ï¼ŒæŒ‰ç…§å…¬å¼è®¡ç®—ï¼Œæ¯ä¸ªåˆ†ç‰‡æ”¯æŒ ç¼“å­˜ 62 ä¸ª Tableã€‚</p>
<pre class="language-cpp"><code>struct Options {
  // çœç•¥
  // Number of open files that can be used by the DB.  You may need to  
  // increase this if your database has a large working set (budget  
  // one open file per 2MB of working set).  
  int max_open_files = 1000;
  // çœç•¥
}

const int kNumNonTableCacheFiles = 10;

static int TableCacheSize(const Options&amp; sanitized_options) {  
  // Reserve ten files or so for other uses and give the rest to TableCache.  
  return sanitized_options.max_open_files - kNumNonTableCacheFiles;  
}</code></pre>
<pre class="language-cpp"><code>explicit ShardedLRUCache(size_t capacity) : last_id_(0) {  
  const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;  
  for (int s = 0; s &lt; kNumShards; s++) {  
    shard_[s].SetCapacity(per_shard);  
  }  
}</code></pre>
<h4>9.4.2 BlockCache - å—ç¼“å­˜</h4>
<p class="text-align-justify">BlockCache çš„ç¼“å­˜å®ç°æ–¹æ¡ˆï¼Œå¯ä»¥ç”±è°ƒç”¨æ–¹å®ç°ï¼Œå¹¶åœ¨æ‰“å¼€ leveldb æ•°æ®åº“æ—¶åœ¨ Options å‚æ•°ä¸­æŒ‡å®šã€‚å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œåˆ™é»˜è®¤ä½¿ç”¨å’Œ TableCache ä¸€æ ·çš„ç¼“å­˜å®ç° - ShardedLRUCacheï¼Œå¯ç¼“å­˜çš„ key æ•°é‡ä¸º <code>8 &lt;&lt; 20</code>ã€‚</p>
<p class="text-align-justify">å¹¶ä¸”éœ€è¦åœ¨æ£€ç´¢æ—¶çš„ ReadOptions å‚æ•°ä¸­æŒ‡å®šå¯ç”¨å—ç¼“å­˜ï¼ˆé»˜è®¤æ˜¯å¯ç”¨ï¼‰ï¼Œæ‰ä¼šå°†å—ç¼“å­˜ä¸­æ‰¾ä¸åˆ°çš„æ•°æ®å—è¯»å–åæ’å…¥ç¼“å­˜ä¸­ã€‚</p>
<pre class="language-cpp"><code>// Should the data read for this iteration be cached in memory?  
// Callers may wish to set this field to false for bulk scans.  
bool fill_cache = true;</code></pre>
<p class="text-align-justify">å—ç¼“å­˜ä½¿ç”¨çš„é”®ä¸º â€œç¼“å­˜ idâ€ æ‹¼æ¥ä¸Š æ•°æ®å—åœ¨æ–‡ä»¶ä¸­çš„åç§»ä½ç½®ï¼š</p>
<pre class="language-cpp"><code>char cache_key_buffer[16];  
EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);  
EncodeFixed64(cache_key_buffer + 8, handle.offset());  
Slice key(cache_key_buffer, sizeof(cache_key_buffer));  
cache_handle = block_cache-&gt;Lookup(key);</code></pre>
<p class="text-align-justify">â€œç¼“å­˜ idâ€ å’Œ Table å¯¹è±¡å…³è”ï¼Œä¸åŒ Table å¯¹è±¡çš„â€œç¼“å­˜ idâ€ ä¸åŒï¼Œæ‰€ä»¥â€œç¼“å­˜ idâ€ ç”¨äºåœ¨åŒä¸€ä¸ªç¼“å­˜ä¸­åŒºåˆ†ä¸åŒæ•°æ®æ–‡ä»¶çš„æ•°æ®å—ã€‚ShardedLRUCache ç¼“å­˜å®ç°ä»¥é€’å¢æ•´æ•°çš„æ–¹å¼åˆ†é…â€œç¼“å­˜ idâ€ï¼š</p>
<pre class="language-cpp"><code>uint64_t NewId() override {  
  MutexLock l(&amp;id_mutex_);  
  return ++(last_id_);  
}</code></pre>
<p class="text-align-justify">compaction è¿‡ç¨‹ä¼šå¯¹è¾“å…¥æ•°æ®æ–‡ä»¶è¿›è¡Œéå†ï¼Œå¹¶ä¸”ä½¿ç”¨çš„ä¹Ÿæ˜¯åŒä¸€ä¸ª TableCache å®ä¾‹å’Œå„ä¸ª Table å®ä¾‹ï¼Œå¦‚æœè¿™ä¸ªè¿‡ç¨‹ä¹Ÿå¯ç”¨å—ç¼“å­˜ï¼Œåˆ™ä¼šå¯¼è‡´å¤§é‡éçƒ­ç‚¹çš„æ•°æ®å—ç¼“å­˜èµ·æ¥ï¼Œå¯¹æ­£å¸¸æ£€ç´¢é€ æˆå¹²æ‰°ã€‚æ‰€ä»¥ <u>compaction è¿‡ç¨‹ä¼šå°† fill_cache è®¾ç½®ä¸º falseï¼Œå…³é—­ compaction è¾“å…¥éå†çš„å—ç¼“å­˜</u>ã€‚</p>
<pre class="language-cpp"><code>// Control over blocks (user data is stored in a set of blocks, and  
// a block is the unit of reading from disk).  
  
// If non-null, use the specified cache for blocks.  
// If null, leveldb will automatically create and use an 8MB internal cache.  
Cache* block_cache = nullptr;  
  
// Approximate size of user data packed per block.  Note that the  
// block size specified here corresponds to uncompressed data.  The  
// actual size of the unit read from disk may be smaller if  
// compression is enabled.  This parameter can be changed dynamically.  
size_t block_size = 4 * 1024;</code></pre>
<h4>9.4.3 ShardedLRUCache</h4>
<img src='/images/13668317937842427369.svg' title='13668317937842427369' alt='13668317937842427369'/>
<p class="text-align-justify">HandleTable æ˜¯ä¸€ä¸ªâ€œé“¾æ¥æ³•ï¼ˆchainingï¼‰â€ å®ç°çš„å“ˆå¸Œè¡¨ï¼Œé»˜è®¤åˆå§‹åŒ– 4 ä¸ª bucketsï¼Œæ¯ä¸ª bucket åˆå§‹å€¼ä¸ºç©ºæŒ‡é’ˆï¼ŒæŒ‡é’ˆç±»å‹ä¸º <code>LRUHandle*</code>ï¼Œå³å“ˆå¸Œè¡¨èŠ‚ç‚¹ç±»å‹ã€‚</p>
<p class="text-align-justify">HandleTable ä¸­ï¼š</p>
<ul><li><code>length_</code>ï¼šè¡¨ç¤ºå“ˆå¸Œè¡¨çš„å½“å‰å®¹é‡ã€‚</li>
<li><code>elems_</code>ï¼šè¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨ä¸­å­˜å‚¨çš„å…ƒç´ /èŠ‚ç‚¹ä¸ªæ•°ï¼Œå¦‚æœ <code>elems_</code> è¶…è¿‡ <code>length_</code>ï¼Œåˆ™æŒ‰å½“å‰å®¹é‡çš„2å€æ‰©å®¹ã€‚</li>
<li><code>list_</code>ï¼šå³ bucket æ•°ç»„ã€‚</li></ul>
<p class="text-align-justify">LRUHandle ä¸­ï¼š</p>
<ul><li><code>next_hash</code> å­—æ®µï¼šæŒ‡å‘å½“å‰èŠ‚ç‚¹æ‰€åœ¨ bucket é“¾è¡¨çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹</li>
<li><code>next</code> & <code>pre</code> å­—æ®µï¼šæŒ‡å‘èŠ‚ç‚¹åœ¨ LRU é“¾è¡¨ä¸­çš„å‰ç½®èŠ‚ç‚¹å’Œåç½®èŠ‚ç‚¹</li>
<li><code>hash</code> å­—æ®µï¼šå­˜å‚¨ key çš„å“ˆå¸Œå€¼ï¼Œç”¨äºåŠ é€Ÿåœ¨ bucket é“¾è¡¨ä¸­éå†æŸ¥æ‰¾è¿‡ç¨‹</li>
<li><code>refs</code>ï¼šèŠ‚ç‚¹è‡ªå·±çš„å¼•ç”¨è®¡æ•°ï¼Œåˆå§‹åŒ–æ—¶ä¼šè®¾ç½®ä¸º 1ï¼Œè¡¨ç¤ºè¢«ç¼“å­˜å¼•ç”¨ï¼›è°ƒç”¨æ–¹ä»ç¼“å­˜ä¸­è·å–åˆ°è¿™ä¸ªèŠ‚ç‚¹æ—¶ï¼Œè®¡æ•°ä¼šåŠ 1ï¼›è°ƒç”¨æ–¹ä¸å†ä½¿ç”¨æ—¶ä¼šè°ƒç”¨ <code>ShardedLRUCache::Release</code> -> <code>LRUCache::Release</code> -> <code>LRUCache::Unref</code> å°†è®¡æ•°å‡1ï¼Œå¦‚æœå¼•ç”¨è®¡æ•°é‡æ–°å˜ä¸º1ï¼Œåˆ™è¡¨ç¤ºå½“å‰è¿™ä¸ªèŠ‚ç‚¹æ²¡æœ‰ä»»ä½•è°ƒç”¨æ–¹åœ¨ä½¿ç”¨ï¼Œä»…ç¼“å­˜æŒæœ‰å¼•ç”¨ã€‚</li></ul>
<p class="text-align-justify">ShardedLRUCache æ˜¯ä¸€ä¸ªå¤šåˆ†ç‰‡çš„ LRU ç¼“å­˜å®ç°ï¼Œé»˜è®¤16ä¸ªåˆ†ç‰‡ï¼Œé€šè¿‡åˆ†æ®µé”æ¥å‡å°‘å¹¶å‘å†²çªï¼Œæå‡æ€§èƒ½ã€‚LRU ç¼“å­˜çš„æ£€ç´¢(Lookup)æˆ–æ’å…¥(Insert)ï¼Œéƒ½å…ˆè®¡ç®— key çš„å“ˆå¸Œå€¼ï¼Œå°†å“ˆå¸Œå€¼çš„å¤´éƒ¨4ä¸ªæ¯”ç‰¹çš„å€¼ä½œä¸ºåˆ†ç‰‡ idï¼Œç„¶ååœ¨ç›®æ ‡åˆ†ç‰‡ LRU ç¼“å­˜ä¸­æ£€ç´¢æˆ–æ’å…¥ã€‚</p>
<p class="text-align-justify">LRUCache æ˜¯å®é™…çš„ LRU ç¼“å­˜å®ç°ï¼Œ</p>
<ul><li><code>HandleTable table_</code>ï¼š å®é™…å­˜æ”¾ç¼“å­˜é¡¹çš„å“ˆå¸Œè¡¨ã€‚</li>
<li><code>LRUHandle in_use_</code>ï¼šå¦‚æœä¸€ä¸ªç¼“å­˜é¡¹è¢«æŸä¸ªè°ƒç”¨æ–¹å¼•ç”¨ï¼ˆrefs > 1ï¼‰ï¼Œåˆ™ä¼šè¢«æ”¾å…¥ <code>in_use_</code> é“¾è¡¨ä¸­ã€‚è¿™äº›ç¼“å­˜é¡¹ä¸ä¼šè¢« LRU å›æ”¶ï¼Œå¯¹äºè°ƒç”¨æ–¹æ¥è¯´æ˜¯å†…å­˜å®‰å…¨çš„ã€‚</li>
<li><code>LRUHandle lru_</code>ï¼šå¦‚æœä¸€ä¸ªç¼“å­˜é¡¹ï¼ˆLRUHandleï¼‰ä¸å†è¢«ä»»ä½•è°ƒç”¨æ–¹å¼•ç”¨ï¼ˆrefs=1ï¼‰ï¼Œåˆ™å°†ä» <code>in_use_</code> é“¾è¡¨ä¸­ç§»é™¤ï¼Œè¢«æ”¾å…¥ <code>lru_</code> åŒå‘é“¾è¡¨ä¸­ï¼š
<ul><li>è¿™äº›ç¼“å­˜é¡¹è¿˜è¢«ç¼“å­˜å¼•ç”¨ï¼Œå­˜åœ¨ <code>table_</code> ä¸­</li>
<li>æœ€æ–°æ”¾å…¥çš„æ”¾åœ¨é˜Ÿå°¾ - è¿™æ„å‘³ç€å¯¹å¤´çš„ç¼“å­˜é¡¹æ˜¯æœ€ä¹…æœªè¢«ä½¿ç”¨çš„ï¼Œå½“ç¼“å­˜é¡¹æ•°é‡è¶…é¢æ—¶ï¼Œåˆ™ä» <code>lru_</code> é“¾è¡¨çš„å¤´éƒ¨å¼€å§‹é€ä¸ªç¼“å­˜é¡¹å›æ”¶</li>
<li>å¦‚æœå…¶ä¸­çš„ç¼“å­˜é¡¹åæ¥è¢«è°ƒç”¨æ–¹å†æ¬¡æ£€ç´¢å¼•ç”¨ï¼Œåˆ™ä¼šä» <code>lru_</code> ä¸­ç§»é™¤ï¼Œé‡æ–°æ”¾åˆ° <code>in_use_</code> é˜Ÿå°¾</li></ul></li></ul>
<pre class="language-cpp"><code>// Dummy head of LRU list.  
// lru.prev is newest entry, lru.next is oldest entry.  
// Entries have refs==1 and in_cache==true.  
LRUHandle lru_ GUARDED_BY(mutex_);  
  
// Dummy head of in-use list.  
// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.  
LRUHandle in_use_ GUARDED_BY(mutex_);  
  
HandleTable table_ GUARDED_BY(mutex_);</code></pre>
<p class="text-align-justify">LRU ç¼“å­˜çš„å¸¸è§„ä½¿ç”¨æ–¹å¼ï¼š</p>
<ul><li>1ã€å…ˆä»ç¼“å­˜ä¸­æ£€ç´¢ï¼ˆLookupï¼‰ï¼Œå¦‚æœæœªæ£€ç´¢åˆ°ï¼Œåˆ™ï¼š</li>
<li>2ã€å‡†å¤‡å¥½ç¼“å­˜çš„é”®å€¼ï¼Œæ’å…¥ç¼“å­˜ï¼ˆInsertï¼‰ï¼Œå¾—åˆ°ç¼“å­˜é¡¹</li>
<li>3ã€ä½¿ç”¨å®Œç¼“å­˜é¡¹åï¼Œé‡Šæ”¾å¼•ç”¨ï¼ˆReleaseï¼‰</li></ul>
<p class="text-align-justify">Lookup è¿‡ç¨‹ - å¦‚æœ HandleTable å“ˆå¸Œè¡¨ä¸­æ£€ç´¢åˆ°ï¼š</p>
<ul><li>å¦‚æœç¼“å­˜é¡¹çš„å¼•ç”¨è®¡æ•°ä¸º 1ï¼Œè¡¨ç¤ºå½“å‰ç¼“å­˜é¡¹ä»…è¢« LRU ç¼“å­˜å¼•ç”¨ï¼ŒæŒ‚æ¥åœ¨ <code>lru_</code> é“¾è¡¨ä¸Šï¼Œæ‰€ä»¥å°†å½“å‰ç¼“å­˜é¡¹ä» <code>lru_</code> é“¾è¡¨ä¸Šæ‘˜é™¤ï¼ŒæŒ‚æ¥åˆ° <code>in_use_</code> é“¾è¡¨é˜Ÿå°¾ï¼Œå¹¶å°†å¼•ç”¨è®¡æ•°åŠ 1</li>
<li>å¦åˆ™å°†å¼•ç”¨è®¡æ•°åŠ 1 å³å¯</li></ul>
<p class="text-align-justify">Insert è¿‡ç¨‹ -</p>
<ul><li>1ã€æ„å»ºç¼“å­˜é¡¹ - ç”³è¯·å†…å­˜ï¼Œè®¾ç½®å„ä¸ªå­—æ®µçš„å€¼ï¼Œå¼•ç”¨è®¡æ•°è®¾ç½®ä¸º 1ï¼ˆInsert ä¼šæŠŠç¼“å­˜é¡¹è¿”å›ç»™è°ƒç”¨æ–¹ä½¿ç”¨ï¼‰ã€‚</li>
<li>2ã€å°†ç¼“å­˜é¡¹å¼•ç”¨è®¡æ•°åŠ 1ï¼Œå¹¶æŒ‚æ¥åˆ° <code>in_use_</code> çš„é˜Ÿå°¾ã€‚</li>
<li>3ã€å°†ç¼“å­˜é¡¹æ’å…¥ HandleTable å“ˆå¸Œè¡¨ã€‚å¦‚æœå“ˆå¸Œè¡¨ä¸­å·²å­˜åœ¨ç›¸åŒçš„ keyï¼Œåˆ™è¿˜éœ€è¦é‡Šæ”¾ç¼“å­˜è‡ªå·±å¯¹åŸæœ‰ç¼“å­˜é¡¹çš„å¼•ç”¨ã€‚</li>
<li>4ã€å¦‚æœç¼“å­˜é¡¹æ•°é‡è¶…é¢ï¼Œåˆ™ä» <code>lru_</code> é“¾è¡¨çš„å¤´éƒ¨å¼€å§‹é€ä¸ªå›æ”¶ç¼“å­˜é¡¹ï¼ˆå› ä¸ºè¿™äº›ç¼“å­˜é¡¹ä»…è¢«ç¼“å­˜è‡ªå·±å¼•ç”¨ï¼Œæ‰€ä»¥å¯ä»¥å®‰å…¨åœ°è¿›è¡Œå†…å­˜å›æ”¶ï¼‰ï¼Œç›´åˆ°ç¼“å­˜é¡¹æ•°é‡æœªè¶…é¢ã€‚</li></ul>
<p class="text-align-justify">Release çš„è¿‡ç¨‹ -</p>
<ul><li>1ã€å°†ç¼“å­˜é¡¹çš„å¼•ç”¨è®¡æ•°å‡1ã€‚</li>
<li>2ã€å°†ç¼“å­˜é¡¹ä» <code>in_use_</code> é“¾è¡¨ä¸­æ‘˜é™¤ï¼ŒæŒ‚æ¥åˆ° <code>lru_</code> é“¾è¡¨é˜Ÿå°¾ã€‚</li></ul>
<h3>9.5ã€è¿‡æ»¤ç­–ç•¥-å¸ƒéš†è¿‡æ»¤å™¨</h3>
<img src='../assets/leveldb/Bloom_filter_speed.png' title='Bloom_filter_speed' alt='Bloom_filter_speed' width='600'/>
<p class="text-align-justify">è¿‡æ»¤å™¨åŒ¹é…è¿”å› falseï¼Œå°±ä¸€å®šä¸åœ¨å­˜å‚¨ä¸­ï¼›å¦‚æœè¿”å› trueï¼Œæœ‰å°æ¦‚ç‡ä¸å¯¹ï¼ˆfalse positiveï¼‰<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">[1]</a></sup>ã€‚</p>
<img src='/images/13668317937842427369.svg' title='13668317937842427369' alt='13668317937842427369'/>
<pre class="language-cpp"><code>class FilterPolicy {
public:  
 virtual ~FilterPolicy();  
  
 // Return the name of this policy.  Note that if the filter encoding  
 // changes in an incompatible way, the name returned by this method
 // must be changed.  Otherwise, old incompatible filters may be
 // passed to methods of this type.
 virtual const char* Name() const = 0;  
  
 // keys[0,n-1] contains a list of keys (potentially with duplicates)  
 // that are ordered according to the user supplied comparator.
 // Append a filter that summarizes keys[0,n-1] to *dst.
 //
 // Warning: do not change the initial contents of *dst.  Instead,
 // append the newly constructed filter to *dst.
 virtual void CreateFilter(const Slice* keys, int n,  
                           std::string* dst) const = 0;  
  
 // &quot;filter&quot; contains the data appended by a preceding call to  
 // CreateFilter() on this class.  This method must return true if
 // the key was in the list of keys passed to CreateFilter().
 // This method may return true or false if the key was not on the
 // list, but it should aim to return false with a high probability.
 virtual bool KeyMayMatch(const Slice&amp; key, const Slice&amp; filter) const = 0;
}

// Return a new filter policy that uses a bloom filter with approximately  
// the specified number of bits per key.  A good value for bits_per_key  
// is 10, which yields a filter with ~ 1% false positive rate.  
//  
// Callers must delete the result after any database that is using the  
// result has been closed.  
//  
// Note: if you are using a custom comparator that ignores some parts  
// of the keys being compared, you must not use NewBloomFilterPolicy()  
// and must provide your own FilterPolicy that also ignores the  
// corresponding parts of the keys.  For example, if the comparator  
// ignores trailing spaces, it would be incorrect to use a  
// FilterPolicy (like NewBloomFilterPolicy) that does not ignore  
// trailing spaces in keys.
const FilterPolicy* NewBloomFilterPolicy(int bits_per_key);</code></pre>
<pre class="language-cpp"><code>static uint32_t BloomHash(const Slice&amp; key) {  
  return Hash(key.data(), key.size(), 0xbc9f1d34);  
}  
  
class BloomFilterPolicy : public FilterPolicy {  
 public:  
  explicit BloomFilterPolicy(int bits_per_key) : bits_per_key_(bits_per_key) {  
    // We intentionally round down to reduce probing cost a little bit 
    /* llama3ï¼š
    åœ¨Bloomè¿‡æ»¤å™¨ä¸­ï¼Œå“ˆå¸Œå‡½æ•°æ¬¡æ•° k æ˜¯ä¸€ä¸ªé‡è¦å‚æ•°ï¼Œå®ƒå†³å®šäº†è¿‡æ»¤å™¨çš„å¤§å°å’Œç²¾åº¦ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œkè¶Šå¤§ï¼Œè¿‡æ»¤å™¨è¶Šå¤§ï¼Œä½†ä¹Ÿè¶Šå‡†ç¡®ï¼›åä¹‹ï¼Œkè¶Šå°ï¼Œè¿‡æ»¤å™¨è¶Šå°ï¼Œä½†ä¹Ÿè¶Šä¸å‡†ç¡®ã€‚
    åœ¨è¿™ä¸ªå®ç°ä¸­ï¼Œä¹˜ä»¥ 0.69 çš„ç›®çš„æ˜¯ä¸ºäº†è®¡ç®—å‡ºä¸€ä¸ªåˆé€‚çš„ k å€¼ï¼Œä½¿å¾—è¿‡æ»¤å™¨çš„å¤§å°å’Œç²¾åº¦è¾¾åˆ°ä¸€ä¸ªå¹³è¡¡ã€‚å…·ä½“æ¥è¯´ï¼Œä¹˜ä»¥ 0.69 æ˜¯ä¸ºäº†å°† bits_per_key å€¼ä¹˜ä»¥ä¸€ä¸ªè¾ƒå°çš„å€æ•°ï¼Œä»è€Œå¾—åˆ°ä¸€ä¸ªè¾ƒå°çš„ k å€¼ã€‚
    å¥½å¤„æ˜¯ï¼š
	1ã€å‡å°‘è¿‡æ»¤å™¨å¤§å°ï¼šé€šè¿‡ä¹˜ä»¥ 0.69ï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªè¾ƒå°çš„ k å€¼ï¼Œè¿™æ„å‘³ç€è¿‡æ»¤å™¨çš„å¤§å°ä¹Ÿä¼šç›¸åº”å‡å°ã€‚è¿™å¯¹äºå­˜å‚¨å’Œä¼ è¾“è¿‡æ»¤å™¨æ¥è¯´æ˜¯ä¸€ä¸ªé‡è¦çš„è€ƒè™‘å› ç´ ã€‚
	2ã€æé«˜åŒ¹é…æ•ˆç‡ï¼šè™½ç„¶è¾ƒå°çš„ k å€¼å¯èƒ½å¯¼è‡´è¿‡æ»¤å™¨ä¸å‡†ç¡®ï¼Œä½†åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™ä¸ªå½±å“å¾€å¾€æ˜¯å¯ä»¥æ¥å—çš„ã€‚å› ä¸ºåŒ¹é…æ•ˆç‡ä¼šå¤§å¹…æé«˜ï¼Œç‰¹åˆ«æ˜¯åœ¨è¿‡æ»¤å™¨å¤§å°ç›¸å¯¹è¾ƒå°æ—¶ã€‚
	3ã€å¹³è¡¡ç²¾åº¦å’Œå¤§å°ï¼šä¹˜ä»¥ 0.69 çš„æ–¹æ³•å¯ä»¥å¸®åŠ©æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„ k å€¼ï¼Œä½¿å¾—è¿‡æ»¤å™¨çš„å¤§å°å’Œç²¾åº¦è¾¾åˆ°ä¸€ä¸ªå¹³è¡¡ã€‚è¿™å¯¹äºå®é™…åº”ç”¨æ¥è¯´éå¸¸é‡è¦ï¼Œå› ä¸ºå®ƒå¯ä»¥ç¡®ä¿è¿‡æ»¤å™¨æ—¢èƒ½å‡†ç¡®åˆèƒ½é«˜æ•ˆã€‚
    */
    k_ = static_cast&lt;size_t&gt;(bits_per_key * 0.69);  // 0.69 =~ ln(2)  
    if (k_ &lt; 1) k_ = 1;  
    if (k_ &gt; 30) k_ = 30;  
  }  
  
  const char* Name() const override { return &quot;leveldb.BuiltinBloomFilter2&quot;; }  
  
  void CreateFilter(const Slice* keys, int n, std::string* dst) const override {  
    // Compute bloom filter size (in both bits and bytes)  
    size_t bits = n * bits_per_key_;  
  
    // For small n, we can see a very high false positive rate.  Fix it  
    // by enforcing a minimum bloom filter length.
    if (bits &lt; 64) bits = 64;  
  
    size_t bytes = (bits + 7) / 8;  
    bits = bytes * 8;  
  
    const size_t init_size = dst-&gt;size();  
    dst-&gt;resize(init_size + bytes, 0);  
    dst-&gt;push_back(static_cast&lt;char&gt;(k_));  // Remember # of probes in filter  
    char* array = &amp;(*dst)[init_size];  
    for (int i = 0; i &lt; n; i++) {  
      // Use double-hashing to generate a sequence of hash values.  
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);  
      const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15);  // Rotate right 17 bits  
      for (size_t j = 0; j &lt; k_; j++) {  // ç®— k_ æ¬¡å“ˆå¸Œä»¥åŠè®¾ç½® k_ ä¸ªæ¯”ç‰¹ä½
        const uint32_t bitpos = h % bits;  
        // ç¬¬å‡ ä¸ªå­—èŠ‚ï¼Ÿbitpos / 8
        // ç›®æ ‡å­—èŠ‚ä¸­çš„ç¬¬å‡ ä¸ªæ¯”ç‰¹ï¼Ÿ bitpos % 8
        array[bitpos / 8] |= (1 &lt;&lt; (bitpos % 8));  
        h += delta;  // æ¯æ¬¡å“ˆå¸Œå€¼æœ‰å˜åŒ–
      }  
    }  
  }  
  
  bool KeyMayMatch(const Slice&amp; key, const Slice&amp; bloom_filter) const override {  
    const size_t len = bloom_filter.size();  
    if (len &lt; 2) return false;  
  
    const char* array = bloom_filter.data();  
    const size_t bits = (len - 1) * 8;  
  
    // Use the encoded k so that we can read filters generated by  
    // bloom filters created using different parameters.
    const size_t k = array[len - 1];  
    if (k &gt; 30) {  
      // Reserved for potentially new encodings for short bloom filters.  
      // Consider it a match.
      return true;  
    }  
  
    uint32_t h = BloomHash(key);  
    const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15);  // Rotate right 17 bits  
    for (size_t j = 0; j &lt; k; j++) {  
      const uint32_t bitpos = h % bits;  
      if ((array[bitpos / 8] &amp; (1 &lt;&lt; (bitpos % 8))) == 0) return false;  // ä»»ä¸€æ¯”ç‰¹ä½ä¸åŒ¹é…ï¼Œå°±ç®—ä¸åŒ¹é…ã€‚
      h += delta;  
    }  
    return true;  
  }  
  
 private:  
  size_t bits_per_key_;  
  size_t k_;  
};</code></pre>
<pre class="language-cpp"><code>const int32_t KEY_VALIDATOR_BYTE_SIZE = 128 * 1024 * 1024;  // 128M
const uint64_t KEY_VALIDATOR_VALUE_MASK = 0x3fffffff;  // 30bit
const uint64_t KEY_VALIDATOR_BIT_MASK = 0x07;  
const uint8_t KEY_VALIDATOR_ONE = 1;

const uint8_t KEY_VALIDATOR_LOCK_COUNT = 32;
const uint8_t KEY_VALIDATOR_LOCK_MASK = KEY_VALIDATOR_LOCK_COUNT - 1;

class KeyValidator {
public:
    static KeyValidator&amp; Instance() {
        static KeyValidator instance;
        return instance;
    }

    ~KeyValidator() {
        if (bitmap_data_) {
            delete [] bitmap_data_;
            bitmap_data_ = nullptr;
        }
    }

    bool IsInitialized() {
        return (bitmap_data_ != nullptr);
    }

    bool Init() {
        if (!bitmap_data_) {
            bitmap_data_ = new uint8_t[KEY_VALIDATOR_BYTE_SIZE];
        }
        std::memset(bitmap_data_, 0, KEY_VALIDATOR_BYTE_SIZE);
        // need to catch bad_alloc ?
        LOG(WARNING) &lt;&lt; &quot;KeyValidator initialized succ.&quot;;
        return true;
    }

    bool Update(uint64_t key_id) {
        if (!bitmap_data_) {
            LOG(ERROR) &lt;&lt; &quot;bitmap_data not initialized!&quot;;
            return false;
        }
        uint64_t byte_index = 0;
        uint8_t bit_mask = 0;
        GetByteIndex(key_id, byte_index, bit_mask);
        // lock to ensure multi-thread write
        auto&amp; lock = spin_locks[byte_index &amp; KEY_VALIDATOR_LOCK_MASK];
        lock.Lock();
        bitmap_data_[byte_index] |= bit_mask;
        lock.UnLock();
        return true;
    }

    bool IsValid(uint64_t key_id) {
        if (!bitmap_data_) {
            LOG(ERROR) &lt;&lt; &quot;bitmap_data not initialized!&quot;;
            return false;
        }
        uint64_t byte_index = 0;
        uint8_t bit_mask = 0;
        GetByteIndex(key_id, byte_index, bit_mask);
        return (bitmap_data_[byte_index] &amp; bit_mask);
    }


    bool GetValidKeys(const std::vector&lt;int64_t&gt;&amp; key_list,
                std::vector&lt;int64_t&gt;&amp; result) {
        result.clear();
        result.reserve(key_list.size());
        for (auto&amp; key_id : key_list) {
            if (IsValid(key_id)) {
                result.push_back(key_id);
            }
        }
        return true;
    }

private:
    uint8_t* bitmap_data_ = nullptr;
    std::vector&lt;psarlib::synchronization::SpinLock&gt; spin_locks;

    KeyValidator()
    : spin_locks(KEY_VALIDATOR_LOCK_COUNT) {}

    void GetByteIndex(uint64_t key_id, uint64_t&amp; byte_index, uint8_t&amp; bit_mask) {
        auto value = key_id &amp; KEY_VALIDATOR_VALUE_MASK;
        byte_index = value &gt;&gt; 3;                          // divide by 8
        auto bit_index = value &amp; KEY_VALIDATOR_BIT_MASK;  // mod by 8
        bit_mask = (KEY_VALIDATOR_ONE &lt;&lt; bit_index);
    }
};</code></pre>
<hr>
<div class="footnotes" role="doc-endnotes"><ol><li id="fn:1"><p><a href='https://hur.st/bloomfilter/'>Bloom Filter Calculator</a><a href="#fnref:1" class="reversefootnote" role="doc-backlink">â†©</a></p></li></ol></div>
    </article>
</div>

    </div>
</div>

<footer class="site-footer">
    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="social-media-list">
                    <li>
                        <a href="https://github.com/kitelife" target="_blank">
                            <span class="icon icon--github">
                                <svg viewBox="0 0 16 16">
                                    <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                                </svg>
                            </span>
                            <span class="username">kitelife</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://maimai.cn/profile/detail?dstu=39580141" target="_blank">
                            <span class="icon icon--maimai">
                                <img src="https://maimai.cn/favicon.ico" width="16"/>
                            </span>
                            <span class="username">Xiayf</span>
                        </a>
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2"></div>
            <div class="footer-col footer-col-3"></div>
            <div class="footer-col footer-col-4">
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                    <img alt="Creative Commons License" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-sa.svg">
                </a>
            </div>
        </div>
    </div>
</footer>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        svg: {
            fontCache: 'global'
        }
    };
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>