<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>黑·白</title><link>http://youngsterxyf.github.io/</link><description></description><lastBuildDate>Sun, 13 Oct 2019 00:00:00 +0800</lastBuildDate><item><title>读文笔记：Kafka 官方设计文档</title><link>http://youngsterxyf.github.io/2019/10/13/reading-kafka-design/</link><description>&lt;p&gt;原文：&lt;a href="http://kafka.apache.org/documentation/#design"&gt;http://kafka.apache.org/documentation/#design&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;数据持久化&lt;/h2&gt;
&lt;h4&gt;不用惧怕文件系统&lt;/h4&gt;
&lt;p&gt;磁盘的读写速度，取决于如何读写。对于线性读写方式，操作系统做了充分的优化：提前读 - 预取若干数据块，滞后写 - 将小的逻辑写操作合并成一个大的物理写操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://queue.acm.org/detail.cfm?id=1563874"&gt;研究&lt;/a&gt;表明：&lt;a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg"&gt;顺序读写磁盘（sequential disk access）的速度有些时候比随机访问内存还要快&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现代操作系统激进地尽可能将空闲内存用作磁盘缓存。所有磁盘读写都经过操作系统提供的统一缓存。这个特性没法轻易关闭，除非直接 I/O （direct I/O），因此，如果程序在用户进程中进行数据缓存，缓存的数据通常也是和操作系统页缓存重复的，缓存两遍，没啥意义，也浪费内存。&lt;/p&gt;
&lt;p&gt;而且，Kafka 是构建在 JVM 之上的，了解 Java 内存使用方式的人应该都知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象的内存开销非常高，通常是实际数据大小的2倍（甚至更多 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Sun, 13 Oct 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-10-13:/2019/10/13/reading-kafka-design/</guid><category>文章</category><category>笔记</category><category>经典</category><category>Kafka</category><category>进行中</category></item><item><title>读文笔记：Photon - Fault-tolerant and Scalable Joining of Continuous Data Streams</title><link>http://youngsterxyf.github.io/2019/10/10/reading-photon/</link><description>&lt;p&gt;原文：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41318.pdf"&gt;Photon: Fault-tolerant and Scalable Joining of Continuous Data Streams&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Photon 是谷歌广告系统中用于 join 广告曝光日志流和点击日志流的一套系统。&lt;/p&gt;
&lt;p&gt;数据流 join 为什么没用 flink 这类通用的流式处理框架？&lt;/p&gt;
&lt;p&gt;数据流 join，特别是广告数据流 join，技术上难在哪里？&lt;/p&gt;
&lt;p&gt;任一条流都可能乱序或延迟，广告点击涉及计费的问题，计费不能多算广告主的钱，也要尽可能避免漏计费，降低广告收入损失。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;该系统在谷歌生产环境中每分钟处理百万级的事件，端到端延迟小于 10 秒（注：对于广告实时竞价的广告主而言，这个延迟的长短很重要）。&lt;/p&gt;
&lt;p&gt;广告曝光、点击整体流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户搜索某个关键词时，谷歌的服务器会返回广告和搜索结果。广告服务器会将广告 query 和结果数据作为日志发送到多个日志数据中心（multiple logs-datacenters），最终持久化存储在 GFS 上。每次 query …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Thu, 10 Oct 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-10-10:/2019/10/10/reading-photon/</guid><category>论文</category><category>笔记</category></item><item><title>读文笔记：日志 - 每个软件工程师都应该了解的实时数据统一抽象</title><link>http://youngsterxyf.github.io/2019/10/10/reading-the-log/</link><description>&lt;p&gt;原文：&lt;a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying"&gt;The Log: What every software engineer should know about real-time data's unifying abstraction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话概括，这篇文章细说了 Kafka 的本质原理、解决的问题、适用性等。&lt;/p&gt;
&lt;p&gt;Kafka 本质上是提供日志数据流。&lt;/p&gt;
&lt;p&gt;日志是客观世界的事件记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A log is perhaps the simplest possible storage abstraction. It is an append-only, totally-ordered sequence of records ordered by time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志数据的特点是：只增不改，自带时间戳，数据存储的先后顺序即（大致）是实际发生的时间先后顺序。&lt;/p&gt;
&lt;p&gt;数据库可以基于日志来还原历史操作行为 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Thu, 10 Oct 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-10-10:/2019/10/10/reading-the-log/</guid><category>论文</category><category>笔记</category></item><item><title>Lucene 查询解析器语法（译）</title><link>http://youngsterxyf.github.io/2019/09/04/lucene-query-parser-syntax/</link><description>&lt;p&gt;原文：&lt;a href="http://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description"&gt;Query Parser Syntax&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;Lucene 除了提供 API 方便开发者创建查询请求，还通过一个查询解析器（一个词法分析器，使用 JavaCC 将一个字符串翻译成一个 Lucene 查询）提供一种功能丰富的查询语言。&lt;/p&gt;
&lt;p&gt;一般来说，查询解析器支持的语法在不同发布版本之间可能会有变化。当前这个文档页面描述的是当前这个发布版本的语法。如果你正在使用一个不同版本的 Lucene，请参考该版本自带的 docs/queryparsersyntax.html 文档。&lt;/p&gt;
&lt;p&gt;在选择使用这个查询解析器之前，请考虑以下 3 点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你准备以编程的方式生成一个查询字符串，然后使用查询解析器来解析它。那么，你应该认真考虑一下是否应该直接使用查询 API 来构建查询。换句话说，查询解析器专门用于人类输入的文本，而不是程序生成的文本。&lt;/li&gt;
&lt;li&gt;不可分词（untokenized）的域（译者注：抱歉，此处没太理解）最好直接添加到查询中，而不是通过查询解析器来解析。如果一个域的值是通过应用自动生成的，那么应该为这个域自动生成查询子句 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 04 Sep 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-09-04:/2019/09/04/lucene-query-parser-syntax/</guid><category>翻译</category><category>Lucene</category><category>ElasticSearch</category><category>Kibana</category></item><item><title>一个 Python 小项目的小结</title><link>http://youngsterxyf.github.io/2019/08/14/a-python-project-summary/</link><description>&lt;p&gt;前段时间临时接手一个 Python 小项目，这个项目实现的类似一个管控平台，其中核心功能是为算法同学提供机器学习模型训练任务的全流程管理，平台后端基于 Flask 框架实现，前端基于 Ant Design Pro 实现。&lt;/p&gt;
&lt;p&gt;代码稍微有些乱，所以做了部分代码的重构，在此做点经验小结。&lt;/p&gt;
&lt;h3&gt;1、并行化或异步化&lt;/h3&gt;
&lt;p&gt;部分请求处理逻辑，由于比较耗时，故使用线程池来加速，或者使用独立线程异步处理，或者先存储一个中间状态，由后台定时任务来完成实际的处理工作。对于异步处理结果，前端通过轮询来获取。&lt;/p&gt;
&lt;p&gt;线程池的使用，主要使用 map 方法：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Pool

input_list = [...]
pool: Pool = Pool(len(input_list))
pool.map(func, input_list)
pool.close()
pool.join()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;独立线程异步处理 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 14 Aug 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-08-14:/2019/08/14/a-python-project-summary/</guid><category>总结</category><category>Python</category></item><item><title>Reactor 官方文档翻译简化版</title><link>http://youngsterxyf.github.io/2019/06/26/simplified-reactor-doc-zh/</link><description>&lt;p&gt;原文：&lt;a href="https://projectreactor.io/docs/core/release/reference/"&gt;Reactor 3 Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. 起步&lt;/h3&gt;
&lt;h4&gt;1.1 Reactor 简介&lt;/h4&gt;
&lt;p&gt;Reactor 是为 JVM 准备的一个完全非阻塞的反应式编程基础组件，支持高效的需求管理（以管理“反压”的形式），直接与 Java 8 的函数式 API 集成，尤其是 &lt;code&gt;CompletableFuture&lt;/code&gt;、&lt;code&gt;Stream&lt;/code&gt; 以及 &lt;code&gt;Duration&lt;/code&gt;，提供可组合的异步序列 API - &lt;code&gt;Flux&lt;/code&gt;（适用于 N 个元素的序列）和 &lt;code&gt;Mono&lt;/code&gt;（适用于 0 或 1个元素的序列）--- 并且全面地（extensively）实现了 &lt;a href="https://www.reactive-streams.org/"&gt;反应式流（Reative Streams）&lt;/a&gt; 规范。&lt;/p&gt;
&lt;p&gt;借助 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-06-26:/2019/06/26/simplified-reactor-doc-zh/</guid><category>翻译</category><category>Reactor</category><category>Reactive</category></item><item><title>Java System.getProperty VS. System.getenv（译）</title><link>http://youngsterxyf.github.io/2019/06/25/java-prop-env/</link><description>&lt;p&gt;原文：&lt;a href="https://www.baeldung.com/java-system-get-property-vs-system-getenv"&gt;Java System.getProperty vs System.getenv&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1、简介&lt;/h2&gt;
&lt;p&gt;Java 应用代码中会自动引入 &lt;code&gt;java.lang&lt;/code&gt; 包。这个包包含很多常用的类，包括 &lt;code&gt;NullPointerException&lt;/code&gt;、&lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;java.lang.System&lt;/code&gt; 类是一个 final 类，这意味着开发者无法继承它，其所有方法都是静态的（static）。&lt;/p&gt;
&lt;p&gt;System 类中有两个方法，分别来&lt;strong&gt;读取系统属性（system properties）和环境变量（environment variables）&lt;/strong&gt;，下面我们来看看这两者的区别。&lt;/p&gt;
&lt;h2&gt;2、使用 System.getProperty()&lt;/h2&gt;
&lt;p&gt;Java 平台使用一个 &lt;code&gt;Properties&lt;/code&gt; 对象来提供&lt;strong&gt;本地系统相关的信息和配置 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Tue, 25 Jun 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-06-25:/2019/06/25/java-prop-env/</guid><category>翻译</category><category>Java</category></item><item><title>Java 单测伴侣 - mockito</title><link>http://youngsterxyf.github.io/2019/06/17/mockito/</link><description>&lt;p&gt;其实工作以来，我很少写测试/单测代码，一方面是大部分互联网公司团队对测试的要求不高，另一方面是想写好测试代码还挺难的，挺花时间，其中最麻烦的是待测代码可能会访问外部资源（比如数据库、HTTP API），如果不能方便地进模拟访问这些外部资源，那么测试起来会非常麻烦。&lt;/p&gt;
&lt;p&gt;但，对于复杂逻辑，如果不经过严格测试，发布到生产环境，又有些不放心，没底气，或者在代码重构时，如果没有覆盖全面的测试，很难评估代码变动带来的影响。&lt;/p&gt;
&lt;p&gt;直到遇到 &lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt;，我才觉得是时候认真写写测试代码了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://site.mockito.org/"&gt;mockito&lt;/a&gt; 提供两种对象模拟方式：&lt;strong&gt;mock&lt;/strong&gt; 和 &lt;strong&gt;spy&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单来说，mock 模拟的对象是一个完全假的对象，只是具备指定类型的接口，以 &lt;code&gt;java.util.List&lt;/code&gt; 为例：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import static&lt;/span&gt; org.mockito.Mockito.mock;

List mockedList = mock(List.class);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Mon, 17 Jun 2019 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2019-06-17:/2019/06/17/mockito/</guid><category>Java</category><category>mockito</category><category>单测</category></item><item><title>编写漂亮的 shell 代码</title><link>http://youngsterxyf.github.io/2018/05/16/beautiful-shell-code/</link><description>&lt;p&gt;使用丑陋的编程语言也能写出漂亮的代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;true_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -eq 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is false, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

false_then_run() {
    condition=$1
    action=$2

    (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;condition&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; [ $? -ne 0 ]
    &lt;span style="color: #0000ff"&gt;then&lt;/span&gt;
        (&lt;span style="color: #a31515"&gt;${&lt;/span&gt;action&lt;span style="color: #a31515"&gt;}&lt;/span&gt;)
    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;
        echo &lt;span style="color: #a31515"&gt;&amp;quot;&amp;#39;&lt;/span&gt;$1&lt;span style="color: #a31515"&gt;&amp;#39; is true, don&amp;#39;t run &amp;#39;&lt;/span&gt;$2&lt;span style="color: #a31515"&gt;&amp;#39;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #0000ff"&gt;fi&lt;/span&gt;
}

map() {
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; item in $2
    &lt;span style="color: #0000ff"&gt;do&lt;/span&gt;
        ($1 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Wed, 16 May 2018 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2018-05-16:/2018/05/16/beautiful-shell-code/</guid><category>Bash</category></item><item><title>配置 Maven 自动化构建 protobuf 代码依赖</title><link>http://youngsterxyf.github.io/2018/05/14/maven-protobuf/</link><description>&lt;p&gt;1.pom.xml 中添加如下属性配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;properties&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- protobuf paths --&amp;gt;&lt;/span&gt;
    &amp;lt;protobuf.input.directory&amp;gt;${project.basedir}/src/main/protobuf&amp;lt;/protobuf.input.directory&amp;gt;
    &amp;lt;protobuf.output.directory&amp;gt;${project.build.directory}/generated-sources&amp;lt;/protobuf.output.directory&amp;gt;
    &lt;span style="color: #008000"&gt;&amp;lt;!-- library versions --&amp;gt;&lt;/span&gt;
    &amp;lt;build-helper-maven-plugin.version&amp;gt;3.0.0&amp;lt;/build-helper-maven-plugin.version&amp;gt;
    &amp;lt;maven-antrun-plugin.version&amp;gt;1.8&amp;lt;/maven-antrun-plugin.version&amp;gt;
    &amp;lt;maven-dependency-plugin.version&amp;gt;3.0.2&amp;lt;/maven-dependency-plugin.version …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Mon, 14 May 2018 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2018-05-14:/2018/05/14/maven-protobuf/</guid><category>java</category><category>maven</category><category>protobuf</category></item><item><title>《Python 编程之美》译者序</title><link>http://youngsterxyf.github.io/2018/04/01/the-python-guide/</link><description>&lt;p&gt;从毕业至今，在互联网行业从事软件研发工作，将近五年。这五年间，做过后端开发、前端开发、大数据处理等，使用过的编程语言包括：Python、PHP、Go、Java、JavaScript 等。&lt;/p&gt;
&lt;p&gt;虽说编程语言各异，但我使用它们来写各种项目的代码却一直坚持两点：代码可读性和自解释性/自文档性（self-documentation）。这很大程度上应该是受到 Python 语言设计哲学的影响 - 追求简单易读易懂的代码。&lt;/p&gt;
&lt;p&gt;很多人可能会认为这两点其实是一点 - 代码可读性，但我想做点区分：代码可读性突出对代码阅读者视觉上的影响，是否存在不必要的理解干扰，比如：必要的空行、变量定义与使用之间的距离、函数体/逻辑分支是否过长、逻辑表达是否直观等等。可读性高的代码通常都非常漂亮、赏心悦目。自解释性代码则更突出语义层面，比如：变量名称/函数名称/类名是否恰当、函数/方法/API 是否单一职责、工程目录结构/包/模块拆分是否符合“高内聚低耦合”原则等等 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">xiayf</dc:creator><pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2018-04-01:/2018/04/01/the-python-guide/</guid><category>翻译</category><category>书籍</category></item><item><title>《精通Python设计模式》译者序</title><link>http://youngsterxyf.github.io/2016/07/01/mpdp/</link><description>&lt;p&gt;在我读大学那几年，设计模式可谓火极一时，各大公司校招面试也几乎都会考设计模式，反观现在，则似乎很少有人聊设计模式的话题。是因为设计模式过时了吗？还是只是一个错误的概念？从个人这几年的开发经验来看，答案是否定的，设计模式并未过时，更不是一个错误的概念。从曾经的“红极一时”到如今的“门可罗雀”，只是说明软件开发行业以更加客观理性的态度来看待设计模式。软件开发领域的技术概念也似乎总是遵循这样的流行度变迁，最终一次又一次地证明不存在“银弹”。&lt;/p&gt;
&lt;p&gt;正确看待设计模式的前提是明白什么是设计模式。正如本书一开始就强调的：“设计模式的本质是在已有的方案之上发现更好的方案（而不是全新发明）”，这是一种务实的态度，设计模式并非是一种高大上或者神秘的东西，而是一些常见的软件工程设计问题的最佳实践方案。&lt;/p&gt;
&lt;p&gt;那么应该如何学习设计模式？个人认为软件开发技术的学习都应该以实践为前提，只有理解实践过程中遇到的种种问题，才能明白那些技术的本质和目的是什么，每种新技术都是因某个/某些问题而出现的，软件开发高手一般都反对新手一开始就一股脑地学习设计模式。有些新手学了点设计模式的理论后，甚至在软件开发过程中生搬硬套，结果是适得其反。因此，软件开发人员应该在积累了一定的开发经验，再系统地学习设计模式，效果往往也能事半功倍。&lt;/p&gt;
&lt;p&gt;现在有些积累一定开发经验的软件开发人员，在谈起设计模式时，一脸鄙夷。我想这也不是一种客观务实的态度。软件开发不是简单的累积代码，在实现业务功能的同时应该仔细考虑如何控制软件的复杂度。软件的复杂度分为两个层面：业务逻辑复杂度和代码实现复杂度。对同一个业务系统，不同的软件开发人员会有不同的实现 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 01 Jul 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-07-01:/2016/07/01/mpdp/</guid><category>翻译</category><category>书籍</category></item><item><title>应用MySQL InnoDB全文索引</title><link>http://youngsterxyf.github.io/2016/06/11/mysql-fulltext-application/</link><description>&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;之前涉及的一项工作要求对某些数据做全文索引，并以API向其他内部系统提供搜索查询服务。&lt;/p&gt;
&lt;p&gt;由于需要建全文索引的数据量并不大，且已有的数据都以InnoDB引擎存储，简单起见，我们选择MySQL InnoDB引擎的全文索引特性来实现。MySQL从版本5.6开始支持InnoDB引擎的全文索引，不过“从5.7.6版本开始才提供一种内建的全文索引ngram parser，支持CJK字符集（中文、日文、韩文，CJK有个共同点就是单词不像英语习惯那样根据空格进行分解的，因此传统的内建分词方式无法准确的对类似中文进行分词）”，我们使用的MySQL版本为5.6.28，并且需要建全文索引的数据部分是中文，所以这是个问题。&lt;/p&gt;
&lt;h2&gt;方案&lt;/h2&gt;
&lt;p&gt;我们先把这项工作按“分治”的思想拆分成几个小问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于版本5.6.28的MySQL不支持中文的全文索引，那么可以对需要建全文索引的数据进行预处理 - 分词，并以空格为间隔将分词结果拼接成一个字符串。&lt;/li&gt;
&lt;li&gt;但经过第1步仍是不够的 - MySQL的系统变量&lt;code&gt;ft_min_word_len&lt;/code&gt;、&lt;code&gt;ft_max_word_len&lt;/code&gt;分别规定了全文检索被编入索引单词的最小长度和最大长度，默认的最小值为4个字符，默认的最大值取决于使用的MySQL版本。为了不改变这个默认值同时也是兼考虑这个值对于英文的意义，则需要通过编码（&lt;code&gt;urlencode&lt;/code&gt;、&lt;code&gt;base64&lt;/code&gt;、&lt;code&gt;汉字转拼音&lt;/code&gt;等）将中文词变长 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 11 Jun 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-06-11:/2016/06/11/mysql-fulltext-application/</guid><category>MySQL</category><category>笔记</category></item><item><title>关于并发的一个小技巧</title><link>http://youngsterxyf.github.io/2016/06/10/a-simple-concurrency-trick/</link><description>&lt;p&gt;前段时间在参与实现一个新业务系统的Demo。该系统集成了多个已有系统的数据，涉及的数据量较大，但由于人力少，时间短，没法专门做一个数据处理子系统，所以只能写了很多数据处理的脚本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/a-simple-concurrency-trick.png"&gt;&lt;/p&gt;
&lt;p&gt;为了复用一些代码，这些数据处理脚本和业务系统一样都是使用PHP实现。在某些数据上报API写入的数据较快较多时，脚本处理不过来（特别在脚本涉及一些网络请求时），只能搞起并发处理 - 在我们的情况下，最简单的并发方式就是多运行几个脚本实例。&lt;/p&gt;
&lt;p&gt;但一切没那么简单：脚本从数据库中取出未经处理的多行数据，逐行处理数据，并将处理后的数据更新到原来的数据行中，运行多个脚本实例时，为了避免更新冲突，只好加事务，但加事务后就会频繁发生事务回滚，数据处理速度还是上不去。&lt;/p&gt;
&lt;p&gt;那么该怎么办呢？&lt;/p&gt;
&lt;p&gt;参考哈希的思路，我对脚本做了一点调整，下面举例说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设对同一脚本运行&lt;code&gt;5&lt;/code&gt;个实例，为每个实例进程分配一个ID，依次为：0、1、2、3、4&lt;/li&gt;
&lt;li&gt;对脚本实例获取数据的SQL，增加选择条件：&lt;code&gt;MOD(id, 5)=SID&lt;/code&gt;（SID为当前脚本实例的ID） - 即使用数据行的&lt;code&gt;id&lt;/code&gt;对实例数取模，如果结果等于实例的ID，则取出来 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 10 Jun 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-06-10:/2016/06/10/a-simple-concurrency-trick/</guid><category>笔记</category><category>SQL</category></item><item><title>关于API访问频率限制的一个问题</title><link>http://youngsterxyf.github.io/2016/06/05/frequency-limitation/</link><description>&lt;p&gt;工作中涉及一些对外开放的无需特殊权限的API，用户会因为某些需求而通过程序来频繁访问这些API，导致系统的负载陡增，可能影响系统其它功能的正常使用。虽然做了一些优化让这种API尽可能地轻量，但仍然不够，因此需要进行访问频率的限制。&lt;/p&gt;
&lt;p&gt;由于这样的API并不多，所以我们并没有在Nginx这样的反向代理接入层中实现频率限制，而是API自己去实现，而且实现方案比较粗糙 - 基于Memcached的缓存自动过期特性。&lt;/p&gt;
&lt;p&gt;方案的PHP示例实现如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;// 每个IP一分钟10次
$limit = 10;

$cache = new Memcached();
$cache-&amp;gt;addServer(&amp;#39;127.0.0.1&amp;#39;, 11211);

$key = __FUNCTION__.$_SERVER[&amp;#39;REMOTE_ADDR&amp;#39;];
$requestNum = $cache-&amp;gt;get($key);

if ($requestNum !== FALSE &amp;amp;&amp;amp; $requestNum &amp;gt; 10) {
    echo json_encode(array(
        &amp;#39;code&amp;#39; =&amp;gt; 403,
        &amp;#39;message&amp;#39; =&amp;gt; &amp;#39;请求太频繁，请一分钟后再试&amp;#39;,
    ));
    return;
}

$cache-&amp;gt;add …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 05 Jun 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-06-05:/2016/06/05/frequency-limitation/</guid><category>Nginx</category><category>笔记</category><category>工作</category></item><item><title>为什么我要送掉纸质书？</title><link>http://youngsterxyf.github.io/2016/02/28/why-preseting-book/</link><description>&lt;p&gt;小时候，不知为何喜欢读书，而又没钱买，所以在家都是翻两个哥哥的课本 - 语文、历史、地理等，都翻个遍。更有甚者，竟然还从邻居家偷偷地拿了本书回来，这应该算是我品行上的污点，这事在此说起，也是第一次。&lt;/p&gt;
&lt;p&gt;因为书少，所以至今还记得爸爸第一次送给我的书 - 《一个变两个》 - 连书里的情节都没忘过。&lt;/p&gt;
&lt;p&gt;读初中时，因为读书，还和好朋友闹过一点不愉快：朋友买了一些好书，我想借来看，他不肯，我就每天比大家早起一些，偷偷从他抽屉里拿来看几页，在他到教室之前再放回去，后来“事发”，。。。当然这一切都已过去，朋友还是朋友。&lt;/p&gt;
&lt;p&gt;高中后，开始有一些零花钱/饭钱，从其中挤出部分钱来买书成了我的一个习惯，书也由此越来越多。&lt;/p&gt;
&lt;p&gt;其实我根本看不了那么多书，最终累积了大量的书没认真读过。有时觉得可惜了，就会为读书而读书，精神为读书所累。&lt;/p&gt;
&lt;p&gt;这些年，几次搬家 - 从本科学校到研究生学校、读研期间换宿舍、毕业工作 - 每次最多最重的都是书，“书生搬家 - 尽是书！”。&lt;/p&gt;
&lt;p&gt;工作后租的房子没那么宽敞，导致到处塞的都是书 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 28 Feb 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-02-28:/2016/02/28/why-preseting-book/</guid><category>笔记</category><category>生活</category><category>感悟</category></item><item><title>如何杀死defunct进程（译）</title><link>http://youngsterxyf.github.io/2016/02/18/kill-defunct/</link><description>&lt;p&gt;原文：&lt;a href="https://kenno.wordpress.com/2007/04/04/how-to-kill-defunct-process/"&gt;How to kill defunct process&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;defunct进程是指出错损坏的进程，父子进程之间不会再通信。有时，它们会演变成“僵尸进程”，存留在你的系统中，直到系统重启。可以尝试 “kill -9” 命令来清除，但多数时候不管用。&lt;/p&gt;
&lt;p&gt;为了杀死这些defunct进程，你有两个选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重启你的计算机&lt;/li&gt;
&lt;li&gt;继续往下读...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先看看系统中是否存在defunct进程：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;$ ps -A | grep defunct
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;假设得到的输出如下所示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;8328 ? 00:00:00 mono &amp;lt;defunct&amp;gt;&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;8522 ? 00:00:01 mono &amp;lt;defunct&amp;gt;&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;13132 ? 00:00:00 mono &amp;lt;defunct&amp;gt;&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;25822 ? 00 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 18 Feb 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-02-18:/2016/02/18/kill-defunct/</guid><category>Linux</category></item><item><title>Base64编码原理与应用</title><link>http://youngsterxyf.github.io/2016/01/24/base64-encoding/</link><description>&lt;p&gt;2015年，我们在青云平台上实现了“百度云观测”应用。青云应用本质上是一个iframe，在向iframe服务方发送的请求中会携带一些数据，青云平台会使用&lt;code&gt;Base64 URL&lt;/code&gt;对这些数据进行编码，其提供的编码解码算法示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;// php版本
function base64_URL_encode($data) {
  return rtrim(strtr(base64_encode($data), &amp;#39;+/&amp;#39;, &amp;#39;-_&amp;#39;), &amp;#39;=&amp;#39;);
}
function base64_URL_decode($data) {
  return base64_decode(str_pad(strtr($data, &amp;#39;-_&amp;#39;, &amp;#39;+/&amp;#39;), 
                            strlen($data) % 4, &amp;#39;=&amp;#39;, STR_PAD_RIGHT));
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出，&lt;code&gt;Base64 URL&lt;/code&gt; 是标准Base64编码的一个变种，分别用 &lt;code&gt;-&lt;/code&gt;、&lt;code&gt;_&lt;/code&gt; 替换标准Base64编码结果中的 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; ，并删除结果最后的 &lt;code&gt;=&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在实现 “百度云观测” 青云应用时，我在想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要使用Base64编码？&lt;/li&gt;
&lt;li&gt;Base64编码算法是什么样的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是围绕这两个问题思考和实践的结果。&lt;/p&gt;
&lt;p&gt;我认为 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 24 Jan 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-01-24:/2016/01/24/base64-encoding/</guid><category>笔记</category><category>编码</category></item><item><title>基于Github的pull request流程做开源贡献</title><link>http://youngsterxyf.github.io/2016/01/18/github-fork-pull-request/</link><description>&lt;p&gt;最近给 &lt;a href="https://github.com/astaxie/beego"&gt;beego&lt;/a&gt; 提了几个 pull request （简称PR），都已被接受。在使用pull request的过程中，遇到了一点小问题，才知以前并非真的理解这个流程，故在此做点记录整理。&lt;/p&gt;
&lt;p&gt;我以 &lt;a href="https://github.com/astaxie/beego"&gt;beego&lt;/a&gt; 为例，将pull request的整体使用流程绘图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fork-pull-request" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/fork-pull-request.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;beego代码库有两个长期分支 &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;develop&lt;/code&gt;，&lt;code&gt;master&lt;/code&gt;为稳定分支，&lt;code&gt;develop&lt;/code&gt;为开发分支，所有PR都要求提交到 &lt;code&gt;develop&lt;/code&gt; 分支。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先将 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 代码库 fork 一份到自己的名下（如我的 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;把 &lt;a href="https://github.com/youngsterxyf/beego"&gt;youngsterxyf/beego&lt;/a&gt; clone 到本地机器上做开发。因为PR要提到 &lt;a href="https://github.com/astaxie/beego"&gt;astaxie/beego&lt;/a&gt; 的 develop 分支，所以最好对应地在你fork的代码库的 develop …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2016-01-18:/2016/01/18/github-fork-pull-request/</guid><category>github</category><category>笔记</category><category>git</category><category>开源</category></item><item><title>关于Redis与Memcached的一点澄清（译）</title><link>http://youngsterxyf.github.io/2015/12/01/redis-vs-memcached/</link><description>&lt;p&gt;原文：&lt;a href="http://antirez.com/news/94"&gt;Clarifications about Redis and Memcached&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;译注：本文为Redis的作者所写&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你了解我，就会知道我并不是那种认为竞品是一件坏事的人。实际上我喜欢用户有选择的空间，因此我很少做将Redis与其他技术做对比这类事情。&lt;/p&gt;
&lt;p&gt;然而，为了选择正确的方案，用户必须获取正确的知识，这一点也是理所应当的。&lt;/p&gt;
&lt;p&gt;本文的起因是读了Mike Perham写的一篇博文，你也许知道他是Sidekiq这一流行程序库的作者，Sidekiq又恰好使用Redis做后端。因此我毫不认为Mike是一个“反对”Redis的人。但在博文（你可以在 &lt;a href="http://www.mikeperham.com/2015/09/24/storing-data-with-redis/"&gt;http://www.mikeperham.com/2015/09/24/storing-data-with-redis/&lt;/a&gt; 找到这篇博文）中，他陈述到：要用缓存，“你可能应该选择Memcached（而不是Redis）”。这样看来，Mike确实简单地相信Redis不适合用做缓存，在文章中他是这样论述的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1) Memcached专为缓存而设计&lt;/li&gt;
&lt;li&gt;2) 它根本不会有磁盘I/O操作&lt;/li&gt;
&lt;li&gt;3 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 01 Dec 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-12-01:/2015/12/01/redis-vs-memcached/</guid><category>翻译</category><category>Redis</category><category>Memcached</category></item><item><title>青云 iframe 应用开发</title><link>http://youngsterxyf.github.io/2015/11/20/qingcloud-iframe-app/</link><description>&lt;p&gt;上周的主要工作是将产品的功能集成到青云。青云提供 iframe 的方式来集成第三方服务，这是一种互利的做法，而且对于青云来说，实现的代价也非常小。&lt;/p&gt;
&lt;p&gt;先上图，看看集成的效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ygc-in-qingcloud" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/ygc-in-qingcloud.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于青云来说，一个iframe应用就是一个URL，由应用开发者提供这个URL，当青云用户访问应用所在的页面时，页面先自动向应用服务器的URL发送数据请求，请求会携带认证信息，应用服务端需要先校验请求确实来自青云，并获取请求中的用户信息，最终响应一个HTML页面内容，青云应用页面收到响应数据后将其置于一个iframe标签中，之后青云用户在iframe页面中的操作都是直接与应用服务器交互。&lt;/p&gt;
&lt;p&gt;&lt;img alt="qingcloud-iframe-interaction" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/qingcloud-iframe-interaction.png"&gt;&lt;/p&gt;
&lt;p&gt;上图交互流程的第&lt;strong&gt;2&lt;/strong&gt;步中，青云服务器向用户响应的内容最终会生成一个包含以下内容的页面：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;form method=&lt;span style="color: #a31515"&gt;&amp;quot;POST&amp;quot;&lt;/span&gt; action=&lt;span style="color: #a31515"&gt;&amp;quot;URL&amp;quot;&lt;/span&gt; target=&lt;span style="color: #a31515"&gt;&amp;quot;appframe&amp;quot;&lt;/span&gt;&amp;gt;
    &amp;lt;input type=&lt;span style="color: #a31515"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt; name=&lt;span style="color: #a31515"&gt;&amp;quot;payload&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&amp;gt;
    &amp;lt;input type=&lt;span style="color: #a31515"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt; name=&lt;span style="color: #a31515"&gt;&amp;quot;signature&amp;quot;&lt;/span&gt; value=&lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;iframe id=&lt;span style="color: #a31515"&gt;&amp;quot;...&amp;quot;&lt;/span&gt; name=&lt;span style="color: #a31515"&gt;&amp;quot;appframe&amp;quot;&lt;/span&gt; width=&lt;span style="color: #a31515"&gt;&amp;quot;100 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 20 Nov 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-11-20:/2015/11/20/qingcloud-iframe-app/</guid><category>笔记</category><category>工作</category><category>总结</category></item><item><title>又一次系统故障</title><link>http://youngsterxyf.github.io/2015/11/16/another-system-fault/</link><description>&lt;p&gt;上周五早上9点多，我还在上班的路上，接到技术leader的电话：线上突然出故障了；接着发来一张故障信息页面截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="system-fault-err-page" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/system-fault-err-page.png"&gt;&lt;/p&gt;
&lt;p&gt;截图包含的信息是：数据库中没找到数据表&lt;code&gt;Users&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但同事检查过数据库，Users数据表是存在的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我快速地回忆了一下最近的代码发布和环境变更 - 前一天有个同事对线上机器做了点改动。因此，让同事赶紧检查一下之前的改动是否有问题，经检查确认改动没有问题，而且稍微思考一下就应该明白不是配置的问题，如果是配置的问题，那么问题应该早就出现了，而不是在早上9点多时候才发生。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我翻了翻手机中最近收到的几条告警短信，去除重复告警短信，只有两条告警：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某台Web服务器上出现大量的500错误&lt;/li&gt;
&lt;li&gt;某台数据库服务器的磁盘使用率为98.99%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可以推测两个故障原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;那台Web服务器上应用的数据库配置有问题 - 但检查之后确认没有问题&lt;/li&gt;
&lt;li&gt;由于那台数据库服务器磁盘满导致的问题，虽然一时还想不到其中的关联 - 同事在检查之后，确认那台机器的磁盘确实已满，但通过内网的数据库管理后台，可以正常访问数据库，所以认为应该不是磁盘满导致的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如此，一时我也没想明白故障的原因。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接着，同事发来消息：只有登录用户才会遇到这个问题！&lt;/p&gt;
&lt;p&gt;这时，基于之前的线索，基本能断定故障原因是 - 数据库服务器磁盘满。为什么呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库管理后台默认是&lt;strong&gt;只读&lt;/strong&gt;：读数据表列表、数据表结构、单个表的若干条数据 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 16 Nov 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-11-16:/2015/11/16/another-system-fault/</guid><category>笔记</category><category>故障</category></item><item><title>记一次系统故障</title><link>http://youngsterxyf.github.io/2015/10/02/note-of-a-system-fault/</link><description>&lt;p&gt;前段时间，工作中遭遇一次故障，虽然不算什么“疑难杂症”，倒也花了不少时间才真正找到故障的原因，故也值得记录一下。&lt;/p&gt;
&lt;p&gt;为方便读者快速理解故障，先给出系统大致的架构图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gxt-tech-arch" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/gxt-tech-arch.png"&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每台Web服务器上开启12个PHP-FPM实例，并配置到Nginx的upstream，每个实例最多可以开启10个子进程&lt;/li&gt;
&lt;li&gt;“Database Proxy”的代理规则为：写操作及事务中的所有SQL操作都交给主MySQL处理，其余的读操作都交给任意一台从MySQL处理&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;故障所表现的现象包括：&lt;/p&gt;
&lt;p&gt;1.大量请求响应为502，但每次故障发生时，错误响应一般集中在一台Web服务器，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx-502-error" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/nginx-502-error.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nginx-502-count" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/nginx-server-502-count.jpg"&gt;&lt;/p&gt;
&lt;p&gt;2.（一台或多台）MySQL数据库服务器CPU使用率飙升（但并非总是一起表现故障），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mysql-slave-server-idle" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/mysql-slave-server-idle.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;故障刚开始出现时，重启/关闭出现故障现象的MySQL服务，或将出现故障的Web服务器上所有PHP-FPM重启，也能解一时的问题，但治不了本，故障还是频繁出现。&lt;/p&gt;
&lt;p&gt;在故障发生时，从相关服务器上收集到的信息如下所示：&lt;/p&gt;
&lt;p&gt;1.出现故障现象的Web服务器 - CPU使用率、内存使用率等系统指标均正常，但PHP-FPM子进程数达到上限（12 x 10 = 120），并且PHP-FPM进程与数据库代理服务器之间的网络连接数量较多（与PHP-FPM子进程数大致相当）&lt;/p&gt;
&lt;p&gt;2.出现故障现象的MySQL服务器 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 02 Oct 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-10-02:/2015/10/02/note-of-a-system-fault/</guid><category>笔记</category><category>故障</category></item><item><title>Xhprof安装与使用</title><link>http://youngsterxyf.github.io/2015/09/15/xhprof-installation-and-usage/</link><description>&lt;p&gt;前两天遇到一个PHP代码的bug，分析的结果是：因为要处理的数据量过大，内存分配超出了限制（&lt;code&gt;php.ini&lt;/code&gt;中配置项&lt;code&gt;memory_limit&lt;/code&gt;，默认是128M）。长期使用Python/PHP做Web开发，对于内存使用关注较少，这个事情让我重新关注起代码的内存占用问题，所以为工作中使用的测试开发环境配置Xhprof，进行性能数据收集分析（注：我们项目是用PHP开发的）。之所以选择Xhprof，是因为比较轻量，对性能影响较小，甚至可以一定方式用于生产环境，安装使用也方便。&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;Xhprof是一个PHP扩展，安装方式与一般PHP扩展一致。&lt;/p&gt;
&lt;p&gt;1.从&lt;a href="https://pecl.php.net/package/xhprof"&gt;这里&lt;/a&gt;下载最新的源码包。假设解压缩后的文件夹为xhprof&lt;/p&gt;
&lt;p&gt;2.编译安装&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;cd xhprof/extension
/path/to/php/bin/phpize
./configure --with-php-config=/path/to/php/bin/php-config
make
make install …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 15 Sep 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-09-15:/2015/09/15/xhprof-installation-and-usage/</guid><category>PHP</category><category>笔记</category><category>Xhprof</category></item><item><title>Yii源码阅读笔记 - 错误/异常处理</title><link>http://youngsterxyf.github.io/2015/09/14/read-yii-code-10/</link><description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;PHP区分“错误”（Error）和“异常”（Exception）。“错误”通常是由PHP内部函数抛出，表示运行时问题，当然也可以通过函数&lt;code&gt;trigger_error&lt;/code&gt;或&lt;code&gt;user_error&lt;/code&gt;抛出一个用户级别的error/warning/notice信息。但在引入面向对象之后，相比使用&lt;code&gt;trigger_error&lt;/code&gt;抛出错误，使用throw抛出异常更常用。&lt;/p&gt;
&lt;p&gt;对于“错误”，PHP允许配置报告哪些级别/类型错误、是否（向用户）展示错误、是否对错误记录日志、错误日志记到哪，分别对应php.ini中的配置项：&lt;code&gt;error_reporting&lt;/code&gt;、&lt;code&gt;display_errors&lt;/code&gt;、&lt;code&gt;log_errors&lt;/code&gt;、&lt;code&gt;error_log&lt;/code&gt;。详细信息见&lt;a href="http://php.net/manual/zh/language.errors.basics.php"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于应用程序内层调用抛出的“异常”，一般可以在外层中使用try...catch来捕获并自定义处理过程。但对于“错误”（PHP运行时抛出或者应用程序使用trigger_error抛出的）或者对于-无法使用try...catch来捕获可能的异常/为了做到即使忘记捕获的异常也能得到自定义处理-的情况，该怎么办 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 14 Sep 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-09-14:/2015/09/14/read-yii-code-10/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>一行式并行方案（译）</title><link>http://youngsterxyf.github.io/2015/09/11/parallelism-in-one-line/</link><description>&lt;p&gt;原文：&lt;a href="http://chriskiehl.com/article/parallelism-in-one-line/"&gt;Parallelism in one line&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在并行处理能力方面，Python的声名并不太好。不考虑关于线程和GIL（多数情况下是合理的）的标准论据，我认为Python中关于并行的真正问题并不是一个技术问题，而是教学问题。围绕Python线程和多进程的常见教程，一般都写得不错，但也令人乏味 - 激烈非凡，对日常真正有用的东西却很少涉及。&lt;/p&gt;
&lt;h4&gt;沿袭的例子&lt;/h4&gt;
&lt;p&gt;在DuckDuckGo（DDG）中搜索“Python多线程教程”，简单调查一下排在前面的结果，就会发现它们给出的都是同样基于Class + Queue的示例。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;介绍threading/multiprocessing、生产者/消费者的真实示例代码：&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008000"&gt;# coding: utf-8&lt;/span&gt;
&lt;span style="color: #008000"&gt;# Example.py&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span style="color: #a31515"&gt;标准的多线程生产者/消费者模式&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; time 
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; threading 
&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; Queue 

&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Consumer&lt;/span&gt;(threading.Thread): 
  &lt;span style="color: #0000ff"&gt;def&lt;/span&gt; __init__(self …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 11 Sep 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-09-11:/2015/09/11/parallelism-in-one-line/</guid><category>PHP</category><category>翻译</category><category>并行</category></item><item><title>那些Python党踩过的PHP坑</title><link>http://youngsterxyf.github.io/2015/09/05/php-trap-and-tip/</link><description>&lt;p&gt;一看题目貌似本文要准备吐槽PHP，但遇到“坑”主要是因为个人经验不足。&lt;/p&gt;
&lt;h4&gt;JSON反序列化 json_decode&lt;/h4&gt;
&lt;p&gt;函数 &lt;code&gt;json_decode&lt;/code&gt; 默认反序列化的结果是对象。Python党在做PHP开发用到这个方法时，很可能会跳进这个坑，认为结果应该是个数组，因为Python中json.loads返回的是一个字典。 &lt;code&gt;json_decode&lt;/code&gt; 的第二个参数 $assoc 可用来指定反序列化的结果为数组。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href="http://php.net/manual/zh/function.json-decode.php"&gt;http://php.net/manual/zh/function.json-decode.php&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;数组序列化&lt;/h4&gt;
&lt;p&gt;Python党初学PHP，可能类比于Python的列表和字典，认为PHP中明确区分索引数组和关联数组。但：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP 实际并不区分索引数组和关联数组，都是一种有序映射。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然很多时候索引数组和关联数组在表现上是不一样的，比如对以下两个数组进行序列化：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$arrA = &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;);
&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; json_encode($arrA) . &lt;span style="color: #a31515"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;

$arrB = &lt;span style="color: #0000ff"&gt;array&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;#39;a …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 05 Sep 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-09-05:/2015/09/05/php-trap-and-tip/</guid><category>PHP</category><category>笔记</category></item><item><title>编程名言集锦（译）</title><link>http://youngsterxyf.github.io/2015/06/02/programming-quotes/</link><description>&lt;p&gt;原文：&lt;a href="http://quotes.cat-v.org/programming/"&gt;Programming Quotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C.A.R. Hoare, The 1980 ACM Turing Award Lecture&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 02 Jun 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-06-02:/2015/06/02/programming-quotes/</guid><category>翻译</category><category>感悟</category></item><item><title>Go并发编程基础（译）</title><link>http://youngsterxyf.github.io/2015/05/20/fundamentals-of-concurrent-programming/</link><description>&lt;p&gt;原文：&lt;a href="http://www.nada.kth.se/~snilsson/concurrency/"&gt;Fundamentals of concurrent programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文是一篇并发编程方面的入门文章，以&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;编写示例代码，内容涵盖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行期并发线程（goroutines）&lt;/li&gt;
&lt;li&gt;基本的同步技术（管道和锁）&lt;/li&gt;
&lt;li&gt;Go语言中基本的并发模式&lt;/li&gt;
&lt;li&gt;死锁和数据竞争&lt;/li&gt;
&lt;li&gt;并行计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在开始阅读本文之前，你应该知道如何编写简单的Go程序。如果你熟悉的是C/C++、Java或Python之类的语言，那么 &lt;a href="http://tour.golang.org/welcome/1"&gt;Go语言之旅&lt;/a&gt; 能提供所有必要的背景知识。也许你还有兴趣读一读 &lt;a href="http://code.google.com/p/go-wiki/wiki/GoForCPPProgrammers"&gt;为C++程序员准备的Go语言教程&lt;/a&gt; 或 &lt;a href="http://www.nada.kth.se/~snilsson/go_for_java_programmers/"&gt;为Java程序员准备的Go语言教程&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;1. 运行期线程&lt;/h4&gt;
&lt;p&gt;Go允许使用&lt;code&gt;go&lt;/code&gt;语句开启一个新的运行期线程，即 &lt;a href="http://golang.org/ref/spec#Go_statements"&gt;goroutine&lt;/a&gt;，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。&lt;/p&gt;
&lt;p&gt;Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 20 May 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-05-20:/2015/05/20/fundamentals-of-concurrent-programming/</guid><category>翻译</category><category>Golang</category></item><item><title>Yii源码阅读笔记 - 自定义类自动加载</title><link>http://youngsterxyf.github.io/2015/04/10/read-yii-code-9/</link><description>&lt;p&gt;前两天突然发现：之前的阅读笔记对于Yii应用中如何自动加载自定义类的问题没有解释。这里的自定义类是指非Yii框架本身的类。&lt;/p&gt;
&lt;p&gt;关于组件类的配置加载已在 &lt;a href="http://blog.xiayf.cn/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt; 一文中做了较为详细的说明，
所以这里不再涉及。&lt;/p&gt;
&lt;p&gt;本文主要解释以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Yii框架是如何找到请求对应的自定义控制器类？&lt;/li&gt;
&lt;li&gt;在自定义控制器类中使用其他类（如Model类、或其他任意目录下文件中定义的类）时，Yii框架是如何自动加载的？&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;在 &lt;a href="http://blog.xiayf.cn/2014/11/20/read-yii-code-7/"&gt;Yii源码阅读笔记 - 应用模块化&lt;/a&gt; 一文中介绍类 &lt;code&gt;CWebApplication&lt;/code&gt; 中的方法 &lt;code&gt;createController&lt;/code&gt; ，
该方法根据目标路由找到对应的控制器类文件并加载，方法中有行代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;$basePath=$owner-&amp;gt;getControllerPath();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的 &lt;code&gt;getControllerPath&lt;/code&gt; 会返回当前应用或模块下的控制器类的存放目录，对应应用级与模块级，其实现有两处，其一是在类 &lt;code&gt;CWebApplication&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;/**
 * @return string the directory that contains the controller classes. Defaults to &amp;#39;protected/controllers&amp;#39;.
 */
public function …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 10 Apr 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-04-10:/2015/04/10/read-yii-code-9/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>Slim源码阅读笔记</title><link>http://youngsterxyf.github.io/2015/03/22/read-slim/</link><description>&lt;p&gt;以前读过 &lt;a href="http://www.phptherightway.com/"&gt;PHP - The Right Way&lt;/a&gt; 一文，
还翻译过其中的 &lt;a href="http://www.phptherightway.com/pages/The-Basics.html"&gt;The Baiscs&lt;/a&gt; 一节
(译文见 &lt;a href="http://blog.xiayf.cn/2013/03/08/php-basics/"&gt;这里&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;前两周读了 &lt;a href="http://www.amazon.cn/Modern-PHP-Lockhart-Josh/dp/1491905018/ref=sr_1_1?ie=UTF8&amp;amp;qid=1427031708&amp;amp;sr=8-1&amp;amp;keywords=Modern+PHP"&gt;Modern PHP - New Features and Good Practices&lt;/a&gt; 一书
（读书笔记见&lt;a href="http://blog.xiayf.cn/2015/03/12/read-modern-php/"&gt;这里&lt;/a&gt;），
甚是不错。&lt;/p&gt;
&lt;p&gt;这篇文档和这本书的作者都是&lt;a href="https://github.com/codeguy"&gt;Josh Lockhart&lt;/a&gt;，
他写了一个Web框架&lt;a href="http://www.slimframework.com/"&gt;Slim&lt;/a&gt;，文档与书籍内容的精华都体现在这个框架中，
所以个人觉得这个框架值得一读。&lt;/p&gt;
&lt;p&gt;Slim的设计与实现都非常精简易懂，其对请求的主处理流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="slim-process" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/slim.png"&gt;&lt;/p&gt;
&lt;p&gt;其中的核心概念包括：IoC容器、中间件、路由匹配等。&lt;/p&gt;
&lt;h4&gt;IoC容器&lt;/h4&gt;
&lt;p&gt;IoC，为Inversion of Control的缩写，中文翻译为“控制反转” - 是一种解决组件间依赖关系、配置和生命周期的设计模式，其最常见的实现方式为：依赖注入（DI）-
当系统 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 22 Mar 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-03-22:/2015/03/22/read-slim/</guid><category>PHP</category><category>slim</category><category>笔记</category><category>总结</category></item><item><title>读书笔记：Modern PHP - New Features and Good Practices</title><link>http://youngsterxyf.github.io/2015/03/12/read-modern-php/</link><description>&lt;p&gt;&lt;img alt="modern-php" src="/assets/uploads/pics/modern-php.png"&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/modern-php.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;推荐阅读！&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 12 Mar 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-03-12:/2015/03/12/read-modern-php/</guid><category>笔记</category><category>PHP</category></item><item><title>Yii源码阅读笔记 - 日志组件</title><link>http://youngsterxyf.github.io/2015/03/09/read-yii-code-8/</link><description>&lt;h3&gt;使用&lt;/h3&gt;
&lt;p&gt;Yii框架为开发者提供两个静态方法进行日志记录：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;Yii::log($message, $level, $category);
Yii::trace($message, $category);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两者的区别在于后者依赖于应用开启调试模式，即定义常量YII_DEBUG：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;defined(&amp;#39;YII_DEBUG&amp;#39;) or define(&amp;#39;YII_DEBUG&amp;#39;, true);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yii::log方法的调用需要指定message的level和category。category是格式为“xxx.yyy.zzz”的路径别名字符串，比如日志是在yii/framework/web/CController类中记录的，那么category为“system.web.CController”。level应为以下几种之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trace：Yii::trace方法即是使用的这个level。用于跟踪执行流&lt;/li&gt;
&lt;li&gt;info：记录通用信息日志&lt;/li&gt;
&lt;li&gt;profile：用于性能分析&lt;/li&gt;
&lt;li&gt;warning：用于记录警告日志&lt;/li&gt;
&lt;li&gt;error：用于记录重大错误日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要想日志真的输出到文件、邮件、web页面等地方 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 09 Mar 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-03-09:/2015/03/09/read-yii-code-8/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>又是一年</title><link>http://youngsterxyf.github.io/2015/01/03/the-2014-is-gone/</link><description>&lt;p&gt;又是一年，依照惯例，得写一篇总结和计划。当然计划更多的只是一种自我鼓励，现实总是一次又一次地证明“计划赶不上变化”。&lt;/p&gt;
&lt;p&gt;我的2014，可能用三个关键词就能概括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结婚&lt;/li&gt;
&lt;li&gt;换工作&lt;/li&gt;
&lt;li&gt;众成技术聚乐部&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;结婚&lt;/h4&gt;
&lt;p&gt;继13年领证，14年把婚礼也办了。由于两家离得远，婚礼也就分两次办。之间还补拍了婚纱照。虽然于我这些流程显得有点折腾，但重要的是大家都是很开心，也不希望老婆以后会有丁点遗憾。&lt;/p&gt;
&lt;p&gt;希望以后的日子总能努力让老婆开心幸福。&lt;/p&gt;
&lt;h4&gt;换工作&lt;/h4&gt;
&lt;p&gt;工作的时间并不长，本没想这么快换工作，何况我还是一个挺念旧的人。但还是那句话“计划赶不上变化”，不得已主动离职跳槽。&lt;/p&gt;
&lt;p&gt;对于目前的工作还比较满意，能做些自己喜欢做的事情，工作氛围也还不错。&lt;/p&gt;
&lt;p&gt;对于自己的要求就是踏踏实实做工作搞技术，不急不躁。&lt;/p&gt;
&lt;h4&gt;&lt;a href="http://happytechgroup.github.io/"&gt;众成技术聚乐部&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;参加过各种大大小小的会议，总觉得水太多，但如果始终自己一个人蒙头研究技术，也有可能落得个“闭门造车”、“目光短浅”的下场，技术的“理”也是越辩越明，所以找了三五同学朋友搞起自己的技术沙龙，
名为“众成技术聚乐部”，之所以为“众成”，是希望 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 03 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2015-01-03:/2015/01/03/the-2014-is-gone/</guid><category>总结</category></item><item><title>Cordova/Phonegap应用构建环境搭建</title><link>http://youngsterxyf.github.io/2014/12/31/setup-cordova-env/</link><description>&lt;p&gt;混合（Hybrid）移动开发将Web开发与原生开发优势互补，之后应该是一个不错的方向。Phonegap是混合移动开发的一个方案，
开发者可以使用标准的Web技术进行开发，然后使用Phonegap打包成原生APP，也可以为Phonegap开发插件来扩展APP功能。
Cordova是Apache的顶级项目，起于Adobe贡献给Apache基金会的Phonegap源码，之后Phonegap官方貌似则专注于提供Phonegap应用的云构建服务。
Phonegap官网提供的文档与Apache Cordova文档是相同的，所以从技术上可以将Phonegap与Cordova视为同一个东西。&lt;/p&gt;
&lt;p&gt;虽然Phonegap官方提供免费的开放（public）应用以及一个私有应用构建服务。但对于应用调试或插件开发来说，
使用云构建服务上传源码下载APP还是挺耗时间的，不太方便，所以搭建本地的应用构建环境是必要的。&lt;/p&gt;
&lt;p&gt;依据Cordova文档的&lt;a href="http://cordova.apache.org/docs/en/4.0.0/guide_cli_index.md.html#The%20Command-Line%20Interface"&gt;The Command-Line Interface&lt;/a&gt;
部分，针对Android应用，在Ubuntu上搭建Cordova应用构建环境的步骤如下所示：&lt;/p&gt;
&lt;h4&gt;1. 安装Node.js和git客户端&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;a href="http://nodejs.org/download/"&gt;NodeJS官网&lt;/a&gt;下载Linux二进制压缩包，解压缩后将bin路径加入PATH环境变量，即可从命令行执行node、npm命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 安装Cordova：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo npm install -g cordova&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. 下载JDK …&lt;/h4&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 31 Dec 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-12-31:/2014/12/31/setup-cordova-env/</guid><category>笔记</category><category>Cordova</category><category>Phonegap</category></item><item><title>读书笔记：演讲之禅-一个技术演讲家的自白</title><link>http://youngsterxyf.github.io/2014/12/15/read-confessions-of-a-public-speaker/</link><description>&lt;p&gt;大大小小的技术会议参加过不少，关于演讲，从一个听众的角度也有一些心得；随着技术积累能力提升，也希望能够在一些正式场合做技术演讲。年轻的技术人应该学会经营自己，show出你自己。&lt;/p&gt;
&lt;p&gt;我并不是一个擅长表达的人，虽然私底下在朋友技术圈内做过一些技术分享，但对于正式场合的技术演讲却没什么经验。&lt;/p&gt;
&lt;p&gt;演讲是个经验活，但总归有一些可事先准备、能够提高成功概率的方法和注意事项吧？所以找来《演讲之禅-一个技术演讲家的自白》一书，看看是否能从别人的经验中学到点什么。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;毋庸置疑，这本书非常实在，值得一读。根据该书内容以及自己的一些想法，按照时间顺序整理出技术演讲相关的注意事项：&lt;/p&gt;
&lt;h4&gt;演讲前&lt;/h4&gt;
&lt;p&gt;一个成功的演讲毫无疑问是需要提前准备的，这里的“准备”不仅仅是准备幻灯片这么简单。&lt;/p&gt;
&lt;p&gt;首先，你需要搞清楚-举办方对会议或者活动的定位，与定位直接相关的即是听众-是哪些人，他们想知道什么，需要听到什么，根据这个定位来选择主题；
与主题相关的是你需要考虑自身是否有能力驾驭这个主题-待分享的技术你是否真的懂？这方面经验是否足够？不要试图分享那些自己还一知半解的技术点，否则就注定是在给自己挖坑！&lt;/p&gt;
&lt;p&gt;从听众情况和自身情况两方面来选择主题，另外还得根据演讲的时间来调整主题的范围大小。从小老师就告诉我们作文题目得小而具体，立意要新。个人认为对于演讲的题目也应如此。&lt;/p&gt;
&lt;p&gt;在确定演讲的具体题目后，个人建议可以先篇文章，在文章中将演讲题目相关的问题细节都搞清楚讲清楚，然后根据文章内容确定要分享内容中哪些方面（通常由于时间限制很难面面俱到，所以要有所选择），
定下演讲的提纲，即明确了演讲的整个大致的思路 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 15 Dec 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-12-15:/2014/12/15/read-confessions-of-a-public-speaker/</guid><category>笔记</category><category>演讲</category></item><item><title>读书笔记：高性能PHP应用开发</title><link>http://youngsterxyf.github.io/2014/12/08/read-high-performance-php-application/</link><description>&lt;p&gt;注：&lt;em&gt;该书的部分内容过时了点 - 比如Opcode缓存：PHP 5.5之后内置一个用于缓存Opcode的组件Opcache，无需额外使用APC组件。所以需要“批判”地阅读。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mindmap-high-performance-php-application" src="/assets/uploads/pics/High-performance-php-app.png"&gt;&lt;/p&gt;
&lt;p&gt;高清无码大图：&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/High-performance-php-app.png"&gt;戳这里&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 08 Dec 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-12-08:/2014/12/08/read-high-performance-php-application/</guid><category>PHP</category><category>笔记</category></item><item><title>Yii源码阅读笔记 - 应用模块化</title><link>http://youngsterxyf.github.io/2014/11/20/read-yii-code-7/</link><description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架有个“模块（Module）”的概念，与“应用（Application）”类似，模块必须归属于一个父模块或者一个应用，模块不能单独部署，一个应用不一定要分模块。&lt;/p&gt;
&lt;p&gt;由此可以看到，Yii的“模块”和“应用”类似于Django框架中的“应用（App）”和“项目（Project）”。&lt;/p&gt;
&lt;p&gt;当一个应用的规模大到一定的程度 - 可能涉及多个团队来开发，就应该考虑分“模块”开发。“模块”通常对应应用的一个相对独立的功能。&lt;/p&gt;
&lt;p&gt;一个模块化的Yii框架应用的工程目录结构大致示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Yii-WebApp-Modules" src="/assets/uploads/pics/yii-webapp-modules.png"&gt;&lt;/p&gt;
&lt;p&gt;上图所示项目有一个名为“forum”的模块，该模块下也有自己的&lt;code&gt;components&lt;/code&gt;、&lt;code&gt;controllers&lt;/code&gt;、&lt;code&gt;models&lt;/code&gt;、&lt;code&gt;views&lt;/code&gt;、&lt;code&gt;extensions&lt;/code&gt;目录，与一个普通的/不分模块的Yii框架Web应用的项目结构非常相似。&lt;/p&gt;
&lt;p&gt;Yii框架模块化应用的所有模块默认都是放在&lt;code&gt;protected/modules&lt;/code&gt;目录下，每个模块的内容又各自放在以模块ID（如&lt;code&gt;forum …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 20 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-20:/2014/11/20/read-yii-code-7/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>Yii源码阅读笔记 - 缓存</title><link>http://youngsterxyf.github.io/2014/11/19/read-yii-code-6/</link><description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;从之前的文章&lt;a href="http://youngsterxyf.github.io/2014/11/12/read-yii-code-2/"&gt;Yii源码阅读笔记 - 路由解析&lt;/a&gt;
及&lt;a href="http://youngsterxyf.github.io/2014/11/14/read-yii-code-4/"&gt;Yii源码阅读笔记 - Model层实现&lt;/a&gt;可以看到Yii框架对于&lt;strong&gt;解析好的路由规则&lt;/strong&gt;及&lt;strong&gt;数据表的schema&lt;/strong&gt;都会根据条件尝试读写缓存
来提高应用性能。&lt;/p&gt;
&lt;p&gt;但缓存组件并非核心组件，需要额外的配置，默认ID为&lt;code&gt;cache&lt;/code&gt;，如果不使用该ID，那么就得注意同时配置好框架中使用缓存的组件。&lt;/p&gt;
&lt;p&gt;恰当地使用缓存组件，能明显地提高应用的性能。&lt;/p&gt;
&lt;p&gt;针对不同的缓存后端（backend），Yii框架提供了多种缓存组件，如文件缓存（CFileCache）、Memcached缓存（CMemCache）、Redis缓存（CRedisCache）等。这些缓存组件（除CDummyCache外，CDummyCache并不是一个有效的缓存组件）均直接继承自抽象类CCache（见文件&lt;code&gt;yii/framework/caching/CCache.php&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面以使用Memcached缓存为例，分析Yii框架缓存组件的实现。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;类&lt;code&gt;CMemcache&lt;/code&gt;所在的整个继承树（&lt;code&gt;CMemcache&lt;/code&gt; -&amp;gt; &lt;code&gt;CCache&lt;/code&gt; -&amp;gt; &lt;code&gt;CApplicationComponent …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 19 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-19:/2014/11/19/read-yii-code-6/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>Yii源码阅读笔记 - 模板引擎集成</title><link>http://youngsterxyf.github.io/2014/11/18/read-yii-code-5/</link><description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;通常我们会使用模板引擎来渲染HTML页面，而不是使用HTML代码中插入PHP代码的方式来编写动态页面。Yii框架中模板引擎也是作为组件引入的，默认ID为viewRenderer，
但从&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;可以看到Yii Web应用加载的核心组件中并没有viewRenderer，所以需要自己配置。
Yii提供了一个直接可用的模板引擎组件类CPradoViewRenderer（见文件&lt;code&gt;yii/framework/web/renderers/CPradoViewRenderer.php&lt;/code&gt;），该模板引擎类让开发者可以使用类Prado框架的模板语法。&lt;/p&gt;
&lt;p&gt;如果你想使用Smarty这种第三方模板引擎，有两种方式将模板引擎引入Yii中使用（以Smarty为例）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将Smarty封装成一个Yii的普通组件，然后配置加载到Yii::app()。假设组件ID为smarty，那么就可以通过&lt;code&gt;Yii::app()-&amp;gt;smarty&lt;/code&gt;来调用组件。&lt;/li&gt;
&lt;li&gt;参考CPradoViewRenderer类的实现，将Smarty封装成一个模板引擎组件，并以ID为viewRenderer进行配置加载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相比而言，第二种方式更好。原因是：第一种方式由于每种第三方模板引擎的接口不一样，如果应用要替换模板引擎，就需要修改控制器类中的代码。而第二种方式由于第三方组件统一封装成Yii框架定义的模板引擎接口形式，
所以如果要替换模板引擎，只需修改自定义模板引擎组件类的接口实现就可以了。这样调用模板引擎的代码逻辑就只依赖接口形式，而不是依赖于接口实现，从而实现解耦。&lt;/p&gt;
&lt;p&gt;本文主要分析第二种方式的实现。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;Yii中对页面模板进行渲染可以调用 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 18 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-18:/2014/11/18/read-yii-code-5/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>Yii源码阅读笔记 - Model层实现</title><link>http://youngsterxyf.github.io/2014/11/14/read-yii-code-4/</link><description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii中，对Model层的使用，有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过类CDbConnection和CDbCommand来操作&lt;/li&gt;
&lt;li&gt;使用ORM形式：编写model类继承自抽象类CActiveRecord&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第1种方式的示例如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$connection = Yii::app()-&amp;gt;db;  &lt;span style="color: #008000"&gt;// 或者Yii::app()-&amp;gt;getComponent(&amp;#39;db&amp;#39;);&lt;/span&gt;
$queryResult = $connection-&amp;gt;createCommand($sql)-&amp;gt;queryRow();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第2种方式中编写的model类可能需要实现方法&lt;code&gt;getDbConnection&lt;/code&gt;、&lt;code&gt;model&lt;/code&gt;、&lt;code&gt;tableName&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在实现上，第2种方式是基于第1种方式的，即第2种方式的抽象程度更高。Yii没有屏蔽第1种方式，这样能让开发者按需选择。
但我个人并不喜欢这样，两种方式同时存在，会导致应用的model实现稍显混乱。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;Yii框架model层的入口为CDbConnection类，该类有很多public的属性可供配置，如&lt;code&gt;connectionString&lt;/code&gt;、&lt;code&gt;username&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;根据&lt;a href="http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/"&gt;Yii源码阅读笔记 - 组件集成&lt;/a&gt;一文可知，组件初始化时会调用init方法。
类CDbConnection的init类实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;public function …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 14 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-14:/2014/11/14/read-yii-code-4/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>Yii源码阅读笔记 - 组件集成</title><link>http://youngsterxyf.github.io/2014/11/13/read-yii-code-3/</link><description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架将各种功能封装成组件，使用时按需配置加载，从而提高应用的性能。内置的组件又分为核心组件与非核心组件，核心组件是任何Web应用和Console应用都需要的。
此外，应用开发者还可以按照一定规则封装配置使用自己的功能组件。Yii会把应用需要的组件都加载到应用容器&lt;code&gt;Yii::app()&lt;/code&gt;中，使得组件的使用方式一致方便。&lt;/p&gt;
&lt;p&gt;基于Yii框架开发应用需要理解如何配置组件、如何开发自己的组件，对应着需要理解Yii是如何注册加载组件的。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;从&lt;a href="http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/"&gt;Yii源码阅读笔记 - 请求处理基本流程&lt;/a&gt;一文可知，Yii加载组件的入口为抽象类CApplication构造方法中的以下两行代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;$this-&amp;gt;registerCoreComponents();
$this-&amp;gt;configure($config);
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;&lt;code&gt;registerCoreComponents&lt;/code&gt;方法定义于类CWebApplication中，用于加载Web应用的核心组件，组件列表如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;array(
    // 核心组件
    &amp;#39;coreMessages&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CPhpMessageSource&amp;#39;,
        &amp;#39;language&amp;#39;=&amp;gt;&amp;#39;en_us&amp;#39;,
        &amp;#39;basePath&amp;#39;=&amp;gt;YII_PATH.DIRECTORY_SEPARATOR.&amp;#39;messages&amp;#39;,
    ),
    &amp;#39;db&amp;#39;=&amp;gt;array(
        &amp;#39;class&amp;#39;=&amp;gt;&amp;#39;CDbConnection&amp;#39;,
    ),
    &amp;#39;messages&amp;#39;=&amp;gt;array(
        &amp;#39;class …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 13 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-13:/2014/11/13/read-yii-code-3/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>Yii源码阅读笔记 - 路由解析</title><link>http://youngsterxyf.github.io/2014/11/12/read-yii-code-2/</link><description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;Yii框架的路由解析功能由核心组件urlManager来完成。路由的形式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get：通过URL中查询字符串（query string）参数r来指定路由，如：&lt;code&gt;r=controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;path：直接通过URL来指定，如：&lt;code&gt;/controllerID/actionID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认使用get路由形式。由于Yii中controller类命名和action方法都是按照规则命名的，而路由也是按照规则来匹配的，所以完全可以不用额外配置urlManager。&lt;/p&gt;
&lt;p&gt;若需要使用path方式，则可如下配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;components&amp;quot; =&amp;gt; array(
    &amp;#39;urlManager&amp;#39; =&amp;gt; array(
        &amp;#39;urlFormat&amp;#39; =&amp;gt; &amp;#39;path&amp;#39;,
        &amp;#39;rules&amp;#39; =&amp;gt; array(
            ...
        ),
),
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进一步说明可参考&lt;a href="http://youngsterxyf.github.io/2014/09/06/experience-about-restful-api/"&gt;RESTful API设计的一点经验&lt;/a&gt;一文。&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;在“请求处理基本流程”一篇可以看到Yii框架路由解析流程的入口在类CWebApplication的processRequest方法中：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;$route=$this-&amp;gt;getUrlManager()-&amp;gt;parseUrl($this-&amp;gt;getRequest());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中getUrlManager方法定义于类CApplication中，作用是初始化获取URL管理组件（ID为urlManager），实现如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;public …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 12 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-12:/2014/11/12/read-yii-code-2/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>读文笔记：An Introduction to APIs</title><link>http://youngsterxyf.github.io/2014/11/09/an-introduction-to-apis/</link><description>&lt;p&gt;原文：&lt;a href="https://zapier.com/learn/apis/"&gt;An Introduction to APIs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：该文是入门级别的文章&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mind-mapping" src="/assets/uploads/pics/An-Introduction-to-APIs.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/An-Introduction-to-APIs.png"&gt;高清无码大图&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-09:/2014/11/09/an-introduction-to-apis/</guid><category>笔记</category><category>API</category><category>REST</category></item><item><title>Yii源码阅读笔记 - 请求处理基本流程</title><link>http://youngsterxyf.github.io/2014/11/04/read-yii-code-1/</link><description>&lt;p&gt;对于Web框架，我认为其主要有三点作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供多人协作的基本规范&lt;/li&gt;
&lt;li&gt;避免重复造轮子&lt;/li&gt;
&lt;li&gt;开发者只需关注业务逻辑，脏活（如：基本的安全防范、兼容问题）Web框架都已完成并提供设计良好的API&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但代价是学习成本 - 为了尽可能发挥Web框架的优势，需要花一些阅读文档，甚至是框架源码（特别是文档缺乏或者文档写得垃圾的），然后经过几次项目实践，一切才能了然于胸。&lt;/p&gt;
&lt;p&gt;喏，为了在工作中更好地使用、避免误用Yii框架，大致阅读了Yii框架的部分代码，然后有了这个系列的笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;深入学习一个Web框架，首先要理解的是请求处理流程。对于PHP而言，处理流程也即包含了应用的初始化过程，如加载配置、初始化组件等。请求处理流程中最核心的应该是路由解析和分发，此外可能还有过滤器处理、事件处理等，直到请求处理进入具体的Controller和Action。响应生成、过滤等也可以关注。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;基于Yii框架的工程目录结构大致如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Yii-Project-Structure" src="/assets/uploads/pics/yii-project-structure.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;index.php是应用的入口&lt;/li&gt;
&lt;li&gt;protected目录是存放动态脚本的地方&lt;ul&gt;
&lt;li&gt;components子目录存放各种组件类&lt;/li&gt;
&lt;li&gt;configs存放应用的配置文件&lt;/li&gt;
&lt;li&gt;controllers存放Controller类文件&lt;/li&gt;
&lt;li&gt;models存放Model类文件&lt;/li&gt;
&lt;li&gt;runtime存放一些应用生成的临时文件或者缓存文件，如Smarty编译好的模板、日志文件&lt;/li&gt;
&lt;li&gt;views存放View模板文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;static目录存放静态文件，如CSS、JS、图片等 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 04 Nov 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-11-04:/2014/11/04/read-yii-code-1/</guid><category>PHP</category><category>Yii</category><category>笔记</category><category>总结</category></item><item><title>QCon上海2014大会见闻录</title><link>http://youngsterxyf.github.io/2014/10/21/qcon-sh-2014-seen-heard/</link><description>&lt;h2&gt;技术&lt;/h2&gt;
&lt;h4&gt;主题演讲&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;软件项目变更的管理和生存之道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人对这个演讲的印象比较深。演讲者即是最近比较火的《Java程序员修炼之道》一书的作者。&lt;/p&gt;
&lt;p&gt;演讲大致以“提出问题 -&amp;gt; 分析问题 -&amp;gt; 解决问题”的思路陈述。&lt;/p&gt;
&lt;p&gt;问题是：在软件演化的整个过程中，变化是始终存在的。如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础架构层面的变化：迁移到新的服务提供商、系统升级&lt;/li&gt;
&lt;li&gt;用户数的变化：突然的增长、持续稳定地增长&lt;/li&gt;
&lt;li&gt;代码的变更：发布新版本、依赖库升级、新的子系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些变化可能会导致两个问题的发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务中断：完全无法为用户提供服务，特别是生产环境变更导致的，发布后的服务中断&lt;/li&gt;
&lt;li&gt;性能问题：性能退化/降级，但可能也不是完全不可用，在预览版(pre-release)和正式发布后(post-release)都可能发生，经常是因为不完全的性能测试造成的。(性能测试是指&lt;strong&gt;基于测量的方法&lt;/strong&gt;来理解一定负载下应用的行为)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“变化”导致的问题，说到底是人为造成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No matter what …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 21 Oct 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-10-21:/2014/10/21/qcon-sh-2014-seen-heard/</guid><category>笔记</category><category>总结</category></item><item><title>中心化日志记录架构（译）</title><link>http://youngsterxyf.github.io/2014/10/14/centralized-logging-architecture/</link><description>&lt;p&gt;原文：&lt;a href="http://jasonwilder.com/blog/2013/07/16/centralized-logging-architecture/"&gt;Centralized Logging Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://jasonwilder.com/blog/2012/01/03/centralized-logging/"&gt;中心化日志记录&lt;/a&gt;一文中，我介绍了几个工具，用于解决中心化日志记录的问题。但这些工具一般仅能解决这个问题的一部分，
这意味着需要综合使用几个工具来构建一个健壮的解决方案。&lt;/p&gt;
&lt;p&gt;你需要解决问题的这几个主要方面：&lt;em&gt;收集&lt;/em&gt;、&lt;em&gt;传输&lt;/em&gt;、&lt;em&gt;存储&lt;/em&gt;、以及&lt;em&gt;分析&lt;/em&gt;。某些特殊的应用场景下，也许还希望具备&lt;em&gt;告警&lt;/em&gt;的能力。&lt;/p&gt;
&lt;h4&gt;收集&lt;/h4&gt;
&lt;p&gt;应用程序以不同的方式产生日志，一些是通过syslog，其他一些是直接写到文件。考虑一个运行在linux主机上的典型web应用，在&lt;code&gt;/var/log&lt;/code&gt;目录会有十几个甚至更多的日志文件，
如果一些应用指定日志存放在HOME目录或者其他位置，则这些目录下也是如此。&lt;/p&gt;
&lt;p&gt;如果你正在运营一个基于web的应用，开发人员或者运维同事需要快速地访问日志数据以便对线上问题进行排错，那么就需要一个能够近乎实时监控日志文件变化的方案。
如果使用基于日志拷贝的方式 --- 文件以固定的时间间隔拷贝到一台中心服务器上，那么仅能检查与复制操作频率相同的新增日志数据。当站点已经挂掉，而你正在等待相关日志数据的复制，
那么一分钟一次的 rsync cron 任务也许还不够快。&lt;/p&gt;
&lt;p&gt;从另外一个角度来看，如果需要分析线下日志数据，计算各种度量指标，或者其他批量的工作 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 14 Oct 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-10-14:/2014/10/14/centralized-logging-architecture/</guid><category>翻译</category><category>日志</category><category>架构</category></item><item><title>流行PHP项目的phpmetrics分析（译）</title><link>http://youngsterxyf.github.io/2014/09/22/phpmetrics-of-popular-php-projects/</link><description>&lt;p&gt;原文：&lt;a href="https://peteraba.com/blog/phpmetrics-of-popular-projects/"&gt;phpmetrics of popular php projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前我偶然发现一个名为&lt;a href="http://www.phpmetrics.org/"&gt;phpmetrics&lt;/a&gt;的新工具，可用于计算及展示php的度量指标。我当时立马喜欢上了这个工具，并决定用它分析我认为重要的一些php项目。
我知道这个项目列表还远远不够完善，但应该仍然值得一看。我特别喜欢其中的“可维护性”报告，我发现视觉上那些红色的斑点就和丑陋的代码一样令人厌恶。&lt;/p&gt;
&lt;p&gt;这个工具貌似还有点小bug，我会尽力尽快修复这个工具项目的这些小问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些重要的说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前我还无法得到Cakephp和Typo3的分析报告，之后我会尽快调查一下这个问题。&lt;/li&gt;
&lt;li&gt;我是在完整的代码库或下载的源码包上执行这个工具的，这意味着某些情况下还分析了项目的外部依赖库。之后我可能会调整，但目前不在计划之内。&lt;/li&gt;
&lt;li&gt;有些项目包含很多代码库，所以我无法确保测试的都是正确的那个代码库。&lt;em&gt;Joomla&lt;/em&gt;尤其可能这样。&lt;/li&gt;
&lt;li&gt;某些项目并非非常知名，但在github上呈现关注度上升趋势。&lt;/li&gt;
&lt;li&gt;dm-mailer这个项目无足轻重，只是我最新的个人兴趣项目。我将它与phpmetrics一起归到Backfire一节。&lt;/li&gt;
&lt;li&gt;注意：php-yaf和phalcon都是非常有意思的php框架，但多数代码是C实现的，因此没有包含进来。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;说明：阅读该报告的一点小提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多的斑点只是意味着更多的类&lt;/li&gt;
&lt;li&gt;红色意味着不可维护，黄色表示可接受，绿色则表明良好、可维护的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;分析结果 …&lt;/h3&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 22 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-09-22:/2014/09/22/phpmetrics-of-popular-php-projects/</guid><category>翻译</category><category>PHP</category></item><item><title>RESTful API设计的一点经验</title><link>http://youngsterxyf.github.io/2014/09/06/experience-about-restful-api/</link><description>&lt;p&gt;前段时间的工作涉及产品开放API的设计与实现，整个过程大致可分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据需求、原有数据库设计等，花了半天左右的工夫完成初稿；&lt;/li&gt;
&lt;li&gt;就初稿与相关同事进行讨论，确定一些细节问题，逐步完善；&lt;/li&gt;
&lt;li&gt;根据设计稿，基于Yii框架，配置路由，实现用户身份认证模块；&lt;/li&gt;
&lt;li&gt;基于步骤3，逐个实现业务相关API；&lt;/li&gt;
&lt;li&gt;对部分代码进行重构，减少不必要的代码重复。主要使用Yii控制器的beforeAction方法来实现多层过滤器。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;设计&lt;/h3&gt;
&lt;p&gt;考虑到RESTful API简洁明了的接口表现形式，一开始我们就一致确定使用RESTful风格的API。参考以前自己使用多个开放平台API的经验，
及&lt;a href="https://developer.github.com/v3/"&gt;Github的开放API文档&lt;/a&gt;，大致完成设计初稿。&lt;/p&gt;
&lt;h5&gt;资源&lt;/h5&gt;
&lt;p&gt;RESTful API主要有两个核心：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP协议的4个谓词 - GET、POST、PUT、DELETE，分别对应“查询”、“新增”、“更新”、“删除”4种操作&lt;/li&gt;
&lt;li&gt;资源（resource）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RESTful风格API的设计，最难之处，我认为就是“资源”。&lt;/p&gt;
&lt;p&gt;“资源”是什么？“资源”并不是对应数据库中一个一个数据表，“资源 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 06 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-09-06:/2014/09/06/experience-about-restful-api/</guid><category>笔记</category><category>RESTful</category></item><item><title>基于socket.io的实时消息推送</title><link>http://youngsterxyf.github.io/2014/09/06/socket.io-push-server/</link><description>&lt;p&gt;用户访问Web站点的过程是基于HTTP协议的，而HTTP协议的工作模式是：请求-响应，客户端发出访问请求，服务器端以资源数据响应请求。
也就是说，服务器端始终是被动的，即使服务器端的资源数据发生变化，如果没有来自客户端的请求，用户就不会看到这些变化。
这种模式是不适合某些应用场景的，比如在社交网络用户需要近乎实时地知道其他用户最新的信息。对于普通站点来说，
请求-响应模式可以满足绝大多数的功能需求，但总有某些功能我们希望能够为用户提供实时消息的体验。&lt;/p&gt;
&lt;p&gt;为解决这个问题，有两种方案可以选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仍旧使用请求-响应模式，只是增大请求的频率或者使用长连接，来达到尽可能接近实时的效果，如使用polling/long-polling，但可能会极大地增加服务器的负载压力或降低服务器的吞吐量&lt;/li&gt;
&lt;li&gt;使用新的协议，在服务器端有资源数据更新时，主动推送给客户端，如WebSocket，虽然这种思路也是使用了长连接，但效率更高，且是客户端服务器端之间的全双工通信。
问题在于目前各大浏览器并不都支持WebSocket。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么目前最好的方式就是结合以上两种方案，在不同的浏览器中，尽可能使用浏览器支持的最好的方案，即浏览器支持第二种方案时，优先使用第二种方案，否则使用第一种方案。socket.io就是这么做的，并且在服务器端和客户端对于不同的方案提供统一的接口。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在我们产品的站内信功能中，希望能够给在线用户实时推送公共消息或私有消息。考虑到以后可能还有其他功能需要实现实时消息推送，所以将实时消息推送实现为一个单独的服务。这种针对不同特性的功能进行解耦也为之后针对性的优化做了铺垫。&lt;/p&gt;
&lt;p&gt;解耦之后的系统结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="socket.io-push-server" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/socket.io-push-server.png"&gt;&lt;/p&gt;
&lt;p&gt;当站点服务器(A)监测到资源数据更新事件发生时，先将数据推送到消息推送服务器 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 06 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-09-06:/2014/09/06/socket.io-push-server/</guid><category>socket.io</category><category>消息推送</category><category>笔记</category></item><item><title>面向分布式系统工程师的分布式系统理论（译）</title><link>http://youngsterxyf.github.io/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/</link><description>&lt;p&gt;原文：&lt;a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/"&gt;Distributed systems theory for the distributed systems engineer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gwen Shapira，大腕级的解决方案架构师（SA），如今Cloudera的全职工程师，在&lt;a href="https://twitter.com/gwenshap/status/497203248332165121"&gt;Twitter上提的一个问题&lt;/a&gt;引起了我的思考。&lt;/p&gt;
&lt;p&gt;如果是以前，我可能会回答“嗯，这里有篇FLP论文，这里有篇Paxos论文，这里还有篇拜占庭将军问题的论文...”，我会罗列一箩筐重要的材料，如果你一头扎进去，至少花费6个月的时间才能过一遍这些材料。然而我已逐渐明白推荐大量的理论性的论文通常恰恰是着手学习分布式系统理论的错误方式（除非你在做一个PhD项目）。论文通常比较深入难懂，需要认真地研习，通常还需要&lt;em&gt;大量的时间投入(significant experience)&lt;/em&gt;来理清这些论文的重要贡献，以及在整个理论体系中的位置。要求工程师具备这样的专业水平又有多大的意义呢？&lt;/p&gt;
&lt;p&gt;但是，很遗憾，对分布式系统理论方面的重大研究成果和思想进行概括、归纳、背景分析的‘导引’性质的优秀材料非常缺乏；特别是没有居高临下态度的材料。对这块空白区域的思考让我想到了另一个有趣的问题：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一个分布式系统工程师应该知道些什么分布式系统理论？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 10 Aug 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-08-10:/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/</guid><category>分布式系统</category><category>翻译</category></item><item><title>技术问题一问一答</title><link>http://youngsterxyf.github.io/2014/06/26/recently-technology-tips/</link><description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何方便地删除某目录下所有空文件？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;find . -size 0 -exec rm {} \;&lt;/code&gt; 或 &lt;code&gt;find . -size 0 | xargs rm -f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;find默认会递归遍历所有子目录，如果想只在当前目录查找，可以添加参数&lt;code&gt;-prune&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何查看某进程打开了哪些文件？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先通过&lt;code&gt;ps aux | grep [进程名]&lt;/code&gt;找到该进程的进程号，然后&lt;code&gt;ls -la /proc/[进程号]/fd&lt;/code&gt;，输出不仅包含打开的普通文件。&lt;/p&gt;
&lt;p&gt;另一种不太直观的方法是使用lsof，&lt;code&gt;lsof -c [进程名]&lt;/code&gt;，但这个命令的输出包含进程打开的各种类型的文件，可以简单过滤一下&lt;code&gt;lsof -c [进程名] | grep REG&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何重启php-fpm？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;php5.3.3以上版本的php-fpm不再支持php-fpm以前具有的&lt;code&gt;php-fpm (start|stop|reload …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 26 Jun 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-06-26:/2014/06/26/recently-technology-tips/</guid><category>笔记</category></item><item><title>微信服务号开发笔记</title><link>http://youngsterxyf.github.io/2014/06/14/wechat-service-account-development/</link><description>&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;微信服务号的原理比较简单。从请求响应角度来看，逻辑是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户微信客户端 &amp;lt;---&amp;gt; 微信服务器 &amp;lt;---&amp;gt; 微信服务号后台程序 &amp;lt;---&amp;gt; 数据库或Web Service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是，用户的各种请求先经过微信的服务器，微信服务器将请求转发给微信服务号后台程序。&lt;/p&gt;
&lt;p&gt;既然是微信服务器把用户请求数据转发给我们开发的微信服务号后台程序，那么在启用服务号的开发模式时就需要提供一个URL。另外为了安全
考虑，还需要提供一个token，用来校验请求是否来自微信服务器。校验的方法见&lt;a href="http://mp.weixin.qq.com/wiki/index.php?title=%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF%E7%9C%9F%E5%AE%9E%E6%80%A7"&gt;微信开发者文档&lt;/a&gt;。校验又分两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在开发者首次提交验证申请时，微信服务器将发送GET请求到填写的URL上，并且带上四个参数（signature、timestamp、nonce、echostr），开发者通过对签名（即signature）的效验，来判断此条消息的真实性。&lt;/p&gt;
&lt;p&gt;此后，每次开发者接收用户消息的时候，微信也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微信服务器转发到微信服务号后台程序的消息以及服务号后台程序返回给微信服务器的响应，都是XML格式，消息中都会指明发送者和接收者。
请求消息中的发送者为微信用户的openid，接收者为服务号开发者微信号，响应消息则相反。&lt;/p&gt;
&lt;p&gt;消息中还有一个关键字段MsgType指明消息类型。微信将请求消息分为：普通消息 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 14 Jun 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-06-14:/2014/06/14/wechat-service-account-development/</guid><category>微信</category><category>PHP</category><category>笔记</category></item><item><title>高流量站点NGINX与PHP-fpm配置优化（译）</title><link>http://youngsterxyf.github.io/2014/05/03/optimizing-nginx-and-php-fpm-for-high-traffic-sites/</link><description>&lt;p&gt;原文：&lt;a href="http://www.softwareprojects.com/resources/programming/t-optimizing-nginx-and-php-fpm-for-high-traffic-sites-2081.html"&gt;Optimizing NGINX and PHP-fpm for high traffic sites&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Nginx搭配PHP已有7年的这份经历让我们学会如何为高流量站点优化NGINX和PHP-fpm配置。&lt;/p&gt;
&lt;p&gt;以下正是这方面的一些提示和建议：&lt;/p&gt;
&lt;h4&gt;1. 将TCP切换为UNIX域套接字&lt;/h4&gt;
&lt;p&gt;UNIX域套接字相比TCP套接字在loopback接口上能提供更好的性能（更少的数据拷贝和上下文切换）。&lt;/p&gt;
&lt;p&gt;但有一点需要牢记：仅运行在同一台服务器上的程序可以访问UNIX域套接字（显然没有网络支持）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;upstream backend
{
    # UNIX domain sockets
    server unix:/var/run/fastcgi.sock;

    # TCP sockets
    # server 127.0.0.1:8080;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2. 调整工作进程数&lt;/h4&gt;
&lt;p&gt;现代计算机硬件是多处理器的，NGINX可以利用多物理或虚拟处理器。&lt;/p&gt;
&lt;p&gt;多数情况下，你的Web服务器都不会配置为处理多种任务（比如作为Web服务器提供服务的同时也是一个打印服务器），你可以配置NGINX使用所有可用的处理器，NGINX工作进程并不是多线程的。&lt;/p&gt;
&lt;p&gt;运行以下命令可以获知你的机器有多少个处理器：&lt;/p&gt;
&lt;p&gt;Linux上 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 03 May 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-05-03:/2014/05/03/optimizing-nginx-and-php-fpm-for-high-traffic-sites/</guid><category>Nginx</category><category>PHP</category><category>服务器</category></item><item><title>Firefox中“max-width:100%”不兼容问题</title><link>http://youngsterxyf.github.io/2014/04/28/max-width-in-firefox/</link><description>&lt;p&gt;这个博客是基于“&lt;a href="http://docs.getpelican.com/en/3.3.0/"&gt;Pelican&lt;/a&gt; + &lt;a href="http://wowubuntu.com/markdown/"&gt;Markdown&lt;/a&gt; +
&lt;a href="https://github.com/youngsterxyf/my-pelican-themes/tree/master/my-gum"&gt;定制的my-gum主题&lt;/a&gt;”的。定制的主题将博文正文页面的
右边栏去掉，这导致在Firefox等浏览器中，正文中大的图片会突破正文块的宽度，高度也得不到限制，显示效果非常差。&lt;/p&gt;
&lt;p&gt;其原因是：Markdown的&lt;a href="http://wowubuntu.com/markdown/#img"&gt;图片区块元素&lt;/a&gt;&lt;code&gt;![Alt
text](/path/to/img.jpg)&lt;/code&gt;渲染成HTML元素的结果为 -&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;p&amp;gt;
    &amp;lt;img src=&lt;span style="color: #a31515"&gt;&amp;quot;/path/to/img.jpg&amp;quot;&lt;/span&gt; alt=&lt;span style="color: #a31515"&gt;&amp;quot;Alt text&amp;quot;&lt;/span&gt;&amp;gt;&amp;lt;/img&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素内的元素是行内(inline)元素。主题my-gum使用的CSS框架&lt;a href="http://gumbyframework.com/"&gt;gumby&lt;/a&gt;对img元素是使用&lt;code&gt;max-width:
100%&lt;/code&gt;将图片的最大宽度限制为父元素的宽度。但&lt;a href="https://developer.mozilla.org/en-US/docs/Web/CSS/max-width"&gt;在Firefox中max-width对于行内元素并不会生效(all elements but non-replaced 
inline …&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 28 Apr 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-04-28:/2014/04/28/max-width-in-firefox/</guid><category>CSS</category><category>浏览器兼容</category><category>JavaScript</category></item><item><title>Windows命令提示符中统计行数（译）</title><link>http://youngsterxyf.github.io/2014/03/05/counting-lines-in-cmd/</link><description>&lt;p&gt;原文：&lt;a href="http://rickardnobel.se/counting-lines-in-windows-command-prompt/"&gt;Counting lines in Windows command prompt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用内置工具FIND统计cmd.exe输出的行数非常方便！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在命令行环境中工作时，能够统计不同工具的输出结果的行数有时会非常有用。许多Unix/Linux操作系统都包含带有许多功能选项的&lt;strong&gt;wc&lt;/strong&gt;
工具，Windows则没有内置一样的替代品，但是Windows命令提示符(cmd.exe)原生支持了部分相同功能。&lt;/p&gt;
&lt;p&gt;本文将讲述在cmd.exe中我们可以如何使用&lt;strong&gt;FIND&lt;/strong&gt;工具来统计行数。工具find，有些类似于Unix上的grep，自MS-DOS以来就一直存在，
使用简单。&lt;/p&gt;
&lt;p&gt;假设我们有一台Windows服务器，想看看当前有多少个活跃的TCP会话。这可以使用netstat命令，并且通过管道连接FIND来查找已建立的会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;netstat -ano | find /i "estab"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="established-TCP-2.png" src="https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/established-TCP-2.png"&gt;&lt;/p&gt;
&lt;p&gt;这行命令的输出可能会有几百行以至于占满整个命令提示符窗口，而我们可能仅仅关心会话的数目。通过在这行命令之后增加一个&lt;strong&gt;/c&lt;/strong&gt;开关选项，
我们就能得到打开的TCP会话的数目。&lt;/p&gt;
&lt;p&gt;我们仍然使用上一个命令的过滤规则（通过查找字符串“estab”来找到包含ESTABLISHED状态的行）但带有 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 05 Mar 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-03-05:/2014/03/05/counting-lines-in-cmd/</guid><category>Windows</category><category>翻译</category></item><item><title>读书笔记：Web容量规划的艺术</title><link>http://youngsterxyf.github.io/2014/02/25/read-the-art-of-capacity-planning/</link><description>&lt;h3&gt;第1章 容量规划的目标、问题和过程&lt;/h3&gt;
&lt;p&gt;了解你的基础设施中每一部分何时会失败（最好不发生）对容量规划至关重要。&lt;/p&gt;
&lt;p&gt;假设你有一台数据库服务器用于响应从前端Web服务器提交过来的查询。容量规划意味着你应该知道下述问题的答案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑到特定的硬件配置，数据库服务器每秒可管理多少个查询？&lt;/li&gt;
&lt;li&gt;在性能降低到影响终端用户体验之前，它每秒可应答多少次查询？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;性能与容量：两种不同的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能调优是优化已经存在的性能。容量规划通过使用当前性能做为基线决定你的系统需要什么以及什么时候需要。&lt;/p&gt;
&lt;p&gt;当面对容量问题的时候，试着少花精力使已存在的设备运行更快，而是关注当下要解决的重点：找出你到底需要什么，什么时候需要。&lt;/p&gt;
&lt;p&gt;权衡对已有系统进行调优所花的人力时间，可能简简单单的买更多的硬件是正确的。在最优化和容量扩展方面的权衡是一个挑战，并且因环境而异。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网站的架构和架构对容量方面的影响&lt;/p&gt;
&lt;p&gt;你的驾车风格会影响到你的车的里程，类似的原理能够应用于网站的架构上。在本书中一个反复出现的主题是你的网站架构对于如何使用、消耗
和管理容量产生重大影响。在有效使用容量上，相比于调整和改变你的服务器和网络，设计能带来更大的影响。同时，随着需求的出现如何方便和灵活
地进行增加或者减少容量，也是设计能带来的重要作用。&lt;/p&gt;
&lt;p&gt;调整架构以便更容易容量管理。保持你的架构易于分割和分段，可以帮助你处理大量的负载特性问题---即在你创建了一个需要增长什么和何时增长的准确规划之前，
你需要解决的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过开放API所提供的Web服务引入了另一个逐渐扩大的问题，因为你的应用程序数据会被更多的应用程序访问，它们也都有自己的使用和增长模式。
这也意味着用户可以方便地滥用系统，从而将更多不确定因素放入容量公式中。API的使用情况需要监控，以观察新出现的模式。&lt;/p&gt;
&lt;p&gt;容量规划可以变得非常重要 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-02-25:/2014/02/25/read-the-art-of-capacity-planning/</guid><category>笔记</category><category>容量规划</category></item><item><title>如何实现Golang的http请求处理中间件（译）</title><link>http://youngsterxyf.github.io/2014/01/17/golang-http-handlers-as-middleware/</link><description>&lt;p&gt;原文：&lt;a href="http://capotej.com/blog/2013/10/07/golang-http-handlers-as-middleware/"&gt;Golang Http Handlers as Middleware&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数现代Web组件栈允许通过栈式/组件式中间件“过滤”请求，这样就能干净地从web应用中分离出横切关注点（译注：面向方面程序设计中的概念？）。
本周我尝试在Go语言的&lt;code&gt;http.FileServer&lt;/code&gt;中植入钩子，发现实现起来十分简便，让我非常惊讶。&lt;/p&gt;
&lt;p&gt;让我们从一个基本的文件服务器开始说起：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; main() {
    http.ListenAndServe(&lt;span style="color: #a31515"&gt;&amp;quot;:8080&amp;quot;&lt;/span&gt;, http.FileServer(http.Dir(&lt;span style="color: #a31515"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt;)))
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段程序会在端口8080上开启一个本地文件服务器。那么我们该如何在这其中植入钩子从而能够在文件请求处理之前执行一些代码？来看一下&lt;code&gt;http.ListenAndServe&lt;/code&gt;的方法签名：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; ListenAndServe(addr &lt;span style="color: #2b91af"&gt;string&lt;/span&gt;, handler Handler) &lt;span style="color: #2b91af"&gt;error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来&lt;code&gt;http.FileServer&lt;/code&gt;返回了一个&lt;code&gt;Handler …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 17 Jan 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-01-17:/2014/01/17/golang-http-handlers-as-middleware/</guid><category>Golang</category><category>翻译</category><category>中间件</category></item><item><title>为何Goroutine的栈空间可以无限大？（译）</title><link>http://youngsterxyf.github.io/2014/01/17/goroutine-stack-infinite/</link><description>&lt;p&gt;原文：&lt;a href="http://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite"&gt;Why is a Goroutine's stack infinite?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go编程新手可能会偶然发现&lt;a href="http://golang.org/"&gt;Go语言&lt;/a&gt;---与一个Goroutine可用栈空间大小相关---的一个古怪特性。这通常是由于程序员
无意间构造了一个无限递归函数调用而产生的。为了阐明这个特性，以如下代码（有点刻意设计的）为例。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;package&lt;/span&gt; main

&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; &lt;span style="color: #a31515"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span style="color: #0000ff"&gt;type&lt;/span&gt; S &lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; {
    a, b &lt;span style="color: #2b91af"&gt;int&lt;/span&gt;
}

&lt;span style="color: #008000"&gt;// String implements the fmt.Stringer interface&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; (s *S) String() &lt;span style="color: #2b91af"&gt;string&lt;/span&gt; {
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span style="color: #a31515"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;, s)     &lt;span style="color: #008000"&gt;// Sprintf will call s.String()&lt;/span&gt;
}

&lt;span style="color: #0000ff"&gt;func …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 17 Jan 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-01-17:/2014/01/17/goroutine-stack-infinite/</guid><category>Golang</category><category>翻译</category></item><item><title>Go - 以任意类型的slices作为输入参数（译）</title><link>http://youngsterxyf.github.io/2014/01/16/go-input-slices-any-type/</link><description>&lt;p&gt;原文：&lt;a href="https://ahmetalpbalkan.com/blog/golang-take-slices-of-any-type-as-input-parameter/"&gt;Go – taking slices of any type as input parameters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近参与的一个业余项目，&lt;a href="https://github.com/ahmetalpbalkan/go-linq"&gt;go-linq&lt;/a&gt;，让我了解到Go语言的类型系统并不是为任何类面向
对象编程而设计的。没有泛型，没有类型继承，也没有提供任何对这些特性有用的东西。&lt;/p&gt;
&lt;p&gt;但是，提供了一个名为&lt;code&gt;interface{}&lt;/code&gt;的类型，你可以向其赋予几乎任意类型的值，不会抛出编译错误，就像.NET的&lt;code&gt;Object&lt;/code&gt;或Java的&lt;code&gt;Object&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;var&lt;/span&gt; o &lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}
o := 3.14
o := Student{Name: &lt;span style="color: #a31515"&gt;&amp;quot;Ahmet&amp;quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们假设你需要一个可以接收任意类型slices的函数，如果考虑如下这样实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;func&lt;/span&gt; Method(in []&lt;span style="color: #0000ff"&gt;interface&lt;/span&gt;{}){...}
...
slice := []&lt;span style="color: #2b91af"&gt;int&lt;/span&gt;{1, 2 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 16 Jan 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-01-16:/2014/01/16/go-input-slices-any-type/</guid><category>Golang</category><category>翻译</category></item><item><title>回顾2013，展望2014</title><link>http://youngsterxyf.github.io/2014/01/06/review13-lookin14/</link><description>&lt;p&gt;2013已经过去了。&lt;/p&gt;
&lt;p&gt;时间消逝得太快，以至于很多事情在记忆上相互重叠，无法明确区分事情发生的时间点。那么该如何回顾这过去的一年？&lt;/p&gt;
&lt;h2&gt;工作&lt;/h2&gt;
&lt;p&gt;2013，参加工作的第一年，我几乎全身心地扑在工作上，自认为做了一些事情，也有很多收获，愉快而充实。技术工作于我而言，更多的
是一种兴趣、乐趣。&lt;/p&gt;
&lt;p&gt;非常感谢领导、导师以及伙伴。领导、导师给了我很大的空间，导师始终耐心地给于业务和技术的指导，和伙伴的合作非常愉快。&lt;/p&gt;
&lt;p&gt;这一年，如果说我有了些许成长进步，很大程度上归功于他们。&lt;/p&gt;
&lt;p&gt;这些话说得也许有些像获奖感言，却是发自我的真心。&lt;/p&gt;
&lt;h2&gt;生活&lt;/h2&gt;
&lt;p&gt;2013，我和老婆，订婚、领证，终于结束了长达5年的异地恋，从此以后会有个人始终和我“相依为命”，面对或许琐碎的每一天，在城市飘荡的
日子也不会再孤单，我很安心，很踏实。&lt;/p&gt;
&lt;p&gt;现在，我没车、没房，每个月的工资也不算高，但我始终在努力，除了为自己，还因为有个人值得你去努力把生活过得更好。&lt;/p&gt;
&lt;p&gt;为了记录我们以前和以后人生中的重要时刻，我特意创建了一个&lt;a href="http://youngsterxyf.github.io/love"&gt;大事年表网页 …&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 06 Jan 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2014-01-06:/2014/01/06/review13-lookin14/</guid><category>总结</category></item><item><title>微博"收藏/赞/转发"技术资料汇总</title><link>http://youngsterxyf.github.io/2013/12/28/weibo_tech_resources_summary/</link><description>&lt;p&gt;使用新浪微博，我很少发状态，主要是跟踪技术圈的一些动态，技术牛人们都在搞些什么东东，因而收藏和转发了一些优秀的技术资源，
但有些资源当时并没有来得及阅读消化，也没必要马上就阅读学习的，所以这里整理汇总一下，以免湮没在浩瀚的网络信息海洋中。&lt;/p&gt;
&lt;h3&gt;书籍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP权威指南 &amp;lt;- &lt;a href="http://weibo.com/fenng"&gt;@Fenng&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nlp.stanford.edu/IR-book/"&gt;Introduction to Information Retrieval&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/lirenchen"&gt;@陈利人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.codingnow.com/temp/readinglua.pdf"&gt;Lua 源码欣赏&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/deepcold"&gt;@简悦云风&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://aosabook.org/en/index.html"&gt;The Architecture of Open Source Applications&lt;/a&gt; &amp;lt;- &lt;a href="http://weibo.com/u/2169336083"&gt;@CloudFoundry &lt;/a&gt; (已陆续读了部分章节，赞！图灵社区有章节翻译)&lt;/li&gt;
&lt;li&gt;程序设计实践 &amp;lt;- &lt;a href="http://weibo.com/wintercn"&gt;@寒冬winter&lt;/a&gt; &lt;em&gt;推荐语：薄薄200页，就能让一个掌握一门编程语言基础的人成为一个合格的程序员，其中“算法和数据结构”一章不到30页，我认为细细读过足以应付大多数面试和工作需要。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;七周七语言 &amp;lt;- &lt;a href="http://weibo.com/tchuba"&gt;@淘宝褚霸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C语言接口与实现 &amp;lt;- &lt;a href="http://weibo.com/huangz1990"&gt;@huangz1990&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Linux Programming Interface &amp;lt;- &lt;a href="http://weibo.com/533452688"&gt;@ASTA谢&lt;/a&gt; &lt;em&gt;推荐语：既 …&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 28 Dec 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-12-28:/2013/12/28/weibo_tech_resources_summary/</guid><category>微博</category><category>技术</category></item><item><title>IE下JavaScript Date对象的不同之处</title><link>http://youngsterxyf.github.io/2013/12/03/date_difference_in_ie/</link><description>&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/29/inner_warehouse_monitor_system/"&gt;仓库作业机器监控系统&lt;/a&gt;项目中使用&lt;a href="http://www.highcharts.com/demo/line-time-series"&gt;HighCharts的时间序列数据图&lt;/a&gt;来绘制机器CPU使用率、内存使用量、网络流量趋势变化图等，这些图在IE下却没有正常显示，IE也没有报错，按理说HighCharts的IE兼容性是较好的，不会出现这种问题，
最后查明原因---确实不是HighCharts的问题，而是由于IE下JavaScript的Date对象缺少一种构造函数导致的。&lt;/p&gt;
&lt;p&gt;IE中JavaScript的Date对象有如下&lt;a href="http://msdn.microsoft.com/zh-cn/library/ie/cd9w2te4.aspx"&gt;三种构造函数&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;dateObj = new Date()
dateObj = new Date(dateVal)
dateObj = new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其他浏览器中除了这三种之外，&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"&gt;还有一种&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;dateObj = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date(dateString);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在IE下使用了这种构造函数，IE不会提示错误，但在调用dateObj的getMonth、getDate等等方法时返回的是&lt;strong&gt;NaN&lt;/strong&gt;，从而导致了其他问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：感谢@yiyun指出，IE中的Date构造函数只是不支持"xxxx-xx-xx …&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 03 Dec 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-12-03:/2013/12/03/date_difference_in_ie/</guid><category>JavaScript</category><category>笔记</category></item><item><title>某运营平台架构调整</title><link>http://youngsterxyf.github.io/2013/12/02/operation_platform_arch_change/</link><description>&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/10/15/standardization-operation-development/"&gt;运营开发规范化&lt;/a&gt;一文中提过工作中涉及一个&lt;strong&gt;运营平台&lt;/strong&gt;。曾有段时间我一直吐槽该平台的代码实现有多烂，各种功能的逻辑有多“野蛮”，应尽快改造，但也许“worse is better”，我的吐槽只能仅仅是吐槽而已了。&lt;/p&gt;
&lt;p&gt;最近该平台终于频繁出问题了。原因是上线了一个新功能---生产系统的模块之间每发生一次模块调用，就会调用该运营平台的API上报一次数据，该API的逻辑是将上报的数据存入Redis中。API由PHP实现，服务器以Nginx + PHP-FPM的方式处理API调用请求。当生产系统的业务量增大，模块直接的调用次数频率增大直接导致API调用的频率增大，
加上该平台所在服务器各种cron任务等的影响，导致在某些时候，PHP-FPM子进程数量飙升，跑满CPU，并且PHP-FPM子进程的数目持续不降（原因不明）。这样导致一方面用户无法访问该平台---服务器响应502（Nginx接受请求，但PHP-FPM无法处理该请求），另一方面更多的数据上报API调用无法完成，造成大量数据丢失和误告警。
用户怨声载道，领导也很头疼，要求尽快搞定该问题，但迟迟没人挑起这个活。&lt;/p&gt;
&lt;p&gt;为了开个头，上上个周末的一天我绘制了两张对比图（如下所示），尝试给出建议方案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="operation_platform_old_arch" src="/assets/uploads/pics/operation_platform_old_arch.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="operation_platform_new_arch" src="/assets/uploads/pics/operation_platform_new_arch.png"&gt;&lt;/p&gt;
&lt;p&gt;这种方案的时间成本较低，无需改动对外API，也无需大量修改代码。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 02 Dec 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-12-02:/2013/12/02/operation_platform_arch_change/</guid><category>架构</category><category>笔记</category></item><item><title>HAProxyConsole简介</title><link>http://youngsterxyf.github.io/2013/12/02/re_introduce_haproxyconsole/</link><description>&lt;p&gt;之前在&lt;a href="http://youngsterxyf.github.io/2013/11/01/unescape-html-in-golang-html_template/"&gt;Golang中如何让html/template不转义html标签&lt;/a&gt;、&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;两篇文章中都提到为了方便使用HAProxy，我实现了一个简单的HAProxy负载均衡任务管理系统。前些天我把&lt;a href="http://youngsterxyf.github.io/haproxyconsole/"&gt;代码放在Github上&lt;/a&gt;，算是开源吧。&lt;/p&gt;
&lt;p&gt;同事使用该管理系统，遇到问题时，由于不清楚其实现，也就无法分析问题出在哪，同时也会有些恐慌，生怕搞挂了HAProxy，毕竟上面承载了一些关键的业务，所以我绘制一张图用于说明HAProxyConsole的应用场景和工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="HAProxyConsole-arch" src="/assets/uploads/pics/HAProxyConsole-arch.png"&gt;&lt;/p&gt;
&lt;p&gt;图中蓝色标识的部分都属于HAProxyConsole。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户通过Web页面增/删/改/查负载均衡任务，但这4个操作直接修改的都仅是数据库（DB.json或MySQL数据库）。另外，HAProxyConsole的Web页面中还嵌入了主从HAProxy自带的数据统计页面。&lt;/li&gt;
&lt;li&gt;只有当用户点击按钮“应用到主HAProxy”或“应用到从HAProxy”后，HAProxyConsole才会根据DB.json或MySQL中存储的数据和配置文件haproxy_conf_comm.json生成最新的HAProxy配置文件，然后拷贝一份为主HAProxy的配置文件或远程拷贝一份为从HAProxy的配置文件，最后重启HAProxy进程（/path/to/haproxy/sbin/haproxy -f /path/to/haproxy/conf/haproxy.conf -st …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 02 Dec 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-12-02:/2013/12/02/re_introduce_haproxyconsole/</guid><category>HAProxy</category><category>Keepalived</category><category>负载均衡</category><category>笔记</category><category>总结</category></item><item><title>仓库作业机器监控系统设计与实现</title><link>http://youngsterxyf.github.io/2013/11/29/inner_warehouse_monitor_system/</link><description>&lt;p&gt;近期在参与一个仓库作业机器监控项目。该项目的需求背景是：公司的电商业务在全国各地有多处或大或小的仓库，仓库的作业人员（没有IT技术背景）经常反馈/投诉作业机器断网、断电、连不了服务等问题。实际情况经常与反馈的不一致，但运维侧并没有数据可以证明，所以才有了这个项目的需求。&lt;/p&gt;
&lt;p&gt;该项目第一期的目标仅是&lt;em&gt;收集、展示作业机器某些监控指标数据，以便在快速定位解决问题，或至少有数据可查&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;为了避免大量监控数据上报影响到生产系统的网络服务，系统采用如下结构：&lt;/p&gt;
&lt;p&gt;&lt;img alt="inner_warehouse_monitor" src="/assets/uploads/pics/inner_warehouse_monitor.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现一个agent用于在仓库作业PC或作业PDA上获取机器的监控数据；&lt;/li&gt;
&lt;li&gt;在仓库本地服务器上实现一个数据收集处理服务，提供API给agent上传监控数据；数据收集处理服务会将接收到的数据持久化到数据库，提供给仓库本地服务器上的webApp进行数据展示等；&lt;/li&gt;
&lt;li&gt;中心服务器可以调用各个仓库本地服务器上的webApp提供的数据查询接口（数据用于定位、发现问题）；定期按需对各个仓库本地服务器上的数据进行归档。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，主要的工作都集中在&lt;strong&gt;作业机器上的agent&lt;/strong&gt;和&lt;strong&gt;数据收集处理服务、webApp&lt;/strong&gt;。这其中最关键的又是&lt;strong&gt;数据收集处理服务&lt;/strong&gt;。考虑到需要多地部署运维仓库本地服务器，而且某些大仓库作业机器的数目目前已多达800-1000，我们做了如下技术选型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Golang实现agent、数据收集处理服务、webApp；&lt;/li&gt;
&lt;li&gt;以SQLite作为数据库来存储agent上报的所有数据；&lt;/li&gt;
&lt;li&gt;以&lt;a href="http://bitly.github.io/nsq/"&gt;NSQ&lt;/a&gt;作为异步消息队列中间件；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选用Golang的理由是：可以静态编译，部署简单，只需将编译好的可执行二进制程序丢到服务器上跑起来就可以了 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 29 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-11-29:/2013/11/29/inner_warehouse_monitor_system/</guid><category>技术</category><category>总结</category><category>笔记</category><category>Golang</category></item><item><title>读书笔记：Just For Fun - The Story of an Accidental Revolutionary</title><link>http://youngsterxyf.github.io/2013/11/07/read-just_for_fun/</link><description>&lt;p&gt;前些天偶然在图灵社区上看到&lt;a href="http://www.ituring.com.cn/book/1115?q=%E8%B6%8A%E7%8E%A9%E8%B6%8A%E5%A4%A7"&gt;这本书的出版计划&lt;/a&gt;，才猛然想起之前看过一两个章节，遂再次找到该书的&lt;a href="http://ishare.iask.sina.com.cn/f/14439267.html"&gt;中文电子版&lt;/a&gt;（&lt;em&gt;原谅我&lt;/em&gt;）（关于该电子版，我不清楚其来源。中国青年出版社出过该书的中文版，译名为《乐者为王》，不知该电子版即为该中文版，还是开源爱好者自己翻译。不过翻译质量不高，应该不是正式出版的），花了一天左右时间看完。&lt;/p&gt;
&lt;p&gt;本书由Linus Torvalds和David Diamond合著，书写方式是Linus自述，穿插David Diamond的一些采访旁白，主要讲述Linus如何偶然地成为信息时代的一个革命者（The Story of an Accidental Revolutionary）。Linus在书中表达了对Linux这一伟大的开源项目的看法、对于人生意义、事物发展规律等问题的个人理解。以下是书中让我印象比较深刻的几处内容：&lt;/p&gt;
&lt;h3&gt;生活的意义&lt;/h3&gt;
&lt;p&gt;对于这一哲学性的问题，估计现在很多人见到都会发笑。本书以这个问题的讨论开始，并以这个问题结尾。Linus并没有直接地回答，而是举例说明人类社会的事物发展都必然经过三个阶段---生存、社会秩序、娱乐，那么生活的意义就是促成这一发展过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;李纳斯：这个答案基本上简单而漂亮。 它不会给你的生活以任何意义，但可以告诉你将发生什么。
有三件事具有生命的意义。它们是你生活当中所有事情的动机，包括你所做的任何事情和一个生命体该做的所有事情 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 07 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-11-07:/2013/11/07/read-just_for_fun/</guid><category>阅读</category><category>笔记</category></item><item><title>修改PyPI源</title><link>http://youngsterxyf.github.io/2013/11/01/change-pypi-mirror/</link><description>&lt;p&gt;使用easy_install或pip安装Python第三方库，默认的源地址是：https://pypi.python.org/simple/ 。使用该源有两个问题:&lt;/p&gt;
&lt;p&gt;1.
国内访问速度较慢&lt;/p&gt;
&lt;p&gt;2.
由于该源使用https协议，若机器上没有安装openssl或ssl配置不对，将导致easy_install或pip访问该源失败&lt;/p&gt;
&lt;p&gt;若想解决这两个问题，可以使用国内的PyPI镜像源。&lt;/p&gt;
&lt;p&gt;从 &lt;a href="http://www.pypi-mirrors.org/"&gt;http://www.pypi-mirrors.org/&lt;/a&gt; 可以看到国内的PyPI镜像源主要有三个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.pypi.python.org&lt;/li&gt;
&lt;li&gt;pypi.douban.com&lt;/li&gt;
&lt;li&gt;pypi.hustunique.com&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;修改easy_install和pip使用的源有两种方式（以Linux上从镜像源e.pypi.python.org下载安装requests为例）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令方式：针对一次使用，临时修改&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;easy_install&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;easy_install -i http://e.pypi.python.org/simple requests …&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 01 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-11-01:/2013/11/01/change-pypi-mirror/</guid><category>Python</category><category>PyPI</category><category>pip</category><category>easy_install</category><category>ssl</category></item><item><title>Golang中如何让html/template不转义html标签</title><link>http://youngsterxyf.github.io/2013/11/01/unescape-html-in-golang-html_template/</link><description>&lt;p&gt;近期在使用Golang的&lt;a href="http://golang.org/pkg/net/http/"&gt;net/http&lt;/a&gt;和&lt;a href="http://golang.org/pkg/html/template/"&gt;html/template&lt;/a&gt;开发一个简单的HAProxy负载均衡任务管理系统（见&lt;a href="http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/"&gt;搭建高可用负载均衡组件及缓存DNS&lt;/a&gt;一文说明）。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://golang.org/pkg/html/template/"&gt;htmp/template&lt;/a&gt;在渲染页面模板的时候默认会转义字符串中的html标签，但有时我们并不想转义html标签，以下图所示为例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="add_haproxy_balance_task" src="/assets/uploads/pics/haproxy_task_add.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="list_haproxy_balance_task" src="/assets/uploads/pics/haproxy_task_list.jpg"&gt;&lt;/p&gt;
&lt;p&gt;图1中“ip:port列表(一行一个)”和“说明”两个输入框的内容行与行是以&lt;code&gt;\n&lt;/code&gt;分隔的；图2中，这两部分内容分别在表格的“后端机器列表”和“说明”两列中展示，但行与行其实是以&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;分隔的；那么在将数据存入数据库之前或从数据库中取出数据后，会将字符串中的&lt;code&gt;\n&lt;/code&gt;替换为&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;。如果将替换后的数据以字符串类型传入模板，&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;标签渲染后的效果就是&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;文本而不是换行。&lt;/p&gt;
&lt;p&gt;有两种方式避免&lt;code&gt;html/template&lt;/code&gt;转义html标签：&lt;/p&gt;
&lt;p&gt;1.
把字符串类型数据转换成&lt;code&gt;template …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 01 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-11-01:/2013/11/01/unescape-html-in-golang-html_template/</guid><category>Golang</category><category>template</category></item><item><title>学在腾讯：简而美的微信后台架构</title><link>http://youngsterxyf.github.io/2013/10/23/learning-in-tencent-backend-arch-of-weixin/</link><description>&lt;p&gt;注：&lt;em&gt;公司分享讲座的一点笔记，不保证准确性。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;h4&gt;极致的业务特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;流畅的消息收发&lt;/li&gt;
&lt;li&gt;及时的通知&lt;/li&gt;
&lt;li&gt;省电&lt;/li&gt;
&lt;li&gt;省流量&lt;/li&gt;
&lt;li&gt;瘦客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;困难的后台-终端同步&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;同步多样数据：账户信息、通讯录、消息、朋友圈等&lt;/li&gt;
&lt;li&gt;及时通知与同步&lt;/li&gt;
&lt;li&gt;移动网络下的可靠同步&lt;/li&gt;
&lt;li&gt;省流量与电量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方案&lt;/h2&gt;
&lt;h4&gt;极简的同步协议&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;后台与终端只需要沟通一个数字，后台即可知道终端缺失的所有数据。&lt;/li&gt;
&lt;li&gt;变更序列号/版本号：&lt;ul&gt;
&lt;li&gt;后台对用户数据的每项变更，都赋予一个单调递增的序列号，即用户的每项数据都有一个全局递增序列号。&lt;/li&gt;
&lt;li&gt;后台每次给终端发送数据都会带上所发送的所有数据的最大序列号。&lt;/li&gt;
&lt;li&gt;终端每次请求数据时都会带上已经接受到的最大序列号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;高效的通知机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ios Apple Push Network Service&lt;/li&gt;
&lt;li&gt;Android等-长连接&lt;/li&gt;
&lt;li&gt;GPRS/EDGE信令风暴优化&lt;/li&gt;
&lt;li&gt;自适应心跳间隔调节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;三层后台架构&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Arch of weixin backend" src="/assets/uploads/pics/arch-of-weixin-backend.png"&gt;&lt;/p&gt;
&lt;h4&gt;统一的RPC框架&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据ProtocolBuffer定义生成服务器框架和客户端&lt;ul&gt;
&lt;li&gt;服务器：开发人员填充接口实现&lt;/li&gt;
&lt;li&gt;客户端： 应用方本地调用客户端提供的接口函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;屏蔽网络细节&lt;ul&gt;
&lt;li&gt;支持基于TCP/UDP的网络调用 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 23 Oct 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-10-23:/2013/10/23/learning-in-tencent-backend-arch-of-weixin/</guid><category>腾讯</category><category>微信</category><category>架构</category></item><item><title>搭建高可用负载均衡组件及缓存DNS</title><link>http://youngsterxyf.github.io/2013/10/16/high-availability-load-balancer-and-dns/</link><description>&lt;p&gt;该项工作，如题所示，主要分为两部分：高可用负载均衡组件、缓存DNS。&lt;/p&gt;
&lt;h3&gt;高可用负载均衡组件&lt;/h3&gt;
&lt;p&gt;需求：优化业务系统架构中某些关键环节，针对TCP层数据流量进行负载均衡，并保证服务的高可用。&lt;/p&gt;
&lt;p&gt;技术选型：HAProxy + Keepalived，这对组合比较常见成熟。&lt;/p&gt;
&lt;p&gt;另外，由于HAProxy的负载均衡任务可能比较多，靠人工修改配置来增删改任务不方便可靠，所以实现了一个简单的HAProxy管理系统，
以后经实际使用验证和完善会开放源码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="high availability load balancer" src="/assets/uploads/pics/high-availability-load-balancer.png"&gt;&lt;/p&gt;
&lt;h3&gt;缓存DNS&lt;/h3&gt;
&lt;p&gt;先以www.qq.com为例，解释一下域名解析过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="resolve qq.com" src="/assets/uploads/pics/resolve-qq-com.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1.
用户向Local DNS发起www.qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;2.
Local DNS向根服务器发起com.查询请求；&lt;/p&gt;
&lt;p&gt;3.
根服务器向Local DNS返回com.解析记录；&lt;/p&gt;
&lt;p&gt;4.
Local DNS向com.权威服务器发起qq.com.查询请求；&lt;/p&gt;
&lt;p&gt;5.
com.权威服务器向Local DNS返回qq.com.解析记录 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 16 Oct 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-10-16:/2013/10/16/high-availability-load-balancer-and-dns/</guid><category>高可用</category><category>负载均衡</category><category>HAProxy</category><category>Keepalived</category><category>HAProxyConsole</category><category>DNS</category><category>BIND</category></item><item><title>运营开发规范化</title><link>http://youngsterxyf.github.io/2013/10/15/standardization-operation-development/</link><description>&lt;p&gt;今年3月底毕业，入职腾讯做运营开发，至今6个月有余。入职之时组内仅有1个运营开发的同事，到目前已扩充到5人，加3个实习生。&lt;/p&gt;
&lt;p&gt;入职之时的运营开发过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在办公机器（Windows）上编写代码，功能测试通过后，&lt;/li&gt;
&lt;li&gt;ssh远程连接到生产服务器（Linux），vim打开一个新文件，复制办公机器上的代码，粘贴到vim中，保存，&lt;/li&gt;
&lt;li&gt;打开浏览器测试上线的功能/效果是否正确，若不正确，&lt;/li&gt;
&lt;li&gt;直接在生产服务器上编辑代码文件，直到达到需要的功能效果，&lt;/li&gt;
&lt;li&gt;再从生产服务器上将修改后的代码复制粘贴到办公机器（也许不会有这一步，之后所有的修改都直接在生产服务器上操作）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程存在如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码没有版本控制&lt;/li&gt;
&lt;li&gt;没有与生产服务器一致的测试环境&lt;/li&gt;
&lt;li&gt;代码部署过程繁琐&lt;/li&gt;
&lt;li&gt;办公开发机器上代码很可能比生产服务器上代码还旧&lt;/li&gt;
&lt;li&gt;上面4点都会导致混乱&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外，当团队从1人扩充到多人后，不可避免地会遇到协作的问题，解决代码开发协作问题一般涉及如下几方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用代码版本控制&lt;/li&gt;
&lt;li&gt;规定版本控制的工作流&lt;/li&gt;
&lt;li&gt;编码规范&lt;/li&gt;
&lt;li&gt;项目/代码文档&lt;/li&gt;
&lt;li&gt;定期code review&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决上述问题，我陆续地做了如下工作：&lt;/p&gt;
&lt;h3&gt;搭建Gitlab服务器、测试服务器&lt;/h3&gt;
&lt;p&gt;个人认为开发工作规范化的第一点就是版本控制，基于版本控制可以完成很多自动化的任务。&lt;/p&gt;
&lt;p&gt;平时个人的代码、文档都通过Git版本控制存放在Github上 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 15 Oct 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-10-15:/2013/10/15/standardization-operation-development/</guid><category>服务器</category><category>Linux</category><category>Git</category><category>Golang</category><category>Python</category></item><item><title>一项工作中涉及的几个命令</title><link>http://youngsterxyf.github.io/2013/10/14/several-command-in-one-task/</link><description>&lt;p&gt;今天写了点shell脚本，在一些CentOS服务器上进行了一些操作，涉及如下命令：&lt;/p&gt;
&lt;h3&gt;统计特定进程个数&lt;/h3&gt;
&lt;p&gt;如统计haproxy进程的个数&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ps -e | grep haproxy | wc -l
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;获取特定进程的pid&lt;/h3&gt;
&lt;p&gt;如获取haproxy进程的pid&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ps -e | grep haproxy | awk &lt;span style="color: #a31515"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;一对多添加ssh信任关系&lt;/h3&gt;
&lt;p&gt;如192.168.2.1用户usernameA到192.168.2.x用户usernameB的信任关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在192.168.2.1创建自己的公钥私钥：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen -t rsa   &lt;span style="color: #008000"&gt;# 提示输入时，全部留空回车。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝192.168.2.1的公钥到192.168.2.x机器上：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ssh-copy-id &lt;span style="color: #a31515"&gt;&amp;quot;-p 22 usernameB@192.168 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 14 Oct 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-10-14:/2013/10/14/several-command-in-one-task/</guid><category>Linux</category><category>命令行</category></item><item><title>从URL监控问题谈网站Web架构</title><link>http://youngsterxyf.github.io/2013/10/12/url-monitoring-and-web-arch/</link><description>&lt;p&gt;之前工作中实现了一个对站点进行URL监控的功能。原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cron脚本定时从一台Nginx服务器上获得Nginx配置文件（包括upstream配置），在解析配置得到：&lt;code&gt;域名-&amp;gt;upstream名&lt;/code&gt;（可能有多个）、&lt;code&gt;upstream名-&amp;gt;属于该upstream的服务器ip列表&lt;/code&gt;，存入数据库；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户通过Web界面配置URL监控项，配置过程为：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入要监控的URL，如http://www.sample.com/test.php ，前端JS解析出域名部分www.sample.com，向后端发送AJAX请求，得到该域名相关的upstream；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;用户选择正确的那个upstream（Nginx可以将对不同URL的请求转发到不同的upstream后端机器）；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后填写监控告警信息接收人等其他配置信息，提交即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个cron脚本定时地:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从数据库中读取URL监控项数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;根据监控项中的upstream名，从数据库中读取属于该upstream的ip列表；&lt;/li&gt;
&lt;li&gt;逐个使用ip列表中的ip替换URL的域名部分，将域名部分作为HTTP请求头的HOST字段的值；&lt;/li&gt;
&lt;li&gt;使用libcurl库或curl命令发出请求（如使用curl命令：&lt;code&gt;curl -H "www.sample.com" http://192.168.1.1/test.php&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;如果响应码非200或非3xx等 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 12 Oct 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-10-12:/2013/10/12/url-monitoring-and-web-arch/</guid><category>监控</category><category>架构</category><category>Web</category><category>工作笔记</category></item><item><title>通过示例学习Git内部构造（译）</title><link>http://youngsterxyf.github.io/2013/09/28/learning-git-internals-by-example/</link><description>&lt;p&gt;原文：&lt;a href="http://teohm.github.io/blog/2011/05/30/learning-git-internals-by-example/"&gt;Learning Git Internals by Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;状态：草稿&lt;/p&gt;
&lt;p&gt;计划修订本文，未来可能会简化一些...&lt;/p&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;p&gt;从Subversion和Mercurial切换到Git之后的几个月，我始终觉得Git在本质上是不同于Subversion和Mercurial的，但没法确切地说出区别。
我经常在Github上看到tree、parent等术语，也搞不清楚它们确切的含义。&lt;/p&gt;
&lt;p&gt;因此我决定花些时间学学Git。&lt;/p&gt;
&lt;p&gt;我会尝试概述，并阐述一路走来学到的关于Git的关键信息...但这仅是有助于我回答Git与其他源码控制工具区别的Git内部构造基本知识。&lt;/p&gt;
&lt;h2&gt;实体、引用、索引（Objects，References，The Index）&lt;/h2&gt;
&lt;p&gt;要理解Git内部构造的核心，我们应理解三个东西： &lt;strong&gt;实体&lt;/strong&gt;、&lt;strong&gt;引用&lt;/strong&gt;、 &lt;strong&gt;索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我发现这个模型非常优雅。用一个小小的图表就能完全展现，也易于理解记忆。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Big Picture" src="/assets/uploads/pics/git-internals/big-picture.png"&gt;&lt;/p&gt;
&lt;h3&gt;实体&lt;/h3&gt;
&lt;p&gt;你提交到一个Git代码仓库中的所有文件，包括每个提交的说明信息（the commit info）都在目录 &lt;code&gt;.git/objects/&lt;/code&gt;中存储为&lt;strong&gt;实体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个实体以一个40字符长度的字符串 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 28 Sep 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-09-28:/2013/09/28/learning-git-internals-by-example/</guid><category>Git</category><category>翻译</category></item><item><title>时间的心</title><link>http://youngsterxyf.github.io/2013/08/22/heart-of-time/</link><description>&lt;p&gt;近期工作生活的一点心得：&lt;/p&gt;
&lt;h3&gt;珍惜自己的时间&lt;/h3&gt;
&lt;p&gt;乐于助人是好事，但，是需要耗费时间的，那么在助人之前就得确认帮助别人所做的事情有多大意义，是否对得起所耗费的时间精力。每个人的时间都很珍贵，应尽可能用来做有价值的事情，不要把自己的时间看得过于廉价。&lt;/p&gt;
&lt;p&gt;所以之后有人请我帮忙时，我会先问两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到什么问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要解决这个问题？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这两个问题来判断是否值得帮忙。&lt;/p&gt;
&lt;h3&gt;平常心&lt;/h3&gt;
&lt;p&gt;一心追求技术，对技术好坏有自己的“正义感”，是好事。但，不能苛求别人，更不能不停评价吐槽，否则于己于人都无益处。对别人、别人的技术水平宽容一点，把苛求留给自己，不断提高自己，努力把事情做得更好，其他的则应保持平常心。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;至于本文的题目，则纯属扯淡，故作矫情，从两个部分的标题中取出最后一词组合而成。&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 22 Aug 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-08-22:/2013/08/22/heart-of-time/</guid><category>总结</category><category>自省</category></item><item><title>Y分钟学会Python（译）</title><link>http://youngsterxyf.github.io/2013/06/29/learn-python-in-y-minutes/</link><description>&lt;p&gt;原文：&lt;a href="http://learnxinyminutes.com/docs/python/"&gt;Learn Python in Y Minutes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python由Guido Van Rossum发明于90年代初期，是目前最流行的编程语言之一，因其语法的清晰简洁我爱上了Python，其代码基本上可以
说是可执行的伪代码。&lt;/p&gt;
&lt;p&gt;非常欢迎反馈！你可以通过推特&lt;a href="https://twitter.com/louiedinh"&gt;@louiedinh&lt;/a&gt;或louiedinh AT gmail联系我。&lt;/p&gt;
&lt;p&gt;备注：本文是专门针对Python 2.7的，但应该是适用于Python 2.x的。很快我也会为Python 3写这样的一篇文章！&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008000"&gt;# 单行注释以井字符开头&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot; 我们可以使用三个双引号（&amp;quot;）或单引号（&amp;#39;）&lt;/span&gt;
&lt;span style="color: #a31515"&gt;    来编写多行注释&lt;/span&gt;
&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;


&lt;span style="color: #008000"&gt;##########################################################&lt;/span&gt;
&lt;span style="color: #008000"&gt;## 1. 基本数据类型和操作符&lt;/span&gt;
&lt;span style="color: #008000"&gt;##########################################################&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 数字&lt;/span&gt;
3 &lt;span style="color: #008000"&gt;#=&amp;gt; 3&lt;/span&gt;

&lt;span style="color: #008000"&gt;# 你预想的数学运算&lt;/span&gt;
1 + 1 &lt;span style="color: #008000"&gt;#=&amp;gt; 2&lt;/span&gt;
8 - 1 &lt;span style="color: #008000"&gt;#=&amp;gt; 7&lt;/span&gt;
10 * 2 &lt;span style="color: #008000"&gt;#=&amp;gt; 20&lt;/span&gt;
35 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 29 Jun 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-06-29:/2013/06/29/learn-python-in-y-minutes/</guid><category>Python</category><category>翻译</category></item><item><title>FTP是90年代的，使用Git取代它来部署代码吧！（译）</title><link>http://youngsterxyf.github.io/2013/06/24/deploy-via-git/</link><description>&lt;p&gt;原文：&lt;a href="https://coderwall.com/p/xczkaq?&amp;amp;p=1&amp;amp;q="&gt;FTP is so 90's. Let's deploy via Git instead!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，在你的服务器上创建一个目录，并在其中初始化一个空的git仓库。我喜欢使用&lt;code&gt;~/www/&lt;/code&gt;目录来存放网站代码，
因此我会这么做：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;mkdir ~/www/example.com &amp;amp;&amp;amp; cd ~/www/example.com
git init
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着，设置你服务器上的git仓库以便很好地通过&lt;code&gt;git push&lt;/code&gt;来部署代码。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;git config core.worktree ~/www/example.com
git config receive.denycurrentbranch ignore
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，为git设置一个post-receive钩子来检出&lt;code&gt;master&lt;/code&gt;分支 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 24 Jun 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-06-24:/2013/06/24/deploy-via-git/</guid><category>Git</category><category>翻译</category></item><item><title>搭建测试服务器(源码编译方式)</title><link>http://youngsterxyf.github.io/2013/06/18/setup-testing-server/</link><description>&lt;p&gt;目前工作中开发流程还比较初级，甚至连测试服务器都没有，代码的变更都是直接先在开发人员的本地机器上简单测试一下，然后直接部署到生产服务器上，这就相当于生产服务器同时充当了测试服务器的角色，虽然开发的是面向公司内部的系统，但作为一个有理想有追求的码农，是不允许这样粗糙混乱的开发流程的，所以申请了台服务器，自己搭建个测试服务器。&lt;/p&gt;
&lt;p&gt;由于公司的服务器统一使用SUSE Linux Server操作系统，并且版本较老。与Ubuntu、Centos等Linux发行版不同，SUSE Linux没有可用的软件源（不知是否与OpenSUSE的软件源兼容？），即没法使用系统的软件包管理工具。这样问题就很多了。&lt;/p&gt;
&lt;p&gt;我选择源码编译的方式来安装所有涉及的软件。也许有人会说，为什么不在网络上查找RPM包然后安装呢？那么先想一下RPM包本质上是个什么东西呢？RPM包（以及DEB包）其实就是将编译好的一些程序以一定的规则打包在一起，然后系统的包管理工具（yum、zypper）按照相同的规则（在依赖满足的情况下）将RPM包里文件复制到指定好的目录里。如果RPM包的依赖没有解决，是无法成功安装的。即使安装好了，若程序依赖的动态链接库等不存在或版本不匹配，也是无法正确运行的，比如libc库的版本过低，但明显你不能轻易替换libc库，因为系统中已安装的很多程序都依赖于libc库。那么相比源码编译方式，RPM包方式的问题更难解决。&lt;/p&gt;
&lt;p&gt;需要安装的软件有Nginx、PHP、MySQL、Memcached、Redis、Mongodb …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 18 Jun 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-06-18:/2013/06/18/setup-testing-server/</guid><category>Linux</category><category>PHP</category><category>MySQL</category><category>Nginx</category><category>服务器</category><category>Python</category><category>Git</category></item><item><title>PHP最佳实践（译）</title><link>http://youngsterxyf.github.io/2013/06/01/php-best-practices/</link><description>&lt;p&gt;原文： &lt;a href="https://phpbestpractices.org/"&gt;PHP Best Practices-A short, practical guide for common and confusing PHP tasks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;最后修订日期&amp;amp;维护者&lt;/h2&gt;
&lt;p&gt;本文档最后审阅于2013年3月8日。最后修改于2013年5月8日。&lt;/p&gt;
&lt;p&gt;由我，&lt;a href="https://alexcabal.com/"&gt;Alex Cabal&lt;/a&gt;，维护该文档。我编写PHP程序已有很长一段时间了，当前我
经营着&lt;a href="http://www.scribophile.com/"&gt;Scribophile，由认真作家组成的一个在线写作团体&lt;/a&gt;,
&lt;a href="http://writerfolio.com/"&gt;Writerfolio，为自由职业者提供的一个易用写作工具集&lt;/a&gt;，以及
&lt;a href="https://standardebooks.com"&gt;Standard Ebooks，一个图文并茂、无数字版权管理的公共领域电子书出版商&lt;/a&gt;。
有时我是个为吸引我的项目或客户而工作的自由职业者。&lt;/p&gt;
&lt;p&gt;如果你认为我在某些事情上能够帮到你，或者对本文档有点建议或纠正存在的错误，&lt;a href="https://alexcabal.com/contact/"&gt;请给我写封邮件&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;PHP是一门复杂的语言，经过多年折腾，使其不同版本之间高度不一致，有时还有些bug。
每个版本都有自己独有的特性、多余和怪异之处，也很难跟踪哪个版本有哪些问题。这也就
很好理解为什么有时它会遭到那么多的厌恶。&lt;/p&gt;
&lt;p&gt;尽管如此 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 01 Jun 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-06-01:/2013/06/01/php-best-practices/</guid><category>翻译</category><category>PHP</category></item><item><title>城市的日子</title><link>http://youngsterxyf.github.io/2013/05/19/life-of-city/</link><description>&lt;p&gt;我仍须一个人&lt;br /&gt;
面对这个城市，&lt;br /&gt;
以及如此雷同的日复日。&lt;br /&gt;
&lt;br /&gt;
电话、网络，&lt;br /&gt;
工作、技术、阅读、爱好，&lt;br /&gt;
朋友，&lt;br /&gt;
还有我的思考，&lt;br /&gt;
都改变不了，&lt;br /&gt;
这城市的日子。&lt;br /&gt;
&lt;br /&gt;
所以，&lt;br /&gt;
我想她。&lt;br /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 19 May 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-05-19:/2013/05/19/life-of-city/</guid><category>诗歌</category><category>笔记</category><category>生活</category></item><item><title>编译安装MemcacheQ</title><link>http://youngsterxyf.github.io/2013/04/27/compile-and-install-memcacheq/</link><description>&lt;p&gt;MemcacheQ是一个MemcacheDB的变种，用来提供简单的消息队列服务。（注：MemcacheDB并不是一个数据缓存解决方案，而是一个为数据持久化设计的分布式的键-值对数据存储系统，采用memcache协议，以BerkeleyDB作为存储后端，&lt;a href="http://memcachedb.org/"&gt;主页&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;MemcacheQ依赖于BerkeleyDB和libevent，所以需先编译安装这两者。&lt;/p&gt;
&lt;p&gt;1.
从&lt;a href="http://www.oracle.com/technetwork/products/berkeleydb/downloads/index.html"&gt;Oracle官网&lt;/a&gt;上下载某一版本的BerkeleyDB（这里以5.0.32版本为例）&lt;/p&gt;
&lt;p&gt;解压缩： &lt;code&gt;tar -xvf db-5.0.32.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入db-5.0.32/build_unix目录后执行： 1) &lt;code&gt;../dist/configure&lt;/code&gt; , 2) &lt;code&gt;make&lt;/code&gt; , 3) &lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，会把BerkeleyDB安装到&lt;code&gt;/usr/local/BerkeleyDB.5.3&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;2.
从&lt;a href="http://libevent.org/"&gt;libevent官网&lt;/a&gt;下载libevent …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 27 Apr 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-04-27:/2013/04/27/compile-and-install-memcacheq/</guid><category>笔记</category><category>工作</category><category>服务器</category><category>技术</category></item><item><title>工作中的技术人</title><link>http://youngsterxyf.github.io/2013/04/23/technical-person/</link><description>&lt;p&gt;工作入职半个月，有些事情不太顺利，还没有正式上手工作，也许大公司的节奏便是如此，但我内心是比较急的，希望能尽快地上手做实际的工作，而不是学习和等待。&lt;/p&gt;
&lt;p&gt;这半个月里，主要是熟悉工作环境，学习了解工作相关的技术。虽说学习，但其实大部分相关技术以前都了解或使用过，只是经验还不够。&lt;/p&gt;
&lt;p&gt;第一周，除了常规的入职事宜，搭建了开发测试环境，并阅读理解工作中使用的web框架。对于这个框架，有太多的吐槽点，严格地说算不上是个框架，可能是因为写得比较早。对于框架，我认为最重要的是为多人协作完成一件事情提供实现上的规范，其次是代码复用，减少工作量。但这个框架除了一些供复用的代码，就啥都没有了。&lt;/p&gt;
&lt;p&gt;第二周，学习巩固PHP基础，一直没认真地学习过PHP，只是在实习的时候做了一些开发，稍微了解了下Yii框架和Zend框架，觉得太复杂了点。除此之外，初步了解组内的运维工作，特别是整个系统的架构。&lt;/p&gt;
&lt;p&gt;经过一番思考，基于自己的理解，昨天编写了一个玩具性质的MVC web框架原型&lt;a href="https://github.com/youngsterxyf/minibean"&gt;minibean&lt;/a&gt;，该框架以路由转发和控制器为核心，所有非静态文件请求的处理都以Application类对象为入口，按照一定规则对请求URI经路由转发找到对应的控制器类，控制器对象中调用模型与视图的类对象等。以后随着开发经验的增加以及对其他开源成熟框架的学习，会不断地完善该框架。在编写该框架的过程中，深感自己经验的不足，特别是对于Model层 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 23 Apr 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-04-23:/2013/04/23/technical-person/</guid><category>工作</category><category>感悟</category></item><item><title>Windows上安装PHP开发测试环境</title><link>http://youngsterxyf.github.io/2013/04/15/install-php-development-environment-on-windows/</link><description>&lt;p&gt;先从HTTP请求处理流程图来看看我们所需的PHP开发测试环境包含哪些组件。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/uploads/pics/php-development-env.jpg" alt="PHP开发测试环境"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出系统包含如下几种组件之间的交互：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx与PHP-CGI(PHP)的交互&lt;/li&gt;
&lt;li&gt;PHP-CGI(PHP)与文件系统、分布式内存对象缓存系统、数据库之间的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了PHP与文件系统之间的交互，其他几种交互均为客户端-服务器模式，以Socket方式进行连接，都需要安装配置相关组件。&lt;/p&gt;
&lt;p&gt;对于Nginx与PHP-CGI(PHP)的交互，PHP-CGI默认打开9000端口，等待Nginx转发过来的请求，所以需要在Nginx配置文件中添加类似于如下所示的虚拟主机配置：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;server {
    listen  8000;
    server_name localhost;

    location / {
        root    html;   # 这里为你的网站的根目录
        index   index.php index.html index.htm;
    }

    location ~ \.php$ {
        root    html;   # 这里也设置为你的网站的根目录
        fastcgi_pass    127.0.0.1:9000; # 这里设置为你的PHP-CGI监听的网络地址
        fastcgi_index   index …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 15 Apr 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-04-15:/2013/04/15/install-php-development-environment-on-windows/</guid><category>笔记</category><category>PHP</category></item><item><title>弄清问题，再求解决</title><link>http://youngsterxyf.github.io/2013/04/09/understand-before-solve/</link><description>&lt;p&gt;今天同事问我：是否有什么python库或工具能够将网页内容转换成图片格式的。他在做这方面的事情，还没有好的方法，因为觉得我对python比较熟悉，所以问一下。&lt;/p&gt;
&lt;p&gt;但是我从一开始我就犯错误了。其实我至少应该问一下：为什么要解决这个问题？也就是业务需求是什么？并且稍微一想这个问题其实比较含糊。现在的web页面可以很简单，也可能很复杂。那么这个问题里的“网页”是什么样的网页呢？是任何可能的网页么？目的是需要通过图片来展示网页的哪个部分的信息还是整个网页？这些问题我都没问，也没仔细考虑。&lt;/p&gt;
&lt;p&gt;在没有明确需求的情况下，我就认为是将任何形式的网页完整地转换成图片，但又没弄清如果是这种情况问题的难度有多大。&lt;/p&gt;
&lt;p&gt;在听完问题后，我就想到可能有两种方法：1. 先将网页转换成pdf，然后转换成图片，因为我对于将网页转换成pdf格式的方法有点印象；2.可能存在python实现的工具直接将网页转换成图片格式。你是否发现我的思路有个误区：问题的解决方案需要python代码实现，我假设了需要将这个功能嵌入到一个大的程序中。&lt;/p&gt;
&lt;p&gt;然后我就开始蒙头google找方案。经过一番“艰苦卓绝”的查找，发现：1.确实有如xhtml2pdf等工具能将网页转换成pdf格式，但貌似对于中文的支持不是很好；2.没有好的python库或工具能够直接将网页转换成图片格式，有的方案要收费，有的方案需要调用第三方API，而公司的数据明显是不能让第三方获得的。&lt;/p&gt;
&lt;p&gt;在查找解决方案的过程中，我也逐步意识到上述的那些问题，特别是若假设需要将任何形式的网页转换成图片格式 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 09 Apr 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-04-09:/2013/04/09/understand-before-solve/</guid><category>笔记</category><category>工作</category></item><item><title>argparse - 命令行选项与参数解析（译）</title><link>http://youngsterxyf.github.io/2013/03/30/argparse/</link><description>&lt;p&gt;原文：&lt;a href="http://pymotw.com/2/argparse/"&gt;argparse – Command line option and argument parsing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;argparse模块作为optparse的一个替代被添加到Python2.7。argparse的实现支持一些不易于添加到optparse以及要求向后不兼容API变化的特性，因此以一个新模块添加到标准库。&lt;/p&gt;
&lt;h3&gt;与optparse相比较&lt;/h3&gt;
&lt;p&gt;argparse的API类似于optparse，甚至在很多情况下通过更新所使用的类名和方法名，使用argparse作为一个简单的替代。然而，有些地方在添加新特性时不能保持直接兼容性。&lt;/p&gt;
&lt;p&gt;你必须视情况决定是否升级已有的程序。如果你已编写了额外的代码以弥补optparse的局限，也许你想升级程序以减少你需要维护的代码量。若argparse在所有部署平台上都可用，那么新的程序应尽可能使用argparse。&lt;/p&gt;
&lt;h3&gt;设置一个解析器&lt;/h3&gt;
&lt;p&gt;使用argparse的第一步就是创建一个解析器对象，并告诉它将会有些什么参数。那么当你的程序运行时，该解析器就可以用于处理命令行参数。&lt;/p&gt;
&lt;p&gt;解析器类是 &lt;strong&gt;ArgumentParser&lt;/strong&gt; 。构造方法接收几个参数来设置用于程序帮助文本的描述信息以及其他全局的行为或设置。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; argparse
parser = argparse.ArgumentParser(description=&lt;span style="color: #a31515"&gt;&amp;#39;This is a PyMOTW sample program&amp;#39;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义参数&lt;/h3&gt;
&lt;p&gt;argparse是一个全面的参数处理库。参数可以触发不同的动作，动作由 &lt;strong&gt;add_argument …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 30 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-30:/2013/03/30/argparse/</guid><category>Python</category><category>翻译</category></item><item><title>读文笔记：What Powers Instagram</title><link>http://youngsterxyf.github.io/2013/03/27/what-powers-instagram/</link><description>&lt;p&gt;原文：&lt;a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances-dozens-of"&gt;What Powers Instagram: Hundreds of Instances, Dozens of Technologies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;该文从多个方面介绍Instagram整个系统栈(stack)的组成，罗列所使用的组件。我觉得重要的不是用了哪些组件和工具，而是在构建一个系统时，应注意哪些问题，从哪些层面对系统进行优化。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;构建系统的核心原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持简单&lt;/li&gt;
&lt;li&gt;不重复造轮子&lt;/li&gt;
&lt;li&gt;尽可能使用经实践验证可靠的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OS/虚拟主机&lt;/h3&gt;
&lt;p&gt;在Amazon EC2上运行Ubuntu Linux 11.04。之前的Ubuntu版本在高流量的情况会产生各种不可预料的冻结事件（freezing episodes）。&lt;/p&gt;
&lt;h3&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;对Instagram的每个请求都会经过负载均衡机器。以前使用两台&lt;strong&gt;Nginx&lt;/strong&gt;机器，并在两者之间使用DNS轮循（Round-Robin）。
这种方法的缺点是当有机器退出使用时DNS需要花些时间来更新。后来使用Amazon的Elastic负载均衡器，并在ELB层面终止SSL（注：不太懂这个），
从而降低nginx的CPU负载。&lt;/p&gt;
&lt;h3&gt;应用服务器&lt;/h3&gt;
&lt;p&gt;Django；多个应用服务器，由于无状态，所以容易横向扩展 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 27 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-27:/2013/03/27/what-powers-instagram/</guid><category>笔记</category></item><item><title>学习JavaScript - 我的经验与建议（译）</title><link>http://youngsterxyf.github.io/2013/03/25/learning-js/</link><description>&lt;p&gt;原文：&lt;a href="http://sivers.org/learn-js"&gt;learning JavaScript - my experience and advice&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自从我曾&lt;a href="http://sivers.org/os"&gt;几&lt;/a&gt;&lt;a href="http://sivers.org/srs"&gt;次&lt;/a&gt;&lt;a href="http://sivers.org/prog"&gt;提到&lt;/a&gt;自己在刚过去的几个月中学习了JavaScript，很多人就发email给我询问我是如何学习JavaScript的以及推荐如何学习。以下就是我的经验和最佳建议。&lt;/p&gt;
&lt;p&gt;注：我是想真正地学习JavaScript---不是捷径，或快速技巧，或元工具（meta-tools）之类让我不必要学习JavaScript的东西。我想学习、掌握、阅读、理解以及记住JavaScript这门语言，从而在以后的日子里能够理解所有其他以JavaScript编写的很酷的东西。&lt;/p&gt;
&lt;p&gt;首先---很多人可能会告诉你去阅读&lt;a href="http://shop.oreilly.com/product/9780596517748.do"&gt;Douglas Crockford的著作《JavaScript语言精粹》&lt;/a&gt;。但当我开始阅读这本书时，才发现它是如此的紧凑简洁以致我根本不知道它在说啥！&lt;/p&gt;
&lt;p&gt;你知道何时一个专家是在谈论自己的领域，就不知道如何为其他人做点简化么？感觉这本书对于那些已有20年的C、Java或C++编程经验来说非常完美，他们只需要快速概览必知的JavaScript知识点。&lt;/p&gt;
&lt;p&gt;但它真的不是要教你学习JavaScript。它不会指导你学习任何东西。因此我建议先跳过这本书。&lt;/p&gt;
&lt;p&gt;相反，从&lt;a href="http://eloquentjavascript.net/"&gt;Marijn Haverbeke的著作《JavaScript编程精解》&lt;/a&gt;开始学习吧。&lt;/p&gt;
&lt;p&gt;这本书一开始非常简单易学，简直是太简单了 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 25 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-25:/2013/03/25/learning-js/</guid><category>JavaScript</category><category>翻译</category></item><item><title>pip install lxml编译失败问题解决</title><link>http://youngsterxyf.github.io/2013/03/17/pip-install-lxml-problem/</link><description>&lt;p&gt;以前在遇到这个问题时，都是偷懒使用&lt;code&gt;sudo apt-get install python-lxml&lt;/code&gt;（Debian系的Linux发行版）直接安装已打包好的deb包。但一方面这样安装的不是最新的库，另一方面我希望把所有的Python第三方库都限制在virtualenv中使用，所以希望使用&lt;code&gt;pip install lxml&lt;/code&gt;，那么这个问题就必须解决了。&lt;/p&gt;
&lt;p&gt;Google了一把，在&lt;a href="http://stackoverflow.com/questions/5178416/pip-install-lxml-error"&gt;这里&lt;/a&gt;找到了解答。&lt;/p&gt;
&lt;p&gt;其实在编译失败的log里，已经有提示：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;make sure the development packages of libxml2 and libxslt are installed
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以正确编译需先安装libxml2和libxslt这两个包。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install libxml2
sudo apt-get install libxslt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，还需安装Python开发包python-dev：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install python-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;OK，再执行&lt;code&gt;pip …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 17 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-17:/2013/03/17/pip-install-lxml-problem/</guid><category>Python</category></item><item><title>读书笔记：JavaScript语言精粹</title><link>http://youngsterxyf.github.io/2013/03/14/read-js-thegoodparts/</link><description>&lt;h2&gt;第2章：语法&lt;/h2&gt;
&lt;p&gt;JavaScript提供两种注释形式，一种是用&lt;code&gt;/* */&lt;/code&gt;包围的注释块，另一种是以&lt;code&gt;//&lt;/code&gt;为开头的行注释。
建议避免使用&lt;code&gt;/* */&lt;/code&gt;，而用&lt;code&gt;//&lt;/code&gt;注释代替它。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;标识符由一个字母开头，其后可选择性地加上一个或多个字母、数字或下划线。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JavaScript只有一个数字类型。它在内部被表示为64位的浮点数。与其他大多数编程语言不同的是，它没有分离出整数类型，所以1和1.0的值相同。&lt;/p&gt;
&lt;p&gt;如果一个数字字面量有指数部分，那么这个字面量的值等于e之前的数字与10的e之后数字的次方相乘。&lt;/p&gt;
&lt;p&gt;NaN是一个数值，它表示一个不能产生正常结果的运算结果。NaN不等于任何值，包括它自己。可以用函数isNaN(number)检测NaN.&lt;/p&gt;
&lt;p&gt;Infinity表示所有大于1.79769313486231570e+308的值。&lt;/p&gt;
&lt;p&gt;JavaScript有一个对象Math，它包含一套作用于数字的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;字符串字面量可以被包在一对单引号或双引号中，它可能包含0个或多个字符。\（反斜杠）是转义字符。JavaScript中的所有字符都是16位的。&lt;/p&gt;
&lt;p&gt;JavaScript没有字符类型。要表示一个字符，只需创建仅包含一个字符的字符串即可。&lt;/p&gt;
&lt;p&gt;字符串是不可变的。一旦字符串被创建，就永远无法改变它。但可以通过+运算符连接其他字符串来创建一个新字符串。两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同（===）的字符串。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个编译单元包含一组可执行的语句。在Web浏览器中 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 14 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-14:/2013/03/14/read-js-thegoodparts/</guid><category>笔记</category><category>JavaScript</category></item><item><title>JavaScript初学者应知的24条最佳实践（译）</title><link>http://youngsterxyf.github.io/2013/03/11/js-best-practices-for-beginners/</link><description>&lt;p&gt;原文：&lt;a href="http://net.tutsplus.com/tutorials/javascript-ajax/24-javascript-best-practices-for-beginners/"&gt;24 JavaScript Best Practices for Beginners&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（注：阅读原文的时候没有注意发布日期，觉得不错就翻译了，翻译到JSON.parse那一节觉得有点不对路才发现是2009年发布的文章，不过还是不错的啦。另外，文章虽说24条最佳实践，其实只有23条，不知道原作者怎么漏了一条。）&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1.优先使用===，而不是==&lt;/h3&gt;
&lt;p&gt;JavaScript使用两种相等性操作符：===|!==和==|!=。通常认为做比较的最佳实践是使用前一组操作符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"若两个操作数的类型和值相同，那么===比较的结果为真，!==比较的结果为假。" --- JavaScript语言精粹(JavaScript: The Good Parts)
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，如果使用==和!=，当比较不同类型的操作数时，你就会碰到问题啦。在这种情况下，这组操作符会尝试对操作数的值做无用的强制转换。&lt;/p&gt;
&lt;h3&gt;2.Eval就是糟糕的代名词&lt;/h3&gt;
&lt;p&gt;对于那些不熟悉JavaScript的人来说，函数"evel"让我们能够访问JavaScript编译器。我们可以通过给"eval"传递一个字符串参数来得到该字符串执行的结果 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 11 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-11:/2013/03/11/js-best-practices-for-beginners/</guid><category>JavaScript</category><category>翻译</category></item><item><title>电脑重装记</title><link>http://youngsterxyf.github.io/2013/03/09/reinstall-my-computer/</link><description>&lt;p&gt;一台电脑使用时间长了，速度就会越来越慢，也会越来越“脏”，因为经过时间的积累，电脑里多了很多的软件、文件等，这些文件和软件中很多以后是不需要的，在当时因为各种原因而下载或安装了，那么我们就会经常去清理，但对于有点洁癖的人来说，这是不够的，所以会过段时间后就会选择重装电脑，一切重新开始。当然一般都是等到无法忍受的时候，不得已而为之，为什么呢？因为电脑重装后，要想重新打造成一个令自己满意的使用环境需要花一些时间和精力，所以破旧立新也是需要勇气的。&lt;/p&gt;
&lt;p&gt;我笔记本的操作系统是Ubuntu+KDE，从安装使用到现在将近一年了，期间经过7个月的实习，所以将笔记本打造成一个开发环境和测试服务器，Nginx+PHP+Mysql+Memcached啥的都安装全了，还有其他的一些软件都不知道安装了些什么。另外，由于做兴趣项目，我主要选择Python进行开发，对于Python第三方库主要有两种安装方式：一种是使用操作系统本身的软件包管理工具，Ubuntu下即为apt-get；另一种是使用Python的包管理工具，如easy_install，pip。通过这两种方式我的系统里安装了很多大大小小的Python第三方库，也懒得去整理了，所以干脆重装，原来实习时使用的那一套开发环境和测试服务器之后也不一定用得到，并且决定之后所有的Python第三方库全部在virtualenv下安装，保持系统干净。&lt;/p&gt;
&lt;p&gt;那么仍旧装Ubuntu呢还是装其它的Linux发行版呢？如ArchLinux、Gentoo Linux。我想这应该看需求 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 09 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-09:/2013/03/09/reinstall-my-computer/</guid><category>笔记</category></item><item><title>PHP之道---PHP基础知识（译）</title><link>http://youngsterxyf.github.io/2013/03/08/php-basics/</link><description>&lt;p&gt;原文：&lt;a href="http://wulijun.github.com/php-the-right-way/pages/The-Basics.html"&gt;PHP: The Right Way - The Basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="http://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;比较操作符&lt;/h2&gt;
&lt;p&gt;比较操作符往往是PHP的一个被忽视的方面，这会导致很多意想不到的结果。其中的一个问题源于严格比较（布尔值为整数的比较）。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&amp;lt;?php&lt;/span&gt;
$a = 5;     &lt;span style="color: #008000"&gt;// 5为一个整数&lt;/span&gt;

var_dump($a == 5);      &lt;span style="color: #008000"&gt;// 比较值；返回true&lt;/span&gt;
var_dump($a == &lt;span style="color: #a31515"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;);        &lt;span style="color: #008000"&gt;// 比较值（忽略类型）；返回true&lt;/span&gt;
var_dump($a === 5);         &lt;span style="color: #008000"&gt;// 比较类型/值（整数 vs. 整数）；返回true&lt;/span&gt;
var_dump($a === &lt;span style="color: #a31515"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;);       &lt;span style="color: #008000"&gt;// 比较类型/值（整数 vs. 整数）；返回false&lt;/span&gt;

&lt;span style="color: #a31515"&gt;/**&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  * 严格比较&lt;/span&gt;
&lt;span style="color: #a31515"&gt;  */&lt;/span&gt;
&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (strpos …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 08 Mar 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-03-08:/2013/03/08/php-basics/</guid><category>PHP</category><category>翻译</category></item><item><title>数据压缩理论简介（译）</title><link>http://youngsterxyf.github.io/2013/02/27/A-introduction-to-compression/</link><description>&lt;p&gt;原文：&lt;a href="http://imrannazar.com/An-Introduction-to-Compression"&gt;A introduction to compression&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近我在思考GIF和JPEG图片格式之间的不同：为什么某些图片存储为GIF格式所占的磁盘空间更大，而另一些图片以JPEG格式存储要占用更大的磁盘空间？事实证明，这是因为不同的图片格式使用了不同的压缩方法。&lt;/p&gt;
&lt;p&gt;压缩是一组程序的简便说法，这些程序能够将数据装进更小的存储空间中，也能将数据从压缩编码中重新取回。这是一个双向的过程：输入文件能够产生经过压缩的输出，并且算法根据压缩后的输出能够重新给你一个输入的拷贝。&lt;/p&gt;
&lt;h2&gt;冗余：行程长度编码（Run-Length Encoding）&lt;/h2&gt;
&lt;p&gt;使压缩成为可能的是冗余：事实表明大多数的数据都以某种方式重复自己。例如，在一个文档中可能多次使用同一个单词，或者一张图片的多处包含相同的颜色。一个非常简单的冗余数据片段的示例如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redundancy: Before compression&lt;/p&gt;
&lt;p&gt;AAAAABBWWWWWWWWWPPPPQZMMMMVVV&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这种情况下，冗余是明显的；整个样本中重复出现了一系列字母。压缩这种数据的一种简单方式是通过重复次数来代表重复出现的字母，从而削减了样本的总长度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redundancy: After compression&lt;/p&gt;
&lt;p&gt;A5B2W9P4Q1Z1M4V3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法读取样本编码后的版本将能够完美地重现原来的数据："A" 5次，"B"
2次，等等。这个简单算法的使用非常广泛，被称为行程长度编码（RLE …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 27 Feb 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-02-27:/2013/02/27/A-introduction-to-compression/</guid><category>理论</category><category>翻译</category></item><item><title>JavaScript：继承和原型链（译）</title><link>http://youngsterxyf.github.io/2013/02/27/Inheritance-and-the-prototype-chain/</link><description>&lt;p&gt;原文：&lt;a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Inheritance_and_the_prototype_chain"&gt;Inheritance and the prototype chain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于具备基于类的编程语言（如Java或C++）经验的程序员来说，JavaScript有点混乱，因为它是一种动态语言，并且不提供&lt;code&gt;class&lt;/code&gt;的实现（虽然关键字&lt;code&gt;class&lt;/code&gt;是保留的，不可用作变量名）。&lt;/p&gt;
&lt;p&gt;说到继承，JavaScript只有一种结构：对象。每个对象都有一个内部链接指向另一个对象，这个对象称为&lt;strong&gt;原型&lt;/strong&gt; (prototype)。那个原型对象也有自己的原型，如此直到某个对象以&lt;code&gt;null&lt;/code&gt;作为其原型。&lt;code&gt;null&lt;/code&gt;，根据定义，没有原型，作为这种&lt;strong&gt;原型链&lt;/strong&gt;的最后一环而存在。&lt;/p&gt;
&lt;h2&gt;以原型链实现继承&lt;/h2&gt;
&lt;h3&gt;继承属性&lt;/h3&gt;
&lt;p&gt;JavaScript对象可看作是动态地装载属性（这里指&lt;strong&gt;自有属性&lt;/strong&gt;）的"包包"，并且每个对象都有一个链指向一个原型对象。如下即为当尝试访问一个属性时发生的事情：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008000"&gt;// 假设有个对象o，其原型链如下所示：&lt;/span&gt;
&lt;span style="color: #008000"&gt;// {a: 1 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 27 Feb 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-02-27:/2013/02/27/Inheritance-and-the-prototype-chain/</guid><category>JavaScript</category><category>翻译</category></item><item><title>Python格式字符串（译）</title><link>http://youngsterxyf.github.io/2013/01/26/python-string-format/</link><description>&lt;p&gt;原文：&lt;a href="http://mkaz.com/solog/python-string-format"&gt;Python String Format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每次使用Python的格式字符串（string formatter），2.7及以上版本的，我都会犯错，并且有生之年，我想我都理解不了它们的文档。我非常习惯于更老的
&lt;code&gt;%&lt;/code&gt; 方法。所以着手编写自己的格式字符串手册。若你有一些其他好的示例请告知我。&lt;/p&gt;
&lt;h2&gt;格式字符串手册&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数字格式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的表格展示了使用Python的后起新秀str.format()格式化数字的多种方法，包含浮点数格式化与整数格式化示例。可使用
&lt;code&gt;print("FORMAT".format(NUMBER));&lt;/code&gt; 来运行示例，因此你可以运行：
&lt;code&gt;print("{:.2f}".format(3.1415926));&lt;/code&gt; 来得到第一个示例的输出。&lt;/p&gt;
&lt;table border="1" align="center" width="80%"&gt;
&lt;tr&gt;&lt;th width="10%"&gt;数字&lt;/th&gt;&lt;th width="10%"&gt;格式&lt;/th&gt;&lt;th width="12%"&gt;输出
&lt;/th&gt;&lt;th width="65%"&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 3.1415926 &lt;/td&gt;
    &lt;td&gt; {:.2f} &lt;/td&gt;
    &lt;td&gt; 3.14 &lt;/td&gt;
    &lt;td&gt; 保留小数点后两位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 3.1415926 &lt;/td&gt;
    &lt;td&gt; {:+.2f …&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 26 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-26:/2013/01/26/python-string-format/</guid><category>Python</category><category>翻译</category></item><item><title>python周刊-第70期（译）</title><link>http://youngsterxyf.github.io/2013/01/25/issue-70-of-python-weekly/</link><description>&lt;p&gt;原文：&lt;a href="http://us2.campaign-archive1.com/?u=e2e180baf855ac797ef407fc7&amp;amp;id=7fc9a4c2e2&amp;amp;e=59f9a3c7e0"&gt;issue 70 of Python Weekly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章，教程和讲座(Articles, Tutorials and Talks)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jakevdp.github.com/blog/2013/01/13/hacking-super-mario-bros-with-python/"&gt;使用Python Hacking超级马里奥(Hacking Super Mario Bros. With Python)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This post shows how you can use matplotlib's animation tool to create animated
gifs based on Super Mario Bros in Python.&lt;/p&gt;
&lt;p&gt;该文展示如何使用matplotlib的动画工具使用Python创建超级马里奥的动画效果gif图。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tech.shift.com/post/40299429203/implementing-a-python-oauth-2-0-provider-part-2"&gt;实现一个Python OAuth 2.0 提供方 - 第2部分 …&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 25 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-25:/2013/01/25/issue-70-of-python-weekly/</guid><category>python</category><category>python-weekly</category><category>翻译</category></item><item><title>回顾12，展望13（技术篇）</title><link>http://youngsterxyf.github.io/2013/01/22/technology-12-13/</link><description>&lt;p&gt;终归是个搞技术的，所以怎么也得搞个总结与展望的特别篇，讲述过去一年的技术学习与成果，规划接下来一年技术学习的计划。&lt;/p&gt;
&lt;p&gt;2012年，阅读较少，写的代码较多，经过几个小项目以及实习，终于觉得自己有点攻城师的样子了，甚感欣慰，哈哈。&lt;/p&gt;
&lt;p&gt;罗列一下个人的小项目，虽然不复杂，代码量不多，代码也写得不漂亮，但自认为有那么点用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;百度音乐下载器：&lt;a href="https://github.com/youngsterxyf/Baidu_Music_Downloader"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/Baidu_Music_Downloader/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简易FTP搜索引擎：&lt;a href="https://github.com/youngsterxyf/simpleFTPsearch"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/simpleFTPsearch/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;，&lt;a href="http://202.120.40.101/services/ftpsearch/"&gt;应用&lt;/a&gt;（注：这个小项目断断续续做了一年，经历了几个版本，以及几次更新，目前看起来还不错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于Web的机器人远程控制：&lt;a href="https://github.com/youngsterxyf/WebBasedRobot"&gt;代码&lt;/a&gt;，&lt;a href="http://youngsterxyf.github.com/WebBasedRobot/"&gt;项目主页&lt;/a&gt; &lt;s&gt;（墙外）&lt;/s&gt;（注：这个项目就是我那尽是水的毕业设计啦，哈哈）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在线代码高亮，分享以及运行：&lt;a href="https://github.com/youngsterxyf/colorfulCode"&gt;代码&lt;/a&gt;（注：这个项目其实很不完整的啦，代码编译与执行部分根本没做防护措施，根本没法实际使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Loven的个人静态站点：&lt;a href="https://github.com/Loven-Project/lovenworks"&gt;代码&lt;/a&gt;（注：其实绝大部分的代码都是loven自己写的啦，我主要写了实现总体动态效果的javascript程序，而且还是仿照的 …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 22 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-22:/2013/01/22/technology-12-13/</guid><category>总结</category><category>技术</category></item><item><title>回顾2012，展望2013</title><link>http://youngsterxyf.github.io/2013/01/18/review12-lookinto13/</link><description>&lt;p&gt;过去的一年里发生了很多事情，很大一部分原来就已在&lt;a href="http://youngsterxyf.github.io/2012/01/01/2011-summary/"&gt;2011年终-回顾与展望&lt;/a&gt;一文中提及---实习、找工作、毕业，除此之外还有：我和女朋友定亲了，总算朝着婚姻近了一步，哈哈。&lt;/p&gt;
&lt;h2&gt;实习&lt;/h2&gt;
&lt;p&gt;关于实习有太多的话想说。7个月的时间里浓缩了太多的欢乐，太欢乐了。原本以为我的读书生涯就要这么平淡无奇地结束了，没想到在这个结尾处竟然给了我个大惊喜，所谓惊喜并不是这份实习有多牛逼，而是遇到了一群欢乐的人，一群“重口味”的人，一群彪悍的人，而其中绝大部分是女人，噢，女生更恰当些。&lt;/p&gt;
&lt;p&gt;在G1C1，我快乐地写代码，上班是种享受，我想以后很可能不会再有这样的享受了。在G1C1，我逐步地发展成为一个吃货，所以毫无疑问地胖了，原本我以为自己会一直瘦下去。另外，我也黑了，因为经过了无数次地“被黑”，但她们说我应该高兴才对，她们“黑”我是因为“爱”我。关于“黑”这件事情，刚入职的时候，我是很同情wenbin的，因为见他被“黑 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 18 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-18:/2013/01/18/review12-lookinto13/</guid><category>总结</category><category>文字</category></item><item><title>可扩展的Web架构与分布式系统（译）</title><link>http://youngsterxyf.github.io/2013/01/16/scalable-web-architecture-and-distributed-systems/</link><description>&lt;p&gt;原文：&lt;a href="http://www.aosabook.org/en/distsys.html"&gt;Scalable Web Architecture and Distributed Systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开源软件已成为一些最大型网站的基础组件。并且随着那些网站的发展，围绕它们的架构出现了一些最佳实践与指导性原则。本章尝试阐述设计大型网站需要考虑的一些关键问题，以及一些实现这些目标的组件。&lt;/p&gt;
&lt;p&gt;本章主要侧重于Web系统，虽然其中一些内容也适用于其它分布式系统。&lt;/p&gt;
&lt;h2&gt;Web分布式系统设计原则&lt;/h2&gt;
&lt;p&gt;构建和运维一个可扩展Web站点或者应用到底意味着什么？说到底这种系统只不过是通过互联网将用户与远程资源相连接---使其可扩展的是分布于多个服务器的资源，或者对这些资源的访问。&lt;/p&gt;
&lt;p&gt;类似于生活中的大多数东西，从长远来说，构建一个web服务之前花些时间提前规划是很有帮助的。理解大型网站背后一些需要考虑的因素与权衡取舍，在创建小一些的web站点时能让你作出更明智的决策。以下是影响大规模web系统设计的一些核心原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可用性：&lt;/strong&gt;
一个网站的正常运行时间对于许多公司的声誉与运作都是至关重要的。对于一些更大的在线零售站点，几分钟的不可用都会造成数千或数百万美元的营收损失，因此系统设计得能够持续服务，并且能迅速从故障中恢复是技术和业务的最基本要求。分布式系统中的高可用性需要仔细考虑关键部件的冗余，从部分系统故障中迅速恢复，以及问题发生时优雅降级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能：&lt;/strong&gt;
对于多数站点而言，网站的性能已成为一个重要的考虑因素。网站的速度影响着使用和用户满意度，以及搜索引擎排名，与营收和是否能留住用户直接相关。因此，创建一个针对快速响应与低延迟进行优化的系统非常重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可靠性：&lt;/strong&gt;
系统必须是可靠的，这样相同数据请求才会始终返回相同的数据。数据变换或更新之后，同样的请求则应该返回新的数据。用户应该知道一点：如果东西写入了系统 …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 16 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-16:/2013/01/16/scalable-web-architecture-and-distributed-systems/</guid><category>分布式系统</category><category>翻译</category></item><item><title>精心挑选的数据可视化工具推荐列表（译）</title><link>http://youngsterxyf.github.io/2013/01/15/a-carefully-selected-list-of-recommended-tools/</link><description>&lt;p&gt;原文： &lt;a href="http://datavisualization.ch/tools/selected-tools/"&gt;A Carefully Selected List of Recommended Tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当我和很多人谈论我们的工作时，经常被问到我们使用什么技术实现交互式和动态的数据可视化。对于实现交互式的东西，我们有一套首选的代码库、应用程序以及服务，在工作中经常使用。根据项目的需求，我们会选择最合适的工具来完成工作。有时，为构建某些有用的东西你所需要的可能就是一个非常简单的工具。在别的情况下，则可能需要一套用于解决多种问题的工具集。但是如何选择恰当的工具呢？可用的工具数都数不清，所以很多时候朋友的推荐非常有价值。&lt;/p&gt;
&lt;p&gt;这就是为什么我们要将使用得最多并且喜欢使用的工具汇集起来。我们将这个精选工具集称为&lt;strong&gt;&lt;a href="http://selection.datavisualization.ch/"&gt;selection.datavisualization.ch&lt;/a&gt;&lt;/strong&gt; 。它包含绘制地图数据的代码库，创建图表的框架，以及简化数据处理的工具。即使你不喜欢编程，也可以不用写一行代码就能使用某些应用。我们会将该工具列表看作一个动态变化的仓库，随着技术发展增删某些东西。我们希望这能帮助你为下一个工作任务找到最佳的工具。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://selection.datavisualization.ch"&gt;&lt;img alt="datavisualization_selection" src="http://datavisualization.ch/wp-content/uploads/2012/05/datavisualization_selection_021.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在我来回答一些你最可能会问的问题：不，该列表并没有收录所有相关工具，所以你可能没看到你个人喜欢的。是的，其中提到的某些库刚刚兴起，可能还没到可以应用于产品的时候，而另一些库也已经有了替代者，但它们仍然可以提供良好的服务。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 15 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-15:/2013/01/15/a-carefully-selected-list-of-recommended-tools/</guid><category>数据可视化</category><category>翻译</category></item><item><title>github pages构建失败问题解决</title><link>http://youngsterxyf.github.io/2013/01/08/fix-github-pages-builds-failed/</link><description>&lt;p&gt;今天为本博客提交更新后，github
pages自动构建始终不成功。原以为是新提交中引入了错误，于是按照&lt;a href="/2013/01/08/git-cancel-commits/"&gt;Git操作：强制删除提交到远程版本库的数据与版本记录&lt;/a&gt;的方法取消了所有的更新，但依旧没用。&lt;/p&gt;
&lt;p&gt;由于构建的结果邮件中只有这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The page build failed with the following error: page build failed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于构建失败的原因一丁点都没有告诉我们，所以根本没法调试嘛。&lt;/p&gt;
&lt;p&gt;在阅读github的官方帮助文档&lt;a href="https://help.github.com/articles/pages-don-t-build-unable-to-run-jekyll"&gt;Pages don't build: "Unable to run Jekyll"&lt;/a&gt;后，决定按照其中Syntax errors部分的内容做如下尝试：&lt;/p&gt;
&lt;p&gt;首先，按照&lt;a href="https://github.com/mojombo/jekyll/wiki/install"&gt;jekyll的官方安装文档&lt;/a&gt;安装jekyll：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo gem install jekyll
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，在博客的根目录下，执行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;jekyll --safe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令会输出详细的信息，如果构建失败，则在输出的信息中查找错误原因 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 08 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-08:/2013/01/08/fix-github-pages-builds-failed/</guid><category>github</category><category>jekyll</category></item><item><title>Git操作：强制删除提交到远程版本库的数据与版本记录</title><link>http://youngsterxyf.github.io/2013/01/08/git-cancel-commits/</link><description>&lt;p&gt;今天因为某些尚不明了的问题导致，博客的Git pages始终构建失败，于是想在远程版本库中删除前几次提交。在&lt;a href="http://www.douban.com/note/189603387/"&gt;该网页&lt;/a&gt;上找到了解决方案：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;git reset --hard HEAD~2                   &lt;span style="color: #008000"&gt;# 取消当前版本之前的两次提交&lt;/span&gt;
git push origin HEAD --force              &lt;span style="color: #008000"&gt;# 强制提交到远程版本库，从而删除之前的两次提交数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 08 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-08:/2013/01/08/git-cancel-commits/</guid><category>Git</category><category>版本控制</category></item><item><title>装饰器与函数式Python（译）</title><link>http://youngsterxyf.github.io/2013/01/04/Decorators-and-Functional-Python/</link><description>&lt;p&gt;原文：&lt;a href="http://www.brianholdefehr.com/decorators-and-functional-python"&gt;Decorators and Functional Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装饰器是Python的一大特色。除了在语言中的原本用处，还帮助我们以一种有趣的方式（函数式）进行思考。&lt;/p&gt;
&lt;p&gt;我打算自底向上解释装饰器如何工作。首先解释几个话题以帮助理解装饰器。然后，深入一点探索几个简单的装饰器以及它们如何工作。最后，讨论一些更高级的使用装饰器的方式，比如：传递可选参数给装饰器或者串接几个装饰器。&lt;/p&gt;
&lt;p&gt;首先以我能想到的最简单的方式来定义Python函数是什么。基于该定义，我们可以类似的简单方式来定义装饰器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数是一个完成特定任务的可复用代码块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好的，那么装饰器又是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是一个修改其他函数的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在在装饰器的定义上进行详述，先解释一些先决条件。&lt;/p&gt;
&lt;h2&gt;函数是一等对象&lt;/h2&gt;
&lt;p&gt;Python中，所有东西都是对象。这意味着可以通过名字引用函数，以及像其他对象那样传递。例如：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; traveling_function():
    print &lt;span style="color: #a31515"&gt;&amp;quot;Here I am!&amp;quot;&lt;/span&gt;

function_dict = {
    &lt;span style="color: #a31515"&gt;&amp;quot;func&amp;quot;&lt;/span&gt;: traveling_function
}

trav_func = function_dict[&lt;span style="color: #a31515"&gt;&amp;#39;func&amp;#39;&lt;/span&gt;]
trav_func()
&lt;span style="color: #008000"&gt;# &amp;gt;&amp;gt; Here I …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 04 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-04:/2013/01/04/Decorators-and-Functional-Python/</guid><category>Python</category><category>翻译</category></item><item><title>Python：字典剧本（译）</title><link>http://youngsterxyf.github.io/2013/01/04/Python-The-Dictionary-Playbook-cn/</link><description>&lt;p&gt;原文： &lt;a href="http://blog.amir.rachum.com/post/39501813266/python-the-dictionary-playbook"&gt;Python: The Dictionary Playbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我经常碰到关于Python中字典的各种样板代码，因此我决定在此展示一些，并分享完成相同操作的更加简洁的方式。&lt;/p&gt;
&lt;p&gt;上演： &lt;strong&gt;字典剧本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="playbook" src="/assets/uploads/pics/The_playbook.png"&gt;&lt;/p&gt;
&lt;p&gt;1.
“你在吗？”&lt;/p&gt;
&lt;p&gt;这个相当简单，但不可错过 - 找出某个键(key)是否存在于字典中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;蹩脚的版本&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;dct.has_key(key)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Pythonic的方式&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;key &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
“尤达测试”(译注：尤达的意思见&lt;a href="http://en.wikipedia.org/wiki/Yoda"&gt;yoda&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;对于那些掌握了“你在吗”剧本的程序员来说，这通常是另一个简单但是令人讨厌的事情。它不仅仅可用于字典数据类型，但非常普通。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;干这事，你必须不能这样&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;not&lt;/span&gt; key &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;英语，你会说吗？&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;key &lt;span style="color: #0000ff"&gt;not&lt;/span&gt; &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; dct …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 04 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-04:/2013/01/04/Python-The-Dictionary-Playbook-cn/</guid><category>Python</category><category>翻译</category></item><item><title>一行Python代码定义树（译）</title><link>http://youngsterxyf.github.io/2013/01/04/one-line-tree-in-Python/</link><description>&lt;p&gt;原文：&lt;a href="https://gist.github.com/2012250"&gt;One-line Tree in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href="https://github.com/youngsterxyf"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Python内置的&lt;a href="http://docs.python.org/2/library/collections.html#collections.defaultdict"&gt;defaultdict&lt;/a&gt;可以轻松定义一棵树：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; tree(): &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; defaultdict(tree)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就这样！&lt;/p&gt;
&lt;p&gt;这段代码简单地说明一棵树是一个字典，其缺省的值（译注：与键对应的值的概念）是树。&lt;/p&gt;
&lt;p&gt;（如果你正随着我写下代码，请先确保 &lt;code&gt;from collections import defaultdict&lt;/code&gt; ）&lt;/p&gt;
&lt;p&gt;（还有：Hacker News读者@zbuc指出这种方法被称为&lt;a href="https://en.wikipedia.org/wiki/Autovivification"&gt;自动唤醒&lt;/a&gt;。Cool！）&lt;/p&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;h3&gt;JSON形式&lt;/h3&gt;
&lt;p&gt;现在我们可以创建JSON式的嵌套字典，而无需显式创建子级字典——当我们引用它们，就会神奇地自动产生：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;users = tree()
users[&lt;span style="color: #a31515"&gt;&amp;#39;harold&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;] = &lt;span style="color: #a31515"&gt;&amp;#39;hrldcpr&amp;#39;&lt;/span&gt;
users[&lt;span style="color: #a31515"&gt;&amp;#39;handler&amp;#39;&lt;/span&gt;][&lt;span style="color: #a31515"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;] = &lt;span style="color: #a31515"&gt;&amp;#39;matthandlersux&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以使用 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 04 Jan 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2013-01-04:/2013/01/04/one-line-tree-in-Python/</guid><category>Python</category><category>翻译</category></item><item><title>几个组合命令</title><link>http://youngsterxyf.github.io/2012/12/12/several-command-line/</link><description>&lt;p&gt;1.
Debian系Linux下查找某个软件包(以indent为例)：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;apt-cache search indent | awk &lt;span style="color: #a31515"&gt;&amp;#39;{if($1~/^indent$/) print $0}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;APT包管理工具也提供了类似功能的命令选项：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;apt-cache pkgnames &lt;span style="color: #a31515"&gt;&amp;#39;indent&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只不过这个输出仅有包名没有简介信息。&lt;/p&gt;
&lt;p&gt;2.
对当前目录下的所有C源码文件使用indent进行格式化：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ls | grep &lt;span style="color: #a31515"&gt;&amp;#39;\.c$&amp;#39;&lt;/span&gt; | xargs indent
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实如下也是可以的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;indent *.c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但因为shell会对*进行展开，如果当前目录下的C源码文件数目很大时，可能会造成命令行长度过长的问题。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 12 Dec 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-12-12:/2012/12/12/several-command-line/</guid><category>Linux</category><category>命令行</category></item><item><title>高性能MySQL - 1.MySQL架构</title><link>http://youngsterxyf.github.io/2012/12/11/high-performance-MySQL-1/</link><description>&lt;h2&gt;MySQL逻辑架构&lt;/h2&gt;
&lt;p&gt;&lt;img alt="mysql-arch" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/mysql-arch.jpg"&gt;&lt;/p&gt;
&lt;p&gt;1.
每个客户连接在服务器进程中都拥有自己的线程，每个连接所属的查询都会在指定的某个单独线程中完成，这些线程轮流运行在某个CPU核心或CPU上。服务器负责缓存线程，因此不需要为每个新的连接重建或撤销线程。&lt;/p&gt;
&lt;p&gt;2.
MySQL会解析查询，并创建一个内部数据结构(解析树)，然后对其进行各种优化。其中包括重写查询，决定查询的读表顺序，以及选择需使用的索引等。用户可以通过特殊的关键字给优化器传递各种提示，影响它的决策过程。另外还可以请求服务器给出优化过程的各种说明，使用户可以知晓服务器是如何进行优化决策的，为用户提供一个参考基准，方便用户重写查询、架构和修改相关配置，便于应用尽可能高效地运行。&lt;/p&gt;
&lt;p&gt;优化器并不关心某个表使用哪种存储引擎，但存储引擎对服务器的查询优化过程有影响。优化器会请求存储引擎为某种具体操作提供性能与开销方面的信息，以及表内数据的统计信息。&lt;/p&gt;
&lt;p&gt;不过，在解析查询之前，服务器会"询问"查询缓存，它只能保存SELECT语句和相应的结果。如果能在缓存中找到将要执行的查询，服务器就不必重新解析、优化或重新执行查询，只需直接返回已有结果即可。&lt;/p&gt;
&lt;h2&gt;并发控制&lt;/h2&gt;
&lt;p&gt;1.
读锁(Read Lock)/写锁(Write Lock)：并发控制的概念很简单-在处理并发写或并发读时，系统会使用一套锁系统来解决问题。这种锁系统由两类锁组成，通常称之为 &lt;strong&gt;共享锁 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 11 Dec 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-12-11:/2012/12/11/high-performance-MySQL-1/</guid><category>数据库</category><category>MySQL</category></item><item><title>日志信息命令行实时输出</title><link>http://youngsterxyf.github.io/2012/12/10/tail-and-xtail/</link><description>&lt;p&gt;Web开发中很多时候需要边看web服务器的日志输出边调试代码。一般的做法使用tail命令输出日志文件的末尾几行日志信息。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;tail -10 /var/log/nginx/access.log  &lt;span style="color: #008000"&gt;# 输出末尾10行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但这样的输出是静态的。在这个命令执行之后，日志文件里新增的日志信息无法直接看到。调试的时候，一遍又一遍地使用这样的命令去查询就显得非常麻烦。那有没有办法来监听日志文件的变化，实时输出最新的日志信息呢？ &lt;strong&gt;xtail&lt;/strong&gt; 就专为这个问题而存在的。它可以监听文件或者目录(监听目录就是监听该目录下的所有文件)。比如我在写本文时，在另一个命令行窗口里执行：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;xtail ./
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么每次vim保存内容时，那个窗口就会产生事件输出最新的文件内容。&lt;/p&gt;
&lt;p&gt;这样在调试web程序的时候就很方便啦。&lt;/p&gt;
&lt;p&gt;其实tail本身就支持监听文件并实时命令行输出。在xtail的&lt;a href="http://www.unicom.com/sw/xtail"&gt;项目主页&lt;/a&gt;上有这样的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xtail watches the growth of files. It's like running a tail -f on a bunch of files at once …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 10 Dec 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-12-10:/2012/12/10/tail-and-xtail/</guid><category>linux</category><category>命令</category><category>调试</category></item><item><title>VMware面试题目总结</title><link>http://youngsterxyf.github.io/2012/12/06/VMware-interview/</link><description>&lt;p&gt;&lt;strong&gt;一面&lt;/strong&gt;中主要有三道题：&lt;/p&gt;
&lt;p&gt;1.
实现strcpy。函数原型：char&lt;em&gt; strcpy(char&lt;/em&gt; dest, const char* src)。&lt;/p&gt;
&lt;p&gt;后来发现自己实现的有问题。正确的实现应该如下：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* strcpy(&lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* dest, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* src)
{
    assert(dest!=NULL &amp;amp;&amp;amp; src!=NULL);
    &lt;span style="color: #2b91af"&gt;char&lt;/span&gt;* ret = dest;
    &lt;span style="color: #0000ff"&gt;while&lt;/span&gt;((*dest++ = *src++) != &lt;span style="color: #a31515"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;);
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ret;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个题目做得不好，我对自己很失望啊。&lt;/p&gt;
&lt;p&gt;2.
给2n+1个数，其中n个数均出现了2次，有1个数只出现了1次，如何找出这个数？&lt;/p&gt;
&lt;p&gt;如果用python的dict数据结构来实现会很简单，一次遍历统计每个数出现的次数就可以了。如果是这样的话，就不需要将题目限制为只有一个1个数只出现了一次了，所以肯定有更好的算法。&lt;/p&gt;
&lt;p&gt;其实更好的方法是这样的：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #2b91af"&gt;int …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 06 Dec 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-12-06:/2012/12/06/VMware-interview/</guid><category>VMware</category><category>面试</category></item><item><title>博大精深的ps命令</title><link>http://youngsterxyf.github.io/2012/12/06/profound-ps/</link><description>&lt;p&gt;Linux命令行里如何获取所有的进程号(pid)？&lt;/p&gt;
&lt;p&gt;1.
第一种方法是通过ps -e或者ps aux获得所有进程的信息，然后通过管道传给grep或者awk进行数据过滤，比如&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ps -e | awk &lt;span style="color: #a31515"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
其实通过ps自身的选项就可以实现： &lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ps -eo pid
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而且输出还是排好序的。&lt;/p&gt;
&lt;p&gt;但ps命令在输出进程信息之前先输出一行header，比如ps -e的输出header是：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;PID TTY          TIME CMD
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如何去除这个header呢？当然用各种过滤方法可以实现，但ps自身的选项也可以实现：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ps -eo pid h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ps -eo pid --no-headers
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 06 Dec 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-12-06:/2012/12/06/profound-ps/</guid><category>Linux</category><category>命令行</category><category>工具</category></item><item><title>2012校招-sonicWALL的两道编程笔试题</title><link>http://youngsterxyf.github.io/2012/12/05/sonicWALL-exam/</link><description>&lt;h2&gt;求二叉树中两个结点的最近公共祖先&lt;/h2&gt;
&lt;p&gt;比如：对于树&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;         A&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;       /&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;      B&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;    /   \&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;   C     D&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt; /   \&lt;/span&gt;
&lt;span style="border: 1px solid #FF0000"&gt;E     F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;结点D，F的最近公共祖先为B&lt;/p&gt;
&lt;p&gt;实现：&lt;a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/nearest_common_ancestor.c"&gt;见源码&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;求二进制整数部分bits求反后的值&lt;/h2&gt;
&lt;p&gt;比如：对于整数0b1001101，将第2(begin)到第5(end)位(从右往左计数)上的bit求反，得到0b1110001。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;#include&lt;/span&gt; &lt;span style="color: #008000"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;&lt;/span&gt;

&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; reverse_somebits(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; a, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; begin, &lt;span style="color: #2b91af"&gt;int&lt;/span&gt; end)
{
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; a^((1&amp;lt;&amp;lt;end)|((1&amp;lt;&amp;lt;end)-1))^((1&amp;lt;&amp;lt;begin)-1);
}

&lt;span style="color: #2b91af"&gt;void&lt;/span&gt; ten_to_two(&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; a)
{
    &lt;span style="color: #0000ff"&gt;if …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 05 Dec 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-12-05:/2012/12/05/sonicWALL-exam/</guid><category>笔试</category><category>算法</category></item><item><title>CentOS + rsync + inotify-tools实时备份配置</title><link>http://youngsterxyf.github.io/2012/11/29/centos+rsync+inotify-tools-realtime-backup/</link><description>&lt;p&gt;现实中，服务器可能会因为各种原因而crash掉，从而造成数据丢失或者服务的暂时不可用。为了提高服务的可用性以及数据的安全性，就需要对数据进行备份，以便数据恢复或者服务的动态切换(将访问请求动态重定向到备份服务器)。&lt;/p&gt;
&lt;p&gt;常见的备份方法是定时的rsync任务或者远程拷贝。但这种方式，如果定时的间隔较大，那么服务器宕掉后，还是会丢失部分数据，动态切换的服务也不是宕机前的最新状态。为了支持实时数据同步，Linux 2.6.13 内核中新引入文件系统变化通知机制inotify，一旦对文件系统有改动，就会触发相关事件任务。通过结合rsync，inotify能够很好地完成实时同步任务。&lt;/p&gt;
&lt;p&gt;主服务器：1.1.1.1
备份服务器：0.0.0.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.
主服务器，备份服务器上安装rsync:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo yum install rsync
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
主服务器上安装inotify-tools:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inotify-tools
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.
备份服务器上添加配置文件/etc …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 29 Nov 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-11-29:/2012/11/29/centos+rsync+inotify-tools-realtime-backup/</guid><category>服务器</category><category>工具</category><category>Linux</category></item><item><title>GoAccess用户手册（译）</title><link>http://youngsterxyf.github.io/2012/11/29/goaccess-man-page-cn/</link><description>&lt;p&gt;原文：&lt;a href="http://goaccess.prosoftcorp.com/man"&gt;http://goaccess.prosoftcorp.com/man&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译：youngsterxyf&lt;/p&gt;
&lt;h2&gt;名称&lt;/h2&gt;
&lt;p&gt;goaccess - 快速的web日志分析器与交互式查看器&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;goaccess  [-f 输入文件]  [-c]  [-e]  [-a]&lt;/p&gt;
&lt;h2&gt;描述&lt;/h2&gt;
&lt;p&gt;goaccess是一个实时的web日志分析器，以及交互式查看器，在类Unix系统的终端(terminal)上运行，是一个基于GPL的自由软件。为需要可视化服务器报告的系统管理员提供快速而重要的HTTP统计信息。首先它会解析web日志文件，从被解析文件中收集数据，然后展示在控制台(console)或者X终端上。收集到的信息会在一个可视化/交互式的窗口中展示给用户，包括：&lt;/p&gt;
&lt;h3&gt;综合统计数字&lt;/h3&gt;
&lt;p&gt;有效请求的总数，无效请求的总数，数据分析的总时间，独立访客总数，被请求的独立文件总数，独立静态文件总数(css, ico, jpg, swf, gif, png)，独立HTTP引荐网站(URL)总数 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 29 Nov 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-11-29:/2012/11/29/goaccess-man-page-cn/</guid><category>翻译</category><category>工具</category></item><item><title>pi的一种并行算法</title><link>http://youngsterxyf.github.io/2012/11/22/pi-parallel-algorithm/</link><description>&lt;p&gt;我们都知道圆周率pi的值是3.141592653...，那么这个值是怎么算出来的呢？一种方式是通过某种方式算出圆的面积或者周长，然后根据公式$ S = pi \times r^2 $(或$ L = 2 \times pi \times r $)算出pi的值。但如何用计算机通过某种算法计算而得？有没有并行的算法？&lt;/p&gt;
&lt;p&gt;&lt;a href="/assets/uploads/files/mapreduce_intro.pdf"&gt;Introduction to Parallel Programming and MapReduce&lt;/a&gt;一文中介绍了一种基于概率的并行算法---假设有个正方形，里面有个內切圆。&lt;/p&gt;
&lt;p&gt;&lt;img alt="sample pic" src="/assets/uploads/pics/inscribe.png"&gt;&lt;/p&gt;
&lt;p&gt;设内切圆的半径为$ r $，则&lt;/p&gt;
&lt;p&gt;正方形的面积为$ S_z = 4r^2 $&lt;/p&gt;
&lt;p&gt;内切圆的面积为$ S_y = pi \times r^2 $&lt;/p&gt;
&lt;p&gt;那么$ pi = \frac{ S_y }{ r^2 } = \frac{ S_y }{ S_z …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 22 Nov 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-11-22:/2012/11/22/pi-parallel-algorithm/</guid><category>算法</category><category>并行</category><category>Python</category></item><item><title>诗歌选</title><link>http://youngsterxyf.github.io/2012/11/20/poems/</link><description>&lt;h3&gt;南乡子&lt;/h3&gt;
&lt;h4&gt;和杨元素，时移守密州&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;苏轼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;东武望余杭，云海天涯两杳茫。何日功成名遂了，还乡，醉笑陪公三万场。&lt;/p&gt;
&lt;p&gt;不用诉离觞，痛饮从来别有肠。今夜送归灯火冷，河塘，堕泪羊公却姓杨。&lt;/p&gt;
&lt;h3&gt;临江仙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;杨慎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;滚滚长江东逝水，浪花淘尽英雄。是非成败转头空，青山依旧在，几度夕阳红。&lt;/p&gt;
&lt;p&gt;白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢，古今多少事。都付笑谈中。&lt;/p&gt;
&lt;h3&gt;结结巴巴&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;伊沙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结结巴巴我的嘴&lt;br /&gt; 
二二二等残废&lt;br /&gt;
咬不住我狂狂狂奔的思维&lt;br /&gt;
还有我的腿&lt;br /&gt;
&lt;br /&gt;
你们四处流流流淌的口水&lt;br /&gt;
散着霉味&lt;br /&gt;
我我我的肺&lt;br /&gt;
多么劳累&lt;br /&gt;
&lt;br /&gt;
我要突突突围&lt;br /&gt;
你们莫莫莫名奇妙&lt;br /&gt;
的节奏&lt;br /&gt;
急待突围&lt;br /&gt;
&lt;br /&gt;
我我我的&lt;br /&gt;
我的机枪点点点射般&lt;br /&gt;
的语言&lt;br /&gt;
充满快慰&lt;br /&gt;
&lt;br /&gt;
结结巴巴我的命&lt;br /&gt;
我的命里没没没有鬼&lt;br /&gt;
你们瞧瞧瞧我&lt;br /&gt;
一脸无所谓&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;父亲和我&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;吕德安 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 20 Nov 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-11-20:/2012/11/20/poems/</guid><category>阅读</category><category>诗歌</category></item><item><title>面试准备</title><link>http://youngsterxyf.github.io/2012/11/20/prepareForInterview/</link><description>&lt;h3&gt;自我介绍&lt;/h3&gt;
&lt;p&gt;我叫夏永锋，目前是一名上海交大的硕士研究生，将于2013年3月毕业。现在作为一名web开发实习生在Google CSR部门实习。实习的工作内容主要包括：开发维护部门旗下的几个网站以及服务器日常运维。&lt;/p&gt;
&lt;p&gt;我的老家是江西省婺源县，她非常美丽，有“中国最美的乡村”的美誉。&lt;/p&gt;
&lt;p&gt;我喜欢写程序，羽毛球，长跑。我觉得编程是一种乐趣，编程是程序员的魔法。&lt;/p&gt;
&lt;p&gt;My name is Xia yongfeng, currently i am a master candidate from School of Software, Shanghai Jiaotong University. And i will graduate in 2013. Now I am a web development intern in …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 20 Nov 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-11-20:/2012/11/20/prepareForInterview/</guid><category>面试</category><category>英语</category></item><item><title>笔试题目</title><link>http://youngsterxyf.github.io/2012/11/20/work-exam/</link><description>&lt;h3&gt;2013-网易-校园招聘-C++开发工程师&lt;/h3&gt;
&lt;h4&gt;Fibonacci number&lt;/h4&gt;
&lt;p&gt;F(n)的值是多少？&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fabonacci" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/NumberedEquation6.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规算法&lt;/strong&gt;：根据Fabonacci的定义，递归求值。时间复杂度$ O(2^n) $&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibobacci(n):
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; n&amp;gt;=2 &lt;span style="color: #0000ff"&gt;and&lt;/span&gt; fibonacci(n-2) + fibonacci(n-1) &lt;span style="color: #0000ff"&gt;or&lt;/span&gt; n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;迭代&lt;/strong&gt;：利用循环取代递归。时间复杂度O(n)&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;def&lt;/span&gt; fibonacci(n):
    a, b = 0, 1
    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range(n):
        a, b = b, a+b
    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; a …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 20 Nov 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-11-20:/2012/11/20/work-exam/</guid><category>笔试</category></item><item><title>Python装饰器入门（译）</title><link>http://youngsterxyf.github.io/2012/07/30/a-primer-on-python-decorators/</link><description>&lt;p&gt;原文: &lt;a href="http://www.thumbtack.com/engineering/a-primer-on-python-decorators/"&gt;A primer on Python decorators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译: &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python允许你，作为程序员，使用函数完成一些很酷的事情。在Python中，函数是&lt;a href="http://en.wikipedia.org/wiki/First-class_function"&gt;一等对象(first-class object)&lt;/a&gt;，这就意味着你可以像使用字符串，整数，或者任何其他对象一样使用函数。例如，你可以将函数赋值给变量:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; def square(n):
...     return n * n;
&amp;gt;&amp;gt;&amp;gt; square(4)
16
&amp;gt;&amp;gt;&amp;gt; alias = square
&amp;gt;&amp;gt;&amp;gt; alias(4)
16
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，一等函数的真正威力在于你可以把函数传给其他函数，或者从其他函数中返回函数。Python的内置函数map利用了这种能力：给map传个函数以及一个列表，它会依次以列表中每个元素为参数调用你传给它的那个函数，从而生成一个新的列表。如下所示的例子中应用了上面的那个square函数:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; number = [1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; map …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 30 Jul 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-07-30:/2012/07/30/a-primer-on-python-decorators/</guid><category>Python</category><category>翻译</category></item><item><title>Python FAQ：Web开发（译）</title><link>http://youngsterxyf.github.io/2012/07/30/python-faq-webdev/</link><description>&lt;p&gt;原文： &lt;a href="http://me.veekun.com/blog/2012/05/05/python-faq-webdev/"&gt;Python FAQ: Webdev&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://github.com/youngsterxyf/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://me.veekun.com/blog/2011/07/22/python-faq/"&gt;Python FAQ&lt;/a&gt;的一部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我只会PHP，那该怎么用Python来编写一个Web应用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个相当复杂的问题，甚至很容易就能写一本书来探讨Web开发与Python，以及如何关联两者，所以我很想先把这个问题放一放。但是鉴于我刚&lt;a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/"&gt;相当粗暴地捣毁了PHP&lt;/a&gt;，明智些，还是回答这个问题吧，宜早不宜迟。&lt;/p&gt;
&lt;p&gt;最直接简单的回答是：不要再读了，马上使用&lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;着手构建一样东西。然而，我觉得还有更好回答。&lt;/p&gt;
&lt;p&gt;本文并非是教程。也许将来我会写一篇，但现在已经存在大量的教程了，我认为你可以阅读那些文档。相反，本文是为新手而写的Python Web开发相关事情的概览。&lt;/p&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;p&gt;显然，你需要安装Python。确保使用Python 2，而不是3。Python 3有一些向后不兼容的改变，并非所有的库都更新过。&lt;/p&gt;
&lt;p&gt;安装Python库，可以考虑使用 &lt;code&gt;pip&lt;/code&gt; 。(如果你在使用类Unix操作系统，那么也许可以通过系统包管理器安装pip，否则使用 &lt;code&gt;easy_install …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Mon, 30 Jul 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-07-30:/2012/07/30/python-faq-webdev/</guid><category>Python</category><category>翻译</category></item><item><title>关于技术的学习方法</title><link>http://youngsterxyf.github.io/2012/05/11/about-method-of-learning-technology/</link><description>&lt;p&gt;关于学习，时间短与效果好始终是一对矛盾的统一体。&lt;/p&gt;
&lt;p&gt;很多时候，要想在最短的时间内完成一件事情，最好的方法就是依葫芦画瓢，但这样的话，即使完成了事情，也只是知其然而不知其所以然，长久来看，对于学习者的能力不会有多大的提高。&lt;/p&gt;
&lt;p&gt;从长远来看，要想自己基础扎实，能力强，那就得一步一步的来，从基础知识开始，一点一点的搞懂，但这种方式需要花费很多时间，短时间内效果不明显。而且，可能效果没有预期的那么好。&lt;/p&gt;
&lt;p&gt;那么，如果做个权衡呢？&lt;/p&gt;
&lt;p&gt;我想，也许最好的学习方式是：先依葫芦画瓢地实践，获得一些直观感受，最好还有一些疑问。在实践完成之后，在整理自己的疑问，以及实践中涉及的知识要点，通过查阅图书或者网络资料，逐个知识点巩固，逐个解决疑问，并整理成文。这个整理总结的过程可能需要较长的时间。&lt;/p&gt;
&lt;p&gt;这种方式的优势在于：1.能让你快速地完成事情；2.实践中用到的知识多半会在以后的实践中经常用到，掌握的就是一些最重要的东西，而不会学习一些很少使用的深奥偏门知识。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 11 May 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-05-11:/2012/05/11/about-method-of-learning-technology/</guid><category>技术</category><category>学习方法</category></item><item><title>ubuntu12.04+ngnix+php-fastcgi+mysql+memcached网站开发测试环境搭建</title><link>http://youngsterxyf.github.io/2012/05/10/ubuntu12.04-nginx-php-factcgi-mysql-memcached/</link><description>&lt;p&gt;1.
安装必要的软件&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install nginx php5-cli php5-cgi spawn-fcgi psmisc mysql-server &lt;span style="color: #a31515"&gt;\&lt;/span&gt;
mysql-client php5-mysql memcached php5-memcache php5-curl php5-gd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.
打开浏览器访问: 127.0.0.1。就能看到表示nginx安装成功的页面。但这时访问php文件页面还不行。
（注：ngnix的配置文件目录为/etc/ngnix/，默认网站根目录为/usr/share/ngnix/www/；php配置文件目录为/etc/php5/）&lt;/p&gt;
&lt;p&gt;3.
编辑文件/etc/ngnix/sites-available/default，内容如下(可以先把原文件备份一下)：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;server {
    #listen   80; ## listen for …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 10 May 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-05-10:/2012/05/10/ubuntu12.04-nginx-php-factcgi-mysql-memcached/</guid><category>Linux</category><category>Nginx</category><category>PHP</category></item><item><title>Python对象创建过程（译）</title><link>http://youngsterxyf.github.io/2012/04/26/python-object-creation-sequence/</link><description>&lt;p&gt;原文： &lt;a href="http://eli.thegreenplace.net/2012/04/16/python-object-creation-sequence/"&gt;Python object creation sequence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者： &lt;a href="http://xiayf.blogspot.com/"&gt;youngsterxyf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[本文讨论的Python版本为3.x]&lt;/p&gt;
&lt;p&gt;本文旨在探究Python中新对象的创建过程。正如我在&lt;a href="http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work"&gt;前一篇文章&lt;/a&gt;中所解释的，对象的创建只是调用可调用对象的一种特例。考虑这样的一段Python代码：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;Joe&lt;/span&gt;:
    &lt;span style="color: #0000ff"&gt;pass&lt;/span&gt;

j = Joe()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当j = Joe()被执行时发生了什么呢？Python把它看作对可调用的Joe的一次调用，并且将它路由到内部函数 &lt;code&gt;PyObject_Call&lt;/code&gt; ，将Joe作为PyObject_Call的第一个参数。 &lt;code&gt;PyObject_Call&lt;/code&gt; 根据其第一个参数的类型抽取这个参数类型的 &lt;code&gt;tp_call&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;那么，Joe的类型是什么呢？无论何时我们定义一个新的Python类(class)，它的类型都是 &lt;code&gt;type&lt;/code&gt; ，除非我们明确地为它指定一个 &lt;a href="http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/"&gt;metaclass&lt;/a&gt;。因此，当 &lt;code&gt;PyObject_Call&lt;/code&gt; 试图查看Joe的类型，将得到类型 &lt;code&gt;type&lt;/code&gt; ，然后选择 &lt;code&gt;type&lt;/code&gt; 的 &lt;code&gt;tp_call&lt;/code&gt; 属性 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 26 Apr 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-04-26:/2012/04/26/python-object-creation-sequence/</guid><category>Python</category><category>翻译</category></item><item><title>关于指针的一道笔试题</title><link>http://youngsterxyf.github.io/2012/04/20/an-exercise-about-pointer/</link><description>&lt;p&gt;同学找实习，遇到这样一道笔试题:&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #2b91af"&gt;int&lt;/span&gt; *a[2][3];
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(*a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(**a) = ?
&lt;span style="color: #0000ff"&gt;sizeof&lt;/span&gt;(***a) = ?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这题还是有点小意思的。遇到这种题，脑子一定要清楚，注意分析。&lt;/p&gt;
&lt;p&gt;对于int *a[2][3]应该这么理解：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a是个数组，有两个元素；元素也是数组，其有3个元素，每个元素是指向int类型的指针。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针的长度固定为4个字节，C语言的int类型也是4个字节。&lt;/p&gt;
&lt;p&gt;这样一分析，这题就简单了。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sizeof(a)意思是求a数组的长度，数组的长度=数组元素的个数*元素的长度，所以sizeof(a) = 2 * 3 * 4 = 24个字节
sizeof(*a)中的*a是指a的第一个元素，所以sizeof(*a …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 20 Apr 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-04-20:/2012/04/20/an-exercise-about-pointer/</guid><category>笔试</category><category>C/C++</category></item><item><title>学习的"道"与"术"</title><link>http://youngsterxyf.github.io/2012/03/31/dao-and-shu-about-learning/</link><description>&lt;p&gt;读研以来，一直觉得自己的学习方法不够高效。试图将要学习的东西进行分类，然后以不同的方法学习之。那么该如何分类呢？我觉得以"道"与"术"区分之比较合适。&lt;/p&gt;
&lt;p&gt;何为"道 "？汉语辞典中有两条解释：&lt;strong&gt;1.指法则、规律；2.学术或宗教的思想体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;何为"术"？：&lt;strong&gt;技艺&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字面理解，“术”更为具体，是完成一件事情的具体过程。而“道”者则是指导实践的思想，是能够举一反三的事物规律。&lt;/p&gt;
&lt;p&gt;那么是否“道”比“术”更重要呢？我想未必。任何理论，任何“道”都最终来源于“术”的实践过程，也最终需要在“术”上得到实施，才能体现其价值。“道”与“术”两者相辅相成。那么在我们学习一门学问的过程中 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sat, 31 Mar 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-03-31:/2012/03/31/dao-and-shu-about-learning/</guid><category>学习方法</category></item><item><title>Python学习路线(针对具备一定编程经验者)</title><link>http://youngsterxyf.github.io/2012/02/21/the-path-of-learning-python/</link><description>&lt;p&gt;相比C,C++,JAVA等编程语言，Python是易学的。但要想深入地理解Python，并熟练地编写Python风格的Python代码。我想还是有一长段路程要走的。下面即是我的一点经验总结，主要是为了整理自己学习的思路。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花1-2天的时间阅读一本好的Python入门书籍，并在亲手实践书中的代码。推荐入门书籍：《A byte of Python》(中文翻译《简明Python教程》)或《Practical Programming:An Introduction to Computer Science Using Python》(中文翻译《Python实践教程》)或者其他的比较薄的入门书籍。&lt;/li&gt;
&lt;li&gt;抛开书籍，用Python去写一切你想写的程序。这时最好的参考文档即为：(1).Python命令解释器中的help(),dir()辅助方法；(2).Python官网文档：&lt;a href="http://docs.python.org/"&gt;http://docs.python.org/&lt;/a&gt; 。遇到不清楚的地方就用这两个方法查，再不行就去google一下。&lt;/li&gt;
&lt;li&gt;两三个月之后，积累一点的代码量，再重新找本讲解比较详细的书，重新梳理一下自己对Python的理解 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Tue, 21 Feb 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-02-21:/2012/02/21/the-path-of-learning-python/</guid><category>Python</category></item><item><title>Linux命令习题</title><link>http://youngsterxyf.github.io/2012/02/15/Linux-Command-Excercise/</link><description>&lt;p&gt;For each of the outputs listed below, find one sequence of commands connected by pipes that produces the output. For each problem, turn in the command sequence that you used to generate the requested output. (Do NOT turn in the output itself.)&lt;/p&gt;
&lt;p&gt;1.
A listing of all processes that you …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 15 Feb 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-02-15:/2012/02/15/Linux-Command-Excercise/</guid><category>Linux</category></item><item><title>2011年终-回顾与展望</title><link>http://youngsterxyf.github.io/2012/01/01/2011-summary/</link><description>&lt;p&gt;昨晚实验室聚餐，和师兄们喝醉了，明年的这个时候，我也就和他们一样将要毕业。时间，总是往前看觉得很漫长，可回过头去看看，一年也就是瞬间的事情。&lt;/p&gt;
&lt;p&gt;2011，我从研一走向研二，2012，我将从研二走向研三，继而毕业，工作。&lt;/p&gt;
&lt;p&gt;回顾过去一年，于我自己而言，过得很平淡，也许是大学以来最平淡的一年，只能说也许，因为对于2011，我记不得太多的事情。&lt;/p&gt;
&lt;p&gt;这一年里，我，一个技术男，比以前更宅，话也相对少了很多，直接表现为QQ空间或者校内上的文字写得很少。很少和别人谈论自己，因为我觉得纠结于那个“小我”是件很“小青年”的事情。人与人之间不可避免的隔膜导致了个人的事情不管多大在别人眼里都是微不足道的，在别人的心里掀不起半点波澜，说过了也就忘了。所以那些关于自己的，还是放在心里比较好，毋须说些没意义的。&lt;/p&gt;
&lt;p&gt;这一年里，我想得挺多，但真正做了或者说做好的却很少。这是件严重的事情。特别在技术上，东看西看，东学西学，眼界确实开阔很多，也养成了较为良好的技术趣味。但从技术能力上来说，真不好说 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Sun, 01 Jan 2012 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2012-01-01:/2012/01/01/2011-summary/</guid><category>总结</category></item><item><title>《Classic Shell Scripting》：ls, locate, type, find, df, du, diff, patch</title><link>http://youngsterxyf.github.io/2011/12/23/classic-shell-scripting-ls-locate-and-so-on/</link><description>&lt;h4&gt;一.ls&lt;/h4&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;ls [ options ] [ file(s) ]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;列出文件目录的内容
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;-1 : 数字1.强制为单栏输出。在交互式模式下，ls一般会以适于当前窗口的最小宽度，使用多个列
-a : 显示所有文件，包括隐藏文件(文件名以点号起始的文件)
-d : 显示与目录本身相关的信息，而非它们包含的文件的信息。
-F : 使用特殊结尾字符，标记特定的文件类型
-g : 仅适用于组：省略所有者名称(隐含-l，小写L选项)
-i : 列出inode编号
-L : 紧接着符号性连接，列出它们指向的文件
-l : 小写的L。以冗长形式列出，带有类型，权限保护，所有者，组，字节计数，最后修改时间和文件名
-r : 倒置默认的排序顺序
-R : 递归列出，下延进入每个子目录 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 23 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-23:/2011/12/23/classic-shell-scripting-ls-locate-and-so-on/</guid><category>Linux</category><category>Shell</category></item><item><title>ArchLinux上安装Consolas字体</title><link>http://youngsterxyf.github.io/2011/12/23/install-Consolas-font-on-ArchLinux/</link><description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从&lt;a href="http://www.iplaysoft.com/consolas.html"&gt;http://www.iplaysoft.com/consolas.html&lt;/a&gt;下载Consolas字体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo mkdir -p /usr/share/fonts/yahei
sudo cp YaHei.Consolas.1.11b.ttf /usr/share/fonts/yahei/
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改变权限：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sudo chmod 644 /usr/share/fonts/yahei/YaHei.Consolas.1.11b.ttf
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;cd /usr/share/fonts/yahei/
sudo mkfontscale
sudo mkfontdir …&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 23 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-23:/2011/12/23/install-Consolas-font-on-ArchLinux/</guid><category>Linux</category><category>字体</category></item><item><title>《Classic Shell Scripting》：文件描述符处理</title><link>http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-file-descriptors/</link><description>&lt;p&gt;在系统内部，UNIX是以一个小的整数数字，称为文件描述符(file descriptors)，表示每个进程打开的文件。数字由零开始，至多到系统定义的打开文件数目的限制。传统上，Shell允许你直接处理至多10个打开文件：文件描述符从0至9（POSIX标准将是否可以处理大于9的文件描述符，保留给各实现自行定义，bash可以，但ksh则否）&lt;/p&gt;
&lt;p&gt;文件描述符0,1与2，各自对应到标准输入，标准输出以及标准错误输出。最常见的操作便是变更这三个文件描述符其中一个的位置，不过也可能处理其他的变动。首先来看的是：将程序的标准输出传送到一个文件，并将起标准错误信息传到另一个文件：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;make 1&amp;gt; results 2&amp;gt; ERRS
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的命令是将make的标准输出(文件描述符为1)传给results,并将标准错误输出(文件描述符为2)传给ERRS。&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;make 1&amp;gt; results 2&amp;gt; /dev/null
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;1&amp;gt; results&lt;/code&gt;里的1其实没有必要，供输出重定向的默认文件描述符是标准输出：也就是文件描述符1。下个例子会将输出与错误信息送给相同的文件：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;make &amp;gt; results 2 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 22 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-22:/2011/12/22/classic-shell-scripting-file-descriptors/</guid><category>Linux</category><category>Shell</category></item><item><title>《Classic Shell Scripting》：sed and cut</title><link>http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-sed-and-cut/</link><description>&lt;h4&gt;一. sed&lt;/h4&gt;
&lt;p&gt;一般来说，执行文本替换的正确程序应该是sed --- 流编辑器(Stream Editor)。sed的设计就是用来以批处理的方式而不是交互的方式来编辑文件。当你知道要做好几个变更 --- 不管是对一个还是数个文件时，比较简单的方式是将这些变更部分写到一个编辑中的脚本里，再将此脚本应用到所有需要修改的文件。
你可能会常在管道中间使用sed，以执行替换操作。做法是使用s命令 --- 要求正则表达式寻找，用替代文本替换匹配的文本：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sed &lt;span style="color: #a31515"&gt;&amp;#39;s/:.*//&amp;#39;&lt;/span&gt; /etc/passwd       &lt;span style="color: #008000"&gt;#删除第一个冒号之后的所有东西&lt;/span&gt;
sort -u                          &lt;span style="color: #008000"&gt;#排序列表并删除重复部分&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这里，/字符扮演定界符(delimiter)的角色，从而分隔正则表达式与替代文本。在本例中，替代文本是空的，实际上会有效地删除匹配的文本。虽然/是最常用的定界符，但任何可显示的字符都能作为定界符。在处理文件名称，通常都会以标点符号字符作为定界符(例如分号，冒号或逗点)：&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;find /home/tolstoy -type d -print    &lt;span style="color: #008000"&gt;#寻找所有目录&lt;/span&gt;
sed &lt;span style="color: #a31515"&gt;&amp;#39;s;/home …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 22 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-22:/2011/12/22/classic-shell-scripting-sed-and-cut/</guid><category>Linux</category><category>Shell</category></item><item><title>《Classic Shell Scripting》：sort, uniq, wc, head, tail</title><link>http://youngsterxyf.github.io/2011/12/22/classic-shell-scripting-sort-uniq-wc-head-tail/</link><description>&lt;h4&gt;一.sort&lt;/h4&gt;
&lt;p&gt;就像awk,cut与join一样，sort将输入看作具有多条记录的数据流，而记录是由可变宽度的字段组成，记录是以换行符作为定界符，字段的定界符则是空白字符或是用户指定的单个字符。&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;sort [ options ] [ file(s)]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用途&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;将输入行按照键值字段与数据类型选项以及locale排序
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;主要选项&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;-b : 忽略开头的空白
-c : 检查输入是否已正确地排序。如输入未经排序，但退出码(exit code)为非零值，则不会有任何输出
-d : 字典顺序，仅文字数字与空白才有意义
-g : 一般数值，以浮点数字类型比较字段
-f : 将混用的字母都看作相同大小写，也就是以不管字母大小写的方式排序。
-i : 忽略无法打印的字符
-k : 定义排序键值字段
-m : 将已排序的输入文件，合并为一个排序后的输出数据流
-n : 以整数类型比较字段
-o outfile : 将输出写到指定的文件，而非标准输出。如果该文件为输入文件之一，则sort在进行排序与写到输出文件之前 …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Thu, 22 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-22:/2011/12/22/classic-shell-scripting-sort-uniq-wc-head-tail/</guid><category>Linux</category><category>Shell</category></item><item><title>《Classic Shell Scripting》第一、二章阅读笔记</title><link>http://youngsterxyf.github.io/2011/12/09/classic-shell-scripting-1-2/</link><description>&lt;h4&gt;第一章：背景知识&lt;/h4&gt;
&lt;p&gt;软件工具的原则&lt;/p&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;一次做好一件事

处理文本行，不要处理二进制数据

使用正则表达式：正则表达式(regular expression)是很强的文本处理机制。了解它的运作模式并加以使用，可适度简化编写命令脚本的工作。

默认使用标准输入/输出：在未明确指定文件名的情况下，程序默认会从它的标准输入读取数据，将数据写到它的标准输出，至于错误信息则会传送到标准错误输出。以这样的方式来编写程序，可以轻松地让它们称为数据过滤器(filter)。

避免喋喋不休

输出格式必须与可接受的输入格式一致：专业的工具程序认为遵循某种格式的输入数据，例如标题行之后接着数据行，或在行上使用某种字段分隔符等，所产生的输出也应遵循与输入一致的规则。这么做的好处是，容易将一个程序的执行结果交给另一个程序处理。

让工具去做困难的部分：虽然UNIX程序并非完全符合你的需求，但是现有的工具或许已经可以为你完成90%的工作。接下来，若有需要，你可以编写一个功能特定的小型程序来完成剩下的工作。

构建特定工具前，先想想：你所要做的事情，是否有其他人也需要做？这个特殊的工作是否有可能是某个一般问题的一个特例？如果是的话，请针对一般问题来编写程序。
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;第二章：入门&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Shell脚本最常用于系统管理工作，或是用于结合现有的程序以完成小型的，特定的工作。一旦你找出完成工作的方法 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Fri, 09 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-09:/2011/12/09/classic-shell-scripting-1-2/</guid><category>Linux</category><category>Shell</category></item><item><title>Linux添加定时任务</title><link>http://youngsterxyf.github.io/2011/12/07/cron-usage/</link><description>&lt;p&gt;在Linux下如果希望某个任务定时地执行，一般是使用cron服务器，将任务添加到cron任务列表中。&lt;/p&gt;
&lt;h4&gt;启动，关闭，重启cron(需超级用户权限)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;/etc/init.d/cron start
/etc/init.d/cron stop
/etc/init.d/cron restart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注:archlinux下为/etc/rc.d/crond start|stop|restart&lt;/p&gt;
&lt;h4&gt;查看用户设置的定时任务列表&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;crontab [-u xxx] -l       #  xxx为用户名
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;编辑用户的定时任务列表(超级用户权限)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;crontab -u xxx -e
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;删除用户的定时任务列表(超级用户权限)&lt;/h4&gt;
&lt;div class="highlight" style="background: #ffffff"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span&gt;&lt;/span&gt;crontab -u xxx -r
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;定时任务的编辑规则 …&lt;/h4&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 07 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-07:/2011/12/07/cron-usage/</guid><category>Linux</category></item><item><title>Linux添加sudo用户权限</title><link>http://youngsterxyf.github.io/2011/12/07/linux-add-sudo-user/</link><description>&lt;p&gt;Linux中很多命令需要使用超级用户权限，在这些命令前添加sudo然后直接执行是很方便的。&lt;/p&gt;
&lt;p&gt;那么就先要将自己的用户名添加到sudoers中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用su命令切换到超级用户(在提示后输入root的密码)&lt;/li&gt;
&lt;li&gt;使用visudo命令(编辑/etc/sudoers文件)，也可以直接使用编辑器编辑&lt;/li&gt;
&lt;li&gt;找到root ALL=(ALL) ALL 这一行，在其下面一行添加xxx ALL=(ALL) ALL，其中xxx为你的用户名&lt;/li&gt;
&lt;li&gt;保存即可起效&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">youngsterxyf</dc:creator><pubDate>Wed, 07 Dec 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:youngsterxyf.github.io,2011-12-07:/2011/12/07/linux-add-sudo-user/</guid><category>Linux</category></item></channel></rss>