<!DOCTYPE html>
<html lang="zh">
<head>

        <title>笔试题目</title>
        <meta charset="utf-8" />
        <link href="http://youngsterxyf.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="黑·白 Full Atom Feed" />
        <link href="http://youngsterxyf.github.io/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="黑·白 Full RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../../../../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/pygment.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/SentyZHAO/SentyZHAO.css" />

        <script src="../../../../theme/js/libs/jquery-1.9.1.min.js"></script>
        <script src="../../../../theme/js/libs/modernizr-2.6.2.min.js"></script>
            <script>
              var _hmt = _hmt || [];
              (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?5c5d8c3fe75afeff117777b9236b96ec";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
              })();
            </script>
</head>

<body id="index" class="home">
    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1 style='font-family: "SentyZHAO";'><a href="../../../..">黑·白 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>

              <ul class="columns" style='font-family: "SentyZHAO";'>
                <li><a href="../../../..">主 页</a></li>

                <li><a href="/archives.html">归 档</a></li>
                <li><a href="/pages/tech-share.html">技术分享</a></li>
                <li><a href="/pages/translation.html">技术翻译</a></li>
                <li><a href="/pages/tools.html">工具集</a></li>
                <li><a href="/pages/links.html">链 接</a></li>
                <li><a href="/pages/aboutme.html">关于我</a></li>
                <li><a href="/feeds/rss.xml">RSS</a></li>

              </ul>
            </div>

<section id="content" class="body">
   <div class="row">
        <div class="columns">
            <header>
              <h2 class="entry-title">
                <a href="../../../../2012/11/20/work-exam/" rel="bookmark" title="Permalink to 笔试题目">笔试题目</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2012-11-20T00:00:00+08:00">
                2012-11-20 Tue
              </abbr>
              <address class="vcard author">
                By <a class="url fn" href="../../../../author/youngsterxyf.html">youngsterxyf</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <h3>2013-网易-校园招聘-C++开发工程师</h3>
<h4>Fibonacci number</h4>
<p>F(n)的值是多少？</p>
<p><img alt="Fabonacci" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/NumberedEquation6.gif"></p>
<p><strong>常规算法</strong>：根据Fabonacci的定义，递归求值。时间复杂度$ O(2^n) $</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fibobacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">&gt;=</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span>
</pre></div>


<p><strong>迭代</strong>：利用循环取代递归。时间复杂度O(n)</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span>
</pre></div>


<p><em>迭代算法的变种</em> ：利用python的generator，原理一样，只是应用场合不一样。</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">():</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">a</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>


<p><strong>利用矩阵运算来加速的算法</strong>：（还没懂）算法复杂度$ O(\log n) $</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">fibonacci_matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fibonacci_matrix</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>


<p><strong>数学方法:使用Fibonacci序列的通用公式</strong>：</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(((</span><span class="mi">1</span><span class="o">+</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>


<p>虽然数学方法在4种方法中速度最快，但当n越大，其计算精度偏差越大。</p>
<h4>图的遍历</h4>
<p><img alt="graph" src="https://raw.githubusercontent.com/youngsterxyf/youngsterxyf.github.com/master/assets/uploads/pics/graph-sample.jpg"></p>
<p><a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/graph.cpp">源代码</a></p>
<h4>大文件处理</h4>
<p>设计算法从文件中随机取K行(内存够存储K行)，每行被取的概率相等，算法复杂度要低。(具体的记不太清楚了)</p>
<h4>CAS(Compare And Swap)</h4>
<div class="highlight"><pre><span class="kt">bool</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">accum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">accum</span> <span class="o">==</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">newval</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>CAS方式实现的进队列操作：</p>
<div class="highlight"><pre><span class="n">EnQueue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1">//进队列</span>
<span class="p">{</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">new</span> <span class="n">record</span><span class="p">();</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>   <span class="c1">//取链表尾指针的快照</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TRUE</span><span class="p">)</span>   <span class="c1">//如果没有把结点链上，再试</span>

    <span class="n">CAS</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>    <span class="c1">//置尾结点</span>
<span class="p">}</span>
</pre></div>


<ol>
<li>
<p><a href="http://blog.csdn.net/lifesider/article/details/6582338">无锁的数据结构（Lock-Free）及CAS（Compare-and-Swap）机制</a></p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Compare-and-swap">Wikipedia---Compare-and-swap</a></p>
</li>
<li>
<p><a href="http://coolshell.cn/articles/8239.html">无锁队列的实现</a></p>
</li>
</ol>
<h4>排序算法</h4>
<p>不稳定排序算法可能会在相等的键值中改变记录的相对次序，但是稳定排序算法从来不会如此。</p>
<p><strong>稳定的</strong></p>
<ul>
<li>
<p>冒泡排序(Bubble sort) --- $ O(n^2) $</p>
</li>
<li>
<p>插入排序(Insertion sort) --- $ O(n^2) $</p>
</li>
<li>
<p>桶排序(Bucket sort) --- <span class="math">\( O(n) $，需要\)</span>O(k)$额外空间</p>
</li>
<li>
<p>计数排序(Counting sort) --- <span class="math">\( O(n+k) $，需要\)</span>O(n+k)$额外空间</p>
</li>
<li>
<p>归并排序(Merge sort) --- <span class="math">\( O(n \log n) $，需要\)</span>O(n)$额外空间</p>
</li>
<li>
<p>基数排序(Radix sort) --- <span class="math">\( O(n \times k) $，需要\)</span>O(n)$额外空间</p>
</li>
</ul>
<p><strong>不稳定的</strong></p>
<ul>
<li>
<p>选择排序(Selection sort) --- $ O(n^2) $</p>
</li>
<li>
<p>希尔排序(Shell sort) --- $ O(n \log n) $</p>
</li>
<li>
<p>堆排序(Heap sort) --- $ O(n \log n) $</p>
</li>
<li>
<p>快速排序(Quick sort) --- $ O(n \log n) $</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p><em>冒泡排序---Python</em>:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;start bubble sort:&#39;</span>
    <span class="k">print</span> <span class="n">L</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">print</span> <span class="n">L</span>
                <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="s">&#39;totalstep:&#39;</span><span class="p">,</span> <span class="n">count</span>
</pre></div>


<p><em>计数排序---C</em>:</p>
<div class="highlight"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">void</span> <span class="nf">counting_sort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
    <span class="n">min</span> <span class="o">=</span> <span class="n">max</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="n">max</span><span class="o">-</span><span class="n">min</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">range</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">range</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">count</span><span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">min</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">min</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">min</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">array</span><span class="p">[</span><span class="n">z</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><em>快速排序---Python</em>:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">qsort</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">L</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">qsort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
        <span class="n">qsort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>


<h3>2013-小米科技-校园招聘-笔试-软件开发工程师</h3>
<h4>完全二叉树</h4>
<p>深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为<strong>完全二叉树</strong> 。</p>
<p>这种树的特点是:1.叶子结点只可能在层次最大的两层上出现; 2.对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。</p>
<p>具有n个结点的完全二叉树的深度为$ [\log n]+1 $</p>
<h4>指针的基本理解</h4>
<p>已知int* p = &amp;n，请问*p是什么？</p>
<p><em>*p是n的值</em></p>
<p><strong>理解指针</strong> ：</p>
<ol>
<li>
<p>每个指针都对应一个类型。这个类型表明指针指向哪一类对象。特殊的void* 类型代表通用指针。比如说，malloc函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。</p>
</li>
<li>
<p>每个指针都有一个值。特殊的NULL(0)值表示该指针没有指向任何地方。</p>
</li>
<li>
<p>指针用&amp;运算符创建。（注：因为leal指令是设计用来计算存储器引用的地址的，&amp;运算符的机器代码实现常常用这条指令来计算表达式的值）</p>
</li>
<li>
<p>数组与指针紧密联系。一个数组的名字可以像一个指针变量一样使用(但是不能修改)</p>
</li>
<li>
<p>将指针从一个类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。例如，如果p是一个char*类型的指针，它的值是P，那么表达式(int*)p+7计算为P+28，而(int*)(p+7)计算为P+7。(回想一下，强制类型转换的优先级高于加法)</p>
</li>
<li>
<p>指针也可以指向函数。例如，如果我们有一个函数，用下面的这个原型定义: <code>int fun(int x, int *p)</code></p>
</li>
</ol>
<p>然后，我们可以声明一个指针fp，将它赋值为这个函数，代码如下：</p>
<div class="highlight"><pre><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">fun</span><span class="p">;</span>
</pre></div>


<p>然后用以下指针来调用这个函数：</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fp</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
</pre></div>


<p>函数指针的值是该函数机器代码表示中第一条指令的地址。</p>
<h4>93&amp;-8等于多少</h4>
<p>11011101 &amp; 11111000 = 11011000 = 88</p>
<h4>已知(he)^2 = she，请求出s, h, e各自的值为多少？</h4>
<p>s = 6; h = 2; e = 5;</p>
<h4>给定二维数组a[1...100][1...65]，以行序进行存储，假设数组的基地址为10000，每个元素需要2个存储单元，请求出元素a[56][21]的存储地址。</h4>
<div class="math">$$ (55 \times 65 + 22) \times 2 + 10000 = 17194 $$</div>
<h4>给定一个数组a，求数组result，其中result[i]的值为除a[i]之外的其他a的元素值的乘积(假设不会溢出)。算法的时间，空间复杂度要尽可能低。</h4>
<div class="highlight"><pre><span class="kt">int</span><span class="o">*</span> <span class="nf">getProduct</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">allproduct</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">index</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
        <span class="n">allproduct</span> <span class="o">*=</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">productResult</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">index</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
        <span class="n">productResult</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">allproduct</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">productResult</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>时间复杂度为O(n)</p>
<div class="highlight"><pre><span class="kt">int</span><span class="o">*</span> <span class="nf">getProduct</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">productResult</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">temp</span> <span class="o">*=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">productResult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">productResult</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>时间复杂度为O(n^2)</p>
<h4>给定一个数组a，其中有3个元素出现了两次，其余元素仅出现一次。请找出其中仅出现一次的任意一个元素。算法的时间，空间复杂度要低</h4>
<p>方法一：先排序，然后对元素依次两两比较遍历一遍排好序的数组，如果两个元素不同，则输出第一个元素，并退出循环。如果相同，则跳过下一个元素，再次开始两两比较。</p>
<p>方法二：先找出数组a中的最大元素x，创建一个大小为x的数组temp，并所有元素初始化为-1。遍历数组a，temp[a[i]]++。再遍历temp，如果temp[i]==0，则返回i，并退出循环。</p>
<h4>给定n个人，以及m对人之间的关联(以二维数组的方式存储)，人与人之间直接关联或间接关联形成一个朋友圈。请找出给定信息的朋友圈的个数。算法时间空间复杂度要低。并分析其时间空间复杂度。</h4>
<p>使用 <strong>合并-查找算法</strong> (<a href="http://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>)</p>
<p><strong>连通问题的快速查找算法</strong>：算法的基础是一个整型数组，当且仅当第p个元素和第q个元素相等时，p和q是连通的。初始时，数组中的第i个元素的值为i，<span class="math">\(0 \le i &lt; N\)</span>。为实现p与q的合并操作，我们遍历数组，把所有名为p的元素值改为q。我们也可以选择另一种方式，把所有名为q的元素改为p。</p>
<hr>
<h3>2013-腾讯-校园招聘-笔试-后台开发工程师</h3>
<h4>黑盒，白盒测试的目的</h4>
<h4>TCP三次握手包含的指令(SYN, ACK)</h4>
<h4>完全二叉树的结点数为769,求其叶子结点数目</h4>
<p>(769-x)*2 = 769-1 =&gt; x=385</p>
<h4>C++的四种类型转换符</h4>
<p><a href="http://www.bccn.net/Article/kfyy/cjj/jszl/200809/7955.html">C++中四种类型转换运算符的使用方法</a></p>
<h4>快速排序</h4>
<h4>有一个指针void *mPem指向一段分配好的内存空间，现在创建类A的对象a，如何使得a在其上申请内存空间？</h4>
<p>难道真是A* a = (A*)mPem么?</p>
<h4>虚继承与多态</h4>
<div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include&lt;stdlib.h&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">A</span><span class="p">()</span><span class="o">:</span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>
        <span class="kt">void</span> <span class="n">S</span><span class="p">(){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;aaa%d&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span><span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">B</span><span class="p">()</span><span class="o">:</span><span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">){}</span>
        <span class="kt">void</span> <span class="n">S</span><span class="p">(){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;bbb%d&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">();</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h4>BITMAP的简单实现：使用char类型数组</h4>
<div class="highlight"><pre><span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//设置第n位为1</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
    <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4>矩阵向右旋转90度的实现</h4>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">maxtrix</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="p">...</span>
<span class="kt">int</span> <span class="n">reverseMatrix</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">reverseMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4>数据结构：线性结构与非线性结构</h4>
<h4>综合考虑等待时间和执行时间的进程调度算法？</h4>
<p><em>高响应比优先调度算法</em></p>
<h4>无法提高可靠性的RAID是？</h4>
<p><em>RAID0</em></p>
<p><a href="http://zh.wikipedia.org/zh/RAID">wikipedia-RAID</a></p>
<h4>类型的空间占用</h4>
<p>下列哪个占用的空间最大？</p>
<p>A.1   B.'1'   C."1"   D.1.0</p>
<p>答：D</p>
<h4>union和struct结构的存储与空间占用问题(对齐)</h4>
<p>1.</p>
<p>联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。</p>
<div class="highlight"><pre><span class="k">union</span> <span class="n">U3</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">double</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>对于类型union U3*的指针p, p-&gt;c、p-&gt;i[0]和p-&gt;v引用的都是数据结构的起始位置。一个联合的总的大小等于它最大字段的大小。</p>
<p>2.</p>
<p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2, 4和8)的倍数。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计。例如，假设一个处理器总是从存储器中取出8个字节，则地址必须是为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个存储器操作来读或者写值了。否则，我们可能需要执行两次存储器访问，因为对象可能被分放在两个8字节存储器块中。</p>
<p>无论数据是否对齐，IA32已经都能正确工作。不过，Intel还是建议要对齐数据以提高存储器系统的性能。Linux沿用的对齐策略是，2字节数据类型(例如short)的地址必须是2的倍数，而较大的数据类型(例如int、int*、float和double)的地址必须是4的倍数。</p>
<h4>二叉树中序遍历</h4>
<h4>最小堆(堆排序)</h4>
<p>堆排序(Heap Sort)只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。</p>
<p>堆的定义如下：n个元素的序列{K1, K2,...,Kn}当且仅当满足关系时，称之为堆:
Ki &lt;= K2i 并且 Ki &lt;= K2i+1  或  Ki &gt;= K2i 并且 Ki &gt;= K2i+1</p>
<p>若将和此序列对应的一维数组看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于(或不小于)其左、右孩子结点的值。由此，若序列{Ki,K2,...,Kn}是堆，则堆顶元素(或完全二叉树的根)必为序列中n个元素的最小值(或最大值)。</p>
<p>若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素中次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。</p>
<p>由此，实现堆排序需要解决两个问题：(1)如何由一个无序序列建成一个堆？(2)如何在输出栈顶元素之后，调整剩余元素成为一个新的堆？</p>
<p><a href="https://github.com/youngsterxyf/Data-Structures-and-Algorithms/blob/master/heapSort.c">源代码</a></p>
<h4>一个线段上，任取两点，截成三段，能组成三角形的概率</h4>
<p>1/4 (怎么算？)</p>
<p>思考1：线段等分成两个区间。两点属于同一区间的概率是1/2，属于不同区间且两点距离大于等于线段长度一半的概率是1/2 * 1/2，则1-1/2-1/4 = 1/4;</p>
<p>思考2：线性规划。<a href="http://zhidao.baidu.com/question/6678655">百度知道</a></p>
<h4>哈希表</h4>
<p><strong>哈希函数的构造方法</strong></p>
<ul>
<li>
<p>直接定址法：取关键字或关键字的某个线性函数值为哈希地址</p>
</li>
<li>
<p>数字分析法：假设关键字是以r为基的数(如：以10为基的十进制数)，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</p>
</li>
<li>
<p>平方取中法：取关键字平方后的中间几位为哈希地址</p>
</li>
<li>
<p>折叠法：将关键字分割成位数相同的几部分(最后一部分的位数可以不同)，然后取这几部分的叠加和(舍去进位)作为哈希地址，这方法称为折叠法。</p>
</li>
<li>
<p>除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。</p>
</li>
<li>
<p>随机数法：选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key)，其中random为随机函数</p>
</li>
</ul>
<p>实际工作中需视不同的情况采用不同的哈希函数。通常，考虑的因素有：</p>
<ul>
<li>
<p>计算哈希函数所需时间(包括硬件指令的因素)</p>
</li>
<li>
<p>关键字的长度</p>
</li>
<li>
<p>哈希表的大小</p>
</li>
<li>
<p>关键字的分布情况</p>
</li>
<li>
<p>记录的查找频率</p>
</li>
</ul>
<p>处理冲突的方法：</p>
<ul>
<li>
<p>开放定址法</p>
</li>
<li>
<p>再哈希法</p>
</li>
<li>
<p>链地址法</p>
</li>
<li>
<p>建立一个公共溢出区</p>
</li>
</ul>
<h3>程序员面试宝典</h3>
<h4>用一个表达式，判断一个数X是否是2的N次方(2,4,8,16,...)，不可用循环语句。</h4>
<h4>下面程序的结果是多少？</h4>
<div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">9999</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="p">){</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="o">&amp;</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4>There are two int variables: a and b, don't use "if", "?:", "switch" or other judgement statements, find out the biggest one of the two numbers.</h4>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">+</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>


<h4>如何将a, b的值进行交换，并且不使用任何中间变量?</h4>
<p>简而言之，用异或语句比较容易，不用担心超界的问题。</p>
<p>如果采用：</p>
<div class="highlight"><pre><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
<span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
</pre></div>


<p>这样做的缺点就是如果a, b都是比较大的两个数，a=a+b时就会超界。</p>
<p>而采用：</p>
<div class="highlight"><pre><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">;</span>
<span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">;</span>
</pre></div>


<p>无需担心超界的问题，这样就比较好</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            </div><!-- /.entry-content -->
            <div class="comments">
              <h3>Comments</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "2012/11/20/work-exam/";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://xiayfblackwhite.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>
        </div><!-- /.twelve.columns -->
 </div><!-- /.row -->
</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">


        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="http://github.com/youngsterxyf" target="_blank">Github</a></div></li>

                <li><div class="btn twitter"><a href="https://twitter.com/youngsterxyf" target="_blank">Twitter</a></div></li>

                <li><div class="btn warning"><a href="http://weibo.com/u/1855563263" target="_blank">Weibo</a></div></li>

                <li><div class="btn douban"><a href="http://www.douban.com/people/youngster21/" target="_blank">Douban</a></div></li>



              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'xiayfblackwhite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../../../../theme/js/libs/gumby.min.js"></script>
  <script src="../../../../theme/js/plugins.js"></script>
  <script src="../../../../theme/js/main.js"></script>
  <link rel="stylesheet" type="text/css" href="../../../../theme/emoji/css/basic/emojify.min.css" />
  <script src="../../../../theme/emoji/js/emojify.min.js"></script>
  <script>
    emojify.setConfig({
        img_dir : '../../../../theme/emoji/images/basic'
    });
    emojify.run();
</script>
</body>
</html>